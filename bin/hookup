#!/bin/bash

#
# Set shell mode to trace each function call
[ "$TRACE" = "1" ] && set -x

# shellcheck disable=2034
HASH=sha256sum
BIN_DIR=${BIN_DIR:-/usr/bin}
HOOKS_DIR=${HOOKS_DIR:-/usr/share/git-core/templates/hooks}
STYLES_DIR=${STYLES_DIR:-/usr/share/zglue/styles}
ZGLUE_LIBDIR=${ZGLUE_LIBDIR:-/usr/share/zglue/scripts}
HOOKS="pre-commit commit-msg"
RED='\033[1;31m'
# shellcheck disable=2034
GREEN='\033[1;32m'
# shellcheck disable=2034
YELLOW='\033[1;33m'
BLUE='\033[1;34m'
RESET='\033[0;39;49m'
SIDE_FILE="$(dirname "$0")/s$(basename "$0")"

declare -a BINS
declare -A DIFFER
#
# List of files required to provide style checking
# and pre-commit hook support to git repos.
#
set_bins()
{
    [ -d "$ROOT" ] && echo "Rebasing on root $ROOT"
    BINS=(
        "${ROOT}${BIN_DIR}"/style_file
        "${ROOT}${BIN_DIR}"/astyle
        "${ROOT}${BIN_DIR}"/hookup
        "${ROOT}${HOOKS_DIR}"/pre-commit
        "${ROOT}${HOOKS_DIR}"/commit-msg
        "${ROOT}${STYLES_DIR}"/astyle-nuttx
        "${ROOT}${ZGLUE_LIBDIR}"/lib_body.sh
 )
}

#
# See if the two files passed in are the same.
#
diff_check()
{
        local File_1=
        local File_2=
        local Sum_1=
        local Sum_2=

        File_1="$1" ; shift
        File_2="$1" ; shift

        [ -f "$File_1" ] && Sum_1="$(sha256sum "$File_1" | awk '{print $1}')"
        [ -f "$File_2" ] && Sum_2="$(sha256sum "$File_2" | awk '{print $1}')"

       [ "$Sum_1" = "$Sum_2" ] && return
       return 1
}

#
# Wrap a check of $DEBUG = 1 and echo.
#
echo_dbg()
{
        [ "$DEBUG" = "1" ] || return
        echo -e "$@" >&2
}

#
#
#
help()
{
        cat <<"EOF"
        This file will install style_file, astyle, pre-commit, commit-msg
        and astyle-nuttx to provide style checking for git commits.

        -p : Place all of these files in the proper locations. Must run as root!
        -u : Refresh .git/hooks with the latest pre-commit and commit-msg.
             Must be run from the root of the repo.
        -v : Validate that the necessary files are all present locally and
             how the compare with currently installed versions of these files.

             Any files that differ from the currently installed versions are
             shown and will be updated when directed to with the "-p" option.


EOF
}

#
# If $0 was one of the files replaced then $0 was mv to $SIDE_FILE.
# If everything went well then both files exist and the SIDE_FILE
#  can be removed. Otherwise mv SIDE_FILE to $0
#
personality_shrink()
{
        if [ -f "$SIDE_FILE" ] ; then
                [ "$DEBUG" = "1" ] && echo ":: Found $SIDE_FILE" >&2
                [ -f "$0" ] && rm "$SIDE_FILE" \
                   &&  [ "$DEBUG" = "1" ]  \
                     &&  echo ":: New hookup in place, remove $SIDE_FILE" >&2
                [ ! -f "$0" ] && mv "$SIDE_FILE" "$0" \
                   &&  [ "$DEBUG" = "1" ]  \
                         && echo ":: New hookup did not install, restore." >&2
        fi
}

#
# Check whether we are replacing ourselves. If
# so then move out of the way else the script
# behavior is undefined.
#
personality_split()
{
        local bin=

        [ -z "$1" ] && return
        bin="$1"

        if [ "$bin" = "$0" ] ; then
                [ "$DEBUG" = "1" ] && echo ":: Rename self to $SIDE_FILE" >&2
                mv "$0" "$SIDE_FILE"
        fi
}

#
# List the steps to be done.
#
instructions()
{
        local COLOR=

        COLOR=$BLUE
        echo -e "\\t${COLOR}As root or using sudo do the following will occur: ...\\n"
        echo -ne "\\tchmod +x "
        for bin in "${BINS[@]}" ; do
                echo -ne "$(basename "$bin") "
        done
        echo ""
        for bin in "${BINS[@]}" ; do
                echo -e "\\tcp $(basename "$bin")\\t\\t$bin"
        done
        echo -e "${RESET}"
}

#
# Copy the global pre-commit and commit-msg hooks into place.
#
refresh_hooks()
{
        local CMD=
        local hook=
        local RepoRoot=
        local msg_now=

        RepoRoot=$(git rev-parse --show-toplevel)
  (
        rv=0
        cd "$RepoRoot"
        for hook in $HOOKS ; do
                [ ! -f "$HOOKS_DIR/$hook" ] && echo "Missing $HOOKS_DIR/$hook." >&2 && FA=1 && continue
                # See if the two files are the same and skip if they are.
                diff_check "$HOOKS_DIR/$hook" .git/hooks/"$hook" && continue
                echo "$hook is different, replacing." >&2
                CMD="cp $HOOKS_DIR/$hook .git/hooks/"
                $CMD && chmod +x .git/hooks/"$hook"
                rv=1
        done
        return $rv
  ) || msg_now="now "

        echo -e "All hooks are ${msg_now}current.\\n"
        return
}

#
#  Given a list of files or anything cycle through the list
#  printing each element in turn.  TODO: add ability to format
#  the page as in more than one column.
#
list_files()
{
        local Msg=
        local fff=
        declare -a Files=

        Msg="$1" ; shift
        Files=( "$@" )

        echo -e "${Msg}"
        for fff in "${Files[@]}" ; do
                echo -e "\\t$fff"
        done
}

#
#  Given a bare variable (File versus $File), dereference
#  it and print out the name of the variable and its value.
#
list_vars()
{
        local Msg=
        local Vars=
        local vvv=

        Msg="$1" ; shift
        Vars=( "$@" )
        echo -e "${Msg}"
        for vvv in "${Vars[@]}" ; do
                echo -n -e "\\t$vvv:\\t"
                [ "${#vvv}" -lt 8 ] && echo -n -e "\\t"
                echo -e "${!vvv}"
        done

        echo ""
}

#
# validate the required files are available to place.
#
validate_horde()
{
        local FA=
        local bin=
        local msg=
        local local_bin=
        declare -a msgs=
        declare -a Found=
        declare -a NotFound=
        declare -a Differs=

        FA=0
        msgs=( "${RED}Differs:${RESET}" "${BLUE}Found${RESET}" "${RED}NotFound:${RESET}" )

        echo "Making sure all of the files are here ... "
	for bin in "${BINS[@]}" ; do
                local_bin=$(basename "$bin")
                if [ -f "$local_bin" ] ; then
                        if ! diff_check "$local_bin"  "$bin"  ; then
                                Differs=( "$local_bin" "${Differs[@]}" )
                                DIFFER["$local_bin"]="$bin"
                        fi
                        Found=( "$local_bin" "${Found[@]}" )
                        continue
                fi
                NotFound=( "$local_bin" "${NotFound[@]}" )
                FA=1
	done
        [ -n "${Found[*]}" ] && list_files "${msgs[1]}" "${Found[@]}"
        [ -n "${Differs[*]}" ] && list_files "${msgs[0]}" "${Differs[@]}"
        [ -n "${NotFound[*]}" ] && list_files "${msgs[2]}" "${NotFound[@]}"
        msg="All files are current."
        [ -z "${NotFound[*]}" ] && [ -z "${Differs[*]}" ] && echo -e "$msg" >&2
        return $FA
}

#
# Check for reasons to skip this bin. The package sourced
# bin is missing, the bin is the same as the package.
#
# return 1 bin is not suitable for placement
#        0 bin is suitable for placement.
#
bin_suitable()
{
        local Bin=
        local This_Bin=

        Bin="$1"
        This_Bin="$(basename "$1")"

        # Nothing to do if the package file is missing.
        [ ! -f "$This_Bin" ] && return 1

        # See if the two files are the same and skip if they are.
        diff_check "$This_Bin"  "$Bin" && return 1

        return 0
}

#
# Update the binaries if necessary.
#
place_files()
{
        declare -a CMD=
        local bin=
        local this_bin=
        local this_dir=
        local SP=

        if [ "$(id -u)" -ne 0 ] && [ -z "$ROOT" ] ; then
                echo "Placing files requires root privileges, please retry." >&2
                exit 1
        fi

        if ! validate_horde ; then
                echo "" >&2
                echo "Not all of the required files are available." >&2
                echo "Please place missing files into this directory." >&2
                return 1
        fi
        if [ "${#DIFFER[@]}" -eq 0 ] ; then
                echo "No files differ, nothing to copy." >&2
                return
        fi
	for bin in "${BINS[@]}" ; do
	        this_bin="$(basename "$bin")"
	        this_dir="$(dirname "$bin")"
                # Empty out the array so it reports 0 elements.
                CMD=()
                # Reset the spacer for the next go around.
                SP=

                bin_suitable "$bin" || continue
                # See if we are replacing ourselves. If so, step aside.
                personality_split "$bin"
	        [ ! -d "$this_dir" ] && CMD=( "mkdir" "-p" "$this_dir" )
	        [ "${#CMD[@]}" -gt 0 ] && echo -e "${CMD[*]}" && "${CMD[@]}"

	        echo -n -e "Placing $this_bin:\\t"
                [ "${#this_bin}" -lt 8 ] && SP="\\t"
                CMD=( "cp" "$this_bin" "$bin" )
	        echo -e "${SP}${CMD[*]}" && "${CMD[@]}"
	        [ "$this_dir" == "${ROOT}${STYLES_DIR}" ] || chmod +x "$bin"
	        sleep 1
	done
}



#
# In case $# is 0 then we fall through the loop
# and execute whatever is in ${CMD[@]}. Which,
# in this case, is the same as -h.
CMD=( "help" "&&" "exit 0" )

while [ $# -ne 0 ] ; do
        case "$1" in
        -h|--help) CMD=( "help" "&&" "exit 0" )
          ;;
        -i) CMD=( "instructions" "&&" "exit 0" )
          ;;
        -l) list_vars "Variables and their values" ROOT HOOKS HOOKS_DIR \
                                STYLES_DIR ZGLUE_LIBDIR SIDE_FILE DEBUG
            exit 0
          ;;
        -p|--place) CMD=( place_files )
          ;;
        -r|--root) [ -d "$2" ] && ROOT=$2 && shift
          ;;
        -u|--update) CMD=( refresh_hooks )
          ;;
        -v|--validate) CMD=( validate_horde )
          ;;
        *) echo "That makes no sense: [$1]" >&2; exit 1
          ;;
        esac
        shift
done
set_bins "$ROOT"

[ "$DEBUG" = "1" ] && list_vars ":: Debug Environs" ZGLUE_LIBDIR HOOKS_DIR STYLES_DIR
[ "$DEBUG" = "1" ] && echo ":: ${CMD[*]}"
"${CMD[@]}"

personality_shrink
