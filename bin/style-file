#!/bin/bash


#
# Wrapping 'echo' with '/bin/echo' so invoking this
# file manually ala "sh $0" won't barf on 'echo -e'.
#
Echo()
{
        /bin/echo -e "$@"
}

#
# Shortcut to send output to stderr by default.
#
echo_err()
{
        Echo  "$@" >&2
}

#
# Shortcut to send output to stderr by default.
#
echo_dbg()
{
        [ -z "$DEBUG" ] && return

        local i=
        local tmp=

        #
        # If the first character in $@ is a ':' then treat $@ as a string.
        #
        tmp="$@"
        [ "${tmp#:}" != "$tmp" ]  && echo "${tmp#:}" && return

        # Else, treat all of the args as undereferenced variables.
        #
        for i in $@ ; do
                /bin/echo -n -e "    ::  $i\t\t" >&2
                Echo  "(${!i})" >&2
        done
}

echo_wbg()
{
        [ -n "$DEBUG" ] && echo_err "$@" && return
}

#
# Create a tmp file to be used by a 'find' call to
# operate on every file of *.[ch]. See filter_style()
#
setup_flip_hashmark()
{
        if [ -z "$1" ] ; then
                echo_err "Is this a file? ($1)?"
                return -1
        fi
        cat >$1 <<"EOF"
#!/bin/bash
#
# For every line that starts with some whitespace leading up to a hash (#)
# replace that set with a leading hash and a space where the original hash
# was
#
# For every instance of '*const', convert to '* const'
#
flip_hashmark()
{
        sed -i  -e '/^  *#/s/^./#/' -e '/^#  *#/s/ #/  /' \
                -e '/^\/\*/,/\*\//s/^\*/ \*/' \
                -e 's/  \*const/ \* const/g'  \
                -e 's/\([^ ]\) \*const/\1 \* const/g' $@
}

if [ -f "$1" ] ; then
        flip_hashmark "$@"
fi

EOF
        chmod +x $1
}


set_files()
{
        local AGAINST=
        local Action=
        local GIT_CMD=

        #
        # Default to working on staged files in the index.
        #
        Action="diff --cached"
        [ "$1" = "unstaged" ] && Action="diff"
        GIT_CMD="git \$Action --name-status --diff-filter=d \$AGAINST | \
                        awk '{print \$NF}'"

        #
        # See if there are any staged files to check:
        #
        Files="$(eval $GIT_CMD)"
        [ -n "$Files" ] && echo $Files && return 0

        #
        # Finding a lack of files to process turn to the most recent
        # commit and assume a commit --amend occurred.
        #
        AGAINST="HEAD^"
        Files="$(eval $GIT_CMD)"
        [ -n "$Files" ] && echo $Files && return 0

        return 1
}

#
# Given a file path find the repo covering that file.
#
find_repo()
{
        cd $(dirname $1) && git rev-parse --show-toplevel 2>/dev/null
}


#
# Given a file path find the repo covering that file.
#
Find_repo()
{
        local TDIR=
        TDIR=$(dirname "$1")

        CMD="TDIR=$(dirname \$TDIR)"
        PRE="$(echo $TDIR | sed -e 's/^\/.*//')"
        if [ "$PRE" != '/' ] ; then
                TDIR="."
                CMD='TDIR="../$TDIR"'
                RECMD='$(cd $TDIR && pwd)'
        fi

        echo_dbg TDIR CMD
        while [ ! -d $TDIR/.git ] && [ ! -d $TDIR/boot/grub ] ; do
                eval $CMD
                [ -n "$DEBUG" ] && sleep 1
        done
        [ -n "$RECMD" ] && eval TDIR=$RECMD
        #
        # Send the results back through stdout.
        #
        [ -d $TDIR/.git ] && echo $TDIR || return 1

        return 0
}

#
# Apply astyle to the list of files
#
filter_style()
{
        local Files=
        local Results=

        Results=$1; shift

        Files=$@
        #
        # Look first in the local directory (ORIGIN) to see if
        # astyle is local and executable.  If not then ask 'which'
        # and if that fails then return error.  While 'which' will
        # only report executable files it could report "" (nothing).
        #
        ASTYLE=${ORIGIN}astyle
        [ ! -x "$ASTYLE" ] && ASTYLE=$(which astyle)
        [ ! -x "$ASTYLE" ] && echo_err "Unable to find the astyle program" && return 1

        ASTYLE_OPTS=astyle-nuttx
        STYLE_OPTIONS=${ORIGIN}${ASTYLE_OPTS}
        ZGLUE_OPTS_DIR=/usr/share/zglue/styles
        [ ! -f $STYLE_OPTIONS ] && STYLE_OPTIONS=$ZGLUE_OPTS_DIR/${ASTYLE_OPTS}

        [ -z "$DEBUG" ]  && QUIET='-q'
        echo_dbg ASTYLE STYLE_OPTIONS

        [ -f "$STYLE_OPTIONS" ] || echo_err "Missing [$STYLE_OPTIONS]" || return 1

        #
        # style check the files to commit, quietly unless DEBUG is set.
        #
        CMD="$ASTYLE --options=$STYLE_OPTIONS $QUIET $Files"
        echo_dbg CMD
        $CMD

        CMD="$TMPFILE $Files"
        $CMD

        # Ignore error messages so they themselves don't cause a style failure.
        git diff $Files > $Results 2>/dev/null

        # Remove incidental files generated by astyle and this script.
        #
        find . -type f -name "*.orig" -exec rm {} \;
}

filter_whitespace()
{
        local file=
        local Results=

        Results="$1"; shift
        for file in "$@" ; do
                if [ ${file%%.c} == $file -a ${file%%.h} == $file ] ; then
                        echo_dbg ":Skipping $file"
                        continue
                fi
                sed -i -e 's/[ 	]\+$//' $file
        done
}

#
# Look for any code bracketed by "#if 0...#endif" and flag it.
# and remove it in case the --add flag was passed.
#
filter_if_0()
{
        local Results=
        local Files=

        Results=$1; shift
        Files=$@

        for i in $Files ; do
                if grep "^[ 	]*#if[ 	]*0" $i >/dev/null  2>&1 ; then
                        sed -i -e '/^[ 	]*#if[ 	]*0/iXXX Remove this if 0!!' $i
                fi
        done
}

#
# Look for externs lurking in header files.
#
filter_externs()
{
        local Files=
        local Results=

        Results=$1; shift
        Files=$@
        for i in $Files ; do
                [ -n "${i%%*.h}" ] && continue
                grep "^extern.*;" $i >/dev/null 2>&1 && sed -i \
                        -e '/^extern.*;/iXXX Remove this extern!' $i
        done
}

FILTER_FUNCTIONS="filter_whitespace filter_if_0 filter_externs"
#
# Run all filters on the files finishing with the astyle formatting last.
#
filter_files()
{
        local RepoRoot=
        local Files=
        local TMPFILE=
        local RESULTS=
        local ZGLUE_OPTS_DIR=
        local STYLE=
        local CMD=
        local ASTYLE=
        local ASTYLE_OPTS=
        local RV=

        RV=1
        RESULTS=${ORIGIN}style.errs

        #
        # Make sure this script is running from the repo root.
        #
        [ "$(basename $0)" = "pre-commit" ] && [ ! -d "$1"/.git ] && return 1

        RepoRoot=$1; shift
        [ ! -f "$1" ] && echo_err "No files to style." && exit 1
        Files=$@

        #
        # Adjust the results to account for minor variations from astyle
        # Create temp script to post process files styled by astyle
        #
        TMPFILE=$(mktemp -p /tmp .cleanup_astyle.XXX)
        setup_flip_hashmark $TMPFILE

        [ -n "$RepoRoot" ] && cd $RepoRoot
        for Func in $FILTER_FUNCTIONS ; do
                $Func $RESULTS $Files
        done
#       filter_whitespace $RESULTS $Files
#       filter_if_0 $RESULTS $Files
#       filter_externs $RESULTS $Files

        #
        # Run filter_style last as it will gather all of the diffs into one file.
        #
        filter_style $RESULTS $Files
        grep "^XXX" $RESULTS && unset GIT_ADD
        cd $ORIGIN

        rm $TMPFILE
        #
        # Set return value based on size of output file.
        #
        [ ! -s $RESULTS ] && RV=0 && echo "Remove $RESULTS" && rm $RESULTS

        return $RV
}

#
# Return the file list containing only *.[ch] files
#
strip_files()
{
        local file=
        local tmp=

        for file in "$@" ; do
                tmp=${file%%*.[ch]}
                [ -n "$tmp" ] && continue
#               [ "${file:0:1}" != "/" ] && file=$REPOROOT/$file
                tmp="$(echo $file | sed -n -e '/^\//p')"
                [ -n "$tmp" ] && file=${REPOROOT}$file
                echo -n "$file "
                echo_dbg file
        done
}

#
# Use the output of git status to create a set of files to process.
#
git_committed()
{
        local IFS=
        local Filter1=
        local Filter2=

        [ "$1" = "unstaged" ] && IFS=" " && echo_dbg ":Setting IFS to a space"
        Filter1="'/^${IFS}[AMC]/p'"
        Filter2="'/^${IFS}[R]/p'"
        git status -uno --porcelain=v1 | eval sed -n -e $Filter1 -e $Filter2 | \
                awk '{print $NF}'
}

#
# Help nessage describing the command line options
#
help()
{
        cat <<"EOF"

        style-file: [-h] [--git] [--add] [--file|-f] [<file 1> <file2> ... ]
                style_file examines the local environment for c source files to
                apply formatting rules to.  For every file listed on the command
                line style_file will format only the *.c *.h files and generate
                a diff file, style.errs, where you are running the program from.

                A list of files may also be provided as a file containing a list
                of files.  Use the '-f <file name>' flag.

                If no files are provided on the command line then style_file will
                first examine the files staged.  If there are no files found then
                style_file examines the set of files in the moxt recent commit
                and format the source files in that check-in.

        -h           Display this message

   -g|  --git        Look to the git index and recent commits for the
                     set of files to check.

   -a | --add        Run 'git add ' on the files formatted

   -f | --file       Provide the list of files to format as a file
                     conbtaining the set of files to format

        *            Files provided on the command line

        Each of these means of collecting files to process are
        mutually exclusive

EOF
#       -w           Target the files in the working directory not in the index. 
#
#
}

#
# Parse the command line args passed in and set variables
# according to args.  Because this is wrapped into a routine
# the variables set mmust be exported from the main env.
#
set_env()
{
        while [ $# -ne 0 ] ; do
                case $1 in
                --add) GIT_ADD=yes;
                        ;;
                -f|--file) [ ! -f "$2" ] && echo_err "No file? [$2]" && exit 1
                        [ -f "$2" ] && FILES=$(cat $2 | sed -e 's/^[ 	]*//') && shift
                        echo_dbg ":" "From containing file, list of files is \n($FILES)"
                        if [ -z "$FILES" ] ; then
                                echo_err "Failed to read files from "$2""
                                exit 1
                        fi
                        [ -n "$FILES" ] && echo_dbg ":" "Found files."
                        ;;
                -g|--git) FILES="$(git_committed)"
                        [ -z "$FILES" ] && echo_err "No files found to process." ; exit 0
                        echo_dbg FILES
                        ;;
                -h) help; exit 0;
                        ;;
                -w) FILES=$(git_committed unstaged);
                        [ -z "$FILES" ] && echo_err "No files found to process." ; exit 0
                        ALT=unstaged
                        ;;
                *) if [ -f "$1" ] ; then
                        FILES="$FILES $1"
                   elif [ ! -f "$1" ]  ; then
                        echo "No such file: ($1)" && exit 1
                   elif [ "$FILE_ARGS" != "1" ] ; then
                        echo_err "Unknown or unexpected arg ($1)."
                        [ -f "$1" ] && \
                                echo_err "The list of files requires a preceding '--'."
                   fi
                        ;;
                esac
                shift
        done
}

ORIGIN=$(pwd)/
export GIT_ADD=
export FILES=
RED='\033[1;31m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
BLUE='\033[1;34m'
RESET='\033[39;49m'
# FUNC="echo_err \"--> ${FUNCNAME[0]}\""

if [ "$(basename $0)" != "pre-commit" ] ; then
        set_env $@
elif [ "$#" -ne 0 ] ; then
        echo_dbg ":Ignoring command line arguments"
fi

[ -z "$FILES" ] && FILES=$(set_files $ALT)
#
# If there are no files to process there weren't any style errors!
#
[ -z "$FILES" ] && Echo  "${GREEN}\tFound no files to process.${RESET}" && exit 0

#
# Assume the first file is representative of the location of the repo
#
REPOROOT=$(find_repo $FILES)
if [ $? -ne 0 -a "$(basename $0)" = "pre-commit" ] ; then
        echo_err "No repo found."
        exit 1
fi
[ -n "$REPOROOT" ] && REPOROOT="$REPOROOT"/

#
# If there are no SRCS to format then by default there are no style errors.
#
SRCS=$(strip_files $FILES)
[ -z "$SRCS" ] && Echo  "${GREEN}\tNo files, no style errors.${RESET}" && exit 0
echo_dbg SRCS REPOROOT ORIGIN

if ! filter_files "$REPOROOT" $SRCS ; then
        [ -n "$DEBUG" ] && VERBOSE=--verbose
        MAIN_PHRASE="${RED}\tNuttx style errors found,"
        PHRASEX="left unstaged."
        if [ -n "$GIT_ADD" ] ; then
                git add $VERBOSE $SRCS
                PHRASEX="${GREEN}corrected, and  staged.${RESET}"
        fi
        echo_err "$MAIN_PHRASE $PHRASEX"
        echo_err "${RED}\tSee style.errs in the root of this repo ($REPOROOT)."
        exit 2
fi
Echo  "${GREEN}\tNo style errors found.${RESET}"

