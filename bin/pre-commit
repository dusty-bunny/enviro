#!/bin/bash

#
# Turn on shell command tracing if DEBUG is "2"
#
[ "$TRACE" = "1" ] && set -x

Red='\033[1;31m'
Reset='\033[0;39;49m'
##### Script personality goes below
ZGLUE_SCRIPTS_DIR=${ZGLUE_SCRIPTS_DIR:-/usr/share/zglue/scripts}
LIB_SCRIPT=${LIB_SCRIPT:-lib_body.sh}
ZGLUE_LIBSTYLE=${ZGLUE_LIBSTYLE:-$ZGLUE_SCRIPTS_DIR/$LIB_SCRIPT}
if [ ! -f "$ZGLUE_SCRIPTS_DIR/$LIB_SCRIPT" ] ; then
        echo "$ZGLUE_SCRIPTS_DIR/$LIB_SCRIPT not found." >&2
        exit 1
fi
# shellcheck disable=1090
source "$ZGLUE_LIBSTYLE"
echo_dbg "ZGLUE_LIBSTYLE := ($ZGLUE_LIBSTYLE)"

#
# Help nessage describing the command line options
#
help()
{
        cat <<"EOF"

        $(basename $0): [-h] [--git] [--add] [--file|-f] [<file 1> <file2> ... ]
                style_file examines the local environment for c source files to
                apply formatting rules to.  For every file listed on the command
                line style_file will format only the *.c *.h files and generate
                a diff file, style.errs, where you are running the program from.

                A list of files may also be provided as a file containing a
                list of files.  Use the '-f <file name>' flag.

                If no files are provided on the command line then style_file
                will first examine the files staged.  If there are no files
                found then style_file examines the set of files in the moxt
                recent commit and format the source files in that check-in.

        -h           Display this message

   -g|  --git        Look to the git index and recent commits for the
                     set of files to check.

   -a | --add        Run 'git add ' on the files formatted

   -f | --file       Provide the list of files to format as a file
                     conbtaining the set of files to format

        *            Files provided on the command line

        Each of these means of collecting files to process are
        mutually exclusive

EOF
}

#
# Parse the command line args passed in and set variables
# according to args.  Because this is wrapped into a routine
# the variables set mmust be exported from the main env.
#
set_env()
{
        while [ $# -ne 0 ] ; do
                # shellcheck disable=2207
                case "$1" in
                --add) GIT_ADD=yes;
                        ;;
                -c|--color-off) COLOR_OFF=0
                        ;;
                -f|--file) [ ! -f "$2" ] && echo_err "No file? [$2]" && exit 1
                        [ -f "$2" ] && FILES=( $(sed -e 's/^[ 	]*//' "$2") ) && shift
                        echo_dbg "From containing file, list of files is \\n(${FILES[*]})"
                        if [ -z "${FILES[*]}" ] ; then
                                echo_err "Failed to read files from $2"
                                exit 1
                        fi
                        [ -n "${FILES[*]}" ] && echo_dbg "Found files."
                        ;;
                -g|--git) FILES=( $(git_committed) )
                        [ -z "${FILES[*]}" ] && echo_err "No files found to process." ; exit 0
                        echo_dbg "${FILES[@]}"
                        ;;
                -h) help; exit 0;
                        ;;
                -w) FILES=( $(git_committed unstaged) );
                        [ -z "${FILES[*]}" ] && echo_err "No files found to process." ; exit 0
                        ALT=unstaged
                        ;;
                *) if [ -f "$1" ] ; then
                        FILES=( "${FILES[@]}" "$1" )
                   elif [ ! -f "$1" ]  ; then
                        echo_err "${Red}No such file: ($1)${Reset}" && exit 1
                   elif [ "$FILE_ARGS" != "1" ] ; then
                        echo_err "Unknown or unexpected arg ($1)."
                        [ -f "$1" ] && \
                                echo_err "The list of files requires a preceding '--'."
                   fi
                        ;;
                esac
                shift
        done

        # In case any leading and/or trailing white space exists
        strip_edge_ws "${FILES[@]}"
}

# In case any leading and/or trailing white space exists
[ -n "${FILES[*]}" ] && strip_edge_ws FILES

export FILTERS_NRF="/nrf52/ /nrf52832_dk/"
export FILTER_FUNCTIONS="filter_out_whitespace filter_set_noexec filter_if_0 filter_for_externs"

REPO_HOST="101.132.142.37"
ACTIVELY_MANAGED_REPOS=( \
        "nuttx@$REPO_HOST" \
        "nuttx_apps@$REPO_HOST" \
        "auto_test@$REPO_HOST" \
        "3rd_Party_SDK@$REPO_HOST" \
        "fast_api@$REPO_HOST" \
        )

if [ "$(basename "$0")" != "pre-commit" ] ; then
        set_env "$@"
elif [ "$#" -ne 0 ] ; then
        echo "Ignoring command line arguments"
fi
set_colors $COLOR_OFF
[ "$COLOR_OFF" = "0" ] && echo_err "${GRNGRN}=== colors should be off."

#
# At this point if no files have been provided over the command line
# make sure we are running within a repo else there will be no way
# to discover any potential files for processing.
#
if ! REPOROOT="$(find_repo "${FILES[@]}")" ; then
        # shellcheck disable=2153
        echo_err "${REDYLW}Error looking for a repo root directory."
        exit 1
fi
#
# Check whether this repo is to be styled.
#
if ! in_managed_repo "${ACTIVELY_MANAGED_REPOS[@]}" ; then
        echo_dbg "This working tree is not from an actively managed repo."
        echo_dbg "Do nothing."
        exit 0
fi
echo_dbg "This repo is actively managed."


# shellcheck disable=2207
[ -z "${FILES[*]}" ] && FILES=( $(set_files "$ALT") )

# In case any leading and/or trailing white space exists
strip_edge_ws "${FILES[@]}"

#
# If there are no files to process there weren't any style errors!
#
[ -z "${FILES[*]}" ] && \
        echo_dbg  "${GRNGRN}\\tNo files to process." && \
        exit 0

#
# Assume the first file is representative of the location of the repo
#
if [ "$REPOROOT" != "$(find_repo "${FILES[@]}")" ] ; then
        echo_err "Yikes!"
        if [ "$(basename "$0")" = "pre-commit" ] ; then
                echo_err "No repo found."
                exit 1
        fi
fi
[ -n "$REPOROOT" ] && REPOROOT="$REPOROOT"/
echo_dbg REPOROOT

#
# If there are no SRCS to format then by default there are no style errors.
#
echo_dbg SRCS REPOROOT ORIGIN
strip_edge_ws "${FILES[@]}"
ERR_FILE=style.errs
if ! filter_files "$REPOROOT" "$ERR_FILE" "${FILES[@]}" ; then
        [ "$DEBUG" = "1" ] && VERBOSE=--verbose
        MAIN_PHRASE="${REDYLW}\\tNuttx style errors found,"
        PHRASEX="left unstaged."
        if [ -n "$GIT_ADD" ] ; then
                git add "$VERBOSE" "$SRCS"
                PHRASEX="${GRNGRN}corrected, and  staged."
        fi
        echo_err "$MAIN_PHRASE $PHRASEX"
        echo_err "${REDYLW}\\tSee style.errs in the root of this repo ($REPOROOT)."
        exit 2
fi
echo_err  "${GRNGRN}\\tNo style errors found."

