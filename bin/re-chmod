#!/bin/bash

[ "$DEBUG" = "1" ] && ECHO="echo" && STDERR='>&2' && echo "ECHO ($ECHO), STDERR ($STDERR)" >&2
[ "$TRACE" = "1" ] && set -x && echo "Set -x"

help_msg()
{
        cat <<"EOF"
        re-chmod [-h | -c | -x ]
        -c:  Run commit as well as git add.
        -h:  help_msg (the message you're, hopefully, reading)
        -r:  Restore the working tree back to top of tree (HEAD)
        -x:  Remove the -x permissions from files in nrf52 directories.
EOF
}
[ $# -eq 0 ] && help_msg && exit

#
# General purpose for loop.
#
# Arg1 : command to run on each loop
# Arg* : list of files to process
#
do_for()
{
        local Cmd=
        declare -a List=
        local var=

        Cmd="$1" ; shift
        List=( "$@" )

        for var in "${List[@]}" ; do
                $ECHO $Cmd $var
        done
}

#
# Check each file found having the executable permissions
# and verify that they no longer have executable permissions.
#
# Output any failures.
#
verify_no_exec()
{
        local Files=
        local file=

        Files=( "$@" )
        for file in "${Files[@]}" ; do
                if [ -x "$file" ] ; then
                        Rv=$(( Rv + 1 ))
                        echo -n "$file"
                        echo -n -e "  "
                        [ "$DEBUG" = "2" ] && echo "===!! ($file)" >&2
                fi
        done
}

#
# back out the chmods by git reset followed by git checkout .
#
restore_repo()
{
        local Msg=

        Msg="$@"
        echo "Resetting your work space to HEAD:"
        HEAD=HEAD
        if git log -1 --grep="$Msg" ; then
                HEAD=HEAD^
        fi
        $ECHO git reset -- hard $HEAD >/dev/null 2>&1
#       git checkout .
}

find_executable_files()
{
find arch/arm/src/nrf52 configs/nrf52832_dk arch/arm/include/nrf52 -type f -executable | while read badperms; do
        if [ -z "$(file -b $badperms | grep -v executable)" ] ; then
                [ "$VERBOSE" = "1" ] && echo "continure for executable $badperms" >&2
                continue
        fi
        if [ -z "${badperms##*.sh}" ] || [ -z "${badperms##*.bat}" ] || [ -z "${badperms##*.pl}" ] || [ -z "${badperms##*.py}" ] ;\
        then
                [ "$VERBOSE" = "1" ] && echo "continure for script $badperms" >&2
                continue
        fi
        echo -n $badperms
        # add space between files
        echo "  "
done
}

COMMIT_MSG="\"  Remove __X__X__X perm bit from source files.\""
while [ $# -gt 0 ] ; do
        case "$1" in
        -c) DO_COMMIT='git commit -m $(echo $COMMIT_MSG)'
            DO_FIX='git add ${GIT_ADD_FILES[@]}'
        ;;
        -h) help_msg
            exit
        ;;
        -l) GIT_ADD_FILES=( $(find_executable_files) )
            if [ -z "${GIT_ADD_FILES[*]}" ] ; then
                echo "No executable source or text files found."
            else
                echo "${GIT_ADD_FILES[@]}"
            fi
            exit
        ;;
        -r) restore_repo
            git status >&2
           exit
        ;;
        -s) git status
        ;;
        -x) DO_FIX='git add ${GIT_ADD_FILES[@]}'
        ;;
        *) echo "What is this: [$1]?" >&2
           help_msg
           exit 1
        ;;
        esac
        shift
done

# echo "GIT_ADD_FILES:  ($GIT_ADD_FILES)"
GIT_ADD_FILES=( $(find_executable_files) )
echo "(${GIT_ADD_FILES[*]})" >&2

[ -z "${GIT_ADD_FILES[*]}" ] && echo "Nothing to chmod" >&2 && exit

[ "$DEBUG" = "1" ] && echo "Files to be added: ${#GIT_ADD_FILES[@]}" >&2

do_for "chmod -x" "${GIT_ADD_FILES[@]}"

BADFILES=$(verify_no_exec ${GIT_ADD_FILES[@]})
# verify_no_exec $GIT_ADD_FILES
[ -n "$BADFILES" ] && [ "$DEBUG" = "1" ] && echo ":: Files remaining unmodified: ($BADFILES)"

eval $ECHO $DO_FIX
$ECHO $DO_COMMIT

