From 5712e005da6df0780884a07e13c80f0c9e4599e8 Mon Sep 17 00:00:00 2001
From: Min <min.yang@zglue.com>
Date: Mon, 27 Nov 2017 17:08:07 -0800
Subject: BLE_HELLO and RTC both work

more ammenments:  address ble_hello failures with bsp.c

ammend origin commit with removal of developer's helper scripts (nordic.bat)
and the error file output of pre-commit (style.errs).  Following those
actions, restore sched/init/os_start.c and sched/clock/clock_initialize.c
to avoid triggering a style check on files within a protected dir space.
In particular the sched directory sub-tree.

This ought to resolve the complaints from Gerrit/Jenkins.

Change-Id: Ib63b893cea4ecaf468c823512849c147853c9e3e
---
 Makefile.unix                                      |   14 +-
 Makefile.win                                       |   21 +-
 README.txt                                         |    4 +-
 arch/arm/src/nrf52/Kconfig                         |    0
 arch/arm/src/nrf52/Make.defs                       |   31 +-
 arch/arm/src/nrf52/Make.vars                       |    1 +
 arch/arm/src/nrf52/chip/nrf52_i2c.h                |    6 +-
 arch/arm/src/nrf52/chip/nrf52_rtc.h                |   12 +-
 .../src/nrf52/components/drivers_nrf/hal/nrf_ecb.c |   22 +-
 .../src/nrf52/components/drivers_nrf/hal/nrf_egu.h |   12 +-
 .../nrf52/components/drivers_nrf/hal/nrf_gpiote.h  |   22 +-
 .../nrf52/components/drivers_nrf/hal/nrf_qspi.h    |    2 +-
 .../nrf52/components/drivers_nrf/hal/nrf_temp.h    |   12 +-
 arch/arm/src/nrf52/components/libraries/bsp/bsp.c  |   81 +-
 arch/arm/src/nrf52/components/libraries/bsp/bsp.h  |    8 +
 .../nrf52/components/libraries/bsp/bsp_btn_ant.c   |   12 +-
 .../nrf52/components/libraries/bsp/bsp_btn_ant.h   |   38 +-
 .../src/nrf52/components/libraries/bsp/bsp_nfc.h   |   26 +-
 .../nrf52/components/libraries/button/app_button.c |   25 +-
 .../nrf52/components/libraries/button/app_button.h |    4 +
 .../components/libraries/sensorsim/sensorsim.c     |   73 ++
 .../components/libraries/sensorsim/sensorsim.h     |   94 ++
 .../nrf52/components/libraries/timer/app_timer.c   | 1071 ++------------------
 .../nrf52/components/libraries/timer/app_timer.h   |  247 +----
 .../nrf52/components/libraries/util/app_error.c    |    2 +-
 .../src/nrf52/components/libraries/util/app_util.h |   52 +-
 .../common/softdevice_handler/softdevice_handler.c |    8 +
 .../nrf52/components/softdevice/s132/headers/ble.h |    8 +-
 .../components/softdevice/s132/headers/ble_gap.h   |    4 +-
 .../components/softdevice/s132/headers/ble_gattc.h |    2 +-
 .../components/softdevice/s132/headers/ble_gatts.h |    4 +-
 .../components/softdevice/s132/headers/ble_l2cap.h |    2 +-
 .../softdevice/s132/headers/nrf52/nrf_mbr.h        |    6 +-
 .../components/softdevice/s132/headers/nrf_error.h |    4 +-
 .../softdevice/s132/headers/nrf_error_sdm.h        |    4 +-
 .../softdevice/s132/headers/nrf_error_soc.h        |    4 +-
 .../components/softdevice/s132/headers/nrf_nvic.h  |    1 -
 .../components/softdevice/s132/headers/nrf_sdm.h   |    4 +-
 .../components/softdevice/s132/headers/nrf_soc.h   |  112 +-
 .../src/nrf52/components/toolchain/system_nrf52.c  |    2 +-
 arch/arm/src/nrf52/nrf.h                           |    6 +-
 arch/arm/src/nrf52/nrf52.h                         |  351 +++----
 arch/arm/src/nrf52/nrf52_exti_comp.c               |    4 +-
 arch/arm/src/nrf52/nrf52_gpiote.c                  |    6 +-
 arch/arm/src/nrf52/nrf52_gpiote.h                  |    7 +-
 arch/arm/src/nrf52/nrf52_i2c.c                     |   14 +-
 arch/arm/src/nrf52/nrf52_idle.c                    |    2 +-
 arch/arm/src/nrf52/nrf52_irq.c                     |    2 +-
 arch/arm/src/nrf52/nrf52_pwm.h                     |   54 +-
 arch/arm/src/nrf52/nrf52_rtc.c                     |   41 +-
 arch/arm/src/nrf52/nrf52_rtc.h                     |    4 +-
 arch/arm/src/nrf52/nrf52_rtc_lowerhalf.c           |   14 +-
 arch/arm/src/nrf52/nrf52_rtcounter.c               |  243 +++++
 arch/arm/src/nrf52/nrf52_serial.c                  |  145 +--
 arch/arm/src/nrf52/nrf52_spi.c                     |    4 +-
 arch/arm/src/nrf52/nrf52_start.c                   |    0
 arch/arm/src/nrf52/nrf52_tim.c                     |  116 +--
 arch/arm/src/nrf52/nrf52_timerisr.c                |    3 +-
 arch/arm/src/nrf52/nrf_drv_common.c                |    2 +-
 configs/nrf52832_dk/Makefile                       |    7 +-
 configs/nrf52832_dk/ble_hello/Make.defs            |    2 +-
 configs/nrf52832_dk/ble_hello/defconfig            |   19 +-
 configs/nrf52832_dk/defaults.mk                    |    4 +-
 configs/nrf52832_dk/nsh/defconfig                  |   53 +-
 configs/nrf52832_dk/rtc/Make.defs                  |   40 +
 configs/nrf52832_dk/rtc/defconfig                  | 1044 +++++++++++++++++++
 configs/nrf52832_dk/src/nrf52_appinit.c            |   28 +-
 drivers/sensors/mc3672.c                           |  609 +++++------
 drivers/timers/Kconfig                             |   22 +-
 drivers/timers/counter.c                           |  300 +++---
 include/nuttx/sensors/ioctl.h                      |   12 +-
 include/nuttx/timers/counter.h                     |   25 +-
 72 files changed, 2725 insertions(+), 2521 deletions(-)
 mode change 100644 => 100755 arch/arm/src/nrf52/Kconfig
 mode change 100644 => 100755 arch/arm/src/nrf52/Make.defs
 mode change 100644 => 100755 arch/arm/src/nrf52/chip/nrf52_rtc.h
 mode change 100644 => 100755 arch/arm/src/nrf52/components/libraries/bsp/bsp.h
 mode change 100644 => 100755 arch/arm/src/nrf52/components/libraries/button/app_button.c
 mode change 100644 => 100755 arch/arm/src/nrf52/components/libraries/button/app_button.h
 create mode 100644 arch/arm/src/nrf52/components/libraries/sensorsim/sensorsim.c
 create mode 100644 arch/arm/src/nrf52/components/libraries/sensorsim/sensorsim.h
 mode change 100644 => 100755 arch/arm/src/nrf52/components/libraries/timer/app_timer.c
 mode change 100644 => 100755 arch/arm/src/nrf52/components/libraries/timer/app_timer.h
 mode change 100644 => 100755 arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_nvic.h
 mode change 100644 => 100755 arch/arm/src/nrf52/nrf52_rtc.h
 create mode 100644 arch/arm/src/nrf52/nrf52_rtcounter.c
 mode change 100644 => 100755 arch/arm/src/nrf52/nrf52_start.c
 mode change 100644 => 100755 configs/nrf52832_dk/Makefile
 mode change 100644 => 100755 configs/nrf52832_dk/ble_hello/defconfig
 create mode 100644 configs/nrf52832_dk/rtc/Make.defs
 create mode 100644 configs/nrf52832_dk/rtc/defconfig
 mode change 100755 => 100644 drivers/sensors/mc3672.c
 mode change 100644 => 100755 drivers/timers/Kconfig
 mode change 100644 => 100755 drivers/timers/counter.c
 mode change 100644 => 100755 include/nuttx/timers/counter.h

diff --git a/Makefile.unix b/Makefile.unix
index f4dae36e2e..5afd47bde7 100644
--- a/Makefile.unix
+++ b/Makefile.unix
@@ -53,16 +53,6 @@ export Q := @
 endif
 endif
 
-ifeq ($(_MAJOR_),)
-export _MAJOR_ := 0
-endif
-ifeq ($(_MINOR_),)
-export _MINOR_ := 0
-endif
-ifeq ($(_BUILD_VERSION_),)
-export _BUILD_VERSION_ := 0
-endif
-
 # Default tools
 
 ifeq ($(DIRLINK),)
@@ -260,8 +250,7 @@ tools/mkversion$(HOSTEXEEXT):
 $(TOPDIR)/.version:
 	$(Q) if [ ! -f .version ]; then \
 		echo "No .version file found, creating one"; \
-		echo "MAJOR $(_MAJOR_) MINOR $(_MINOR_) Build_Version $(_BUILD_VERSION_)" ; \
-		tools/version.sh -v $(_MAJOR_).$(_MINOR_) -b $(_BUILD_VERSION_) .version; \
+		tools/version.sh -v 0.0 -b 0 .version; \
 		chmod 755 .version; \
 	fi
 
@@ -351,7 +340,6 @@ clean_context:
 	$(Q) $(MAKE) -C configs TOPDIR="$(TOPDIR)" clean_context
 	$(call DELFILE, include/nuttx/config.h)
 	$(call DELFILE, include/nuttx/version.h)
-	$(call DELFILE, .version)
 	$(call DELFILE, include/math.h)
 	$(call DELFILE, include/stdarg.h)
 	$(Q) $(DIRUNLINK) include/arch/board
diff --git a/Makefile.win b/Makefile.win
index 2fb3bab992..feb94d5eb3 100644
--- a/Makefile.win
+++ b/Makefile.win
@@ -53,18 +53,6 @@ export Q := @
 endif
 endif
 
-ifeq ($(_MAJOR_),)
-export _MAJOR_ := 0
-endif
-
-ifeq ($(_MINOR_),)
-export _MINOR_ := 0
-endif
-
-ifeq ($(_BUILD_VERSION_),)
-export _BUILD_VERSION_ := 0
-endif
-
 # This define is passed as EXTRADEFINES for kernel-mode builds.  It is also passed
 # during PASS1 (but not PASS2) context and depend targets.
 
@@ -253,10 +241,10 @@ tools\mkversion$(HOSTEXEEXT):
 	$(Q) $(MAKE) -C tools -f Makefile.host TOPDIR="$(TOPDIR)"  mkversion$(HOSTEXEEXT)
 
 $(TOPDIR)\.version:
-	$(Q) echo CONFIG_VERSION_STRING="$(_MAJOR_).$(_MINOR_)" > .version
-	$(Q) echo CONFIG_VERSION_MAJOR=$(_MAJOR_) >> .version
-	$(Q) echo CONFIG_VERSION_MINOR=$(_MINOR_) >> .version
-	$(Q) echo CONFIG_VERSION_BUILD="$(_BUILD_VERSION_)" >> .version
+	$(Q) echo CONFIG_VERSION_STRING="0" > .version
+	$(Q) echo CONFIG_VERSION_MAJOR=0 >> .version
+	$(Q) echo CONFIG_VERSION_MINOR=0 >> .version
+	$(Q) echo CONFIG_VERSION_BUILD="0" >> .version
 
 # $(Q) if [ ! -f .version ]; then \
 # 	echo "No .version file found, creating one"; \
@@ -369,7 +357,6 @@ context: check_context include\nuttx\config.h include\nuttx\version.h include\ma
 clean_context:
 	$(call DELFILE, include\nuttx\config.h)
 	$(call DELFILE, include\nuttx\version.h)
-	$(call DELFILE, .version)
 	$(call DELFILE, include\math.h)
 	$(call DELFILE, include\stdarg.h)
 	$(call DELDIR, include\arch\board)
diff --git a/README.txt b/README.txt
index ed3d41c30f..ed079aaf3d 100644
--- a/README.txt
+++ b/README.txt
@@ -1,5 +1,5 @@
-README
-^^^^^^
+README --:wq!
+ 
 
   o Environments
     - Installing Cygwin
diff --git a/arch/arm/src/nrf52/Kconfig b/arch/arm/src/nrf52/Kconfig
old mode 100644
new mode 100755
diff --git a/arch/arm/src/nrf52/Make.defs b/arch/arm/src/nrf52/Make.defs
old mode 100644
new mode 100755
index ccb770fc88..aee1c6f677
--- a/arch/arm/src/nrf52/Make.defs
+++ b/arch/arm/src/nrf52/Make.defs
@@ -104,20 +104,10 @@ endif
 
 CHIP_ASRCS  =
 CHIP_CSRCS  =  nrf52_gpio.c nrf52_start.c nrf52_idle.c nrf52_irq.c
-CHIP_CSRCS  += nrf52_timerisr.c nrf_drv_common.c nrf52_lowputc.c
-CHIP_CSRCS  += nrf52_allocateheap.c nrf52_serial.c
-
-
-VPATH += $(TOOLCHAIN)
-CHIP_CSRCS  += system_nrf52.c
-VPATH += $(CLOCK)
-CHIP_CSRCS  += nrf_drv_clock.c
-
-VPATH += $(LIB_UTIL)
-CHIP_CSRCS  += app_util_platform.c
-
-VPATH  += $(LIB_UART)
-CHIP_CSRCS  += app_uart.c retarget.c
+CHIP_CSRCS  += nrf52_timerisr.c nrf_drv_common.c $(TOOLCHAIN)/system_nrf52.c
+CHIP_CSRCS  += nrf52_allocateheap.c nrf52_serial.c $(CLOCK)/nrf_drv_clock.c
+CHIP_CSRCS  += nrf52_lowputc.c $(LIB_UTIL)/app_util_platform.c
+CHIP_CSRCS  += $(LIB_UART)/app_uart.c $(LIB_UART)/retarget.c
 
 VPATH  += $(HAL_HEADERS)
 CHIP_CSRCS  += nrf_nvmc.c
@@ -125,24 +115,22 @@ CHIP_CSRCS  += nrf52_flash.c
 CHIP_CSRCS  += nrf52_waste.c
 
 ifeq ($(CONFIG_NRF52_BLUETOOTH),y)
-
 VPATH  += $(LIB_SRC)
 VPATH  += $(LIB_BSP)
 VPATH  += $(SD_HANDLER)
-VPATH  += $(LIB_FDS) $(LIB_FSTORE) $(LIB_TIMR) $(BOARDS) $(BUTTON)
+VPATH  += $(LIB_FDS) $(LIB_FSTORE) $(LIB_TIMR) $(BOARDS) $(BUTTON) $(LIB_SENSOR) $(LIB_UTIL)
 CHIP_CSRCS  += softdevice_handler.c app_error_weak.c
 CHIP_CSRCS  += sdk_mapped_flags.c
 CHIP_CSRCS  += nrf_log_frontend.c nrf_log_backend_serial.c
 CHIP_CSRCS  += app_error.c
 CHIP_CSRCS  += bsp.c bsp_btn_ble.c
-
 CHIP_CSRCS  += fds.c fstorage.c
 CHIP_CSRCS  += app_timer.c
 CHIP_CSRCS  += boards.c
 CHIP_CSRCS  += app_button.c
+CHIP_CSRCS  += sensorsim.c
 endif
 
-
 ifeq ($(CONFIG_I2C),y)
 CHIP_CSRCS += nrf52_i2c.c
 endif
@@ -159,6 +147,10 @@ ifeq ($(CONFIG_NRF52_PPI),y)
 CHIP_CSRCS += nrf52_ppi.c
 endif
 
+ifeq ($(CONFIG_RTC),y)
+CHIP_CSRCS += nrf52_rtcounter.c
+endif
+
 #ifneq ($(CONFIG_SCHED_TICKLESS),y)
 #CHIP_CSRCS += nrf52_timerisr.c
 #else
@@ -231,6 +223,9 @@ endif
 #CHIP_CSRCS += nrf52_rtc_lowerhalf.c
 #CHIP_CSRCS += nrf52_rtcc.c
 #endif
+ifeq ($(CONFIG_COUNTER),y)
+CHIP_CSRCS += nrf52_rtc_lowerhalf.c nrf52_rtc.c nrf52_rtcounter.c 
+endif
 #endif
 
 #ifeq ($(CONFIG_DEBUG_FEATURES),y)
diff --git a/arch/arm/src/nrf52/Make.vars b/arch/arm/src/nrf52/Make.vars
index ebb075ebc8..ab8c3d9fe1 100755
--- a/arch/arm/src/nrf52/Make.vars
+++ b/arch/arm/src/nrf52/Make.vars
@@ -32,6 +32,7 @@ LIB_FSTORE  = $(COMP_DIR)/libraries/fstorage
 LIB_LOG     = $(COMP_DIR)/libraries/log
 LIB_SRC     = $(COMP_DIR)/libraries/log/src
 LIB_TIMR    = $(COMP_DIR)/libraries/timer
+LIB_SENSOR  = $(COMP_DIR)/libraries/sensorsim
 LIB_UTIL    = $(COMP_DIR)/libraries/util
 LIB_UART    = $(COMP_DIR)/libraries/uart
 MIDDLE      = $(COMP_DIR)/serialization/connectivity/codecs/ble/middleware
diff --git a/arch/arm/src/nrf52/chip/nrf52_i2c.h b/arch/arm/src/nrf52/chip/nrf52_i2c.h
index 6a5f1f7b9e..d00247f23e 100644
--- a/arch/arm/src/nrf52/chip/nrf52_i2c.h
+++ b/arch/arm/src/nrf52/chip/nrf52_i2c.h
@@ -97,9 +97,9 @@
     }
 
 /**
-* @enum nrf_i2c_frequency_t
-* @brief i2c frequency supported by nrf52.
-*/
+ * @enum nrf_i2c_frequency_t
+ * @brief i2c frequency supported by nrf52.
+ */
 typedef enum
 {
   NRF_I2C_FREQUENCY_100K   =  26738688,
diff --git a/arch/arm/src/nrf52/chip/nrf52_rtc.h b/arch/arm/src/nrf52/chip/nrf52_rtc.h
old mode 100644
new mode 100755
index 971ea9cd03..6ecc096a18
--- a/arch/arm/src/nrf52/chip/nrf52_rtc.h
+++ b/arch/arm/src/nrf52/chip/nrf52_rtc.h
@@ -54,7 +54,9 @@
 extern "C" {
 #endif
 
-//#define RTC_PRESCALER 4095  // RTC freq=8Hz
+#define APP_TIMER_ENABLE 1  //MinYang temporarity defined for the Macro, need to think to put to other place
+
+
 #define RTC_PRESCALER 327  // RTC freq=100Hz
 
 #ifndef RTC_DEFAULT_CONFIG_FREQUENCY
@@ -304,6 +306,14 @@ uint32_t nrf52_drv_rtc_cc_set(FAR struct nrf52_rtc_dev_s *dev,
 uint32_t nrf52_get_current_rtc_timeout(FAR struct nrf52_rtc_dev_s *dev);
 
 
+
+/**
+ * @brief Get the current counter value in the private structure
+ *
+ * @param[in] p_instance Pointer to the driver instance structure.
+ */
+uint32_t nrf52_get_current_rtc_counter(FAR struct nrf52_rtc_dev_s *dev);
+
 /**
  * @brief Function for initializing the rtc.
  *
diff --git a/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_ecb.c b/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_ecb.c
index edb044c265..045f4da4b5 100644
--- a/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_ecb.c
+++ b/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_ecb.c
@@ -1,15 +1,15 @@
 /* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
-*
-* The information contained herein is property of Nordic Semiconductor ASA.
-* Terms and conditions of usage are described in detail in NORDIC
-* SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
-*
-* Licensees are granted free, non-transferable use of the information. NO
-* WARRANTY of ANY KIND is provided. This heading must NOT be removed from
-* the file.
-*
-* $LastChangedRevision: 25419 $
-*/
+ *
+ * The information contained herein is property of Nordic Semiconductor ASA.
+ * Terms and conditions of usage are described in detail in NORDIC
+ * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
+ *
+ * Licensees are granted free, non-transferable use of the information. NO
+ * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
+ * the file.
+ *
+ * $LastChangedRevision: 25419 $
+ */
 
 /**
  * @file
diff --git a/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_egu.h b/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_egu.h
index f8aa160f2d..2d8e3901f3 100644
--- a/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_egu.h
+++ b/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_egu.h
@@ -14,12 +14,12 @@
 #define NRF_EGU_H__
 
 /**
-* @defgroup nrf_egu EGU (Event Generator Unit) abstraction
-* @{
-* @ingroup nrf_drivers
-* @brief @tagAPI52 EGU (Event Generator Unit) module functions.
-*
-*/
+ * @defgroup nrf_egu EGU (Event Generator Unit) abstraction
+ * @{
+ * @ingroup nrf_drivers
+ * @brief @tagAPI52 EGU (Event Generator Unit) module functions.
+ *
+ */
 
 #include <stddef.h>
 #include <stdbool.h>
diff --git a/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_gpiote.h b/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_gpiote.h
index 5ee794e029..2afbc830fe 100644
--- a/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_gpiote.h
+++ b/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_gpiote.h
@@ -28,16 +28,16 @@ extern "C" {
 #define GPIOTE_CONFIG_PORT_PIN_Msk GPIOTE_CONFIG_PSEL_Msk
 #endif
 /**
-* @defgroup nrf_gpiote_abs GPIOTE abstraction
-* @{
-* @ingroup nrf_gpiote
-* @brief GPIOTE abstraction for configuration of channels.
-*/
+ * @defgroup nrf_gpiote_abs GPIOTE abstraction
+ * @{
+ * @ingroup nrf_gpiote
+ * @brief GPIOTE abstraction for configuration of channels.
+ */
 
 /**
-* @enum nrf_gpiote_polarity_t
-* @brief Polarity for the GPIOTE channel.
-*/
+ * @enum nrf_gpiote_polarity_t
+ * @brief Polarity for the GPIOTE channel.
+ */
 typedef enum
 {
   NRF_GPIOTE_POLARITY_LOTOHI = GPIOTE_CONFIG_POLARITY_LoToHi,       ///<  Low to high.
@@ -47,9 +47,9 @@ typedef enum
 
 
 /**
-* @enum nrf_gpiote_outinit_t
-* @brief Initial output value for the GPIOTE channel.
-*/
+ * @enum nrf_gpiote_outinit_t
+ * @brief Initial output value for the GPIOTE channel.
+ */
 typedef enum
 {
   NRF_GPIOTE_INITIAL_VALUE_LOW  = GPIOTE_CONFIG_OUTINIT_Low,       ///<  Low to high.
diff --git a/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_qspi.h b/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_qspi.h
index 288a8cbc19..ecf969cb30 100644
--- a/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_qspi.h
+++ b/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_qspi.h
@@ -374,7 +374,7 @@ __STATIC_INLINE void nrf_qspi_ifconfig1_set(NRF_QSPI_Type              *p_reg,
  *
  * @param[in] p_reg    Pointer to the peripheral register structure.
  * @param[in] p_config Pointer to the addressing mode configuration structure. See @ref nrf_qspi_addrconfig_conf_t.
-*/
+ */
 __STATIC_INLINE void nrf_qspi_addrconfig_set(NRF_QSPI_Type                     *p_reg,
                                              const nrf_qspi_addrconfig_conf_t *p_config);
 
diff --git a/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_temp.h b/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_temp.h
index bc84b2e904..44209cbb90 100644
--- a/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_temp.h
+++ b/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_temp.h
@@ -20,12 +20,12 @@ extern "C" {
 #endif
 
 /**
-* @defgroup nrf_temperature TEMP (temperature) abstraction
-* @{
-* @ingroup nrf_drivers temperature_example
-* @brief Temperature module init and read functions.
-*
-*/
+ * @defgroup nrf_temperature TEMP (temperature) abstraction
+ * @{
+ * @ingroup nrf_drivers temperature_example
+ * @brief Temperature module init and read functions.
+ *
+ */
 
 /**@cond NO_DOXYGEN */
 #define MASK_SIGN           (0x00000200UL)
diff --git a/arch/arm/src/nrf52/components/libraries/bsp/bsp.c b/arch/arm/src/nrf52/components/libraries/bsp/bsp.c
index 29c146ba10..d826d90325 100644
--- a/arch/arm/src/nrf52/components/libraries/bsp/bsp.c
+++ b/arch/arm/src/nrf52/components/libraries/bsp/bsp.c
@@ -30,15 +30,17 @@ static bsp_indication_t m_stable_state        = BSP_INDICATE_IDLE;
 static bool             m_leds_clear          = false;
 static uint32_t         m_app_ticks_per_100ms = 0;
 static uint32_t         m_indication_type     = 0;
-APP_TIMER_DEF(m_leds_timer_id);
-APP_TIMER_DEF(m_alert_timer_id);
+//APP_TIMER_DEF(m_alert_timer_id);
+struct timer_posix m_leds_timer_id, m_alert_timer_id;
 #endif // LEDS_NUMBER > 0 && !(defined BSP_SIMPLE)
 
 #if defined(BUTTONS_NUMBER) && BUTTONS_NUMBER > 0
 #ifndef BSP_SIMPLE
 static bsp_event_callback_t   m_registered_callback         = NULL;
 static bsp_button_event_cfg_t m_events_list[BUTTONS_NUMBER] = {{BSP_EVENT_NOTHING, BSP_EVENT_NOTHING}};
-APP_TIMER_DEF(m_button_timer_id);
+//APP_TIMER_DEF(m_button_timer_id);
+struct timer_posix m_button_timer_id;
+
 static void bsp_button_event_handler(uint8_t pin_no, uint8_t button_action);
 #endif // BSP_SIMPLE
 
@@ -98,9 +100,8 @@ static void bsp_button_event_handler(uint8_t pin_no, uint8_t button_action)
 {
   bsp_event_t        event  = BSP_EVENT_NOTHING;
   uint32_t           button = 0;
-  uint32_t           err_code;
-  static uint8_t
-  current_long_push_pin_no;              /**< Pin number of a currently pushed button, that could become a long push if held long enough. */
+  //uint32_t           err_code;
+  //static uint8_t     current_long_push_pin_no;              /**< Pin number of a currently pushed button, that could become a long push if held long enough. */
   static bsp_event_t
   release_event_at_push[BUTTONS_NUMBER]; /**< Array of what the release event of each button was last time it was pushed, so that no release event is sent if the event was bound after the push of the button. */
 
@@ -112,18 +113,9 @@ static void bsp_button_event_handler(uint8_t pin_no, uint8_t button_action)
         {
           case APP_BUTTON_PUSH:
             event = m_events_list[button].push_event;
-            if (m_events_list[button].long_push_event != BSP_EVENT_NOTHING)
-              {
-                err_code = app_timer_start(m_button_timer_id, BSP_MS_TO_TICK(BSP_LONG_PUSH_TIMEOUT_MS), (void *)&current_long_push_pin_no);
-                if (err_code == NRF_SUCCESS)
-                  {
-                    current_long_push_pin_no = pin_no;
-                  }
-              }
             release_event_at_push[button] = m_events_list[button].release_event;
             break;
           case APP_BUTTON_RELEASE:
-            (void)app_timer_stop(m_button_timer_id);
             if (release_event_at_push[button] == m_events_list[button].release_event)
               {
                 event = m_events_list[button].release_event;
@@ -144,7 +136,7 @@ static void bsp_button_event_handler(uint8_t pin_no, uint8_t button_action)
  *
  * @param[in]   p_context   parameter registered in timer start function.
  */
-static void button_timer_handler(void *p_context)
+void button_timer_handler(void *p_context)   //MinYang2
 {
   bsp_button_event_handler(*(uint8_t *)p_context, BSP_BUTTON_ACTION_LONG_PUSH);
 }
@@ -193,7 +185,7 @@ static uint32_t bsp_led_indication(bsp_indication_t indicate)
           }
 
         m_stable_state = indicate;
-        err_code       = app_timer_start(m_leds_timer_id, BSP_MS_TO_TICK(next_delay), NULL);
+        err_code = app_timer_start(&m_leds_timer_id, next_delay, APP_TIMER_MODE_SINGLE_SHOT);
         break;
 
       case BSP_INDICATE_ADVERTISING_WHITELIST:
@@ -215,7 +207,7 @@ static uint32_t bsp_led_indication(bsp_indication_t indicate)
                          ADVERTISING_SLOW_LED_ON_INTERVAL;
           }
         m_stable_state = indicate;
-        err_code       = app_timer_start(m_leds_timer_id, BSP_MS_TO_TICK(next_delay), NULL);
+        err_code = app_timer_start(&m_leds_timer_id, next_delay, APP_TIMER_MODE_SINGLE_SHOT);
         break;
 
       case BSP_INDICATE_ADVERTISING_SLOW:
@@ -235,7 +227,7 @@ static uint32_t bsp_led_indication(bsp_indication_t indicate)
                          ADVERTISING_SLOW_LED_ON_INTERVAL;
           }
         m_stable_state = indicate;
-        err_code       = app_timer_start(m_leds_timer_id, BSP_MS_TO_TICK(next_delay), NULL);
+        err_code = app_timer_start(&m_leds_timer_id, next_delay, APP_TIMER_MODE_SINGLE_SHOT);
         break;
 
       case BSP_INDICATE_ADVERTISING_DIRECTED:
@@ -257,7 +249,7 @@ static uint32_t bsp_led_indication(bsp_indication_t indicate)
                          ADVERTISING_SLOW_LED_ON_INTERVAL;
           }
         m_stable_state = indicate;
-        err_code       = app_timer_start(m_leds_timer_id, BSP_MS_TO_TICK(next_delay), NULL);
+        err_code = app_timer_start(&m_leds_timer_id, next_delay, APP_TIMER_MODE_SINGLE_SHOT);
         break;
 
       case BSP_INDICATE_BONDING:
@@ -265,8 +257,7 @@ static uint32_t bsp_led_indication(bsp_indication_t indicate)
         bsp_board_led_invert(BSP_LED_INDICATE_BONDING);
 
         m_stable_state = indicate;
-        err_code       =
-          app_timer_start(m_leds_timer_id, BSP_MS_TO_TICK(BONDING_INTERVAL), NULL);
+        err_code = app_timer_start(&m_leds_timer_id, BONDING_INTERVAL, APP_TIMER_MODE_SINGLE_SHOT);
         break;
 
       case BSP_INDICATE_CONNECTED:
@@ -278,28 +269,28 @@ static uint32_t bsp_led_indication(bsp_indication_t indicate)
         // when sending shortly invert LED_1
         m_leds_clear = true;
         bsp_board_led_invert(BSP_LED_INDICATE_SENT_OK);
-        err_code = app_timer_start(m_leds_timer_id, BSP_MS_TO_TICK(SENT_OK_INTERVAL), NULL);
+        err_code = app_timer_start(&m_leds_timer_id, SENT_OK_INTERVAL, APP_TIMER_MODE_SINGLE_SHOT);
         break;
 
       case BSP_INDICATE_SEND_ERROR:
         // on receving error invert LED_1 for long time
         m_leds_clear = true;
         bsp_board_led_invert(BSP_LED_INDICATE_SEND_ERROR);
-        err_code = app_timer_start(m_leds_timer_id, BSP_MS_TO_TICK(SEND_ERROR_INTERVAL), NULL);
+        err_code = app_timer_start(&m_leds_timer_id, SEND_ERROR_INTERVAL, APP_TIMER_MODE_SINGLE_SHOT);
         break;
 
       case BSP_INDICATE_RCV_OK:
         // when receving shortly invert LED_1
         m_leds_clear = true;
         bsp_board_led_invert(BSP_LED_INDICATE_RCV_OK);
-        err_code = app_timer_start(m_leds_timer_id, BSP_MS_TO_TICK(RCV_OK_INTERVAL), NULL);
+        err_code = app_timer_start(&m_leds_timer_id, RCV_OK_INTERVAL, APP_TIMER_MODE_SINGLE_SHOT);
         break;
 
       case BSP_INDICATE_RCV_ERROR:
         // on receving error invert LED_1 for long time
         m_leds_clear = true;
         bsp_board_led_invert(BSP_LED_INDICATE_RCV_ERROR);
-        err_code = app_timer_start(m_leds_timer_id, BSP_MS_TO_TICK(RCV_ERROR_INTERVAL), NULL);
+        err_code = app_timer_start(&m_leds_timer_id, RCV_ERROR_INTERVAL, APP_TIMER_MODE_SINGLE_SHOT);
         break;
 
       case BSP_INDICATE_FATAL_ERROR:
@@ -313,18 +304,11 @@ static uint32_t bsp_led_indication(bsp_indication_t indicate)
       case BSP_INDICATE_ALERT_2:
       case BSP_INDICATE_ALERT_3:
       case BSP_INDICATE_ALERT_OFF:
-        err_code   = app_timer_stop(m_alert_timer_id);
         next_delay = (uint32_t)BSP_INDICATE_ALERT_OFF - (uint32_t)indicate;
 
         // a little trick to find out that if it did not fall through ALERT_OFF
         if (next_delay && (err_code == NRF_SUCCESS))
           {
-            if (next_delay > 1)
-              {
-                err_code = app_timer_start(m_alert_timer_id,
-                                           BSP_MS_TO_TICK((next_delay * ALERT_INTERVAL)),
-                                           NULL);
-              }
             bsp_board_led_on(BSP_LED_ALERT);
           }
         else
@@ -379,9 +363,8 @@ static uint32_t bsp_led_indication(bsp_indication_t indicate)
  *
  * @param[in]   p_context   parameter registered in timer start function.
  */
-static void leds_timer_handler(void *p_context)
+void leds_timer_handler()
 {
-  UNUSED_PARAMETER(p_context);
 
   if (m_indication_type & BSP_INIT_LED)
     {
@@ -394,11 +377,13 @@ static void leds_timer_handler(void *p_context)
  *
  * @param[in]   p_context   parameter registered in timer start function.
  */
-static void alert_timer_handler(void *p_context)
+/*
+static void alert_timer_handler(void * p_context)
 {
-  UNUSED_PARAMETER(p_context);
-  bsp_board_led_invert(BSP_LED_ALERT);
+    UNUSED_PARAMETER(p_context);
+    bsp_board_led_invert(BSP_LED_ALERT);
 }
+ */
 #endif // #if LEDS_NUMBER > 0 && !(defined BSP_SIMPLE)
 
 
@@ -455,14 +440,6 @@ uint32_t bsp_init(uint32_t type, uint32_t ticks_per_100ms, bsp_event_callback_t
         {
           err_code = app_button_enable();
         }
-
-      if (err_code == NRF_SUCCESS)
-        {
-          err_code = app_timer_create(&m_button_timer_id,
-                                      APP_TIMER_MODE_SINGLE_SHOT,
-                                      button_timer_handler);
-        }
-
     }
 
 #elif defined(BUTTONS_NUMBER) && (BUTTONS_NUMBER > 0) && (defined BSP_SIMPLE)
@@ -481,18 +458,6 @@ uint32_t bsp_init(uint32_t type, uint32_t ticks_per_100ms, bsp_event_callback_t
     }
 
   // timers module must be already initialized!
-  if (err_code == NRF_SUCCESS)
-    {
-      err_code =
-        app_timer_create(&m_leds_timer_id, APP_TIMER_MODE_SINGLE_SHOT, leds_timer_handler);
-    }
-
-  if (err_code == NRF_SUCCESS)
-    {
-      err_code =
-        app_timer_create(&m_alert_timer_id, APP_TIMER_MODE_REPEATED, alert_timer_handler);
-    }
-
 #endif // LEDS_NUMBER > 0 && !(defined BSP_SIMPLE)
 
   return err_code;
diff --git a/arch/arm/src/nrf52/components/libraries/bsp/bsp.h b/arch/arm/src/nrf52/components/libraries/bsp/bsp.h
old mode 100644
new mode 100755
index de1a07aa5d..53dcb67916
--- a/arch/arm/src/nrf52/components/libraries/bsp/bsp.h
+++ b/arch/arm/src/nrf52/components/libraries/bsp/bsp.h
@@ -148,6 +148,8 @@ typedef enum
   BSP_EVENT_KEY_LAST = BSP_EVENT_KEY_7,
 } bsp_event_t;
 
+void button_timer_handler(void *p_context);   //MinYang2
+void leds_timer_handler(void);
 
 typedef struct
 {
@@ -165,6 +167,8 @@ typedef struct
  */
 typedef void (* bsp_event_callback_t)(bsp_event_t);
 
+void button_timer_handler(void *p_context);   //MinYang2
+void leds_timer_handler(void);
 
 /**@brief       Function for initializing BSP.
  *
@@ -279,6 +283,10 @@ uint32_t bsp_wakeup_button_enable(uint32_t button_idx);
 uint32_t bsp_wakeup_button_disable(uint32_t button_idx);
 
 
+void leds_timer_handler(void);
+
+void leds_timer_handler(void);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/arch/arm/src/nrf52/components/libraries/bsp/bsp_btn_ant.c b/arch/arm/src/nrf52/components/libraries/bsp/bsp_btn_ant.c
index ae8e3c07d9..28108fe6d1 100644
--- a/arch/arm/src/nrf52/components/libraries/bsp/bsp_btn_ant.c
+++ b/arch/arm/src/nrf52/components/libraries/bsp/bsp_btn_ant.c
@@ -23,8 +23,8 @@
 
 
 /**@brief This macro will return from the current function if err_code
-*        is not NRF_SUCCESS or NRF_ERROR_INVALID_PARAM.
-*/
+ *        is not NRF_SUCCESS or NRF_ERROR_INVALID_PARAM.
+ */
 #define RETURN_ON_ERROR_NOT_INVALID_PARAM(err_code)                             \
 do                                                                              \
 {                                                                               \
@@ -54,10 +54,10 @@ static bool m_connected = false;  /**< Notify if channel is connected. */
 
 
 /**@brief Function for configuring the buttons for connection.
-*
-* @retval NRF_SUCCESS  Configured successfully.
-* @return A propagated error code.
-*/
+ *
+ * @retval NRF_SUCCESS  Configured successfully.
+ * @return A propagated error code.
+ */
 static uint32_t connection_buttons_configure(void)
 {
   uint32_t err_code;
diff --git a/arch/arm/src/nrf52/components/libraries/bsp/bsp_btn_ant.h b/arch/arm/src/nrf52/components/libraries/bsp/bsp_btn_ant.h
index df7d56f3da..1946c20a72 100644
--- a/arch/arm/src/nrf52/components/libraries/bsp/bsp_btn_ant.h
+++ b/arch/arm/src/nrf52/components/libraries/bsp/bsp_btn_ant.h
@@ -11,19 +11,19 @@
  */
 
 /**@file
-*
-* @defgroup bsp_btn_ant BSP: ANT Button Module
-* @{
-* @ingroup bsp
-*
-* @brief Module for controlling ANT behavior through button actions.
-*
-* @details The application must propagate ANT events to the ANT Button Module.
-* Based on these events, the ANT Button Module configures the Board Support Package
-* to generate BSP events for certain button actions. These BSP events should then be
-* handled by the application's BSP event handler.
-*
-*/
+ *
+ * @defgroup bsp_btn_ant BSP: ANT Button Module
+ * @{
+ * @ingroup bsp
+ *
+ * @brief Module for controlling ANT behavior through button actions.
+ *
+ * @details The application must propagate ANT events to the ANT Button Module.
+ * Based on these events, the ANT Button Module configures the Board Support Package
+ * to generate BSP events for certain button actions. These BSP events should then be
+ * handled by the application's BSP event handler.
+ *
+ */
 
 #ifndef BSP_BTN_ANT_H__
 #define BSP_BTN_ANT_H__
@@ -36,12 +36,12 @@ extern "C" {
 #endif
 
 /**@brief Function for initializing the ANT Button Module.
-*
-* Before calling this function, the BSP module must be initialized with buttons.
-*
-* @retval NRF_SUCCESS  If initialization was successful. Otherwise, a propagated error code is
-*                      returned.
-*/
+ *
+ * Before calling this function, the BSP module must be initialized with buttons.
+ *
+ * @retval NRF_SUCCESS  If initialization was successful. Otherwise, a propagated error code is
+ *                      returned.
+ */
 uint32_t bsp_btn_ant_init(void);
 
 /**@brief Function for setting up wakeup buttons before going into sleep mode.
diff --git a/arch/arm/src/nrf52/components/libraries/bsp/bsp_nfc.h b/arch/arm/src/nrf52/components/libraries/bsp/bsp_nfc.h
index 9f7a7bb7b4..b41b42fcd1 100644
--- a/arch/arm/src/nrf52/components/libraries/bsp/bsp_nfc.h
+++ b/arch/arm/src/nrf52/components/libraries/bsp/bsp_nfc.h
@@ -11,19 +11,19 @@
  */
 
 /**@file
-*
-* @defgroup bsp_nfc NFC BSP Module
-* @{
-* @ingroup bsp
-*
-* @brief Module for setting the NFCT peripheral as a wakeup source.
-*
-* @details The application must notify this module before going into System OFF mode.
-* Based on this notification, the NFC BSP Module sets the NFCT peripheral as a wakeup source
-* through the Board Support Package. Additionally, any BSP Button can be configured to
-* generate BSP sleep events. This module is applicable only if NFCT is used exclusively for
-* wakeup. If NFCT is used for a different purpose, this module cannot be used.
-*/
+ *
+ * @defgroup bsp_nfc NFC BSP Module
+ * @{
+ * @ingroup bsp
+ *
+ * @brief Module for setting the NFCT peripheral as a wakeup source.
+ *
+ * @details The application must notify this module before going into System OFF mode.
+ * Based on this notification, the NFC BSP Module sets the NFCT peripheral as a wakeup source
+ * through the Board Support Package. Additionally, any BSP Button can be configured to
+ * generate BSP sleep events. This module is applicable only if NFCT is used exclusively for
+ * wakeup. If NFCT is used for a different purpose, this module cannot be used.
+ */
 
 #ifndef BSP_NFC_H__
 #define BSP_NFC_H__
diff --git a/arch/arm/src/nrf52/components/libraries/button/app_button.c b/arch/arm/src/nrf52/components/libraries/button/app_button.c
old mode 100644
new mode 100755
index 58a65f03c3..41babdd1c7
--- a/arch/arm/src/nrf52/components/libraries/button/app_button.c
+++ b/arch/arm/src/nrf52/components/libraries/button/app_button.c
@@ -21,8 +21,8 @@
 static app_button_cfg_t const        *mp_buttons = NULL;           /**< Button configuration. */
 static uint8_t                        m_button_count;              /**< Number of configured buttons. */
 static uint32_t                       m_detection_delay;           /**< Delay before a button is reported as pushed. */
-APP_TIMER_DEF(m_detection_delay_timer_id);  /**< Polling timer id. */
-
+//APP_TIMER_DEF(m_detection_delay_timer_id);  /**< Polling timer id. */
+struct timer_posix m_detection_delay_timer_id;
 
 static uint32_t m_pin_state;
 static uint32_t m_pin_transition;
@@ -39,8 +39,10 @@ static uint32_t m_pin_transition;
  *                         In the app_button module the p_context holds information on pressed
  *                         buttons.
  */
-static void detection_delay_timeout_handler(void *p_context)
+void detection_delay_timeout_handler()
 {
+  printf("detection_delay_timeout_handler\r\n");
+#if 0
   uint8_t i;
 
   // Pushed button(s) detected, execute button handler(s).
@@ -63,10 +65,12 @@ static void detection_delay_timeout_handler(void *p_context)
             }
         }
     }
+#endif
 }
 
 static void gpiote_event_handler(nrf_drv_gpiote_pin_t pin, nrf_gpiote_polarity_t action)
 {
+  printf("gpiote_event_handler");
   uint32_t err_code;
   uint32_t pin_mask = 1 << pin;
 
@@ -74,7 +78,9 @@ static void gpiote_event_handler(nrf_drv_gpiote_pin_t pin, nrf_gpiote_polarity_t
   // NOTE: Using the p_context parameter of app_timer_start() to transfer the pin states to the
   //       timeout handler (by casting event_pins_mask into the equally sized void * p_context
   //       parameter).
-  err_code = app_timer_stop(m_detection_delay_timer_id);
+
+  err_code = app_timer_stop(&m_detection_delay_timer_id);
+
   if (err_code != NRF_SUCCESS)
     {
       // The impact in app_button of the app_timer queue running full is losing a button press.
@@ -93,8 +99,10 @@ static void gpiote_event_handler(nrf_drv_gpiote_pin_t pin, nrf_gpiote_polarity_t
           m_pin_state &= ~(pin_mask);
         }
       m_pin_transition |= (pin_mask);
-
+      err_code = app_timer_start(&m_detection_delay_timer_id, m_detection_delay, APP_TIMER_MODE_SINGLE_SHOT);
+#if 0 //MinYang1
       err_code = app_timer_start(m_detection_delay_timer_id, m_detection_delay, NULL);
+#endif
       if (err_code != NRF_SUCCESS)
         {
           // The impact in app_button of the app_timer queue running full is losing a button press.
@@ -143,11 +151,13 @@ uint32_t app_button_init(app_button_cfg_t const        *p_buttons,
       err_code = nrf_drv_gpiote_in_init(p_btn->pin_no, &config, gpiote_event_handler);
       VERIFY_SUCCESS(err_code);
     }
-
+#if 0 //MinYang1
   // Create polling timer.
   return app_timer_create(&m_detection_delay_timer_id,
                           APP_TIMER_MODE_SINGLE_SHOT,
                           detection_delay_timeout_handler);
+#endif
+  return OK;
 
 }
 
@@ -176,7 +186,8 @@ uint32_t app_button_disable(void)
     }
 
   // Make sure polling timer is not running.
-  return app_timer_stop(m_detection_delay_timer_id);
+  return app_timer_stop(&m_detection_delay_timer_id);
+
 }
 
 
diff --git a/arch/arm/src/nrf52/components/libraries/button/app_button.h b/arch/arm/src/nrf52/components/libraries/button/app_button.h
old mode 100644
new mode 100755
index a729a83f7d..7855460a91
--- a/arch/arm/src/nrf52/components/libraries/button/app_button.h
+++ b/arch/arm/src/nrf52/components/libraries/button/app_button.h
@@ -70,6 +70,10 @@ typedef struct
   uint32_t low_to_high;   /**Pin went from low to high */
 } pin_transition_t;
 
+void detection_delay_timeout_handler(void);
+
+void detection_delay_timeout_handler(void);
+
 /**@brief Function for initializing the Buttons.
  *
  * @details This function will initialize the specified pins as buttons, and configure the Button
diff --git a/arch/arm/src/nrf52/components/libraries/sensorsim/sensorsim.c b/arch/arm/src/nrf52/components/libraries/sensorsim/sensorsim.c
new file mode 100644
index 0000000000..e7769bfec7
--- /dev/null
+++ b/arch/arm/src/nrf52/components/libraries/sensorsim/sensorsim.c
@@ -0,0 +1,73 @@
+/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
+ *
+ * The information contained herein is property of Nordic Semiconductor ASA.
+ * Terms and conditions of usage are described in detail in NORDIC
+ * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
+ *
+ * Licensees are granted free, non-transferable use of the information. NO
+ * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
+ * the file.
+ *
+ */
+
+#include "sensorsim.h"
+
+
+void sensorsim_init(sensorsim_state_t      *p_state,
+                    const sensorsim_cfg_t *p_cfg)
+{
+  if (p_cfg->start_at_max)
+    {
+      p_state->current_val   = p_cfg->max;
+      p_state->is_increasing = false;
+    }
+  else
+    {
+      p_state->current_val   = p_cfg->min;
+      p_state->is_increasing = true;
+    }
+}
+
+
+uint32_t sensorsim_measure(sensorsim_state_t      *p_state,
+                           const sensorsim_cfg_t *p_cfg)
+{
+  if (p_state->is_increasing)
+    {
+      sensorsim_increment(p_state, p_cfg);
+    }
+  else
+    {
+      sensorsim_decrement(p_state, p_cfg);
+    }
+  return p_state->current_val;
+}
+
+void sensorsim_increment(sensorsim_state_t      *p_state,
+                         const sensorsim_cfg_t *p_cfg)
+{
+  if (p_cfg->max - p_state->current_val > p_cfg->incr)
+    {
+      p_state->current_val += p_cfg->incr;
+    }
+  else
+    {
+      p_state->current_val   = p_cfg->max;
+      p_state->is_increasing = false;
+    }
+}
+
+
+void sensorsim_decrement(sensorsim_state_t      *p_state,
+                         const sensorsim_cfg_t *p_cfg)
+{
+  if (p_state->current_val - p_cfg->min > p_cfg->incr)
+    {
+      p_state->current_val -= p_cfg->incr;
+    }
+  else
+    {
+      p_state->current_val   = p_cfg->min;
+      p_state->is_increasing = true;
+    }
+}
diff --git a/arch/arm/src/nrf52/components/libraries/sensorsim/sensorsim.h b/arch/arm/src/nrf52/components/libraries/sensorsim/sensorsim.h
new file mode 100644
index 0000000000..ab7c416e5d
--- /dev/null
+++ b/arch/arm/src/nrf52/components/libraries/sensorsim/sensorsim.h
@@ -0,0 +1,94 @@
+/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
+ *
+ * The information contained herein is property of Nordic Semiconductor ASA.
+ * Terms and conditions of usage are described in detail in NORDIC
+ * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
+ *
+ * Licensees are granted free, non-transferable use of the information. NO
+ * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
+ * the file.
+ *
+ */
+
+/** @file
+ *
+ * @defgroup ble_sdk_lib_sensorsim Sensor Data Simulator
+ * @{
+ * @ingroup ble_sdk_lib
+ * @brief Functions for simulating sensor data.
+ *
+ * @details Currently only a triangular waveform simulator is implemented.
+ */
+
+#ifndef SENSORSIM_H__
+#define SENSORSIM_H__
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**@brief Triangular waveform sensor simulator configuration. */
+typedef struct
+{
+  uint32_t min;                       /**< Minimum simulated value. */
+  uint32_t max;                       /**< Maximum simulated value. */
+  uint32_t incr;                      /**< Increment between each measurement. */
+  bool     start_at_max;              /**< TRUE is measurement is to start at the maximum value, FALSE if it is to start at the minimum. */
+} sensorsim_cfg_t;
+
+/**@brief Triangular waveform sensor simulator state. */
+typedef struct
+{
+  uint32_t current_val;               /**< Current sensor value. */
+  bool     is_increasing;             /**< TRUE if the simulator is in increasing state, FALSE otherwise. */
+} sensorsim_state_t;
+
+/**@brief Function for initializing a triangular waveform sensor simulator.
+ *
+ * @param[out]  p_state  Current state of simulator.
+ * @param[in]   p_cfg    Simulator configuration.
+ */
+void sensorsim_init(sensorsim_state_t      *p_state,
+                    const sensorsim_cfg_t *p_cfg);
+
+/**@brief Function for generating a simulated sensor measurement using a triangular waveform generator.
+ *
+ * @param[in,out]  p_state  Current state of simulator.
+ * @param[in]      p_cfg    Simulator configuration.
+ *
+ * @return         Simulator output.
+ */
+uint32_t sensorsim_measure(sensorsim_state_t      *p_state,
+                           const sensorsim_cfg_t *p_cfg);
+
+/**@brief Function for incrementing a simulated sensor measurement value.
+ *
+ * @param[in,out]  p_state  Current state of simulator.
+ * @param[in]      p_cfg    Simulator configuration.
+ *
+ * @return         Simulator output.
+ */
+void sensorsim_increment(sensorsim_state_t      *p_state,
+                         const sensorsim_cfg_t *p_cfg);
+
+/**@brief Function for decrementing a simulated sensor measurement value.
+ *
+ * @param[in,out]  p_state  Current state of simulator.
+ * @param[in]      p_cfg    Simulator configuration.
+ *
+ * @return         Simulator output.
+ */
+void sensorsim_decrement(sensorsim_state_t      *p_state,
+                         const sensorsim_cfg_t *p_cfg);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // SENSORSIM_H__
+
+/** @} */
diff --git a/arch/arm/src/nrf52/components/libraries/timer/app_timer.c b/arch/arm/src/nrf52/components/libraries/timer/app_timer.c
old mode 100644
new mode 100755
index cffcf96abe..6a5675682e
--- a/arch/arm/src/nrf52/components/libraries/timer/app_timer.c
+++ b/arch/arm/src/nrf52/components/libraries/timer/app_timer.c
@@ -19,1048 +19,125 @@
 #include "nrf_delay.h"
 #include "app_util_platform.h"
 
-#define RTC1_IRQ_PRI            APP_IRQ_PRIORITY_LOWEST                        /**< Priority of the RTC1 interrupt (used for checking for timeouts and executing timeout handlers). */
-#define SWI_IRQ_PRI             APP_IRQ_PRIORITY_LOWEST                        /**< Priority of the SWI  interrupt (used for updating the timer list). */
-
-// The current design assumes that both interrupt handlers run at the same interrupt level.
-// If this is to be changed, protection must be added to prevent them from interrupting each other
-// (e.g. by using guard/trigger flags).
-STATIC_ASSERT(RTC1_IRQ_PRI == SWI_IRQ_PRI);
-
-#define MAX_RTC_COUNTER_VAL     0x00FFFFFF                                  /**< Maximum value of the RTC counter. */
-
-#define RTC_COMPARE_OFFSET_MIN  3                                           /**< Minimum offset between the current RTC counter value and the Capture Compare register. Although the nRF51 Series User Specification recommends this value to be 2, we use 3 to be safer.*/
-
-#define MAX_RTC_TASKS_DELAY     47                                          /**< Maximum delay until an RTC task is executed. */
-
-#define SWI_IRQn SWI0_IRQn
-#define SWI_IRQHandler SWI0_IRQHandler
-
-#define MODULE_INITIALIZED (m_op_queue.p_user_op_queue != NULL) /**< Macro designating whether the module has been initialized properly. */
-
-/**@brief Timer node type. The nodes will be used form a linked list of running timers. */
-typedef struct
-{
-  uint32_t
-  ticks_to_expire;                            /**< Number of ticks from previous timer interrupt to timer expiry. */
-  uint32_t
-  ticks_at_start;                             /**< Current RTC counter value when the timer was started. */
-  uint32_t                    ticks_first_interval;                       /**< Number of ticks in the first timer interval. */
-  uint32_t                    ticks_periodic_interval;                    /**< Timer period (for repeating timers). */
-  bool                        is_running;                                 /**< True if timer is running, False otherwise. */
-  app_timer_mode_t            mode;                                       /**< Timer mode. */
-  app_timer_timeout_handler_t
-  p_timeout_handler;                          /**< Pointer to function to be executed when the timer expires. */
-  void
-  *p_context;                                  /**< General purpose pointer. Will be passed to the timeout handler when the timer expires. */
-  void                       *next;                                       /**< Pointer to the next node. */
-} timer_node_t;
-
-STATIC_ASSERT(sizeof(timer_node_t) == APP_TIMER_NODE_SIZE);
-
-/**@brief Set of available timer operation types. */
-typedef enum
-{
-  TIMER_USER_OP_TYPE_NONE,                                                /**< Invalid timer operation type. */
-  TIMER_USER_OP_TYPE_START,                                               /**< Timer operation type Start. */
-  TIMER_USER_OP_TYPE_STOP,                                                /**< Timer operation type Stop. */
-  TIMER_USER_OP_TYPE_STOP_ALL                                             /**< Timer operation type Stop All. */
-} timer_user_op_type_t;
-
-/**@brief Structure describing a timer start operation. */
-typedef struct
-{
-  uint32_t ticks_at_start;                                                /**< Current RTC counter value when the timer was started. */
-  uint32_t ticks_first_interval;                                          /**< Number of ticks in the first timer interval. */
-  uint32_t ticks_periodic_interval;                                       /**< Timer period (for repeating timers). */
-  void    *p_context;                                                     /**< General purpose pointer. Will be passed to the timeout handler when the timer expires. */
-} timer_user_op_start_t;
-
-/**@brief Structure describing a timer operation. */
-typedef struct
-{
-  timer_user_op_type_t
-  op_type;                                             /**< Id of timer on which the operation is to be performed. */
-  timer_node_t        *p_node;
-  union
-  {
-    timer_user_op_start_t start;                                        /**< Structure describing a timer start operation. */
-  } params;
-} timer_user_op_t;
-
-STATIC_ASSERT(sizeof(timer_user_op_t) <= APP_TIMER_USER_OP_SIZE);
-STATIC_ASSERT(sizeof(timer_user_op_t) % 4 == 0);
-
-/**@brief Structure describing a timer operations queue.
- *
- * @details This queue will hold timer operations issued by the application
- *          until the timer interrupt handler processes these operations.
- */
-typedef struct
-{
-  uint8_t
-  first;                                                    /**< Index of first entry to have been inserted in the queue (i.e. the next entry to be executed). */
-  uint8_t
-  last;                                                     /**< Index of last entry to have been inserted in the queue. */
-  uint8_t           size;                                                     /**< Queue size. */
-  timer_user_op_t *p_user_op_queue;                                           /**< Queue buffer. */
-} timer_op_queue_t;
-
-STATIC_ASSERT(sizeof(timer_op_queue_t) % 4 == 0);
-
-#define CONTEXT_QUEUE_SIZE_MAX      (2)
-
-static timer_op_queue_t              m_op_queue;                                /**< Timer operations queue. */
-static timer_node_t                 *mp_timer_id_head;                          /**< First timer in list of running timers. */
-static uint32_t                      m_ticks_latest;                            /**< Last known RTC counter value. */
-static uint32_t                      m_ticks_elapsed[CONTEXT_QUEUE_SIZE_MAX];   /**< Timer internal elapsed ticks queue. */
-static uint8_t
-m_ticks_elapsed_q_read_ind;                /**< Timer internal elapsed ticks queue read index. */
-static uint8_t
-m_ticks_elapsed_q_write_ind;               /**< Timer internal elapsed ticks queue write index. */
-static app_timer_evt_schedule_func_t
-m_evt_schedule_func;                       /**< Pointer to function for propagating timeout events to the scheduler. */
-static bool                          m_rtc1_running;                            /**< Boolean indicating if RTC1 is running. */
-static bool
-m_rtc1_reset;                              /**< Boolean indicating if RTC1 counter has been reset due to last timer removed from timer list during the timer list handling. */
-
-#if APP_TIMER_WITH_PROFILER
-static uint8_t
-m_max_user_op_queue_utilization;           /**< Maximum observed timer user operations queue utilization. */
-#endif
-
-/**@brief Function for initializing the RTC1 counter.
- *
- * @param[in] prescaler   Value of the RTC1 PRESCALER register. Set to 0 for no prescaling.
- */
-static void rtc1_init(uint32_t prescaler)
-{
-  NRF_RTC1->PRESCALER = prescaler;
-  NVIC_SetPriority(RTC1_IRQn, RTC1_IRQ_PRI);
-}
-
-
-/**@brief Function for starting the RTC1 timer.
- */
-static void rtc1_start(void)
-{
-  NRF_RTC1->EVTENSET = RTC_EVTEN_COMPARE0_Msk;
-  NRF_RTC1->INTENSET = RTC_INTENSET_COMPARE0_Msk;
-
-  NVIC_ClearPendingIRQ(RTC1_IRQn);
-  NVIC_EnableIRQ(RTC1_IRQn);
-
-  NRF_RTC1->TASKS_START = 1;
-  nrf_delay_us(MAX_RTC_TASKS_DELAY);
-
-  m_rtc1_running = true;
-}
-
-
-/**@brief Function for stopping the RTC1 timer.
- */
-static void rtc1_stop(void)
-{
-  NVIC_DisableIRQ(RTC1_IRQn);
-
-  NRF_RTC1->EVTENCLR = RTC_EVTEN_COMPARE0_Msk;
-  NRF_RTC1->INTENCLR = RTC_INTENSET_COMPARE0_Msk;
-
-  NRF_RTC1->TASKS_STOP = 1;
-  nrf_delay_us(MAX_RTC_TASKS_DELAY);
-
-  NRF_RTC1->TASKS_CLEAR = 1;
-  m_ticks_latest        = 0;
-  nrf_delay_us(MAX_RTC_TASKS_DELAY);
-
-  m_rtc1_running = false;
-}
-
-
-/**@brief Function for returning the current value of the RTC1 counter.
- *
- * @return     Current value of the RTC1 counter.
- */
-static __INLINE uint32_t rtc1_counter_get(void)
-{
-  return NRF_RTC1->COUNTER;
-}
-
-
-/**@brief Function for computing the difference between two RTC1 counter values.
- *
- * @return     Number of ticks elapsed from ticks_old to ticks_now.
- */
-static __INLINE uint32_t ticks_diff_get(uint32_t ticks_now, uint32_t ticks_old)
-{
-  return ((ticks_now - ticks_old) & MAX_RTC_COUNTER_VAL);
-}
-
-
-/**@brief Function for setting the RTC1 Capture Compare register 0, and enabling the corresponding
- *        event.
- *
- * @param[in] value   New value of Capture Compare register 0.
- */
-static __INLINE void rtc1_compare0_set(uint32_t value)
-{
-  NRF_RTC1->CC[0] = value;
-}
-
-
-/**@brief Function for inserting a timer in the timer list.
- *
- * @param[in]  timer_id   Id of timer to insert.
- */
-static void timer_list_insert(timer_node_t *p_timer)
-{
-  if (mp_timer_id_head == NULL)
-    {
-      mp_timer_id_head = p_timer;
-    }
-  else
-    {
-      if (p_timer->ticks_to_expire <= mp_timer_id_head->ticks_to_expire)
-        {
-          mp_timer_id_head->ticks_to_expire -= p_timer->ticks_to_expire;
-
-          p_timer->next   = mp_timer_id_head;
-          mp_timer_id_head = p_timer;
-        }
-      else
-        {
-          timer_node_t *p_previous;
-          timer_node_t *p_current;
-          uint32_t       ticks_to_expire;
-
-          ticks_to_expire   = p_timer->ticks_to_expire;
-          p_previous        = mp_timer_id_head;
-          p_current         = mp_timer_id_head;
-
-          while ((p_current != NULL) && (ticks_to_expire > p_current->ticks_to_expire))
-            {
-              ticks_to_expire   -= p_current->ticks_to_expire;
-              p_previous         = p_current;
-              p_current          = p_current->next;
-            }
-
-          if (p_current != NULL)
-            {
-              p_current->ticks_to_expire -= ticks_to_expire;
-            }
-
-          p_timer->ticks_to_expire = ticks_to_expire;
-          p_timer->next            = p_current;
-          p_previous->next         = p_timer;
-        }
-    }
-}
-
-
-/**@brief Function for removing a timer from the timer queue.
- *
- * @param[in]  timer_id   Id of timer to remove.
- */
-static void timer_list_remove(timer_node_t *p_timer)
-{
-  timer_node_t *p_previous;
-  timer_node_t *p_current;
-  uint32_t       timeout;
-
-  // Find the timer's position in timer list.
-  p_previous = mp_timer_id_head;
-  p_current  = p_previous;
-
-  while (p_current != NULL)
-    {
-      if (p_current == p_timer)
-        {
-          break;
-        }
-      p_previous = p_current;
-      p_current  = p_current->next;
-    }
-
-  // Timer not in active list.
-  if (p_current == NULL)
-    {
-      return;
-    }
-
-  // Timer is the first in the list
-  if (p_previous == p_current)
-    {
-      mp_timer_id_head = mp_timer_id_head->next;
-
-      // No more timers in the list. Reset RTC1 in case Start timer operations are present in the queue.
-      if (mp_timer_id_head == NULL)
-        {
-          NRF_RTC1->TASKS_CLEAR = 1;
-          m_ticks_latest        = 0;
-          m_rtc1_reset          = true;
-        }
-    }
-
-  // Remaining timeout between next timeout.
-  timeout = p_current->ticks_to_expire;
-
-  // Link previous timer with next of this timer, i.e. removing the timer from list.
-  p_previous->next = p_current->next;
-
-  // If this is not the last timer, increment the next timer by this timer timeout.
-  p_current = p_previous->next;
-  if (p_current != NULL)
-    {
-      p_current->ticks_to_expire += timeout;
-    }
-}
-
-
-/**@brief Function for scheduling a check for timeouts by generating a RTC1 interrupt.
- */
-static void timer_timeouts_check_sched(void)
-{
-  NVIC_SetPendingIRQ(RTC1_IRQn);
-}
-
-
-/**@brief Function for scheduling a timer list update by generating a SWI interrupt.
- */
-static void timer_list_handler_sched(void)
-{
-  NVIC_SetPendingIRQ(SWI_IRQn);
-}
-
-
-/**@brief Function for executing an application timeout handler, either by calling it directly, or
- *        by passing an event to the @ref app_scheduler.
- *
- * @param[in]  p_timer   Pointer to expired timer.
- */
-static void timeout_handler_exec(timer_node_t *p_timer)
-{
-  if (m_evt_schedule_func != NULL)
-    {
-      uint32_t err_code = m_evt_schedule_func(p_timer->p_timeout_handler, p_timer->p_context);
-      APP_ERROR_CHECK(err_code);
-    }
-  else
-    {
-      p_timer->p_timeout_handler(p_timer->p_context);
-    }
-}
-
-
-/**@brief Function for checking for expired timers.
- */
-static void timer_timeouts_check(void)
-{
-  // Handle expired of timer
-  if (mp_timer_id_head != NULL)
-    {
-      timer_node_t   *p_timer;
-      timer_node_t   *p_previous_timer;
-      uint32_t        ticks_elapsed;
-      uint32_t        ticks_expired;
-
-      // Initialize actual elapsed ticks being consumed to 0.
-      ticks_expired = 0;
-
-      // ticks_elapsed is collected here, job will use it.
-      ticks_elapsed = ticks_diff_get(rtc1_counter_get(), m_ticks_latest);
-
-      // Auto variable containing the head of timers expiring.
-      p_timer = mp_timer_id_head;
-
-      // Expire all timers within ticks_elapsed and collect ticks_expired.
-      while (p_timer != NULL)
-        {
-          // Do nothing if timer did not expire.
-          if (ticks_elapsed < p_timer->ticks_to_expire)
-            {
-              break;
-            }
-
-          // Decrement ticks_elapsed and collect expired ticks.
-          ticks_elapsed -= p_timer->ticks_to_expire;
-          ticks_expired += p_timer->ticks_to_expire;
-
-          // Move to next timer.
-          p_previous_timer = p_timer;
-          p_timer = p_timer->next;
-
-          // Execute Task.
-          if (p_previous_timer->is_running)
-            {
-              p_previous_timer->is_running = false;
-              timeout_handler_exec(p_previous_timer);
-            }
-        }
-
-      // Prepare to queue the ticks expired in the m_ticks_elapsed queue.
-      if (m_ticks_elapsed_q_read_ind == m_ticks_elapsed_q_write_ind)
-        {
-          // The read index of the queue is equal to the write index. This means the new
-          // value of ticks_expired should be stored at a new location in the m_ticks_elapsed
-          // queue (which is implemented as a double buffer).
-
-          // Check if there will be a queue overflow.
-          if (++m_ticks_elapsed_q_write_ind == CONTEXT_QUEUE_SIZE_MAX)
-            {
-              // There will be a queue overflow. Hence the write index should point to the start
-              // of the queue.
-              m_ticks_elapsed_q_write_ind = 0;
-            }
-        }
-
-      // Queue the ticks expired.
-      m_ticks_elapsed[m_ticks_elapsed_q_write_ind] = ticks_expired;
-
-      timer_list_handler_sched();
-    }
-}
-
-
-/**@brief Function for acquiring the number of ticks elapsed.
- *
- * @param[out] p_ticks_elapsed   Number of ticks elapsed.
- *
- * @return     TRUE if elapsed ticks was read from queue, FALSE otherwise.
- */
-static bool elapsed_ticks_acquire(uint32_t *p_ticks_elapsed)
-{
-  // Pick the elapsed value from queue.
-  if (m_ticks_elapsed_q_read_ind != m_ticks_elapsed_q_write_ind)
-    {
-      // Dequeue elapsed value.
-      m_ticks_elapsed_q_read_ind++;
-      if (m_ticks_elapsed_q_read_ind == CONTEXT_QUEUE_SIZE_MAX)
-        {
-          m_ticks_elapsed_q_read_ind = 0;
-        }
-
-      *p_ticks_elapsed = m_ticks_elapsed[m_ticks_elapsed_q_read_ind];
-
-      m_ticks_latest += *p_ticks_elapsed;
-      m_ticks_latest &= MAX_RTC_COUNTER_VAL;
-
-      return true;
-    }
-  else
-    {
-      // No elapsed value in queue.
-      *p_ticks_elapsed = 0;
-      return false;
-    }
-}
-
-
-/**@brief Function for handling the timer list deletions.
- *
- * @return     TRUE if Capture Compare register must be updated, FALSE otherwise.
- */
-static bool list_deletions_handler(void)
-{
-  timer_node_t *p_timer_old_head;
-  uint8_t        user_ops_first = m_op_queue.first;
-
-  // Remember the old head, so as to decide if new compare needs to be set.
-  p_timer_old_head = mp_timer_id_head;
-
-  while (user_ops_first != m_op_queue.last)
-    {
-      timer_user_op_t *p_user_op = &m_op_queue.p_user_op_queue[user_ops_first];
-
-      // Traverse to next operation in queue.
-      user_ops_first++;
-      if (user_ops_first == m_op_queue.size)
-        {
-          user_ops_first = 0;
-        }
-
-      switch (p_user_op->op_type)
-        {
-          case TIMER_USER_OP_TYPE_STOP:
-            // Delete node if timer is running.
-            timer_list_remove(p_user_op->p_node);
-            break;
-
-          case TIMER_USER_OP_TYPE_STOP_ALL:
-            // Delete list of running timers, and mark all timers as not running.
-            while (mp_timer_id_head != NULL)
-              {
-                timer_node_t *p_head = mp_timer_id_head;
-
-                p_head->is_running = false;
-                mp_timer_id_head    = p_head->next;
-              }
-            break;
-
-          default:
-            // No implementation needed.
-            break;
-        }
-    }
+#include <nuttx/config.h>
+#include <sys/ioctl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <errno.h>
 
-  // Detect change in head of the list.
-  return (mp_timer_id_head != p_timer_old_head);
-}
 
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
 
-/**@brief Function for updating the timer list for expired timers.
- *
- * @param[in]  ticks_elapsed         Number of elapsed ticks.
- * @param[in]  ticks_previous        Previous known value of the RTC counter.
- * @param[out] p_restart_list_head   List of repeating timers to be restarted.
- */
-static void expired_timers_handler(uint32_t         ticks_elapsed,
-                                   uint32_t         ticks_previous,
-                                   timer_node_t   **p_restart_list_head)
+uint32_t app_timer_create(struct timer_posix *ptimer, int sigvalue_int)
 {
-  uint32_t ticks_expired = 0;
-
-  while (mp_timer_id_head != NULL)
-    {
-      timer_node_t *p_timer;
-      timer_node_t *p_timer_expired;
 
-      // Auto variable for current timer node.
-      p_timer = mp_timer_id_head;
+  printf("timer_test: Creating timer\n" );
 
-      // Do nothing if timer did not expire
-      if (ticks_elapsed < p_timer->ticks_to_expire)
-        {
-          p_timer->ticks_to_expire -= ticks_elapsed;
-          break;
-        }
+  int                status;
 
-      // Decrement ticks_elapsed and collect expired ticks.
-      ticks_elapsed -= p_timer->ticks_to_expire;
-      ticks_expired += p_timer->ticks_to_expire;
-
-      // Timer expired, set ticks_to_expire zero.
-      p_timer->ticks_to_expire = 0;
-
-      // Remove the expired timer from head.
-      p_timer_expired  = mp_timer_id_head;
-      mp_timer_id_head = p_timer->next;
-
-      // Timer will be restarted if periodic.
-      if (p_timer->ticks_periodic_interval != 0)
-        {
-          p_timer->ticks_at_start       = (ticks_previous + ticks_expired) & MAX_RTC_COUNTER_VAL;
-          p_timer->ticks_first_interval = p_timer->ticks_periodic_interval;
-          p_timer->next                 = *p_restart_list_head;
-          *p_restart_list_head          = p_timer_expired;
-        }
-    }
-}
-
-
-/**@brief Function for handling timer list insertions.
- *
- * @param[in]  p_restart_list_head   List of repeating timers to be restarted.
- *
- * @return     TRUE if Capture Compare register must be updated, FALSE otherwise.
- */
-static bool list_insertions_handler(timer_node_t *p_restart_list_head)
-{
-  timer_node_t *p_timer_id_old_head;
-
-  // Remember the old head, so as to decide if new compare needs to be set.
-  p_timer_id_old_head = mp_timer_id_head;
-
-  // Handle insertions of timers.
-  while ((p_restart_list_head != NULL) || (m_op_queue.first != m_op_queue.last))
+  (void)sigemptyset(&ptimer->set);
+  (void)sigaddset(&ptimer->set, MY_TIMER_SIGNAL);
+  status = sigprocmask(SIG_UNBLOCK, &ptimer->set, NULL);
+  if (status != OK)
     {
-      timer_node_t *p_timer;
-
-      if (p_restart_list_head != NULL)
-        {
-          p_timer           = p_restart_list_head;
-          p_restart_list_head = p_timer->next;
-        }
-      else
-        {
-          timer_user_op_t *p_user_op = &m_op_queue.p_user_op_queue[m_op_queue.first];
-
-          m_op_queue.first++;
-          if (m_op_queue.first == m_op_queue.size)
-            {
-              m_op_queue.first = 0;
-            }
-
-          p_timer = p_user_op->p_node;
-
-          if ((p_user_op->op_type != TIMER_USER_OP_TYPE_START) || p_timer->is_running)
-            {
-              continue;
-            }
-
-          p_timer->ticks_at_start          = p_user_op->params.start.ticks_at_start;
-          p_timer->ticks_first_interval    = p_user_op->params.start.ticks_first_interval;
-          p_timer->ticks_periodic_interval = p_user_op->params.start.ticks_periodic_interval;
-          p_timer->p_context               = p_user_op->params.start.p_context;
-
-          if (m_rtc1_reset)
-            {
-              p_timer->ticks_at_start = 0;
-            }
-        }
-
-      // Prepare the node to be inserted.
-      if (
-        ((p_timer->ticks_at_start - m_ticks_latest) & MAX_RTC_COUNTER_VAL)
-        <
-        (MAX_RTC_COUNTER_VAL / 2)
-      )
-        {
-          p_timer->ticks_to_expire = ticks_diff_get(p_timer->ticks_at_start, m_ticks_latest) +
-                                     p_timer->ticks_first_interval;
-        }
-      else
-        {
-          uint32_t delta_current_start;
-
-          delta_current_start = ticks_diff_get(m_ticks_latest, p_timer->ticks_at_start);
-          if (p_timer->ticks_first_interval > delta_current_start)
-            {
-              p_timer->ticks_to_expire = p_timer->ticks_first_interval - delta_current_start;
-            }
-          else
-            {
-              p_timer->ticks_to_expire = 0;
-            }
-        }
-
-      p_timer->ticks_at_start       = 0;
-      p_timer->ticks_first_interval = 0;
-      p_timer->is_running           = true;
-      p_timer->next                 = NULL;
-
-      // Insert into list
-      timer_list_insert(p_timer);
+      printf("timer_test: ERROR sigprocmask failed, status=%d\n",
+             status);
     }
 
-  return (mp_timer_id_head != p_timer_id_old_head);
-}
+  printf("timer_test: Registering signal handler\n" );
+  ptimer->act.sa_sigaction = app_timer_signal_handler;
+  ptimer->act.sa_flags  = SA_SIGINFO;
 
+  (void)sigfillset(&ptimer->act.sa_mask);
+  (void)sigdelset(&ptimer->act.sa_mask, MY_TIMER_SIGNAL);
 
-/**@brief Function for updating the Capture Compare register.
- */
-static void compare_reg_update(timer_node_t *p_timer_id_head_old)
-{
-  // Setup the timeout for timers on the head of the list
-  if (mp_timer_id_head != NULL)
-    {
-      uint32_t ticks_to_expire = mp_timer_id_head->ticks_to_expire;
-      uint32_t pre_counter_val = rtc1_counter_get();
-      uint32_t cc              = m_ticks_latest;
-      uint32_t ticks_elapsed   = ticks_diff_get(pre_counter_val, cc) + RTC_COMPARE_OFFSET_MIN;
-
-      if (!m_rtc1_running)
-        {
-          // No timers were already running, start RTC
-          rtc1_start();
-        }
-
-      cc += (ticks_elapsed < ticks_to_expire) ? ticks_to_expire : ticks_elapsed;
-      cc &= MAX_RTC_COUNTER_VAL;
-
-      rtc1_compare0_set(cc);
-
-      uint32_t post_counter_val = rtc1_counter_get();
+  status = sigaction(MY_TIMER_SIGNAL, &ptimer->act, &ptimer->oact);
 
-      if (
-        (ticks_diff_get(post_counter_val, pre_counter_val) + RTC_COMPARE_OFFSET_MIN)
-        >
-        ticks_diff_get(cc, pre_counter_val)
-      )
-        {
-          // When this happens the COMPARE event may not be triggered by the RTC.
-          // The nRF51 Series User Specification states that if the COUNTER value is N
-          // (i.e post_counter_val = N), writing N or N + 1 to a CC register may not trigger a
-          // COMPARE event. Hence the RTC interrupt is forcefully pended by calling the following
-          // function.
-          rtc1_compare0_set(rtc1_counter_get());  // this should prevent CC to fire again in the background while the code is in RTC-ISR
-          nrf_delay_us(MAX_RTC_TASKS_DELAY);
-          timer_timeouts_check_sched();
-        }
-    }
-  else
+  if (status != OK)
     {
-#if (APP_TIMER_KEEPS_RTC_ACTIVE == 0)
-      // No timers are running, stop RTC
-      rtc1_stop();
-#endif //(APP_TIMER_KEEPS_RTC_ACTIVE == 0)
+      printf("timer_test: ERROR sigaction failed, status=%d\n", status);
     }
-}
-
-
-/**@brief Function for handling changes to the timer list.
- */
-static void timer_list_handler(void)
-{
-  timer_node_t *p_restart_list_head = NULL;
-
-  uint32_t       ticks_elapsed;
-  uint32_t       ticks_previous;
-  bool           ticks_have_elapsed;
-  bool           compare_update;
-  timer_node_t *p_timer_id_head_old;
-
-#if APP_TIMER_WITH_PROFILER
-  {
-    uint8_t size = m_op_queue.size;
-    uint8_t first = m_op_queue.first;
-    uint8_t last = m_op_queue.last;
-    uint8_t utilization = (first <= last) ? (last - first) : (size + 1 - first + last);
 
-    if (utilization > m_max_user_op_queue_utilization)
-      {
-        m_max_user_op_queue_utilization = utilization;
-      }
-  }
+#ifndef SDCC
+  printf("timer_test: oact.sigaction=%p oact.sa_flags=%x oact.sa_mask=%x\n",
+         ptimer->oact.sa_sigaction, ptimer->oact.sa_flags, ptimer->oact.sa_mask);
 #endif
 
-  // Back up the previous known tick and previous list head
-  ticks_previous    = m_ticks_latest;
-  p_timer_id_head_old = mp_timer_id_head;
-
-  // Get number of elapsed ticks
-  ticks_have_elapsed = elapsed_ticks_acquire(&ticks_elapsed);
-
-  // Handle list deletions
-  compare_update = list_deletions_handler();
-
-  // Handle expired timers
-  if (ticks_have_elapsed)
-    {
-      expired_timers_handler(ticks_elapsed, ticks_previous, &p_restart_list_head);
-      compare_update = true;
-    }
-
-  // Handle list insertions
-  if (list_insertions_handler(p_restart_list_head))
-    {
-      compare_update = true;
-    }
-
-  // Update compare register if necessary
-  if (compare_update)
-    {
-      compare_reg_update(p_timer_id_head_old);
-    }
-  m_rtc1_reset = false;
-}
 
+  ptimer->notify.sigev_notify            = SIGEV_SIGNAL;
+  ptimer->notify.sigev_signo             = MY_TIMER_SIGNAL;
+  ptimer->notify.sigev_value.sival_int   = sigvalue_int;
+#ifdef CONFIG_SIG_EVTHREAD
+  ptimer->notify.sigev_notify_function   = NULL;
+  ptimer->notify.sigev_notify_attributes = NULL;
+#endif
 
-/**@brief Function for enqueueing a new operations queue entry.
- *
- * @param[in]  last_index Index of the next last index to be enqueued.
- */
-static void user_op_enque(uint8_t last_index)
-{
-  m_op_queue.last = last_index;
-}
 
 
-/**@brief Function for allocating a new operations queue entry.
- *
- * @param[out] p_last_index Index of the next last index to be enqueued.
- *
- * @return     Pointer to allocated queue entry, or NULL if queue is full.
- */
-static timer_user_op_t *user_op_alloc( uint8_t *p_last_index)
-{
-  uint8_t           last;
-  timer_user_op_t *p_user_op;
+  status = timer_create(CLOCK_REALTIME, &ptimer->notify, &ptimer->timerid);
 
-  last = m_op_queue.last + 1;
-  if (last == m_op_queue.size)
+  if (status != OK)
     {
-      // Overflow case.
-      last = 0;
+      printf("timer_test: timer_create failed, errno=%d\n", errno);
     }
-  if (last == m_op_queue.first)
-    {
-      // Queue is full.
-      return NULL;
-    }
-
-  *p_last_index = last;
-  p_user_op     = &m_op_queue.p_user_op_queue[m_op_queue.last];
-
-  return p_user_op;
+  return OK;
 }
 
 
-/**@brief Function for scheduling a Timer Start operation.
- *
- * @param[in]  timer_id          Id of timer to start.
- * @param[in]  timeout_initial   Time (in ticks) to first timer expiry.
- * @param[in]  timeout_periodic  Time (in ticks) between periodic expiries.
- * @param[in]  p_context         General purpose pointer. Will be passed to the timeout handler when
- *                               the timer expires.
- * @return     NRF_SUCCESS on success, otherwise an error code.
- */
-
-static uint32_t timer_start_op_schedule(timer_node_t *p_node,
-                                        uint32_t        timeout_initial,
-                                        uint32_t        timeout_periodic,
-                                        void           *p_context)
+uint32_t app_timer_start(struct timer_posix *ptimer, int msec, app_timer_mode_t mode)
 {
-  uint8_t last_index;
-  uint32_t err_code = NRF_SUCCESS;
+  int status;
+  printf("timer_test: Starting timer\n" );
+  ptimer->timer.it_value.tv_sec     = msec / 1000;
+  ptimer->timer.it_value.tv_nsec    = (msec % 1000) * 1000000;
+  ptimer->timer.it_interval.tv_sec = (mode == APP_TIMER_MODE_REPEATED) ? (msec / 1000) : 0;
+  ptimer->timer.it_interval.tv_nsec = (mode == APP_TIMER_MODE_REPEATED) ? (msec % 1000) * 1000000 : 0;
 
-  CRITICAL_REGION_ENTER();
-  timer_user_op_t *p_user_op = user_op_alloc(&last_index);
-  if (p_user_op == NULL)
+  status = timer_settime(ptimer->timerid, 0, &ptimer->timer, NULL);
+  if (status != OK)
     {
-      err_code = NRF_ERROR_NO_MEM;
+      printf("timer_test: timer_settime failed, errno=%d\n", errno);
     }
-  else
-    {
-
-      p_user_op->op_type                              = TIMER_USER_OP_TYPE_START;
-      p_user_op->p_node                               = p_node;
-      p_user_op->params.start.ticks_at_start          = rtc1_counter_get();
-      p_user_op->params.start.ticks_first_interval    = timeout_initial;
-      p_user_op->params.start.ticks_periodic_interval = timeout_periodic;
-      p_user_op->params.start.p_context               = p_context;
-
-      user_op_enque(last_index);
-    }
-  CRITICAL_REGION_EXIT();
-
-  if (err_code == NRF_SUCCESS)
-    {
-      timer_list_handler_sched();
-    }
-
-  return err_code;
+  return OK;
 }
 
-
-/**@brief Function for scheduling a Timer Stop operation.
- *
- * @param[in]  timer_id   Id of timer to stop.
- * @param[in]  op_type    Type of stop operation
- *
- * @return NRF_SUCCESS on successful scheduling a timer stop operation. NRF_ERROR_NO_MEM when there
- *         is no memory left to schedule the timer stop operation.
- */
-static uint32_t timer_stop_op_schedule(timer_node_t *p_node,
-                                       timer_user_op_type_t op_type)
+uint32_t app_timer_stop(struct timer_posix *ptimer)
 {
-  uint8_t last_index;
-  uint32_t err_code = NRF_SUCCESS;
+  int status;
+  printf("timer_test: Starting timer\n" );
+  ptimer->timer.it_value.tv_sec     = 0;
+  ptimer->timer.it_value.tv_nsec    = 0;
+  ptimer->timer.it_interval.tv_sec = 0;
+  ptimer->timer.it_interval.tv_nsec = 0;
 
-  CRITICAL_REGION_ENTER();
-  timer_user_op_t *p_user_op = user_op_alloc(&last_index);
-  if (p_user_op == NULL)
-    {
-      err_code = NRF_ERROR_NO_MEM;
-    }
-  else
+  status = timer_settime(ptimer->timerid, 0, &ptimer->timer, NULL);
+  if (status != OK)
     {
-      p_user_op->op_type  = op_type;
-      p_user_op->p_node = p_node;
-
-      user_op_enque(last_index);
+      printf("timer_test: timer_settime failed, errno=%d\n", errno);
     }
-  CRITICAL_REGION_EXIT();
-
-  if (err_code == NRF_SUCCESS)
-    {
-      timer_list_handler_sched();
-    }
-
-  return err_code;
+  return OK;
 }
 
-/**@brief Function for handling the RTC1 interrupt.
- *
- * @details Checks for timeouts, and executes timeout handlers for expired timers.
- */
-void RTC1_IRQHandler(void)
-{
-  // Clear all events (also unexpected ones)
-  NRF_RTC1->EVENTS_COMPARE[0] = 0;
-  NRF_RTC1->EVENTS_COMPARE[1] = 0;
-  NRF_RTC1->EVENTS_COMPARE[2] = 0;
-  NRF_RTC1->EVENTS_COMPARE[3] = 0;
-  NRF_RTC1->EVENTS_TICK       = 0;
-  NRF_RTC1->EVENTS_OVRFLW     = 0;
-
-  // Check for expired timers
-  timer_timeouts_check();
-}
-
-
-/**@brief Function for handling the SWI interrupt.
- *
- * @details Performs all updates to the timer list.
- */
-void SWI_IRQHandler(void)
-{
-  timer_list_handler();
-}
-
-
-uint32_t app_timer_init(uint32_t                      prescaler,
-                        uint8_t                       op_queue_size,
-                        void                         *p_buffer,
-                        app_timer_evt_schedule_func_t evt_schedule_func)
+uint32_t app_timer_delete(struct timer_posix *ptimer)
 {
-  // Check that buffer is correctly aligned
-  if (!is_word_aligned(p_buffer))
+  int status;
+  printf("timer_test: Deleting timer\n" );
+  status = timer_delete(ptimer->timerid);
+  if (status != OK)
     {
-      return NRF_ERROR_INVALID_PARAM;
+      printf("timer_test: timer_create failed, errno=%d\n", errno);
     }
-  // Check for NULL buffer
-  if (p_buffer == NULL)
-    {
-      return NRF_ERROR_INVALID_PARAM;
-    }
-
-  // Stop RTC to prevent any running timers from expiring (in case of reinitialization)
-  rtc1_stop();
-
-  m_evt_schedule_func = evt_schedule_func;
-
-  // Initialize operation queue
-  m_op_queue.first           = 0;
-  m_op_queue.last            = 0;
-  m_op_queue.size            = op_queue_size;
-  m_op_queue.p_user_op_queue = p_buffer;
-
-  mp_timer_id_head            = NULL;
-  m_ticks_elapsed_q_read_ind  = 0;
-  m_ticks_elapsed_q_write_ind = 0;
-
-#if APP_TIMER_WITH_PROFILER
-  m_max_user_op_queue_utilization   = 0;
+  /* Detach the signal handler */
+#if 0
+  (ptimer->act).sa_handler = SIG_DFL;
+  status = sigaction(my_timer_signal, &ptimer->act, &ptimer->oact);
 #endif
-
-  NVIC_ClearPendingIRQ(SWI_IRQn);
-  NVIC_SetPriority(SWI_IRQn, SWI_IRQ_PRI);
-  NVIC_EnableIRQ(SWI_IRQn);
-
-  rtc1_init(prescaler);
-
-  m_ticks_latest = rtc1_counter_get();
-
-  return NRF_SUCCESS;
-}
-
-
-uint32_t app_timer_create(app_timer_id_t const       *p_timer_id,
-                          app_timer_mode_t            mode,
-                          app_timer_timeout_handler_t timeout_handler)
-{
-
-  // Check state and parameters
-  // VERIFY_MODULE_INITIALIZED(); //MinYang comment temp. I guess it's because I didn't enable it in sdk_config.h (Since freeRTOS example use app_timer_freertos)
-
-  if (timeout_handler == NULL)
-    {
-      return NRF_ERROR_INVALID_PARAM;
-    }
-
-  if (p_timer_id == NULL)
-    {
-      return NRF_ERROR_INVALID_PARAM;
-    }
-  if (((timer_node_t *)*p_timer_id)->is_running)
-    {
-      return NRF_ERROR_INVALID_STATE;
-    }
-
-  timer_node_t *p_node     = (timer_node_t *)*p_timer_id;
-  p_node->is_running        = false;
-  p_node->mode              = mode;
-  p_node->p_timeout_handler = timeout_handler;
-
-  return NRF_SUCCESS;
-}
-
-uint32_t app_timer_start(app_timer_id_t timer_id, uint32_t timeout_ticks, void *p_context)
-{
-  uint32_t timeout_periodic;
-  timer_node_t *p_node = (timer_node_t *)timer_id;
-
-  // Check state and parameters
-  //VERIFY_MODULE_INITIALIZED(); /MinYang comment temp. I guess it's because I didn't enable it in sdk_config.h (Since freeRTOS example use app_timer_freertos)
-
-  if (timer_id == 0)
-    {
-      return NRF_ERROR_INVALID_STATE;
-    }
-  if (timeout_ticks < APP_TIMER_MIN_TIMEOUT_TICKS)
-    {
-      return NRF_ERROR_INVALID_PARAM;
-    }
-  if (p_node->p_timeout_handler == NULL)
-    {
-      return NRF_ERROR_INVALID_STATE;
-    }
-
-  // Schedule timer start operation
-  timeout_periodic = (p_node->mode == APP_TIMER_MODE_REPEATED) ? timeout_ticks : 0;
-
-  return timer_start_op_schedule(p_node,
-                                 timeout_ticks,
-                                 timeout_periodic,
-                                 p_context);
-
-}
-
-
-uint32_t app_timer_stop(app_timer_id_t timer_id)
-{
-  timer_node_t *p_node = (timer_node_t *)timer_id;
-  // Check state and parameters
-  //VERIFY_MODULE_INITIALIZED(); //MinYang comment temp. I guess it's because I didn't enable it in sdk_config.h (Since freeRTOS example use app_timer_freertos)
-
-  if ((timer_id == NULL) || (p_node->p_timeout_handler == NULL))
-    {
-      return NRF_ERROR_INVALID_STATE;
-    }
-
-  p_node->is_running = false;
-  // Schedule timer stop operation
-  return timer_stop_op_schedule(p_node, TIMER_USER_OP_TYPE_STOP);
-}
-
-
-uint32_t app_timer_stop_all(void)
-{
-  // Check state
-  //VERIFY_MODULE_INITIALIZED(); //MinYang comment temp. I guess it's because I didn't enable it in sdk_config.h (Since freeRTOS example use app_timer_freertos)
-
-  return timer_stop_op_schedule(NULL, TIMER_USER_OP_TYPE_STOP_ALL);
+  return OK;
 }
 
 
-uint32_t app_timer_cnt_get(void)
-{
-  return rtc1_counter_get();
-}
-
-
-uint32_t app_timer_cnt_diff_compute(uint32_t   ticks_to,
-                                    uint32_t   ticks_from,
-                                    uint32_t *p_ticks_diff)
-{
-  *p_ticks_diff = ticks_diff_get(ticks_to, ticks_from);
-  return NRF_SUCCESS;
-}
-
-#if APP_TIMER_WITH_PROFILER
-uint8_t app_timer_op_queue_utilization_get(void)
-{
-  return m_max_user_op_queue_utilization;
-}
-#endif
 #endif //NRF_MODULE_ENABLED(APP_TIMER)
diff --git a/arch/arm/src/nrf52/components/libraries/timer/app_timer.h b/arch/arm/src/nrf52/components/libraries/timer/app_timer.h
old mode 100644
new mode 100755
index c19fc5da21..e90a6d0bbf
--- a/arch/arm/src/nrf52/components/libraries/timer/app_timer.h
+++ b/arch/arm/src/nrf52/components/libraries/timer/app_timer.h
@@ -51,243 +51,44 @@
 extern "C" {
 #endif
 
-#define APP_TIMER_CLOCK_FREQ         32768                      /**< Clock frequency of the RTC timer used to implement the app timer module. */
-#define APP_TIMER_MIN_TIMEOUT_TICKS  5                          /**< Minimum value of the timeout_ticks parameter of app_timer_start(). */
 
-#ifdef RTX
-#define APP_TIMER_NODE_SIZE          40                         /**< Size of app_timer.timer_node_t (used to allocate data). */
-#else
-#define APP_TIMER_NODE_SIZE          32                         /**< Size of app_timer.timer_node_t (used to allocate data). */
-#endif // RTX
-#define APP_TIMER_USER_OP_SIZE       24                         /**< Size of app_timer.timer_user_op_t (only for use inside APP_TIMER_BUF_SIZE()). */
+#define MY_TIMER_SIGNAL 17  //timer signal id
 
-/**@brief Compute number of bytes required to hold the application timer data structures.
- *
- * @param[in]  OP_QUEUE_SIZE   Size of the queue holding timer operations that are pending execution.
- *                             Note that due to the queue implementation, this size must be one more
- *                             than the size that is actually needed.
- *
- * @return     Required application timer buffer size (in bytes).
- */
-#define APP_TIMER_BUF_SIZE(OP_QUEUE_SIZE)                                  \
-    (                                                                      \
-        (                                                                  \
-            (((OP_QUEUE_SIZE) + 1) * APP_TIMER_USER_OP_SIZE)               \
-        )                                                                  \
-    )
+#define APP_TIMER_MIN_TIMEOUT_TICKS  5  /**< Minimum value of the timeout_ticks parameter of app_timer_start(). */
 
-/**@brief Convert milliseconds to timer ticks.
- *
- * This macro uses 64-bit integer arithmetic, but as long as the macro parameters are
- *       constants (i.e. defines), the computation will be done by the preprocessor.
- *
- * When using this macro, ensure that the
- *         values provided as input result in an output value that is supported by the
- *         @ref app_timer_start function. For example, when the ticks for 1 ms is needed, the
- *         maximum possible value of PRESCALER must be 6, when @ref APP_TIMER_CLOCK_FREQ is 32768.
- *         This will result in a ticks value as 5. Any higher value for PRESCALER will result in a
- *         ticks value that is not supported by this module.
- *
- * @param[in]  MS          Milliseconds.
- * @param[in]  PRESCALER   Value of the RTC1 PRESCALER register (must be the same value that was
- *                         passed to APP_TIMER_INIT()).
- *
- * @return     Number of timer ticks.
- */
+//MinYang1 ++ temp add for compiling
+#define APP_TIMER_CLOCK_FREQ         32768                      /**< Clock frequency of the RTC timer used to implement the app timer module. */
 #define APP_TIMER_TICKS(MS, PRESCALER)\
             ((uint32_t)ROUNDED_DIV((MS) * (uint64_t)APP_TIMER_CLOCK_FREQ, ((PRESCALER) + 1) * 1000))
+//MinYang1 --
 
-typedef struct app_timer_t
-{
-  uint32_t data[CEIL_DIV(APP_TIMER_NODE_SIZE, sizeof(uint32_t))];
-} app_timer_t;
-
-/**@brief Timer ID type.
- * Never declare a variable of this type, but use the macro @ref APP_TIMER_DEF instead.*/
-typedef app_timer_t *app_timer_id_t;
-
-/**
- * @brief Create a timer identifier and statically allocate memory for the timer.
- *
- * @param timer_id Name of the timer identifier variable that will be used to control the timer.
- */
-#define APP_TIMER_DEF(timer_id)                                  \
-    static app_timer_t timer_id##_data = { {0} };                  \
-    static const app_timer_id_t timer_id = &timer_id##_data
-
-
-/**@brief Application time-out handler type. */
-typedef void (*app_timer_timeout_handler_t)(void *p_context);
-
-/**@brief Type of function for passing events from the timer module to the scheduler. */
-typedef uint32_t (*app_timer_evt_schedule_func_t) (app_timer_timeout_handler_t timeout_handler,
-                                                   void                       *p_context);
-
-/**@brief Timer modes. */
 typedef enum
 {
   APP_TIMER_MODE_SINGLE_SHOT,                 /**< The timer will expire only once. */
   APP_TIMER_MODE_REPEATED                     /**< The timer will restart each time it expires. */
 } app_timer_mode_t;
 
-/**@brief Initialize the application timer module.
- *
- * @details This macro handles dimensioning and allocation of the memory buffer required by the timer,
- *          making sure that the buffer is correctly aligned. It will also connect the timer module
- *          to the scheduler (if specified).
- *
- * @note    This module assumes that the LFCLK is already running. If it is not, the module will
- *          be non-functional, since the RTC will not run. If you do not use a SoftDevice, you
- *          must start the LFCLK manually. See the rtc_example's lfclk_config() function
- *          for an example of how to do this. If you use a SoftDevice, the LFCLK is started on
- *          SoftDevice init.
- *
- *
- * @param[in]  PRESCALER        Value of the RTC1 PRESCALER register. This will decide the
- *                              timer tick rate. Set to 0 for no prescaling.
- * @param[in]  OP_QUEUE_SIZE    Size of the queue holding timer operations that are pending execution.
- * @param[in]  SCHEDULER_FUNC   Pointer to scheduler event handler
- *
- * @note Since this macro allocates a buffer, it must only be called once (it is OK to call it
- *       several times as long as it is from the same location, for example, to do a re-initialization).
- */
-/*lint -emacro(506, APP_TIMER_INIT) */ /* Suppress "Constant value Boolean */
-#define APP_TIMER_INIT(PRESCALER, OP_QUEUE_SIZE, SCHEDULER_FUNC)                  \
-    do                                                                            \
-    {                                                                             \
-        static uint32_t APP_TIMER_BUF[CEIL_DIV(APP_TIMER_BUF_SIZE(OP_QUEUE_SIZE), \
-                                               sizeof(uint32_t))];                \
-        uint32_t ERR_CODE = app_timer_init((PRESCALER),                           \
-                                           (OP_QUEUE_SIZE) + 1,                   \
-                                           APP_TIMER_BUF,                         \
-                                           SCHEDULER_FUNC);                       \
-        APP_ERROR_CHECK(ERR_CODE);                                                \
-    } while (0)
-
-
-
-/**@brief Function for initializing the timer module.
- *
- * Normally, initialization should be done using the APP_TIMER_INIT() macro, because that macro will both
- *       allocate the buffers needed by the timer module (including aligning the buffers correctly)
- *       and take care of connecting the timer module to the scheduler (if specified).
- *
- * @param[in]  prescaler           Value of the RTC1 PRESCALER register. Set to 0 for no prescaling.
- * @param[in]  op_queue_size       Size of the queue holding timer operations that are pending
- *                                 execution. Note that due to the queue implementation, this size must
- *                                 be one more than the size that is actually needed.
- * @param[in]  p_buffer            Pointer to memory buffer for internal use in the app_timer
- *                                 module. The size of the buffer can be computed using the
- *                                 APP_TIMER_BUF_SIZE() macro. The buffer must be aligned to a
- *                                 4 byte boundary.
- * @param[in]  evt_schedule_func   Function for passing time-out events to the scheduler. Point to
- *                                 app_timer_evt_schedule() to connect to the scheduler. Set to NULL
- *                                 to make the timer module call the time-out handler directly from
- *                                 the timer interrupt handler.
- *
- * @retval     NRF_SUCCESS               If the module was initialized successfully.
- * @retval     NRF_ERROR_INVALID_PARAM   If a parameter was invalid (buffer not aligned to a 4 byte
- *                                       boundary or NULL).
- */
-uint32_t app_timer_init(uint32_t                      prescaler,
-                        uint8_t                       op_queue_size,
-                        void                         *p_buffer,
-                        app_timer_evt_schedule_func_t evt_schedule_func);
-
-/**@brief Function for creating a timer instance.
- *
- * @param[in]  p_timer_id        Pointer to timer identifier.
- * @param[in]  mode              Timer mode.
- * @param[in]  timeout_handler   Function to be executed when the timer expires.
- *
- * @retval     NRF_SUCCESS               If the timer was successfully created.
- * @retval     NRF_ERROR_INVALID_PARAM   If a parameter was invalid.
- * @retval     NRF_ERROR_INVALID_STATE   If the application timer module has not been initialized or
- *                                       the timer is running.
- *
- * @note This function does the timer allocation in the caller's context. It is also not protected
- *       by a critical region. Therefore care must be taken not to call it from several interrupt
- *       levels simultaneously.
- * @note The function can be called again on the timer instance and will re-initialize the instance if
- *       the timer is not running.
- * @attention The FreeRTOS and RTX app_timer implementation does not allow app_timer_create to
- *       be called on the previously initialized instance.
- */
-uint32_t app_timer_create(app_timer_id_t const       *p_timer_id,
-                          app_timer_mode_t            mode,
-                          app_timer_timeout_handler_t timeout_handler);
-
-/**@brief Function for starting a timer.
- *
- * @param[in]       timer_id      Timer identifier.
- * @param[in]       timeout_ticks Number of ticks (of RTC1, including prescaling) to time-out event
- *                                (minimum 5 ticks).
- * @param[in]       p_context     General purpose pointer. Will be passed to the time-out handler when
- *                                the timer expires.
- *
- * @retval     NRF_SUCCESS               If the timer was successfully started.
- * @retval     NRF_ERROR_INVALID_PARAM   If a parameter was invalid.
- * @retval     NRF_ERROR_INVALID_STATE   If the application timer module has not been initialized or the timer
- *                                       has not been created.
- * @retval     NRF_ERROR_NO_MEM          If the timer operations queue was full.
- *
- * @note The minimum timeout_ticks value is 5.
- * @note For multiple active timers, time-outs occurring in close proximity to each other (in the
- *       range of 1 to 3 ticks) will have a positive jitter of maximum 3 ticks.
- * @note When calling this method on a timer that is already running, the second start operation
- *       is ignored.
- */
-uint32_t app_timer_start(app_timer_id_t timer_id, uint32_t timeout_ticks, void *p_context);
+typedef void (*app_timer_timeout_handler_t)(int signo, siginfo_t *info, void *ucontext);
 
-/**@brief Function for stopping the specified timer.
- *
- * @param[in]  timer_id                  Timer identifier.
- *
- * @retval     NRF_SUCCESS               If the timer was successfully stopped.
- * @retval     NRF_ERROR_INVALID_PARAM   If a parameter was invalid.
- * @retval     NRF_ERROR_INVALID_STATE   If the application timer module has not been initialized or the timer
- *                                       has not been created.
- * @retval     NRF_ERROR_NO_MEM          If the timer operations queue was full.
- */
-uint32_t app_timer_stop(app_timer_id_t timer_id);
-
-/**@brief Function for stopping all running timers.
- *
- * @retval     NRF_SUCCESS               If all timers were successfully stopped.
- * @retval     NRF_ERROR_INVALID_STATE   If the application timer module has not been initialized.
- * @retval     NRF_ERROR_NO_MEM          If the timer operations queue was full.
- */
-uint32_t app_timer_stop_all(void);
-
-/**@brief Function for returning the current value of the RTC1 counter.
- *
- * @return    Current value of the RTC1 counter.
- */
-uint32_t app_timer_cnt_get(void);
-
-/**@brief Function for computing the difference between two RTC1 counter values.
- *
- * @param[in]  ticks_to       Value returned by app_timer_cnt_get().
- * @param[in]  ticks_from     Value returned by app_timer_cnt_get().
- * @param[out] p_ticks_diff   Number of ticks from ticks_from to ticks_to.
- *
- * @retval     NRF_SUCCESS   If the counter difference was successfully computed.
- */
-uint32_t app_timer_cnt_diff_compute(uint32_t   ticks_to,
-                                    uint32_t   ticks_from,
-                                    uint32_t *p_ticks_diff);
-
-
-/**@brief Function for getting the maximum observed operation queue utilization.
- *
- * Function for tuning the module and determining OP_QUEUE_SIZE value and thus module RAM usage.
- *
- * @note APP_TIMER_WITH_PROFILER must be enabled to use this functionality.
- *
- * @return Maximum number of events in queue observed so far.
- */
-uint8_t app_timer_op_queue_utilization_get(void);
 
+struct timer_posix
+{
+  sigset_t           set;
+  struct sigaction   act;
+  struct sigaction   oact;
+  struct sigevent    notify;
+  struct itimerspec  timer;
+  timer_t            timerid;
+};
+
+extern struct timer_posix m_heart_rate_timer_id, m_conn_params_timer_id, m_battery_timer_id;
+
+void app_timer_signal_handler(int signo, siginfo_t *info, void *ucontext);
+
+uint32_t app_timer_create(struct timer_posix *ptimer, int sigvalue_int);
+uint32_t app_timer_start(struct timer_posix *ptimer, int msec, app_timer_mode_t mode);
+uint32_t app_timer_stop(struct timer_posix *ptimer);
+uint32_t app_timer_delete(struct timer_posix *ptimer);
 
 #ifdef __cplusplus
 }
diff --git a/arch/arm/src/nrf52/components/libraries/util/app_error.c b/arch/arm/src/nrf52/components/libraries/util/app_error.c
index 751f971d42..706a34b6c8 100644
--- a/arch/arm/src/nrf52/components/libraries/util/app_error.c
+++ b/arch/arm/src/nrf52/components/libraries/util/app_error.c
@@ -53,13 +53,13 @@ void app_error_handler(ret_code_t error_code, uint32_t line_num, const uint8_t *
 /*lint -save -e14 */
 void app_error_handler_bare(ret_code_t error_code)
 {
+
   error_info_t error_info =
   {
     .line_num    = 0,
     .p_file_name = NULL,
     .err_code    = error_code,
   };
-
   app_error_fault_handler(NRF_FAULT_ID_SDK_ERROR, 0, (uint32_t)(&error_info));
 
   UNUSED_VARIABLE(error_info);
diff --git a/arch/arm/src/nrf52/components/libraries/util/app_util.h b/arch/arm/src/nrf52/components/libraries/util/app_util.h
index f71a4290ef..63e8faa312 100644
--- a/arch/arm/src/nrf52/components/libraries/util/app_util.h
+++ b/arch/arm/src/nrf52/components/libraries/util/app_util.h
@@ -59,20 +59,20 @@ enum
 
 
 /**@brief Implementation specific macro for delayed macro expansion used in string concatenation
-*
-* @param[in]   lhs   Left hand side in concatenation
-* @param[in]   rhs   Right hand side in concatenation
-*/
+ *
+ * @param[in]   lhs   Left hand side in concatenation
+ * @param[in]   rhs   Right hand side in concatenation
+ */
 #define STRING_CONCATENATE_IMPL(lhs, rhs) lhs ## rhs
 
 
 /**@brief Macro used to concatenate string using delayed macro expansion
-*
-* @note This macro will delay concatenation until the expressions have been resolved
-*
-* @param[in]   lhs   Left hand side in concatenation
-* @param[in]   rhs   Right hand side in concatenation
-*/
+ *
+ * @note This macro will delay concatenation until the expressions have been resolved
+ *
+ * @param[in]   lhs   Left hand side in concatenation
+ * @param[in]   rhs   Right hand side in concatenation
+ */
 #define STRING_CONCATENATE(lhs, rhs) STRING_CONCATENATE_IMPL(lhs, rhs)
 
 
@@ -96,14 +96,14 @@ enum
 
 
 /**@brief Macro for doing static (i.e. compile time) assertion.
-*
-* @note If the EXPR isn't resolvable, then the error message won't be shown.
-*
-* @note The output of STATIC_ASSERT_MSG will be different across different compilers.
-*
-* @param[in] EXPR Constant expression to be verified.
-* @param[in] MSG  Name of the static assert.
-*/
+ *
+ * @note If the EXPR isn't resolvable, then the error message won't be shown.
+ *
+ * @note The output of STATIC_ASSERT_MSG will be different across different compilers.
+ *
+ * @param[in] EXPR Constant expression to be verified.
+ * @param[in] MSG  Name of the static assert.
+ */
 #if defined(__COUNTER__)
 
 #define STATIC_ASSERT_MSG(EXPR, MSG) \
@@ -118,13 +118,13 @@ enum
 
 
 /**@brief Macro for doing static (i.e. compile time) assertion.
-*
-* @note If the EXPR isn't resolvable, then the error message won't be shown.
-*
-* @note The output of STATIC_ASSERT will be different across different compilers.
-*
-* @param[in] EXPR Constant expression to be verified.
-*/
+ *
+ * @note If the EXPR isn't resolvable, then the error message won't be shown.
+ *
+ * @note The output of STATIC_ASSERT will be different across different compilers.
+ *
+ * @param[in] EXPR Constant expression to be verified.
+ */
 #define STATIC_ASSERT(EXPR) STATIC_ASSERT_MSG((EXPR), static_assert_)
 
 
@@ -916,7 +916,7 @@ static __INLINE uint64_t uint48_decode(const uint8_t *p_encoded_data)
  *  @param[in] mvolts The voltage in mV
  *
  *  @return    Battery level in percent.
-*/
+ */
 static __INLINE uint8_t battery_level_in_percent(const uint16_t mvolts)
 {
   uint8_t battery_level;
diff --git a/arch/arm/src/nrf52/components/softdevice/common/softdevice_handler/softdevice_handler.c b/arch/arm/src/nrf52/components/softdevice/common/softdevice_handler/softdevice_handler.c
index 8e2e6eb001..191af4735a 100644
--- a/arch/arm/src/nrf52/components/softdevice/common/softdevice_handler/softdevice_handler.c
+++ b/arch/arm/src/nrf52/components/softdevice/common/softdevice_handler/softdevice_handler.c
@@ -302,11 +302,13 @@ uint32_t softdevice_handler_init(nrf_clock_lf_cfg_t            *p_clock_lf_cfg,
     }
 #endif
 
+
 //Disable interrupt before sd_softdevice_enable
   up_disable_irq(POWER_CLOCK_IRQn);
   up_disable_irq(UARTE0_UART0_IRQn);
   up_disable_irq(RNG_IRQn);
   up_disable_irq(GPIOTE_IRQn);
+  up_disable_irq(RTC1_IRQn);
 
 
 #if defined(S212) || defined(S332)
@@ -315,11 +317,15 @@ uint32_t softdevice_handler_init(nrf_clock_lf_cfg_t            *p_clock_lf_cfg,
   err_code = sd_softdevice_enable(p_clock_lf_cfg, softdevice_fault_handler);
 #endif
 
+
 //Enable irq again.
   up_enable_irq(POWER_CLOCK_IRQn);
   up_enable_irq(UARTE0_UART0_IRQn);
   up_enable_irq(RNG_IRQn);
   up_enable_irq(GPIOTE_IRQn);
+  up_enable_irq(RTC1_IRQn);
+
+
 
   if (err_code != NRF_SUCCESS)
     {
@@ -344,7 +350,9 @@ uint32_t softdevice_handler_init(nrf_clock_lf_cfg_t            *p_clock_lf_cfg,
   nrf_drv_clock_on_sd_enable();
 #endif
 
+
   // Enable BLE event interrupt (interrupt priority has already been set by the stack).
+
 #ifdef SOFTDEVICE_PRESENT
   //err_code = sd_nvic_EnableIRQ((IRQn_Type)SOFTDEVICE_EVT_IRQ); //comment out...change to Nuttx's format
   irq_attach(SOFTDEVICE_EVT_IRQ, (xcpt_t)SOFTDEVICE_EVT_IRQHandler, NULL);  //add Nuttx irq api
diff --git a/arch/arm/src/nrf52/components/softdevice/s132/headers/ble.h b/arch/arm/src/nrf52/components/softdevice/s132/headers/ble.h
index e8c3fd00ae..1a1acadfab 100644
--- a/arch/arm/src/nrf52/components/softdevice/s132/headers/ble.h
+++ b/arch/arm/src/nrf52/components/softdevice/s132/headers/ble.h
@@ -117,17 +117,17 @@ enum BLE_COMMON_OPTS
  * @{ */
 
 /** @brief  Required pointer alignment for BLE Events.
-*/
+ */
 #define BLE_EVT_PTR_ALIGNMENT    4
 
 /** @brief  Leaves the maximum of the two arguments.
-*/
+ */
 #define BLE_MAX(a, b) ((a) < (b) ? (b) : (a))
 
 /** @brief  Maximum possible length for BLE Events.
  * @note Value of @ref ble_gatt_enable_params_t::att_mtu shall be used as a parameter.
  * If that value is set to 0 then @ref BLE_GATT_MTU_SIZE_DEFAULT must be used instead.
-*/
+ */
 #define BLE_EVT_LEN_MAX(ATT_MTU) (BLE_MAX( \
   sizeof(ble_evt_t), \
   BLE_MAX( \
@@ -686,4 +686,4 @@ SVCALL(SD_BLE_OPT_GET, uint32_t, sd_ble_opt_get(uint32_t opt_id, ble_opt_t *p_op
 /**
   @}
   @}
-*/
+ */
diff --git a/arch/arm/src/nrf52/components/softdevice/s132/headers/ble_gap.h b/arch/arm/src/nrf52/components/softdevice/s132/headers/ble_gap.h
index 2f2f815646..30012c802d 100644
--- a/arch/arm/src/nrf52/components/softdevice/s132/headers/ble_gap.h
+++ b/arch/arm/src/nrf52/components/softdevice/s132/headers/ble_gap.h
@@ -805,7 +805,7 @@ uint8_t oobd_req       :
 
 /**@brief Security levels supported.
  * @note See Bluetooth Specification Version 4.2 Volume 3, Part C, Chapter 10, Section 10.2.1.
-*/
+ */
 typedef struct
 {
   uint8_t lv1 : 1;                              /**< If 1: Level 1 is supported. */
@@ -2052,4 +2052,4 @@ SVCALL(SD_BLE_GAP_PHY_REQUEST, uint32_t, sd_ble_gap_phy_request(uint16_t conn_ha
 
 /**
   @}
-*/
+ */
diff --git a/arch/arm/src/nrf52/components/softdevice/s132/headers/ble_gattc.h b/arch/arm/src/nrf52/components/softdevice/s132/headers/ble_gattc.h
index edf486d0c2..5d361bf6be 100644
--- a/arch/arm/src/nrf52/components/softdevice/s132/headers/ble_gattc.h
+++ b/arch/arm/src/nrf52/components/softdevice/s132/headers/ble_gattc.h
@@ -689,4 +689,4 @@ __STATIC_INLINE uint32_t sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter(ble_gat
 
 /**
   @}
-*/
+ */
diff --git a/arch/arm/src/nrf52/components/softdevice/s132/headers/ble_gatts.h b/arch/arm/src/nrf52/components/softdevice/s132/headers/ble_gatts.h
index 7c7a249a6f..a78abfb56a 100644
--- a/arch/arm/src/nrf52/components/softdevice/s132/headers/ble_gatts.h
+++ b/arch/arm/src/nrf52/components/softdevice/s132/headers/ble_gatts.h
@@ -90,7 +90,7 @@ enum BLE_GATTS_EVTS
   BLE_GATTS_EVT_SC_CONFIRM,                       /**< Service Changed Confirmation. No additional event structure applies.                                                    */
   BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST,             /**< Exchange MTU Request.                                                \n Reply with @ref sd_ble_gatts_exchange_mtu_reply. \n See @ref ble_gatts_evt_exchange_mtu_request_t. */
   BLE_GATTS_EVT_TIMEOUT,                          /**< Peer failed to resonpond to an ATT request in time.                  \n See @ref ble_gatts_evt_timeout_t.               */
-  BLE_GATTS_EVT_HVN_TX_COMPLETE					  /**< Handle Value Notification transmission complete.					    \n See @ref ble_gatts_evt_hvn_tx_complete_t.		 */
+  BLE_GATTS_EVT_HVN_TX_COMPLETE           /**< Handle Value Notification transmission complete.             \n See @ref ble_gatts_evt_hvn_tx_complete_t.     */
 };
 /** @} */
 
@@ -800,4 +800,4 @@ SVCALL(SD_BLE_GATTS_EXCHANGE_MTU_REPLY, uint32_t, sd_ble_gatts_exchange_mtu_repl
 
 /**
   @}
-*/
+ */
diff --git a/arch/arm/src/nrf52/components/softdevice/s132/headers/ble_l2cap.h b/arch/arm/src/nrf52/components/softdevice/s132/headers/ble_l2cap.h
index 2f20796937..4a62086815 100644
--- a/arch/arm/src/nrf52/components/softdevice/s132/headers/ble_l2cap.h
+++ b/arch/arm/src/nrf52/components/softdevice/s132/headers/ble_l2cap.h
@@ -200,4 +200,4 @@ SVCALL(SD_BLE_L2CAP_TX, uint32_t, sd_ble_l2cap_tx(uint16_t conn_handle, ble_l2ca
 
 /**
   @}
-*/
+ */
diff --git a/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf52/nrf_mbr.h b/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf52/nrf_mbr.h
index add17c9dae..620082540a 100644
--- a/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf52/nrf_mbr.h
+++ b/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf52/nrf_mbr.h
@@ -39,7 +39,7 @@
 
   @brief APIs for updating SoftDevice and BootLoader
 
-*/
+ */
 
 /* Header guard */
 #ifndef NRF_MBR_H__
@@ -202,7 +202,7 @@ typedef struct
  *
  * @retval NRF_ERROR_NO_MEM if UICR.NRFFW[1] is not set (i.e. is 0xFFFFFFFF).
  * @retval NRF_ERROR_INVALID_PARAM if an invalid command is given.
-*/
+ */
 SVCALL(SD_MBR_COMMAND, uint32_t, sd_mbr_command(sd_mbr_command_t *param));
 
 /** @} */
@@ -214,4 +214,4 @@ SVCALL(SD_MBR_COMMAND, uint32_t, sd_mbr_command(sd_mbr_command_t *param));
 
 /**
   @}
-*/
+ */
diff --git a/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_error.h b/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_error.h
index e0f568f2ec..362a4823e9 100644
--- a/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_error.h
+++ b/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_error.h
@@ -38,7 +38,7 @@
  @{
 
  @brief Global Error definitions
-*/
+ */
 
 /* Header guard */
 #ifndef NRF_ERROR_H__
@@ -84,4 +84,4 @@ extern "C" {
 
 /**
   @}
-*/
+ */
diff --git a/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_error_sdm.h b/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_error_sdm.h
index a5006d3f61..386ebe0464 100644
--- a/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_error_sdm.h
+++ b/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_error_sdm.h
@@ -40,7 +40,7 @@
  @{
 
  @brief Error definitions for the SDM API
-*/
+ */
 
 /* Header guard */
 #ifndef NRF_ERROR_SDM_H__
@@ -64,4 +64,4 @@ extern "C" {
 /**
   @}
   @}
-*/
+ */
diff --git a/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_error_soc.h b/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_error_soc.h
index e31d8c9c97..ee6a4e32b3 100644
--- a/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_error_soc.h
+++ b/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_error_soc.h
@@ -41,7 +41,7 @@
 
   @brief Error definitions for the SoC library
 
-*/
+ */
 
 /* Header guard */
 #ifndef NRF_ERROR_SOC_H__
@@ -79,4 +79,4 @@ extern "C" {
 /**
   @}
   @}
-*/
+ */
diff --git a/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_nvic.h b/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_nvic.h
old mode 100644
new mode 100755
index ce4d79a7f3..1a40475839
--- a/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_nvic.h
+++ b/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_nvic.h
@@ -97,7 +97,6 @@ extern "C" {
 #define __NRF_NVIC_ISER_COUNT (2) /**< The number of ISER/ICER registers in the NVIC that are used. */
 
 /**@brief Interrupts used by the SoftDevice. */
-//MinYang modified because of compiler warning
 #define __NRF_NVIC_SD_IRQS_0 ((uint32_t)( \
         (1U << (POWER_CLOCK_IRQn-NRF52_IRQ_FIRST)) \
       | (1U << (RADIO_IRQn-NRF52_IRQ_FIRST)) \
diff --git a/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_sdm.h b/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_sdm.h
index 704ebbe798..8fdaf181ee 100644
--- a/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_sdm.h
+++ b/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_sdm.h
@@ -39,7 +39,7 @@
 
   @brief APIs for SoftDevice management.
 
-*/
+ */
 
 #ifndef NRF_SDM_H__
 #define NRF_SDM_H__
@@ -331,4 +331,4 @@ SVCALL(SD_SOFTDEVICE_VECTOR_TABLE_BASE_SET, uint32_t, sd_softdevice_vector_table
 
 /**
   @}
-*/
+ */
diff --git a/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_soc.h b/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_soc.h
index 4d91c96898..8683188ee7 100644
--- a/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_soc.h
+++ b/arch/arm/src/nrf52/components/softdevice/s132/headers/nrf_soc.h
@@ -416,7 +416,7 @@ SVCALL(SD_RAND_APPLICATION_BYTES_AVAILABLE_GET, uint32_t, sd_rand_application_by
  *
  * @retval ::NRF_SUCCESS The requested bytes were written to p_buff.
  * @retval ::NRF_ERROR_SOC_RAND_NOT_ENOUGH_VALUES No bytes were written to the buffer, because there were not enough bytes available.
-*/
+ */
 SVCALL(SD_RAND_APPLICATION_VECTOR_GET, uint32_t, sd_rand_application_vector_get(uint8_t *p_buff, uint8_t length));
 
 /**@brief Gets the reset reason register.
@@ -753,66 +753,66 @@ SVCALL(SD_EVT_GET, uint32_t, sd_evt_get(uint32_t *p_evt_id));
 SVCALL(SD_TEMP_GET, uint32_t, sd_temp_get(int32_t *p_temp));
 
 /**@brief Flash Write
-*
-* Commands to write a buffer to flash
-*
-* If the SoftDevice is enabled:
-*  This call initiates the flash access command, and its completion will be communicated to the
-*  application with exactly one of the following events:
-*      - @ref NRF_EVT_FLASH_OPERATION_SUCCESS - The command was successfully completed.
-*      - @ref NRF_EVT_FLASH_OPERATION_ERROR   - The command could not be started.
-*
-* If the SoftDevice is not enabled no event will be generated, and this call will return @ref NRF_SUCCESS when the
+ *
+ * Commands to write a buffer to flash
+ *
+ * If the SoftDevice is enabled:
+ *  This call initiates the flash access command, and its completion will be communicated to the
+ *  application with exactly one of the following events:
+ *      - @ref NRF_EVT_FLASH_OPERATION_SUCCESS - The command was successfully completed.
+ *      - @ref NRF_EVT_FLASH_OPERATION_ERROR   - The command could not be started.
+ *
+ * If the SoftDevice is not enabled no event will be generated, and this call will return @ref NRF_SUCCESS when the
  * write has been completed
-*
-* @note
-*      - This call takes control over the radio and the CPU during flash erase and write to make sure that
-*        they will not interfere with the flash access. This means that all interrupts will be blocked
-*        for a predictable time (depending on the NVMC specification in nRF51 Series Reference Manual
-*        and the command parameters).
-*      - The data in the p_src buffer should not be modified before the @ref NRF_EVT_FLASH_OPERATION_SUCCESS
-*        or the @ref NRF_EVT_FLASH_OPERATION_ERROR have been received if the SoftDevice is enabled.
-*
-*
-* @param[in]  p_dst Pointer to start of flash location to be written.
-* @param[in]  p_src Pointer to buffer with data to be written.
-* @param[in]  size  Number of 32-bit words to write. Maximum size is 256 32-bit words for nRF51 and 1024 for nRF52.
-*
-* @retval ::NRF_ERROR_INVALID_ADDR   Tried to write to a non existing flash address, or p_dst or p_src was unaligned.
-* @retval ::NRF_ERROR_BUSY           The previous command has not yet completed.
-* @retval ::NRF_ERROR_INVALID_LENGTH Size was 0, or higher than the maximum allowed size.
-* @retval ::NRF_ERROR_FORBIDDEN      Tried to write to or read from protected location.
-* @retval ::NRF_SUCCESS              The command was accepted.
-*/
+ *
+ * @note
+ *      - This call takes control over the radio and the CPU during flash erase and write to make sure that
+ *        they will not interfere with the flash access. This means that all interrupts will be blocked
+ *        for a predictable time (depending on the NVMC specification in nRF51 Series Reference Manual
+ *        and the command parameters).
+ *      - The data in the p_src buffer should not be modified before the @ref NRF_EVT_FLASH_OPERATION_SUCCESS
+ *        or the @ref NRF_EVT_FLASH_OPERATION_ERROR have been received if the SoftDevice is enabled.
+ *
+ *
+ * @param[in]  p_dst Pointer to start of flash location to be written.
+ * @param[in]  p_src Pointer to buffer with data to be written.
+ * @param[in]  size  Number of 32-bit words to write. Maximum size is 256 32-bit words for nRF51 and 1024 for nRF52.
+ *
+ * @retval ::NRF_ERROR_INVALID_ADDR   Tried to write to a non existing flash address, or p_dst or p_src was unaligned.
+ * @retval ::NRF_ERROR_BUSY           The previous command has not yet completed.
+ * @retval ::NRF_ERROR_INVALID_LENGTH Size was 0, or higher than the maximum allowed size.
+ * @retval ::NRF_ERROR_FORBIDDEN      Tried to write to or read from protected location.
+ * @retval ::NRF_SUCCESS              The command was accepted.
+ */
 SVCALL(SD_FLASH_WRITE, uint32_t, sd_flash_write(uint32_t * const p_dst, uint32_t const * const p_src, uint32_t size));
 
 
 /**@brief Flash Erase page
-*
-* Commands to erase a flash page
-* If the SoftDevice is enabled:
-*  This call initiates the flash access command, and its completion will be communicated to the
-*  application with exactly one of the following events:
-*      - @ref NRF_EVT_FLASH_OPERATION_SUCCESS - The command was successfully completed.
-*      - @ref NRF_EVT_FLASH_OPERATION_ERROR   - The command could not be started.
-*
-* If the SoftDevice is not enabled no event will be generated, and this call will return @ref NRF_SUCCESS when the
-* erase has been completed
-*
-* @note
-*      - This call takes control over the radio and the CPU during flash erase and write to make sure that
-*        they will not interfere with the flash access. This means that all interrupts will be blocked
-*        for a predictable time (depending on the NVMC specification in nRF51 Series Reference Manual
-*        and the command parameters).
-*
-*
-* @param[in]  page_number Pagenumber of the page to erase
-* @retval ::NRF_ERROR_INTERNAL      If a new session could not be opened due to an internal error.
-* @retval ::NRF_ERROR_INVALID_ADDR  Tried to erase to a non existing flash page.
-* @retval ::NRF_ERROR_BUSY          The previous command has not yet completed.
-* @retval ::NRF_ERROR_FORBIDDEN     Tried to erase a protected page.
-* @retval ::NRF_SUCCESS             The command was accepted.
-*/
+ *
+ * Commands to erase a flash page
+ * If the SoftDevice is enabled:
+ *  This call initiates the flash access command, and its completion will be communicated to the
+ *  application with exactly one of the following events:
+ *      - @ref NRF_EVT_FLASH_OPERATION_SUCCESS - The command was successfully completed.
+ *      - @ref NRF_EVT_FLASH_OPERATION_ERROR   - The command could not be started.
+ *
+ * If the SoftDevice is not enabled no event will be generated, and this call will return @ref NRF_SUCCESS when the
+ * erase has been completed
+ *
+ * @note
+ *      - This call takes control over the radio and the CPU during flash erase and write to make sure that
+ *        they will not interfere with the flash access. This means that all interrupts will be blocked
+ *        for a predictable time (depending on the NVMC specification in nRF51 Series Reference Manual
+ *        and the command parameters).
+ *
+ *
+ * @param[in]  page_number Pagenumber of the page to erase
+ * @retval ::NRF_ERROR_INTERNAL      If a new session could not be opened due to an internal error.
+ * @retval ::NRF_ERROR_INVALID_ADDR  Tried to erase to a non existing flash page.
+ * @retval ::NRF_ERROR_BUSY          The previous command has not yet completed.
+ * @retval ::NRF_ERROR_FORBIDDEN     Tried to erase a protected page.
+ * @retval ::NRF_SUCCESS             The command was accepted.
+ */
 SVCALL(SD_FLASH_PAGE_ERASE, uint32_t, sd_flash_page_erase(uint32_t page_number));
 
 
diff --git a/arch/arm/src/nrf52/components/toolchain/system_nrf52.c b/arch/arm/src/nrf52/components/toolchain/system_nrf52.c
index f75b3e5695..5df3ffa292 100644
--- a/arch/arm/src/nrf52/components/toolchain/system_nrf52.c
+++ b/arch/arm/src/nrf52/components/toolchain/system_nrf52.c
@@ -119,7 +119,7 @@ void SystemInit(void)
       NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
       NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
       NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
-      //NRF_TEMP->B0 = NRF_FICR->TEMP.B0;  //MinYang comment out to make compile not fail
+      //NRF_TEMP->B0 = NRF_FICR->TEMP.B0;  //XXX comment out to make compile not fail
       NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
       NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
       NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
diff --git a/arch/arm/src/nrf52/nrf.h b/arch/arm/src/nrf52/nrf.h
index b22287552b..1adc5fb89c 100644
--- a/arch/arm/src/nrf52/nrf.h
+++ b/arch/arm/src/nrf52/nrf.h
@@ -6,15 +6,13 @@
  ***************************************************************************/
 
 
-//#include <nrf52.h>
+#include <nrf52.h>
 
-#define	__STATIC_INLINE	static inline
+#define __STATIC_INLINE static inline
 
 #ifndef NRF_H
 #define NRF_H
 
-#define NRF52 //MinYang add 
-
 /* MDK version */
 #define MDK_MAJOR_VERSION   8
 #define MDK_MINOR_VERSION   12
diff --git a/arch/arm/src/nrf52/nrf52.h b/arch/arm/src/nrf52/nrf52.h
index 574489e67d..444e4fa9e4 100644
--- a/arch/arm/src/nrf52/nrf52.h
+++ b/arch/arm/src/nrf52/nrf52.h
@@ -54,7 +54,7 @@
   */
 
 #ifndef NRF52_H
-#define	NRF52_H
+#define NRF52_H
 #include "core_cm4.h"       /*!< Cortex-M4 processor and core peripherals              */
 #include "system_nrf52.h"   /*!< nrf52 System                                          */
 
@@ -71,17 +71,17 @@ extern "C" {
     \li for automatic generation of peripheral register debug information.
  */
 #ifdef __cplusplus
-#define	__I     volatile /*!< Defines 'read only' permissions */
+#define __I     volatile /*!< Defines 'read only' permissions */
 #else
-#define	__I     volatile const       /*!< Defines 'read only' permissions */
+#define __I     volatile const       /*!< Defines 'read only' permissions */
 #endif
-#define	__O     volatile /*!< Defines 'write only' permissions */
-#define	__IO    volatile /*!< Defines 'read / write' permissions */
+#define __O     volatile /*!< Defines 'write only' permissions */
+#define __IO    volatile /*!< Defines 'read / write' permissions */
 
 /* following defines should be used for structure members */
-#define	__IM     volatile const      /*! Defines 'read only' structure member permissions */
-#define	__OM     volatile/*! Defines 'write only' structure member permissions */
-#define	__IOM    volatile/*! Defines 'read / write' structure member permissions */
+#define __IM     volatile const      /*! Defines 'read only' structure member permissions */
+#define __OM     volatile/*! Defines 'write only' structure member permissions */
+#define __IOM    volatile/*! Defines 'read / write' structure member permissions */
 
 /*@} end of group Cortex_M4 */
 
@@ -101,60 +101,54 @@ typedef enum
 /* =========      Bluetooth Settings Section     ================ */
 /* ========================================================================= */
 #if defined(CONFIG_ARCH_CHIP_NRF52832)
-#define	NRF52832 1
+#define NRF52832 1
 #endif
 
 #if CONFIG_ARCH_BOARD_NRF52832_DK == 1
-#define	BOARD_PCA10040 1
+#define BOARD_PCA10040 1
 #endif
 
+#define NRF52
 #if defined(CONFIG_NRF52_BLUETOOTH)
-#define	FREERTOS 1
-#define	S132 1
-#define	BLE_STACK_SUPPORT_REQD 0
-#define	 __STACK_SIZE	CONFIG_BLE__STACK_SIZE /* =2048 */
-#define	__HEAP_SIZE  CONFIG_BLE___HEAP_SIZE	/* =1024 */
+#define FREERTOS 1
+#define S132 1
+#define BLE_STACK_SUPPORT_REQD 0
+#define  __STACK_SIZE CONFIG_BLE__STACK_SIZE /* =2048 */
+#define __HEAP_SIZE  CONFIG_BLE___HEAP_SIZE /* =1024 */
 #define  SOFTDEVICE_PRESENT 1
-#define NRF52
-#define	NRF52_PAN_12 1
-#define	NRF52_PAN_15 1
-#define	NRF52_PAN_20 1
-#define	NRF52_PAN_31 1
-#define	NRF52_PAN_36 1
-#define	NRF52_PAN_51 1
-#define	NRF52_PAN_54 1
-#define	NRF52_PAN_55 1
-#define	NRF52_PAN_58 1
-#define	NRF52_PAN_64 1
+#define NRF52_PAN_12 1
+#define NRF52_PAN_15 1
+#define NRF52_PAN_20 1
+#define NRF52_PAN_31 1
+#define NRF52_PAN_36 1
+#define NRF52_PAN_51 1
+#define NRF52_PAN_54 1
+#define NRF52_PAN_55 1
+#define NRF52_PAN_58 1
+#define NRF52_PAN_64 1
 
 #if defined(CONFIG_GATT_BLE_MTU_SIZE_DEFAULT)
-#define	GATT_MTU_SIZE_DEFAULT CONFIG_BLE_GATT_MTU_SIZE_DEFAULT
+#define GATT_MTU_SIZE_DEFAULT CONFIG_BLE_GATT_MTU_SIZE_DEFAULT
 #endif
 
 #if defined(CONFIG_NRF_SD_BLE_API_VERSION)
-#define	NRF_SD_BLE_API_VERSION CONFIG_NRF_SD_BLE_API_VERSION
+#define NRF_SD_BLE_API_VERSION CONFIG_NRF_SD_BLE_API_VERSION
 #endif
 
 #endif /* CONFIG_NRF52_BLUETOOTH */
 
-/** @addtogroup Configuration_of_CMSIS
-  * @{
-  */
-
-#if 0  //MY comment out
 /* ========================================================================= */
-/* =========      Processor and Core Peripheral Section     ================ */
+/* =========      RTC setting     ================ */
+/* Context switch, posix timer and other schedule related feature all depends
+on ARM SysTick which uses high frequency clock by default.
+User can also uses low frequency clock(RTC) instead of ARM SysTick
+by selecting RTC_TICKS in menuconfig */
 /* ========================================================================= */
 
-/* -----Configuration of the Cortex-M4 Processor and Core Peripherals ------ */
-#define	__CM4_REV     0x0001            /*!< Cortex-M4 Core Revision */
-#define	__MPU_PRESENT      1            /*!< MPU present or not      */
-#define	__NVIC_PRIO_BITS   3            /*!< Number of Bits used for Priority Levels               */
-#define	__Vendor_SysTickConfig         0/*!< Set to 1 if different SysTick Config is used          */
-#define	__FPU_PRESENT      1            /*!< FPU present or not      */
-/** @} */
-/* End of group Configuration_of_CMSIS */
-#endif
+
+/** @addtogroup Configuration_of_CMSIS
+  * @{
+  */
 
 /* ========================================================================= */
 /* =========       Device Specific Peripheral Section       ================ */
@@ -1951,152 +1945,143 @@ typedef struct                          /* GPIO Structure                */
 /* =========              Peripheral memory map             ================ */
 /* ========================================================================= */
 
-#define	NRF_FICR_BASE                   0x10000000UL
-#define	NRF_UICR_BASE                   0x10001000UL
-#define	NRF_BPROT_BASE                  0x40000000UL
-#define	NRF_POWER_BASE                  0x40000000UL
-#define	NRF_CLOCK_BASE                  0x40000000UL
-#define	NRF_RADIO_BASE                  0x40001000UL
-#define	NRF_UARTE0_BASE                 0x40002000UL
-#define	NRF_UART0_BASE                  0x40002000UL
-#define	NRF_SPIM0_BASE                  0x40003000UL
-#define	NRF_SPIS0_BASE                  0x40003000UL
-#define	NRF_TWIM0_BASE                  0x40003000UL
-#define	NRF_TWIS0_BASE                  0x40003000UL
-#define	NRF_SPI0_BASE                   0x40003000UL
-#define	NRF_TWI0_BASE                   0x40003000UL
-#define	NRF_SPIM1_BASE                  0x40004000UL
-#define	NRF_SPIS1_BASE                  0x40004000UL
-#define	NRF_TWIM1_BASE                  0x40004000UL
-#define	NRF_TWIS1_BASE                  0x40004000UL
-#define	NRF_SPI1_BASE                   0x40004000UL
-#define	NRF_TWI1_BASE                   0x40004000UL
-#define	NRF_NFCT_BASE                   0x40005000UL
-#define	NRF_GPIOTE_BASE                 0x40006000UL
-#define	NRF_SAADC_BASE                  0x40007000UL
-#define	NRF_TIMER0_BASE                 0x40008000UL
-#define	NRF_TIMER1_BASE                 0x40009000UL
-#define	NRF_TIMER2_BASE                 0x4000A000UL
-#define	NRF_RTC0_BASE                   0x4000B000UL
-#define	NRF_TEMP_BASE                   0x4000C000UL
-#define	NRF_RNG_BASE                    0x4000D000UL
-#define	NRF_ECB_BASE                    0x4000E000UL
-#define	NRF_CCM_BASE                    0x4000F000UL
-#define	NRF_AAR_BASE                    0x4000F000UL
-#define	NRF_WDT_BASE                    0x40010000UL
-#define	NRF_RTC1_BASE                   0x40011000UL
-#define	NRF_QDEC_BASE                   0x40012000UL
-#define	NRF_COMP_BASE                   0x40013000UL
-#define	NRF_LPCOMP_BASE                 0x40013000UL
-#define	NRF_SWI0_BASE                   0x40014000UL
-#define	NRF_EGU0_BASE                   0x40014000UL
-#define	NRF_SWI1_BASE                   0x40015000UL
-#define	NRF_EGU1_BASE                   0x40015000UL
-#define	NRF_SWI2_BASE                   0x40016000UL
-#define	NRF_EGU2_BASE                   0x40016000UL
-#define	NRF_SWI3_BASE                   0x40017000UL
-#define	NRF_EGU3_BASE                   0x40017000UL
-#define	NRF_SWI4_BASE                   0x40018000UL
-#define	NRF_EGU4_BASE                   0x40018000UL
-#define	NRF_SWI5_BASE                   0x40019000UL
-#define	NRF_EGU5_BASE                   0x40019000UL
-#define	NRF_TIMER3_BASE                 0x4001A000UL
-#define	NRF_TIMER4_BASE                 0x4001B000UL
-#define	NRF_PWM0_BASE                   0x4001C000UL
-#define	NRF_PDM_BASE                    0x4001D000UL
-#define	NRF_NVMC_BASE                   0x4001E000UL
-#define	NRF_PPI_BASE                    0x4001F000UL
-#define	NRF_MWU_BASE                    0x40020000UL
-#define	NRF_PWM1_BASE                   0x40021000UL
-#define	NRF_PWM2_BASE                   0x40022000UL
-#define	NRF_SPIM2_BASE                  0x40023000UL
-#define	NRF_SPIS2_BASE                  0x40023000UL
-#define	NRF_SPI2_BASE                   0x40023000UL
-#define	NRF_RTC2_BASE                   0x40024000UL
-#define	NRF_I2S_BASE                    0x40025000UL
-#define	NRF_FPU_BASE                    0x40026000UL
-#define	NRF_P0_BASE                     0x50000000UL
+#define NRF_FICR_BASE                   0x10000000UL
+#define NRF_UICR_BASE                   0x10001000UL
+#define NRF_BPROT_BASE                  0x40000000UL
+#define NRF_POWER_BASE                  0x40000000UL
+#define NRF_CLOCK_BASE                  0x40000000UL
+#define NRF_RADIO_BASE                  0x40001000UL
+#define NRF_UARTE0_BASE                 0x40002000UL
+#define NRF_UART0_BASE                  0x40002000UL
+#define NRF_SPIM0_BASE                  0x40003000UL
+#define NRF_SPIS0_BASE                  0x40003000UL
+#define NRF_TWIM0_BASE                  0x40003000UL
+#define NRF_TWIS0_BASE                  0x40003000UL
+#define NRF_SPI0_BASE                   0x40003000UL
+#define NRF_TWI0_BASE                   0x40003000UL
+#define NRF_SPIM1_BASE                  0x40004000UL
+#define NRF_SPIS1_BASE                  0x40004000UL
+#define NRF_TWIM1_BASE                  0x40004000UL
+#define NRF_TWIS1_BASE                  0x40004000UL
+#define NRF_SPI1_BASE                   0x40004000UL
+#define NRF_TWI1_BASE                   0x40004000UL
+#define NRF_NFCT_BASE                   0x40005000UL
+#define NRF_GPIOTE_BASE                 0x40006000UL
+#define NRF_SAADC_BASE                  0x40007000UL
+#define NRF_TIMER0_BASE                 0x40008000UL
+#define NRF_TIMER1_BASE                 0x40009000UL
+#define NRF_TIMER2_BASE                 0x4000A000UL
+#define NRF_RTC0_BASE                   0x4000B000UL
+#define NRF_TEMP_BASE                   0x4000C000UL
+#define NRF_RNG_BASE                    0x4000D000UL
+#define NRF_ECB_BASE                    0x4000E000UL
+#define NRF_CCM_BASE                    0x4000F000UL
+#define NRF_AAR_BASE                    0x4000F000UL
+#define NRF_WDT_BASE                    0x40010000UL
+#define NRF_RTC1_BASE                   0x40011000UL
+#define NRF_QDEC_BASE                   0x40012000UL
+#define NRF_COMP_BASE                   0x40013000UL
+#define NRF_LPCOMP_BASE                 0x40013000UL
+#define NRF_SWI0_BASE                   0x40014000UL
+#define NRF_EGU0_BASE                   0x40014000UL
+#define NRF_SWI1_BASE                   0x40015000UL
+#define NRF_EGU1_BASE                   0x40015000UL
+#define NRF_SWI2_BASE                   0x40016000UL
+#define NRF_EGU2_BASE                   0x40016000UL
+#define NRF_SWI3_BASE                   0x40017000UL
+#define NRF_EGU3_BASE                   0x40017000UL
+#define NRF_SWI4_BASE                   0x40018000UL
+#define NRF_EGU4_BASE                   0x40018000UL
+#define NRF_SWI5_BASE                   0x40019000UL
+#define NRF_EGU5_BASE                   0x40019000UL
+#define NRF_TIMER3_BASE                 0x4001A000UL
+#define NRF_TIMER4_BASE                 0x4001B000UL
+#define NRF_PWM0_BASE                   0x4001C000UL
+#define NRF_PDM_BASE                    0x4001D000UL
+#define NRF_NVMC_BASE                   0x4001E000UL
+#define NRF_PPI_BASE                    0x4001F000UL
+#define NRF_MWU_BASE                    0x40020000UL
+#define NRF_PWM1_BASE                   0x40021000UL
+#define NRF_PWM2_BASE                   0x40022000UL
+#define NRF_SPIM2_BASE                  0x40023000UL
+#define NRF_SPIS2_BASE                  0x40023000UL
+#define NRF_SPI2_BASE                   0x40023000UL
+#define NRF_RTC2_BASE                   0x40024000UL
+#define NRF_I2S_BASE                    0x40025000UL
+#define NRF_FPU_BASE                    0x40026000UL
+#define NRF_P0_BASE                     0x50000000UL
 
 
 /* ========================================================================= */
 /* =========             Peripheral declaration             ================ */
 /* ========================================================================= */
 
-#define	NRF_FICR                 ((NRF_FICR_Type    *) NRF_FICR_BASE)
-#define	NRF_UICR                 ((NRF_UICR_Type    *) NRF_UICR_BASE)
-#define	NRF_BPROT                ((NRF_BPROT_Type   *) NRF_BPROT_BASE)
-#define	NRF_POWER                ((NRF_POWER_Type   *) NRF_POWER_BASE)
-#define	NRF_CLOCK                ((NRF_CLOCK_Type   *) NRF_CLOCK_BASE)
-#define	NRF_RADIO                ((NRF_RADIO_Type   *) NRF_RADIO_BASE)
-#define	NRF_UARTE0               ((NRF_UARTE_Type   *) NRF_UARTE0_BASE)
-#define	NRF_UART0                ((nrf_uartx_t      *) NRF_UART0_BASE)
-#define	NRF_SPIM0                ((NRF_SPIM_Type    *) NRF_SPIM0_BASE)
-#define	NRF_SPIS0                ((NRF_SPIS_Type    *) NRF_SPIS0_BASE)
-#define	NRF_TWIM0                ((NRF_TWIM_Type    *) NRF_TWIM0_BASE)
-#define	NRF_TWIS0                ((NRF_TWIS_Type    *) NRF_TWIS0_BASE)
-#define	NRF_SPI0                 ((NRF_SPI_Type     *) NRF_SPI0_BASE)
-#define	NRF_TWI0                 ((NRF_TWI_Type     *) NRF_TWI0_BASE)
-#define	NRF_SPIM1                ((NRF_SPIM_Type    *) NRF_SPIM1_BASE)
-#define	NRF_SPIS1                ((NRF_SPIS_Type    *) NRF_SPIS1_BASE)
-#define	NRF_TWIM1                ((NRF_TWIM_Type    *) NRF_TWIM1_BASE)
-#define	NRF_TWIS1                ((NRF_TWIS_Type    *) NRF_TWIS1_BASE)
-#define	NRF_SPI1                 ((NRF_SPI_Type     *) NRF_SPI1_BASE)
-#define	NRF_TWI1                 ((NRF_TWI_Type     *) NRF_TWI1_BASE)
-#define	NRF_NFCT                 ((NRF_NFCT_Type    *) NRF_NFCT_BASE)
-#define	NRF_GPIOTE               ((NRF_GPIOTE_Type  *) NRF_GPIOTE_BASE)
-#define	NRF_SAADC                ((NRF_SAADC_Type   *) NRF_SAADC_BASE)
-#define	NRF_TIMER0               ((NRF_TIMER_Type   *) NRF_TIMER0_BASE)
-#define	NRF_TIMER1               ((NRF_TIMER_Type   *) NRF_TIMER1_BASE)
-#define	NRF_TIMER2               ((NRF_TIMER_Type   *) NRF_TIMER2_BASE)
-#define	NRF_RTC0                 ((NRF_RTC_Type     *) NRF_RTC0_BASE)
-#define	NRF_TEMP                 ((NRF_TEMP_Type    *) NRF_TEMP_BASE)
-#define	NRF_RNG                  ((NRF_RNG_Type     *) NRF_RNG_BASE)
-#define	NRF_ECB                  ((NRF_ECB_Type     *) NRF_ECB_BASE)
-#define	NRF_CCM                  ((NRF_CCM_Type     *) NRF_CCM_BASE)
-#define	NRF_AAR                  ((NRF_AAR_Type     *) NRF_AAR_BASE)
-#define	NRF_WDT                  ((NRF_WDT_Type     *) NRF_WDT_BASE)
-#define	NRF_RTC1                 ((NRF_RTC_Type     *) NRF_RTC1_BASE)
-#define	NRF_QDEC                 ((NRF_QDEC_Type    *) NRF_QDEC_BASE)
-#define	NRF_COMP                 ((NRF_COMP_Type    *) NRF_COMP_BASE)
-#define	NRF_LPCOMP               ((NRF_LPCOMP_Type  *) NRF_LPCOMP_BASE)
-#define	NRF_SWI0                 ((NRF_SWI_Type     *) NRF_SWI0_BASE)
-#define	NRF_EGU0                 ((NRF_EGU_Type     *) NRF_EGU0_BASE)
-#define	NRF_SWI1                 ((NRF_SWI_Type     *) NRF_SWI1_BASE)
-#define	NRF_EGU1                 ((NRF_EGU_Type     *) NRF_EGU1_BASE)
-#define	NRF_SWI2                 ((NRF_SWI_Type     *) NRF_SWI2_BASE)
-#define	NRF_EGU2                 ((NRF_EGU_Type     *) NRF_EGU2_BASE)
-#define	NRF_SWI3                 ((NRF_SWI_Type     *) NRF_SWI3_BASE)
-#define	NRF_EGU3                 ((NRF_EGU_Type     *) NRF_EGU3_BASE)
-#define	NRF_SWI4                 ((NRF_SWI_Type     *) NRF_SWI4_BASE)
-#define	NRF_EGU4                 ((NRF_EGU_Type     *) NRF_EGU4_BASE)
-#define	NRF_SWI5                 ((NRF_SWI_Type     *) NRF_SWI5_BASE)
-#define	NRF_EGU5                 ((NRF_EGU_Type     *) NRF_EGU5_BASE)
-#define	NRF_TIMER3               ((NRF_TIMER_Type   *) NRF_TIMER3_BASE)
-#define	NRF_TIMER4               ((NRF_TIMER_Type   *) NRF_TIMER4_BASE)
-#define	NRF_PWM0                 ((NRF_PWM_Type     *) NRF_PWM0_BASE)
-#define	NRF_PDM                  ((NRF_PDM_Type     *) NRF_PDM_BASE)
-#define	NRF_NVMC                 ((NRF_NVMC_Type    *) NRF_NVMC_BASE)
-#define	NRF_PPI                  ((NRF_PPI_Type     *) NRF_PPI_BASE)
-#define	NRF_MWU                  ((NRF_MWU_Type     *) NRF_MWU_BASE)
-#define	NRF_PWM1                 ((NRF_PWM_Type     *) NRF_PWM1_BASE)
-#define	NRF_PWM2                 ((NRF_PWM_Type     *) NRF_PWM2_BASE)
-#define	NRF_SPIM2                ((NRF_SPIM_Type    *) NRF_SPIM2_BASE)
-#define	NRF_SPIS2                ((NRF_SPIS_Type    *) NRF_SPIS2_BASE)
-#define	NRF_SPI2                 ((NRF_SPI_Type     *) NRF_SPI2_BASE)
-#define	NRF_RTC2                 ((NRF_RTC_Type     *) NRF_RTC2_BASE)
-#define	NRF_I2S                  ((NRF_I2S_Type     *) NRF_I2S_BASE)
-#define	NRF_FPU                  ((NRF_FPU_Type     *) NRF_FPU_BASE)
-#define	NRF_P0                   ((NRF_GPIO_Type    *) NRF_P0_BASE)
-
-#if 0 //MY comment
-#if defined(CONFIG_ARCH_CORTEXM4)
-#define	__CORTEX_M 0x04
-#elif defined(CONFIG_ARCH_CORTEXM0)
-#define	__CORTEX_M 0x00
-#else
-#error "No CORTEX Configured."
-#endif
-#endif
+#define NRF_FICR                 ((NRF_FICR_Type    *) NRF_FICR_BASE)
+#define NRF_UICR                 ((NRF_UICR_Type    *) NRF_UICR_BASE)
+#define NRF_BPROT                ((NRF_BPROT_Type   *) NRF_BPROT_BASE)
+#define NRF_POWER                ((NRF_POWER_Type   *) NRF_POWER_BASE)
+#define NRF_CLOCK                ((NRF_CLOCK_Type   *) NRF_CLOCK_BASE)
+#define NRF_RADIO                ((NRF_RADIO_Type   *) NRF_RADIO_BASE)
+#define NRF_UARTE0               ((NRF_UARTE_Type   *) NRF_UARTE0_BASE)
+#define NRF_UART0                ((nrf_uartx_t      *) NRF_UART0_BASE)
+#define NRF_SPIM0                ((NRF_SPIM_Type    *) NRF_SPIM0_BASE)
+#define NRF_SPIS0                ((NRF_SPIS_Type    *) NRF_SPIS0_BASE)
+#define NRF_TWIM0                ((NRF_TWIM_Type    *) NRF_TWIM0_BASE)
+#define NRF_TWIS0                ((NRF_TWIS_Type    *) NRF_TWIS0_BASE)
+#define NRF_SPI0                 ((NRF_SPI_Type     *) NRF_SPI0_BASE)
+#define NRF_TWI0                 ((NRF_TWI_Type     *) NRF_TWI0_BASE)
+#define NRF_SPIM1                ((NRF_SPIM_Type    *) NRF_SPIM1_BASE)
+#define NRF_SPIS1                ((NRF_SPIS_Type    *) NRF_SPIS1_BASE)
+#define NRF_TWIM1                ((NRF_TWIM_Type    *) NRF_TWIM1_BASE)
+#define NRF_TWIS1                ((NRF_TWIS_Type    *) NRF_TWIS1_BASE)
+#define NRF_SPI1                 ((NRF_SPI_Type     *) NRF_SPI1_BASE)
+#define NRF_TWI1                 ((NRF_TWI_Type     *) NRF_TWI1_BASE)
+#define NRF_NFCT                 ((NRF_NFCT_Type    *) NRF_NFCT_BASE)
+#define NRF_GPIOTE               ((NRF_GPIOTE_Type  *) NRF_GPIOTE_BASE)
+#define NRF_SAADC                ((NRF_SAADC_Type   *) NRF_SAADC_BASE)
+#define NRF_TIMER0               ((NRF_TIMER_Type   *) NRF_TIMER0_BASE)
+#define NRF_TIMER1               ((NRF_TIMER_Type   *) NRF_TIMER1_BASE)
+#define NRF_TIMER2               ((NRF_TIMER_Type   *) NRF_TIMER2_BASE)
+#define NRF_RTC0                 ((NRF_RTC_Type     *) NRF_RTC0_BASE)
+#define NRF_TEMP                 ((NRF_TEMP_Type    *) NRF_TEMP_BASE)
+#define NRF_RNG                  ((NRF_RNG_Type     *) NRF_RNG_BASE)
+#define NRF_ECB                  ((NRF_ECB_Type     *) NRF_ECB_BASE)
+#define NRF_CCM                  ((NRF_CCM_Type     *) NRF_CCM_BASE)
+#define NRF_AAR                  ((NRF_AAR_Type     *) NRF_AAR_BASE)
+#define NRF_WDT                  ((NRF_WDT_Type     *) NRF_WDT_BASE)
+#define NRF_RTC1                 ((NRF_RTC_Type     *) NRF_RTC1_BASE)
+#define NRF_QDEC                 ((NRF_QDEC_Type    *) NRF_QDEC_BASE)
+#define NRF_COMP                 ((NRF_COMP_Type    *) NRF_COMP_BASE)
+#define NRF_LPCOMP               ((NRF_LPCOMP_Type  *) NRF_LPCOMP_BASE)
+#define NRF_SWI0                 ((NRF_SWI_Type     *) NRF_SWI0_BASE)
+#define NRF_EGU0                 ((NRF_EGU_Type     *) NRF_EGU0_BASE)
+#define NRF_SWI1                 ((NRF_SWI_Type     *) NRF_SWI1_BASE)
+#define NRF_EGU1                 ((NRF_EGU_Type     *) NRF_EGU1_BASE)
+#define NRF_SWI2                 ((NRF_SWI_Type     *) NRF_SWI2_BASE)
+#define NRF_EGU2                 ((NRF_EGU_Type     *) NRF_EGU2_BASE)
+#define NRF_SWI3                 ((NRF_SWI_Type     *) NRF_SWI3_BASE)
+#define NRF_EGU3                 ((NRF_EGU_Type     *) NRF_EGU3_BASE)
+#define NRF_SWI4                 ((NRF_SWI_Type     *) NRF_SWI4_BASE)
+#define NRF_EGU4                 ((NRF_EGU_Type     *) NRF_EGU4_BASE)
+#define NRF_SWI5                 ((NRF_SWI_Type     *) NRF_SWI5_BASE)
+#define NRF_EGU5                 ((NRF_EGU_Type     *) NRF_EGU5_BASE)
+#define NRF_TIMER3               ((NRF_TIMER_Type   *) NRF_TIMER3_BASE)
+#define NRF_TIMER4               ((NRF_TIMER_Type   *) NRF_TIMER4_BASE)
+#define NRF_PWM0                 ((NRF_PWM_Type     *) NRF_PWM0_BASE)
+#define NRF_PDM                  ((NRF_PDM_Type     *) NRF_PDM_BASE)
+#define NRF_NVMC                 ((NRF_NVMC_Type    *) NRF_NVMC_BASE)
+#define NRF_PPI                  ((NRF_PPI_Type     *) NRF_PPI_BASE)
+#define NRF_MWU                  ((NRF_MWU_Type     *) NRF_MWU_BASE)
+#define NRF_PWM1                 ((NRF_PWM_Type     *) NRF_PWM1_BASE)
+#define NRF_PWM2                 ((NRF_PWM_Type     *) NRF_PWM2_BASE)
+#define NRF_SPIM2                ((NRF_SPIM_Type    *) NRF_SPIM2_BASE)
+#define NRF_SPIS2                ((NRF_SPIS_Type    *) NRF_SPIS2_BASE)
+#define NRF_SPI2                 ((NRF_SPI_Type     *) NRF_SPI2_BASE)
+#define NRF_RTC2                 ((NRF_RTC_Type     *) NRF_RTC2_BASE)
+#define NRF_I2S                  ((NRF_I2S_Type     *) NRF_I2S_BASE)
+#define NRF_FPU                  ((NRF_FPU_Type     *) NRF_FPU_BASE)
+#define NRF_P0                   ((NRF_GPIO_Type    *) NRF_P0_BASE)
+
 /**
  * @brief API Result.
  *
diff --git a/arch/arm/src/nrf52/nrf52_exti_comp.c b/arch/arm/src/nrf52/nrf52_exti_comp.c
index b3e9c40490..642c0447e1 100644
--- a/arch/arm/src/nrf52/nrf52_exti_comp.c
+++ b/arch/arm/src/nrf52/nrf52_exti_comp.c
@@ -78,8 +78,8 @@ static const uint32_t g_comp_lines[STM32L4_COMP_NUM] =
 };
 
 /****************************************************************************
-* Private Functions
-****************************************************************************/
+ * Private Functions
+ ****************************************************************************/
 
 static int stm32l4_exti_comp_isr(int irq, void *context)
 {
diff --git a/arch/arm/src/nrf52/nrf52_gpiote.c b/arch/arm/src/nrf52/nrf52_gpiote.c
index 83ac893649..d28b5961f4 100644
--- a/arch/arm/src/nrf52/nrf52_gpiote.c
+++ b/arch/arm/src/nrf52/nrf52_gpiote.c
@@ -219,7 +219,7 @@ static void channel_free(uint8_t channel_id)
  * Description:
  *
  ****************************************************************************/
-void GPIOTE_IRQHandler(int irq, void *context, FAR void *arg)
+void GPIOTE_IRQHandler(void)
 {
   uint32_t status            = 0;
   uint32_t input[GPIO_COUNT] = {0};
@@ -405,9 +405,7 @@ ret_code_t nrf_drv_gpiote_init(void)
       channel_free(i);
     }
 
-  irq_attach(GPIOTE_IRQn, (xcpt_t)GPIOTE_IRQHandler, NULL);
-  up_enable_irq(GPIOTE_IRQn); //MinYang add
-  //nrf_drv_common_irq_enable(GPIOTE_IRQn, GPIOTE_CONFIG_IRQ_PRIORITY);
+  nrf_drv_common_irq_enable(GPIOTE_IRQn, GPIOTE_CONFIG_IRQ_PRIORITY);
   nrf_gpiote_event_clear(NRF_GPIOTE_EVENTS_PORT);
   nrf_gpiote_int_enable(GPIOTE_INTENSET_PORT_Msk);
   g_gpiotedev.state = NRF_DRV_STATE_INITIALIZED;
diff --git a/arch/arm/src/nrf52/nrf52_gpiote.h b/arch/arm/src/nrf52/nrf52_gpiote.h
index 5b8167acf6..b27e807ff5 100644
--- a/arch/arm/src/nrf52/nrf52_gpiote.h
+++ b/arch/arm/src/nrf52/nrf52_gpiote.h
@@ -30,9 +30,6 @@
 #include <stdbool.h>
 #include "sdk_config.h"
 
-#ifdef __cplusplus
-extern "C" {
-#endif
 
 /**@brief Input pin configuration. */
 typedef struct
@@ -347,9 +344,7 @@ void nrf_drv_gpiote_clr_task_trigger(nrf_drv_gpiote_pin_t pin);
 #endif
 
 
-#ifdef __cplusplus
-}
-#endif
+
 
 /**
  *@}
diff --git a/arch/arm/src/nrf52/nrf52_i2c.c b/arch/arm/src/nrf52/nrf52_i2c.c
index 2c652db1ce..1cc28d7ef4 100644
--- a/arch/arm/src/nrf52/nrf52_i2c.c
+++ b/arch/arm/src/nrf52/nrf52_i2c.c
@@ -73,9 +73,9 @@
 #include "chip.h"
 #include "nrf52.h"
 #include "nrf_drv_common.h"
-#include "nrf52_gpio.h"
+#include <nrf52_gpio.h>
 #include "nrf52_i2c.h"
-#include "chip/nrf52_i2c.h"
+#include <chip/nrf52_i2c.h>
 
 #if defined(CONFIG_NRF52_I2C0) || defined(CONFIG_NRF52_I2C1)
 
@@ -120,13 +120,13 @@ struct nrf52_i2cdev_s
   struct i2c_master_s dev;     /* Generic I2C device */
   unsigned int     base;       /* Base address of registers */
   uint16_t         irqid;      /* IRQ for this device */
-  uint32_t         sda;		   /* SDA GPIO pin number */
-  uint32_t         scl;		   /* SCL GPIO pin number */
+  uint32_t         sda;      /* SDA GPIO pin number */
+  uint32_t         scl;      /* SCL GPIO pin number */
 
   sem_t            mutex;      /* Only one thread can access at a time */
 #ifndef CONFIG_I2C_POLLED
   int (*isr)(int, void *, void *);    /* Interrupt handler */
-  sem_t 		   wait;     /* Interrupt wait semaphore */
+  sem_t        wait;     /* Interrupt wait semaphore */
 #endif
   WDOG_ID          timeout;    /* Watchdog to timeout when bus hung */
   uint32_t         frequency;  /* Current I2C frequency */
@@ -148,7 +148,7 @@ struct nrf52_i2cdev_s
   bool                      repeated;
   uint8_t                   bytes_transferred;
   bool                      hold_bus_uninit;
-  bool 						clear_bus_init;
+  bool            clear_bus_init;
 };
 
 
@@ -310,7 +310,7 @@ static ret_code_t nrf_twi_process_error(uint32_t errorsrc)
  *   Set the frequency for the next transfer
  *
  ****************************************************************************/
-static inline ret_code_t nrf_twim_xfer(struct nrf52_i2cdev_s		    *dev,
+static inline ret_code_t nrf_twim_xfer(struct nrf52_i2cdev_s        *dev,
                                        NRF_TWIM_Type                  *p_twim,
                                        nrf_drv_twi_xfer_desc_t const *p_xfer_desc,
                                        uint32_t                        flags)
diff --git a/arch/arm/src/nrf52/nrf52_idle.c b/arch/arm/src/nrf52/nrf52_idle.c
index 65f4918f6f..1120f2c07f 100644
--- a/arch/arm/src/nrf52/nrf52_idle.c
+++ b/arch/arm/src/nrf52/nrf52_idle.c
@@ -182,7 +182,7 @@ void up_idle(void)
 
 #if !(defined(CONFIG_DEBUG_SYMBOLS) && defined(CONFIG_STM32L4_DISABLE_IDLE_SLEEP_DURING_DEBUG))
   //BEGIN_IDLE();
-  //asm("WFI"); //MinYang comment out
+  //__asm("WFI"); //XXX
   //END_IDLE();
 #endif
 
diff --git a/arch/arm/src/nrf52/nrf52_irq.c b/arch/arm/src/nrf52/nrf52_irq.c
index b8b0063685..e3ac8dcf48 100644
--- a/arch/arm/src/nrf52/nrf52_irq.c
+++ b/arch/arm/src/nrf52/nrf52_irq.c
@@ -318,7 +318,7 @@ void up_irqinitialize(void)
    * the address of the nuttx _vectors table.
    */
   putreg32((uint32_t)_vectors, NVIC_VECTAB);
-  putreg32((uint32_t)0, NVIC_VECTAB); //MinYang add
+  putreg32((uint32_t)0, NVIC_VECTAB); //XXX Add this line to assign vector table from 0x00 for softdevice
 #else
   putreg32((uint32_t)_vectors, NVIC_VECTAB);
 #endif
diff --git a/arch/arm/src/nrf52/nrf52_pwm.h b/arch/arm/src/nrf52/nrf52_pwm.h
index 0d1db1aa7c..f3c067db3b 100644
--- a/arch/arm/src/nrf52/nrf52_pwm.h
+++ b/arch/arm/src/nrf52/nrf52_pwm.h
@@ -72,9 +72,9 @@
 #endif
 
 /* Check if PWM support for any channel is enabled.
-*  NRF52 PWM module can support up to 4 channels for different
-*  duty cycle base on same period
-*/
+ *  NRF52 PWM module can support up to 4 channels for different
+ *  duty cycle base on same period
+ */
 
 #if defined(CONFIG_NRF52_PWM_M0)  || defined(CONFIG_NRF52_PWM_M1)  || \
     defined(CONFIG_NRF52_PWM_M2)
@@ -86,32 +86,32 @@
 #ifndef CONFIG_NRF52_PWM_M0_CHANNEL1_GPIO_PIN
 #    error "CONFIG_NRF52_PWM_M0_CHANNEL1_GPIO_PIN must be provided for NRF52 PWM Module 0"
 #else
-#	define PWM0_CHANNEL1 1
+# define PWM0_CHANNEL1 1
 #endif
 
 #ifndef CONFIG_NRF52_PWM_M0_CHANNEL2_GPIO_PIN
 #    define CONFIG_NRF52_PWM_M0_CHANNEL2_GPIO_PIN 0xFF
-#	define PWM0_CHANNEL2 0
+# define PWM0_CHANNEL2 0
 #else
-#	define PWM0_CHANNEL2 1
+# define PWM0_CHANNEL2 1
 #endif
 
 #ifndef CONFIG_NRF52_PWM_M0_CHANNEL3_GPIO_PIN
 #    define CONFIG_NRF52_PWM_M0_CHANNEL3_GPIO_PIN 0xFF
-#	define PWM0_CHANNEL3 0
+# define PWM0_CHANNEL3 0
 #else
-#	define PWM0_CHANNEL3 1
+# define PWM0_CHANNEL3 1
 #endif
 
 #ifndef CONFIG_NRF52_PWM_M0_CHANNEL4_GPIO_PIN
 #    define CONFIG_NRF52_PWM_M0_CHANNEL4_GPIO_PIN 0xFF
-#	define PWM0_CHANNEL4 0
+# define PWM0_CHANNEL4 0
 #else
-#	define PWM0_CHANNEL4 1
+# define PWM0_CHANNEL4 1
 #endif
 
 #define PWM0_NCHANNELS (PWM0_CHANNEL1 + PWM0_CHANNEL2 + \
-					  	PWM0_CHANNEL3 + PWM0_CHANNEL4)
+              PWM0_CHANNEL3 + PWM0_CHANNEL4)
 #else
 #define PWM0_NCHANNELS 0
 #endif
@@ -121,32 +121,32 @@
 #ifndef CONFIG_NRF52_PWM_M1_CHANNEL1_GPIO_PIN
 #    error "CONFIG_NRF52_PWM_M1_CHANNEL1_GPIO_PIN must be provided for NRF52 PWM Module 1"
 #else
-#	define PWM1_CHANNEL1 1
+# define PWM1_CHANNEL1 1
 #endif
 
 #ifndef CONFIG_NRF52_PWM_M1_CHANNEL2_GPIO_PIN
 #    define CONFIG_NRF52_PWM_M1_CHANNEL2_GPIO_PIN 0xFF
-#	define PWM1_CHANNEL2 0
+# define PWM1_CHANNEL2 0
 #else
-#	define PWM1_CHANNEL2 1
+# define PWM1_CHANNEL2 1
 #endif
 
 #ifndef CONFIG_NRF52_PWM_M1_CHANNEL3_GPIO_PIN
 #    define CONFIG_NRF52_PWM_M1_CHANNEL3_GPIO_PIN 0xFF
-#	define PWM1_CHANNEL3 0
+# define PWM1_CHANNEL3 0
 #else
-#	define PWM1_CHANNEL3 1
+# define PWM1_CHANNEL3 1
 #endif
 
 #ifndef CONFIG_NRF52_PWM_M1_CHANNEL4_GPIO_PIN
 #    define CONFIG_NRF52_PWM_M1_CHANNEL4_GPIO_PIN 0xFF
-#	define PWM1_CHANNEL4 0
+# define PWM1_CHANNEL4 0
 #else
-#	define PWM1_CHANNEL4 1
+# define PWM1_CHANNEL4 1
 #endif
 
 #define PWM1_NCHANNELS (PWM1_CHANNEL1 + PWM1_CHANNEL2 + \
-						PWM1_CHANNEL3 + PWM1_CHANNEL4)
+            PWM1_CHANNEL3 + PWM1_CHANNEL4)
 #else
 #define PWM1_NCHANNELS 0
 #endif
@@ -156,32 +156,32 @@
 #ifndef CONFIG_NRF52_PWM_M2_CHANNEL1_GPIO_PIN
 #    error "CONFIG_NRF52_PWM_M2_CHANNEL1_GPIO_PIN must be provided for NRF52 PWM Module 2"
 #else
-#	define PWM2_CHANNEL1 1
+# define PWM2_CHANNEL1 1
 #endif
 
 #ifndef CONFIG_NRF52_PWM_M2_CHANNEL2_GPIO_PIN
 #    define CONFIG_NRF52_PWM_M2_CHANNEL2_GPIO_PIN 0xFF
-#	define PWM2_CHANNEL2 0
+# define PWM2_CHANNEL2 0
 #else
-#	define PWM2_CHANNEL2 1
+# define PWM2_CHANNEL2 1
 #endif
 
 #ifndef CONFIG_NRF52_PWM_M2_CHANNEL3_GPIO_PIN
 #    define CONFIG_NRF52_PWM_M2_CHANNEL3_GPIO_PIN 0xFF
-#	define PWM2_CHANNEL3 0
+# define PWM2_CHANNEL3 0
 #else
-#	define PWM2_CHANNEL3 1
+# define PWM2_CHANNEL3 1
 #endif
 
 #ifndef CONFIG_NRF52_PWM_M2_CHANNEL4_GPIO_PIN
 #    define CONFIG_NRF52_PWM_M2_CHANNEL4_GPIO_PIN 0xFF
-#	define PWM2_CHANNEL4 0
+# define PWM2_CHANNEL4 0
 #else
-#	define PWM2_CHANNEL4 1
+# define PWM2_CHANNEL4 1
 #endif
 
 #define PWM2_NCHANNELS (PWM2_CHANNEL1 + PWM2_CHANNEL2 + \
-						PWM2_CHANNEL3 + PWM2_CHANNEL4)
+            PWM2_CHANNEL3 + PWM2_CHANNEL4)
 #else
 #define PWM2_NCHANNELS 0
 #endif
diff --git a/arch/arm/src/nrf52/nrf52_rtc.c b/arch/arm/src/nrf52/nrf52_rtc.c
index 35db1b94d9..5c0b5e4b84 100644
--- a/arch/arm/src/nrf52/nrf52_rtc.c
+++ b/arch/arm/src/nrf52/nrf52_rtc.c
@@ -85,11 +85,11 @@ static const struct nrf52_rtc_ops_s nrf52_rtc_ops =
 struct nrf52_rtc_priv_s
 {
   const struct nrf52_rtc_ops_s *ops;
-  uint32_t 						base;        	/* RTCn base address */
-  nrf_drv_state_t           	state;			/* Current rtc state */
-  nrf_rtc_cc_channel_t    	channel_number; /* Current channel number */
-  uint32_t                  	timeout;		/* Current timeout in uS  */
-  uint8_t 						channel_count;
+  uint32_t            base;         /* RTCn base address */
+  nrf_drv_state_t             state;      /* Current rtc state */
+  nrf_rtc_cc_channel_t      channel_number; /* Current channel number */
+  uint32_t                    timeout;    /* Current timeout in uS  */
+  uint8_t             channel_count;
   bool            reliable;     /**< Reliable mode flag. */
   uint8_t         tick_latency; /**< Maximum length of interrupt handler in ticks (max 7.7 ms). */
 
@@ -98,32 +98,32 @@ struct nrf52_rtc_priv_s
 #ifdef CONFIG_NRF52_RTC0
 struct nrf52_rtc_priv_s nrf52_rtc0_priv =
 {
-  .ops        		= &nrf52_rtc_ops,
-  .base       		= NRF_RTC0_BASE,
-  .state      		= NRF_DRV_STATE_UNINITIALIZED,
-  .channel_count 	= RTC0_CC_NUM,
-  .channel_number 	= NRF_RTC_CC_CHANNEL0,
+  .ops            = &nrf52_rtc_ops,
+  .base           = NRF_RTC0_BASE,
+  .state          = NRF_DRV_STATE_UNINITIALIZED,
+  .channel_count  = RTC0_CC_NUM,
+  .channel_number   = NRF_RTC_CC_CHANNEL0,
 };
 #endif
 #ifdef CONFIG_NRF52_RTC1
 struct nrf52_rtc_priv_s nrf52_rtc1_priv =
 {
-  .ops        		= &nrf52_rtc_ops,
-  .base       		= NRF_RTC1_BASE,
-  .state      		= NRF_DRV_STATE_UNINITIALIZED,
-  .channel_count 	= RTC1_CC_NUM,
-  .channel_number 	= NRF_RTC_CC_CHANNEL0,
+  .ops            = &nrf52_rtc_ops,
+  .base           = NRF_RTC1_BASE,
+  .state          = NRF_DRV_STATE_UNINITIALIZED,
+  .channel_count  = RTC1_CC_NUM,
+  .channel_number   = NRF_RTC_CC_CHANNEL0,
 };
 #endif
 
 #ifdef CONFIG_NRF52_RTC2
 struct nrf52_rtc_priv_s nrf52_rtc2_priv =
 {
-  .ops        		= &nrf52_rtc_ops,
-  .base       		= NRF_RTC2_BASE,
-  .state      		= NRF_DRV_STATE_UNINITIALIZED,
-  .channel_count 	= RTC2_CC_NUM,
-  .channel_number 	= NRF_RTC_CC_CHANNEL0,
+  .ops            = &nrf52_rtc_ops,
+  .base           = NRF_RTC2_BASE,
+  .state          = NRF_DRV_STATE_UNINITIALIZED,
+  .channel_count  = RTC2_CC_NUM,
+  .channel_number   = NRF_RTC_CC_CHANNEL0,
 };
 #endif
 
@@ -349,7 +349,6 @@ bool nrf52_rtc_irq_handleint(FAR struct nrf52_rtc_dev_s *dev)
       int_mask <<= 1;
       event    = (nrf_rtc_event_t)((uint32_t)event + sizeof(uint32_t));
     }
-
   event = NRF_RTC_EVENT_TICK;
   if (nrf_rtc_int_is_enabled((NRF_RTC_Type *)((struct nrf52_rtc_priv_s *)dev)->base, NRF_RTC_INT_TICK_MASK) &&
       nrf_rtc_event_pending((NRF_RTC_Type *)((struct nrf52_rtc_priv_s *)dev)->base, event))
diff --git a/arch/arm/src/nrf52/nrf52_rtc.h b/arch/arm/src/nrf52/nrf52_rtc.h
old mode 100644
new mode 100755
index 8d74f1a238..7634ed6b0b
--- a/arch/arm/src/nrf52/nrf52_rtc.h
+++ b/arch/arm/src/nrf52/nrf52_rtc.h
@@ -47,8 +47,8 @@
  ************************************************************************************/
 
 /************************************************************************************
-* Pre-processor Definitions
-************************************************************************************/
+ * Pre-processor Definitions
+ ************************************************************************************/
 
 /************************************************************************************
  * Public Types
diff --git a/arch/arm/src/nrf52/nrf52_rtc_lowerhalf.c b/arch/arm/src/nrf52/nrf52_rtc_lowerhalf.c
index d82bf9753e..8e5fe4700f 100644
--- a/arch/arm/src/nrf52/nrf52_rtc_lowerhalf.c
+++ b/arch/arm/src/nrf52/nrf52_rtc_lowerhalf.c
@@ -66,6 +66,7 @@
     (defined(CONFIG_NRF52_RTC0)  || defined(CONFIG_NRF52_RTC1)  || \
      defined(CONFIG_NRF52_RTC2))
 
+
 /****************************************************************************
  * Pre-processor Definitions
  ****************************************************************************/
@@ -126,7 +127,7 @@ static struct nrf52_lowerhalf_s g_rtc0_lowerhalf =
 {
   .ops         = &g_rtc_ops,
   .started     = false,
-  .callback	   = NULL,
+  .callback    = NULL,
   .channel_count = RTC0_CC_NUM,
 };
 #endif
@@ -135,7 +136,7 @@ static struct nrf52_lowerhalf_s g_rtc1_lowerhalf =
 {
   .ops         = &g_rtc_ops,
   .started     = false,
-  .callback	   = NULL,
+  .callback    = NULL,
   .channel_count = RTC1_CC_NUM,
 };
 #endif
@@ -145,7 +146,7 @@ static struct nrf52_lowerhalf_s g_rtc2_lowerhalf =
 {
   .ops         = &g_rtc_ops,
   .started     = false,
-  .callback	   = NULL,
+  .callback    = NULL,
   .channel_count = RTC2_CC_NUM,
 };
 #endif
@@ -339,14 +340,7 @@ static int nrf52_settimeout(FAR struct rtc_lowerhalf_s *lower,
 
   if (!priv->started)
     {
-#ifdef CONFIG_EXAMPLES_COUNTER_TICK
-      //Enable tick event & interrupt
-      nrf52_drv_rtc_tick_enable(priv->rtc, true); //MinYang test tick
-#endif
-
-#ifdef CONFIG_EXAMPLES_COUNTER_COMPARE
       nrf52_drv_rtc_cc_set(priv->rtc, 0, timeout * RTC_DEFAULT_CONFIG_FREQUENCY / (RTC_PRESCALER + 1), true);
-#endif
       return OK;
     }
 
diff --git a/arch/arm/src/nrf52/nrf52_rtcounter.c b/arch/arm/src/nrf52/nrf52_rtcounter.c
new file mode 100644
index 0000000000..e00779a629
--- /dev/null
+++ b/arch/arm/src/nrf52/nrf52_rtcounter.c
@@ -0,0 +1,243 @@
+/************************************************************************************
+ * arch/arm/src/nrf52/nrf52_rtcounter.c
+ *
+ *   Copyright (C) 2011 Uros Platise. All rights reserved.
+ *   Author: Uros Platise <uros.platise@isotel.eu>
+ *
+ * With extensions, modifications by:
+ *
+ *   Copyright (C) 2011-2013, 2015 Gregory Nutt. All rights reserved.
+ *   Author: Gregroy Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ************************************************************************************/
+
+/************************************************************************************
+ * Included Files
+ ************************************************************************************/
+
+#include <nuttx/config.h>
+#include <nuttx/arch.h>
+#include <nuttx/irq.h>
+#include <nuttx/timers/rtc.h>
+#include <arch/board/board.h>
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <errno.h>
+
+#include "up_arch.h"
+#include "nrf_drv_clock.h"
+#include "chip/nrf52_rtc.h"
+/************************************************************************************
+ * Pre-processor Definitions
+ ************************************************************************************/
+#if defined(CONFIG_RTC)
+#define RTC_BASE NRF_RTC1_BASE
+#define RTC_IRQ RTC1_IRQn
+#endif
+/************************************************************************************
+ * Private Types
+ ************************************************************************************/
+
+
+
+/************************************************************************************
+ * Private Data
+ ************************************************************************************/
+
+
+/************************************************************************************
+ * Public Data
+ ************************************************************************************/
+/* Variable determines the state of the LSE oscillator.
+ * Possible errors:
+ *   - on start-up
+ *   - during operation, reported by LSE interrupt
+ */
+
+volatile bool g_rtc_enabled = false;
+
+/************************************************************************************
+ * Private Functions
+ ************************************************************************************/
+
+
+
+
+/************************************************************************************
+ * Name: nrf52_rtc_interrupt
+ *
+ * Description:
+ *    RTC interrupt service routine
+ *
+ * Input Parameters:
+ *   irq - The IRQ number that generated the interrupt
+ *   context - Architecture specific register save information.
+ *
+ * Returned Value:
+ *   Zero (OK) on success; A negated errno value on failure.
+ *
+ ************************************************************************************/
+
+
+
+static int nrf52_rtc_interrupt(int irq, void *context, FAR void *arg)
+{
+  ((NRF_RTC_Type *)RTC_BASE)->EVENTS_TICK = 0;
+#if defined(CONFIG_RTC_TICKS)
+  sched_process_timer();
+#endif
+
+  return OK;
+}
+
+/************************************************************************************
+ * Public Functions
+ ************************************************************************************/
+
+int up_rtc_initialize(void)
+{
+
+  int ret;
+
+  ret = nrf_drv_clock_init();
+  /* Select the lower power external 32,768Hz (Low-Speed External, LSE) oscillator
+   * as RTC Clock Source and enable the Clock */
+  nrf_drv_clock_lfclk_request(NULL);
+
+  /* TODO: Get state from this function, if everything is
+  *   okay and whether it is already enabled (if it was disabled
+  *   reset upper time register)
+  */
+  g_rtc_enabled = true;
+
+
+#if defined(CONFIG_RTC_TICKS)
+  /* Configure prescaler, note that these are write-only registers */
+  ((NRF_RTC_Type *)RTC_BASE)->PRESCALER = RTC_PRESCALER;
+
+  /* Enable RTC Tick interrupt */
+  ((NRF_RTC_Type *)RTC_BASE)->INTENSET = NRF_RTC_INT_TICK_MASK;
+
+  /* Configure RTC interrupt to catch overflow and alarm interrupts. */
+  irq_attach(RTC_IRQ, nrf52_rtc_interrupt, NULL);
+  up_enable_irq(RTC_IRQ);
+#ifdef CONFIG_ARCH_IRQPRIO
+  /* Set the interrupt priority */
+  up_prioritize_irq(RTC_IRQ, NVIC_SYSH_PRIORITY_DEFAULT);
+#endif
+#endif
+
+  /* Enable RTC tick */
+  ((NRF_RTC_Type *)RTC_BASE)->TASKS_START = 1;
+
+  return OK;
+}
+
+
+/************************************************************************************
+ * Name: up_rtc_time
+ *
+ * Description:
+ *   Get the current time in seconds.  This is similar to the standard time()
+ *   function.  This interface is only required if the low-resolution RTC/counter
+ *   hardware implementation selected.  It is only used by the RTOS during
+ *   initialization to set up the system time when CONFIG_RTC is set but neither
+ *   CONFIG_RTC_HIRES nor CONFIG_RTC_DATETIME are set.
+ *
+ * Input Parameters:
+ *   None
+ *
+ * Returned Value:
+ *   The current time in seconds
+ *
+ ************************************************************************************/
+
+#ifndef CONFIG_RTC_HIRES
+time_t up_rtc_time(void)
+{
+  irqstate_t flags;
+  uint16_t cnth = 0;
+  uint16_t cntl = 0;
+  uint16_t tmp;
+
+  return (time_t)cnth << 16 | (time_t)cntl;
+}
+#endif
+
+/************************************************************************************
+ * Name: up_rtc_gettime
+ *
+ * Description:
+ *   Get the current time from the high resolution RTC clock/counter.  This interface
+ *   is only supported by the high-resolution RTC/counter hardware implementation.
+ *   It is used to replace the system timer.
+ *
+ * Input Parameters:
+ *   tp - The location to return the high resolution time value.
+ *
+ * Returned Value:
+ *   Zero (OK) on success; a negated errno on failure
+ *
+ ************************************************************************************/
+
+#ifdef CONFIG_RTC_HIRES
+int up_rtc_gettime(FAR struct timespec *tp)
+{
+
+  return OK;
+}
+#endif
+
+/************************************************************************************
+ * Name: up_rtc_settime
+ *
+ * Description:
+ *   Set the RTC to the provided time.  All RTC implementations must be able to
+ *   set their time based on a standard timespec.
+ *
+ * Input Parameters:
+ *   tp - the time to use
+ *
+ * Returned Value:
+ *   Zero (OK) on success; a negated errno on failure
+ *
+ ************************************************************************************/
+
+int up_rtc_settime(FAR const struct timespec *tp)
+{
+
+  return OK;
+}
+
+
+
diff --git a/arch/arm/src/nrf52/nrf52_serial.c b/arch/arm/src/nrf52/nrf52_serial.c
index e33d01bdd2..38cf5483b3 100644
--- a/arch/arm/src/nrf52/nrf52_serial.c
+++ b/arch/arm/src/nrf52/nrf52_serial.c
@@ -68,8 +68,8 @@
 #include "up_arch.h"
 #include "up_internal.h"
 #include "nrf52.h"
-#include "nrf52_uart.h"
-#include "nrf52_gpio.h"
+#include <nrf52_uart.h>
+#include <nrf52_gpio.h>
 #include "nrf_drv_common.h"
 
 
@@ -595,133 +595,6 @@ static bool tx_byte(nrf_uartx_t *p_uart, uart_control_block_t *p_cb)
 }
 #endif
 
-#if 0
-static inline ret_code_t nrf_drv_uart_tx_for_uart(const struct up_dev_s *p_dev)
-{
-  nrf_uartx_t *p_uart;
-  uart_control_block_t *p_cb;
-  ret_code_t err_code;
-
-  err_code = NRF_SUCCESS;
-  p_uart = (nrf_uartx_t *)(p_dev->uartbase);
-  p_cb = p_dev->p_cb;
-  nrf_uart_event_clear(p_uart, p_dev->event_tx);
-  nrf_uart_task_trigger(p_uart, NRF_UART_TASK_STARTTX);
-
-  if (!tx_byte(p_uart, p_cb))
-    {
-      err_code = NRF_ERROR_DATA_SIZE;
-    }
-  else if ((p_cb->handler == NULL) &&
-           nrf_uart_int_enable_check(p_uart, p_dev->mask_tx))
-    {
-      while (p_cb->tx_counter < (uint16_t) p_cb->tx_buffer_length)
-        {
-          WAIT_FOR_UART_EVENT(p_uart, p_dev->event_tx);
-          if (p_cb->tx_counter != TX_COUNTER_ABORT_REQ_VALUE)
-            {
-              if (!tx_byte(p_uart, p_cb))
-                {
-                  err_code = NRF_ERROR_DATA_SIZE;
-                  break;
-                }
-            }
-        }
-
-      if (p_cb->tx_counter == TX_COUNTER_ABORT_REQ_VALUE)
-        {
-          err_code = NRF_ERROR_FORBIDDEN;
-        }
-      else
-        {
-          WAIT_FOR_UART_EVENT(p_uart, p_dev->event_tx);
-          nrf_uart_task_trigger(p_uart, NRF_UART_TASK_STOPTX);
-        }
-      p_cb->tx_buffer_length = 0;
-    }
-
-  return err_code;
-}
-
-static inline ret_code_t nrf_drv_uart_tx_for_uarte(const struct up_dev_s *p_dev)
-{
-  nrf_uartx_t *p_uart;
-
-  uart_control_block_t *p_cb;
-  ret_code_t err_code = NRF_SUCCESS;
-
-  p_cb = p_dev->p_cb;
-  p_uart = (nrf_uartx_t *)(p_dev->uartbase);
-  nrf_uart_event_clear(p_uart, p_dev->event_tx);
-  nrf_uart_event_clear(p_uart, NRF_UART_EVENT_TXSTOPPED);
-  nrf_uartx_tx_buffer_set(p_uart, p_cb->p_tx_buffer, p_cb->tx_buffer_length);
-  nrf_uart_task_trigger(p_uart, NRF_UART_TASK_STARTTX);
-
-  if (p_cb->handler == NULL)
-    {
-      bool endtx;
-      bool txstopped;
-      do
-        {
-          endtx     = nrf_uart_event_check(p_uart, NRF_UART_EVENT_ENDTX);
-          txstopped = nrf_uart_event_check(p_uart, NRF_UART_EVENT_TXSTOPPED);
-        }
-      while ((!endtx) && (!txstopped));
-
-      if (txstopped)
-        {
-          err_code = NRF_ERROR_FORBIDDEN;
-        }
-      p_cb->tx_buffer_length = 0;
-    }
-
-  return err_code;
-}
-
-ret_code_t nrf_drv_uart_tx(const struct up_dev_s *p_dev, uint8_t const *p_data,
-                           uint8_t length)
-{
-  uart_control_block_t *p_cb;
-  ASSERT(length > 0);
-  ASSERT(p_data);
-
-  ret_code_t err_code;
-  p_cb = p_dev->p_cb;
-
-  if (p_dev->easy)
-    {
-      /*
-       * EasyDMA requires that transfer buffers are placed in DataRAM,
-       * signal error if they are not.
-       */
-      if (!nrf_drv_is_in_RAM(p_data))
-        {
-          err_code = NRF_ERROR_INVALID_ADDR;
-          return err_code;
-        }
-    }
-
-  if (nrf_drv_uart_tx_in_progress(p_dev))
-    {
-      err_code = EBUSY;
-      return err_code;
-    }
-  p_cb->tx_buffer_length = length;
-  p_cb->p_tx_buffer      = p_data;
-  p_cb->tx_counter       = 0;
-
-//    if (p_dev->easy)
-//  {
-//      return nrf_drv_uart_tx_for_uarte(p_dev);
-//  }
-//  else
-//  {
-  return nrf_drv_uart_tx_for_uart(p_dev);
-//  }
-}
-
-#endif
-
 static bool inline nrf_drv_uart_tx_in_progress(const struct up_dev_s *p_dev)
 {
   return (p_dev->p_cb->tx_enabled);
@@ -879,20 +752,6 @@ static inline void rx_done_event(uart_control_block_t *p_cb, uint8_t bytes,
   p_cb->handler(&event, p_cb->p_context);
 }
 
-#if 0
-static inline void tx_done_event(uart_control_block_t *p_cb, uint8_t bytes)
-{
-  nrf_drv_uart_event_t event;
-
-  event.type             = NRF_DRV_UART_EVT_TX_DONE;
-  event.data.rxtx.bytes  = bytes;
-  event.data.rxtx.p_data = (uint8_t *)p_cb->p_tx_buffer;
-
-  p_cb->tx_buffer_length = 0;
-
-  p_cb->handler(&event, p_cb->p_context);
-}
-#endif
 static void nrf_drv_uart_tx_abort(const struct up_dev_s *p_dev)
 {
   uart_control_block_t *p_cb;
diff --git a/arch/arm/src/nrf52/nrf52_spi.c b/arch/arm/src/nrf52/nrf52_spi.c
index 93ae8a106f..6e89956aa6 100644
--- a/arch/arm/src/nrf52/nrf52_spi.c
+++ b/arch/arm/src/nrf52/nrf52_spi.c
@@ -83,9 +83,9 @@
 
 #include "up_internal.h"
 #include "nrf52.h"
-#include "nrf52_gpio.h"
+#include <nrf52_gpio.h>
 #include "nrf52_spi.h"
-#include "chip/nrf52_spi.h"
+#include <chip/nrf52_spi.h>
 
 #include "chip.h"
 #include "stm32l4.h"
diff --git a/arch/arm/src/nrf52/nrf52_start.c b/arch/arm/src/nrf52/nrf52_start.c
old mode 100644
new mode 100755
diff --git a/arch/arm/src/nrf52/nrf52_tim.c b/arch/arm/src/nrf52/nrf52_tim.c
index b4b366081c..bcd0b8d0ff 100644
--- a/arch/arm/src/nrf52/nrf52_tim.c
+++ b/arch/arm/src/nrf52/nrf52_tim.c
@@ -80,20 +80,20 @@
 
 static const struct nrf52_tim_ops_s nrf52_tim_ops =
 {
-  .enable     	= &nrf52_timer_enable,
-  .pause      	= &nrf52_timer_pause,
-  .resume 	= &nrf52_timer_resume,
-  .disable    	= &nrf52_timer_disable,
-  .clear	= &nrf52_timer_clear,
-  .setisr	= &nrf52_tim_setisr,
-  .enableint  	= &nrf52_timer_compare_int_enable,
-  .disableint 	= &nrf52_timer_compare_int_disable,
-  .checkint   	= &nrf52_timer_irq_checkint,
-  .clearint   	= &nrf52_timer_irq_clearint,
+  .enable     = &nrf52_timer_enable,
+  .pause      = &nrf52_timer_pause,
+  .resume   = &nrf52_timer_resume,
+  .disable    = &nrf52_timer_disable,
+  .clear    = &nrf52_timer_clear,
+  .setisr   = &nrf52_tim_setisr,
+  .enableint  = &nrf52_timer_compare_int_enable,
+  .disableint = &nrf52_timer_compare_int_disable,
+  .checkint   = &nrf52_timer_irq_checkint,
+  .clearint   = &nrf52_timer_irq_clearint,
   /* .increment = nrf52_timer_increment,
     .decrement = nrf52_timer_decrement,
     .capture   = nrf52_timer_capture,
-    .compare 	 = nrf52_timer_compare,
+    .compare   = nrf52_timer_compare,
   */
 };
 
@@ -102,81 +102,81 @@ static const struct nrf52_tim_ops_s nrf52_tim_ops =
 struct nrf52_tim_priv_s
 {
   const struct nrf52_tim_ops_s *ops;
-  nrf_timer_mode_t 				mode;
-  uint32_t 						base;        	/* TIMn base address */
-  nrf_drv_state_t           	state;			/* Current timer state */
-  nrf_timer_bit_width_t     	bit_width;		/* Current bit width   */
-  nrf_timer_frequency_t     	frequency;
-  nrf_timer_cc_channel_t    	channel_number; /* Current channel number */
-  uint8_t 						channel_count;
+  nrf_timer_mode_t        mode;
+  uint32_t            base;         /* TIMn base address */
+  nrf_drv_state_t             state;      /* Current timer state */
+  nrf_timer_bit_width_t       bit_width;    /* Current bit width   */
+  nrf_timer_frequency_t       frequency;
+  nrf_timer_cc_channel_t      channel_number; /* Current channel number */
+  uint8_t             channel_count;
 };
 
 #ifdef CONFIG_NRF52_TIM0
 struct nrf52_tim_priv_s nrf52_tim0_priv =
 {
-  .ops        		= &nrf52_tim_ops,
-  .mode       		= NRF_TIMER_MODE_TIMER,
-  .base       		= NRF_TIMER0_BASE,
-  .state      		= NRF_DRV_STATE_UNINITIALIZED,
-  .channel_count 	= TIMER0_CC_NUM,
-  .frequency  		= NRF_TIMER_FREQ_16MHz,
-  .bit_width  		= NRF_TIMER_BIT_WIDTH_32,
-  .channel_number 	= NRF_TIMER_CC_CHANNEL0,
+  .ops            = &nrf52_tim_ops,
+  .mode           = NRF_TIMER_MODE_TIMER,
+  .base           = NRF_TIMER0_BASE,
+  .state          = NRF_DRV_STATE_UNINITIALIZED,
+  .channel_count  = TIMER0_CC_NUM,
+  .frequency      = NRF_TIMER_FREQ_16MHz,
+  .bit_width      = NRF_TIMER_BIT_WIDTH_32,
+  .channel_number   = NRF_TIMER_CC_CHANNEL0,
 };
 #endif
 #ifdef CONFIG_NRF52_TIM1
 struct nrf52_tim_priv_s nrf52_tim1_priv =
 {
-  .ops        		= &nrf52_tim_ops,
-  .mode      		= NRF_TIMER_MODE_TIMER,
-  .base       		= NRF_TIMER1_BASE,
-  .state      		= NRF_DRV_STATE_UNINITIALIZED,
-  .channel_count 	= TIMER1_CC_NUM,
-  .frequency  		= NRF_TIMER_FREQ_16MHz,
-  .bit_width  		= NRF_TIMER_BIT_WIDTH_32,
-  .channel_number 	= NRF_TIMER_CC_CHANNEL0,
+  .ops            = &nrf52_tim_ops,
+  .mode         = NRF_TIMER_MODE_TIMER,
+  .base           = NRF_TIMER1_BASE,
+  .state          = NRF_DRV_STATE_UNINITIALIZED,
+  .channel_count  = TIMER1_CC_NUM,
+  .frequency      = NRF_TIMER_FREQ_16MHz,
+  .bit_width      = NRF_TIMER_BIT_WIDTH_32,
+  .channel_number   = NRF_TIMER_CC_CHANNEL0,
 };
 #endif
 
 #ifdef CONFIG_NRF52_TIM2
 struct nrf52_tim_priv_s nrf52_tim2_priv =
 {
-  .ops        		= &nrf52_tim_ops,
-  .mode      		= NRF_TIMER_MODE_TIMER,
-  .base       		= NRF_TIMER2_BASE,
-  .state      		= NRF_DRV_STATE_UNINITIALIZED,
-  .channel_count 	= TIMER2_CC_NUM,
-  .frequency  		= NRF_TIMER_FREQ_16MHz,
-  .bit_width  		= NRF_TIMER_BIT_WIDTH_32,
-  .channel_number 	= NRF_TIMER_CC_CHANNEL0,
+  .ops            = &nrf52_tim_ops,
+  .mode         = NRF_TIMER_MODE_TIMER,
+  .base           = NRF_TIMER2_BASE,
+  .state          = NRF_DRV_STATE_UNINITIALIZED,
+  .channel_count  = TIMER2_CC_NUM,
+  .frequency      = NRF_TIMER_FREQ_16MHz,
+  .bit_width      = NRF_TIMER_BIT_WIDTH_32,
+  .channel_number   = NRF_TIMER_CC_CHANNEL0,
 };
 #endif
 
 #ifdef CONFIG_NRF52_TIM3
 struct nrf52_tim_priv_s nrf52_tim3_priv =
 {
-  .ops        		= &nrf52_tim_ops,
-  .mode       		= NRF_TIMER_MODE_TIMER,
-  .base       		= NRF_TIMER3_BASE,
-  .state      		= NRF_DRV_STATE_UNINITIALIZED,
-  .channel_count 	= TIMER3_CC_NUM,
-  .frequency  		= NRF_TIMER_FREQ_16MHz,
-  .bit_width  		= NRF_TIMER_BIT_WIDTH_32,
-  .channel_number 	= NRF_TIMER_CC_CHANNEL0,
+  .ops            = &nrf52_tim_ops,
+  .mode           = NRF_TIMER_MODE_TIMER,
+  .base           = NRF_TIMER3_BASE,
+  .state          = NRF_DRV_STATE_UNINITIALIZED,
+  .channel_count  = TIMER3_CC_NUM,
+  .frequency      = NRF_TIMER_FREQ_16MHz,
+  .bit_width      = NRF_TIMER_BIT_WIDTH_32,
+  .channel_number   = NRF_TIMER_CC_CHANNEL0,
 };
 #endif
 
 #ifdef CONFIG_NRF52_TIM4
 struct nrf52_tim_priv_s nrf52_tim4_priv =
 {
-  .ops        		= &nrf52_tim_ops,
-  .mode       		= NRF_TIMER_MODE_TIMER,
-  .base       		= NRF_TIMER4_BASE,
-  .state      		= NRF_DRV_STATE_UNINITIALIZED,
-  .channel_count 	= TIMER4_CC_NUM,
-  .frequency  		= NRF_TIMER_FREQ_16MHz,
-  .bit_width  		= NRF_TIMER_BIT_WIDTH_32,
-  .channel_number 	= NRF_TIMER_CC_CHANNEL0,
+  .ops            = &nrf52_tim_ops,
+  .mode           = NRF_TIMER_MODE_TIMER,
+  .base           = NRF_TIMER4_BASE,
+  .state          = NRF_DRV_STATE_UNINITIALIZED,
+  .channel_count  = TIMER4_CC_NUM,
+  .frequency      = NRF_TIMER_FREQ_16MHz,
+  .bit_width      = NRF_TIMER_BIT_WIDTH_32,
+  .channel_number   = NRF_TIMER_CC_CHANNEL0,
 };
 #endif
 /************************************************************************************
diff --git a/arch/arm/src/nrf52/nrf52_timerisr.c b/arch/arm/src/nrf52/nrf52_timerisr.c
index ae9b5ca63e..2f7fbf3f78 100644
--- a/arch/arm/src/nrf52/nrf52_timerisr.c
+++ b/arch/arm/src/nrf52/nrf52_timerisr.c
@@ -73,8 +73,9 @@
 static int nrf52_timerisr(int irq, uint32_t *regs, void *arg)
 {
   /* Process timer interrupt */
-
+#ifndef CONFIG_RTC_TICKS
   sched_process_timer();
+#endif
   return 0;
 }
 
diff --git a/arch/arm/src/nrf52/nrf_drv_common.c b/arch/arm/src/nrf52/nrf_drv_common.c
index 7591636929..8600a63674 100755
--- a/arch/arm/src/nrf52/nrf_drv_common.c
+++ b/arch/arm/src/nrf52/nrf_drv_common.c
@@ -307,7 +307,7 @@ void nrf_drv_common_irq_enable(IRQn_Type IRQn, uint8_t priority)
 
   /* nrf52832 only had 3bits for priority */
 
-  priority <<=5;
+  priority <<= 5;
 
 #ifdef CONFIG_ARCH_IRQPRIO
   up_prioritize_irq(IRQn, priority);
diff --git a/configs/nrf52832_dk/Makefile b/configs/nrf52832_dk/Makefile
old mode 100644
new mode 100755
index 47a8c398dd..637401f550
--- a/configs/nrf52832_dk/Makefile
+++ b/configs/nrf52832_dk/Makefile
@@ -16,7 +16,7 @@ PLATFORM ?= nrf52832_dk
 DEPTH = ../..
 CHIP_SRC = arch/arm/src/nrf52
 CHIP_SRC_DEPTH=../../../..
-APPS = nsh hello ble_hello ble_app_uart
+APPS = nsh hello ble_hello ble_app_uart rtc
 CD = cd
 LN = ln -sf
 CP = cp
@@ -28,11 +28,6 @@ help:
 	@echo "Run make with one of the following targets"
 	@echo "config $(APPS)"
 	@echo ""
-	@echo "Parameter: _MAJOR_ , _MINOR_ , _BUILD_VERSION_"
-	@echo "\t _MAJOR_ is for Nuttx major version"
-	@echo "\t _MINOR_ is for Nuttx minor version"
-	@echo "\t _BUILD_VERSION_ is for custimizing build version"
-	@echo "\t example: make nsh _MAJOR_=7 _MINOR_=21 _BUILD_VERSION_=201711111111_12345"
 	@echo "if build for ZEUS2 , please export ZEUS2_BOARD=1"
 
 menuconfig config:
diff --git a/configs/nrf52832_dk/ble_hello/Make.defs b/configs/nrf52832_dk/ble_hello/Make.defs
index a4794310fd..3151a3c109 100644
--- a/configs/nrf52832_dk/ble_hello/Make.defs
+++ b/configs/nrf52832_dk/ble_hello/Make.defs
@@ -4,7 +4,7 @@
 #   Copyright (C) 2016 Gregory Nutt. All rights reserved.
 #   Author: dev@ziggurat29.com
 #
-# Redistribution and use in source and binary forms, with or without
+# Redistribution  and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions
 # are met:
 #
diff --git a/configs/nrf52832_dk/ble_hello/defconfig b/configs/nrf52832_dk/ble_hello/defconfig
old mode 100644
new mode 100755
index ec5021bad9..139c54c46c
--- a/configs/nrf52832_dk/ble_hello/defconfig
+++ b/configs/nrf52832_dk/ble_hello/defconfig
@@ -158,7 +158,7 @@ CONFIG_ARCH_FAMILY="armv7-m"
 CONFIG_ARCH_CHIP="nrf52"
 # CONFIG_ARM_TOOLCHAIN_IAR is not set
 CONFIG_ARM_TOOLCHAIN_GNU=y
-# CONFIG_ARMV7M_USEBASEPRI is not set
+#CONFIG_ARMV7M_USEBASEPRI=y
 CONFIG_ARCH_HAVE_CMNVECTOR=y
 CONFIG_ARMV7M_CMNVECTOR=y
 # CONFIG_ARMV7M_LAZYFPU is not set
@@ -199,10 +199,22 @@ CONFIG_NRF52_NRF52832_HAVE_PERIPH=y
 # CONFIG_NRF52832_FLASH_256KB is not set
 CONFIG_NRF52832_FLASH_512KB=y
 
+CONFIG_WIRELESS_BT=y
+CONFIG_BT_LIBUTILS=y
+CONFIG_BT_MSG_Q_STACKSIZE=1024
+CONFIG_BT_MSG_Q_MAX_MSG_NUMBER=32
+CONFIG_BT_MSG_Q_PRIORITY=64
+CONFIG_BT_NRF=y
 #
 # NRF52 Peripherals
 #
 
+CONFIG_WIRELESS_BT=y
+CONFIG_BT_LIBUTILS=y
+CONFIG_BT_MSG_Q_STACKSIZE=1024
+CONFIG_BT_MSG_Q_MAX_MSG_NUMBER=32
+CONFIG_BT_MSG_Q_PRIORITY=64
+CONFIG_BT_NRF=y
 #
 # NRF52 Peripheral Support
 #
@@ -237,7 +249,7 @@ CONFIG_SRAM_LENGTH="0xde98"
 # CONFIG_NRF52_DAC is not set
 # CONFIG_NRF52_DMA is not set
 CONFIG_NRF52_I2C=y
-# CONFIG_NRF52_SAI is not set
+CONFIG_NRF52_GPIOTE=y
 # CONFIG_NRF52_SPI is not set
 CONFIG_NRF52_UART=y
 # CONFIG_NRF52_LPTIM is not set
@@ -284,6 +296,7 @@ CONFIG_NRF52_PWR=y
 CONFIG_NRF52_UART0=y
 CONFIG_NRF52_I2C0=y
 CONFIG_NRF52_I2C1=y
+CONFIG_NRF52_GPIOTE=y
 # CONFIG_NRF52_DAC1 is not set
 # CONFIG_NRF52_DAC2 is not set
 # CONFIG_NRF52_OPAMP is not set
@@ -368,7 +381,7 @@ CONFIG_ARCH_HAVE_MPU=y
 # CONFIG_ARCH_HAVE_POWEROFF is not set
 CONFIG_ARCH_HAVE_RESET=y
 CONFIG_ARCH_USE_MPU=y
-# CONFIG_ARCH_IRQPRIO is not set
+CONFIG_ARCH_IRQPRIO=y
 CONFIG_ARCH_STACKDUMP=y
 # CONFIG_ENDIAN_BIG is not set
 # CONFIG_ARCH_IDLE_CUSTOM is not set
diff --git a/configs/nrf52832_dk/defaults.mk b/configs/nrf52832_dk/defaults.mk
index 6fe8ba7535..6706a59067 100755
--- a/configs/nrf52832_dk/defaults.mk
+++ b/configs/nrf52832_dk/defaults.mk
@@ -84,8 +84,10 @@ ifeq ($(CONFIG_NRF52_BLUETOOTH),y)
   ARCHINCLUDES += -I$(DEV_DIR) \
 		  -I$(SD_HANDLER) \
 		  -I$(LIB_FDS) -I$(LIB_FSTORE) -I$(LIB_EXPRMTL) \
-		  -I$(LIB_BSP) -I$(BOARDS) -I$(BUTTON) -I$(LIB_TIMR) \
+		  -I$(BLE_BAS) -I$(BLE_DIS) \
+		  -I$(LIB_BSP) -I$(BOARDS) -I$(BUTTON) -I$(LIB_TIMR) -I$(LIB_SENSOR) \
 		  -I$(DRV_DELAY)
+# -I$(GPIOTE)
 endif
 
   ARCHXXINCLUDES = -I. -isystem $(TOPDIR)/include -isystem $(TOPDIR)/include/cxx
diff --git a/configs/nrf52832_dk/nsh/defconfig b/configs/nrf52832_dk/nsh/defconfig
index 9dd415fc1b..ed81fe9340 100644
--- a/configs/nrf52832_dk/nsh/defconfig
+++ b/configs/nrf52832_dk/nsh/defconfig
@@ -231,11 +231,11 @@ CONFIG_NRF52832_FLASH_512KB=y
 CONFIG_NRF52_HAVE_LPTIM1=y
 CONFIG_NRF52_HAVE_LPTIM2=y
 CONFIG_NRF52_HAVE_COMP=y
-CONFIG_NRF52_HAVE_I2S=y
+CONFIG_NRF52_HAVE_SAI1=y
+CONFIG_NRF52_HAVE_SAI2=y
 CONFIG_NRF52_HAVE_UART0=y
 CONFIG_NRF52_HAVE_BLUETOOTH=y
 # CONFIG_NRF52_BLUETOOTH is not set
-CONFIG_GPIO_AS_PINRESET=21
 CONFIG_FLASH_ORIGIN="0"
 CONFIG_FLASH_LENGTH="0x80000"
 CONFIG_SRAM_ORIGIN="0x20000000"
@@ -244,21 +244,41 @@ CONFIG_SRAM_LENGTH="0x10000"
 # CONFIG_NRF52_DAC is not set
 # CONFIG_NRF52_DMA is not set
 CONFIG_NRF52_I2C=y
-# CONFIG_NRF52_GPIOTE is not set
+# CONFIG_NRF52_SAI is not set
 # CONFIG_NRF52_SPI is not set
 CONFIG_NRF52_UART=y
 # CONFIG_NRF52_LPTIM is not set
+
+#
+# AHB1 Peripherals
+#
+# CONFIG_NRF52_DMA1 is not set
+# CONFIG_NRF52_DMA2 is not set
 # CONFIG_NRF52_CRC is not set
 # CONFIG_NRF52_TSC is not set
+
+#
+# AHB2 Peripherals
+#
 # CONFIG_NRF52_OTGFS is not set
 # CONFIG_NRF52_ADC1 is not set
-# CONFIG_NRF52_PPI is not set
 # CONFIG_NRF52_ADC2 is not set
 # CONFIG_NRF52_ADC3 is not set
 CONFIG_NRF52_AES=y
 CONFIG_NRF52_RNG=y
-# CONFIG_NRF52_I2S is not set
+# CONFIG_NRF52_SAI1_A is not set
+# CONFIG_NRF52_SAI1_B is not set
+# CONFIG_NRF52_SAI2_A is not set
+# CONFIG_NRF52_SAI2_B is not set
+
+#
+# AHB3 Peripherals
+#
 # CONFIG_NRF52_FMC is not set
+
+#
+# APB1 Peripherals
+#
 CONFIG_NRF52_PWR=y
 # CONFIG_NRF52_TIM0 is not set
 # CONFIG_NRF52_TIM1 is not set
@@ -278,12 +298,20 @@ CONFIG_NRF52_I2C0=y
 # CONFIG_NRF52_DAC2 is not set
 # CONFIG_NRF52_OPAMP is not set
 # CONFIG_NRF52_LPTIM1 is not set
+# CONFIG_NRF52_LPUART1 is not set
 # CONFIG_NRF52_SWPMI is not set
 # CONFIG_NRF52_LPTIM2 is not set
+
+#
+# APB2 Peripherals
+#
 CONFIG_NRF52_SYSCFG=y
 CONFIG_NRF52_FIREWALL=y
+# CONFIG_NRF52_SDMMC1 is not set
 # CONFIG_NRF52_UART1 is not set
 # CONFIG_NRF52_COMP is not set
+# CONFIG_NRF52_SAI1 is not set
+# CONFIG_NRF52_SAI2 is not set
 # CONFIG_NRF52_DFSDM is not set
 CONFIG_NRF52_PWM=y
 
@@ -292,10 +320,11 @@ CONFIG_NRF52_PWM=y
 #
 # CONFIG_NRF52_BKPSRAM is not set
 CONFIG_NRF52_WDG=y
-# CONFIG_NRF52_QDECODER is not set
 CONFIG_NRF52_FLASH_PREFETCH=y
 CONFIG_NRF52_DISABLE_IDLE_SLEEP_DURING_DEBUG=y
 # CONFIG_ARCH_BOARD_NRF52_CUSTOM_CLOCKCONFIG is not set
+# CONFIG_NRF52_SAI1PLL is not set
+# CONFIG_NRF52_SAI2PLL is not set
 
 #
 # Timer Configuration
@@ -691,7 +720,6 @@ CONFIG_MS58XX_VDD=30
 # CONFIG_LM75 is not set
 # CONFIG_LM92 is not set
 # CONFIG_QENCODER is not set
-# CONFIG_QDECODER is not set
 # CONFIG_VEML6070 is not set
 # CONFIG_XEN1210 is not set
 # CONFIG_ZEROCROSS is not set
@@ -1035,16 +1063,7 @@ CONFIG_EXAMPLES_NSH=y
 # CONFIG_EXAMPLES_NXLINES is not set
 # CONFIG_EXAMPLES_NXTERM is not set
 # CONFIG_EXAMPLES_NXTEXT is not set
-CONFIG_EXAMPLES_OSTEST=y
-CONFIG_EXAMPLES_OSTEST_LOOPS=1
-CONFIG_EXAMPLES_OSTEST_STACKSIZE=8192
-CONFIG_EXAMPLES_OSTEST_NBARRIER_THREADS=8
-# CONFIG_EXAMPLES_PTHREAD_RW_LOCK is not set
-# CONFIG_EXAMPLES_PTHREAD_MUTEX_ROBUST is not set
-CONFIG_EXAMPLES_OSTEST_RR_RANGE=10000
-CONFIG_EXAMPLES_OSTEST_RR_RUNS=10
-CONFIG_EXAMPLES_OSTEST_FPUTESTDISABLE=y
-CONFIG_EXAMPLES_OSTEST_WAITRESULT=y
+# CONFIG_EXAMPLES_OSTEST is not set
 # CONFIG_EXAMPLES_PCA9635 is not set
 # CONFIG_EXAMPLES_POSIXSPAWN is not set
 # CONFIG_EXAMPLES_POWERMONITOR is not set
diff --git a/configs/nrf52832_dk/rtc/Make.defs b/configs/nrf52832_dk/rtc/Make.defs
new file mode 100644
index 0000000000..3151a3c109
--- /dev/null
+++ b/configs/nrf52832_dk/rtc/Make.defs
@@ -0,0 +1,40 @@
+############################################################################
+# configs/stm32l476-mdk/nsh/Make.defs
+#
+#   Copyright (C) 2016 Gregory Nutt. All rights reserved.
+#   Author: dev@ziggurat29.com
+#
+# Redistribution  and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name NuttX nor the names of its contributors may be
+#    used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+############################################################################
+
+include ${TOPDIR}/.config
+include ${TOPDIR}/tools/Config.mk
+include ${TOPDIR}/arch/arm/src/armv7-m/Toolchain.defs
+include ${TOPDIR}/configs/$(CONFIG_ARCH_BOARD)/defaults.mk
+
diff --git a/configs/nrf52832_dk/rtc/defconfig b/configs/nrf52832_dk/rtc/defconfig
new file mode 100644
index 0000000000..fd5b69abdd
--- /dev/null
+++ b/configs/nrf52832_dk/rtc/defconfig
@@ -0,0 +1,1044 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Nuttx/ Configuration
+#
+
+#
+# Build Setup
+#
+# CONFIG_EXPERIMENTAL is not set
+# CONFIG_DEFAULT_SMALL is not set
+CONFIG_HOST_LINUX=y
+# CONFIG_HOST_OSX is not set
+# CONFIG_HOST_WINDOWS is not set
+# CONFIG_HOST_OTHER is not set
+
+#
+# Build Configuration
+#
+CONFIG_APPS_DIR="../apps"
+CONFIG_BUILD_FLAT=y
+# CONFIG_BUILD_PROTECTED is not set
+# CONFIG_BUILD_2PASS is not set
+
+#
+# Binary Output Formats
+#
+# CONFIG_RRLOAD_BINARY is not set
+CONFIG_INTELHEX_BINARY=y
+# CONFIG_MOTOROLA_SREC is not set
+CONFIG_RAW_BINARY=y
+# CONFIG_UBOOT_UIMAGE is not set
+
+#
+# Customize Header Files
+#
+# CONFIG_ARCH_STDINT_H is not set
+# CONFIG_ARCH_STDBOOL_H is not set
+# CONFIG_ARCH_MATH_H is not set
+# CONFIG_ARCH_FLOAT_H is not set
+# CONFIG_ARCH_STDARG_H is not set
+# CONFIG_ARCH_DEBUG_H is not set
+
+#
+# Debug Options
+#
+CONFIG_DEBUG_ALERT=y
+CONFIG_DEBUG_FEATURES=y
+
+#
+# Debug SYSLOG Output Controls
+#
+CONFIG_DEBUG_ERROR=y
+CONFIG_DEBUG_WARN=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_ASSERTIONS=y
+
+#
+# Subsystem Debug Options
+#
+# CONFIG_DEBUG_BINFMT is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_DEBUG_GRAPHICS is not set
+# CONFIG_DEBUG_LIB is not set
+# CONFIG_DEBUG_MM is not set
+# CONFIG_DEBUG_SCHED is not set
+
+#
+# OS Function Debug Options
+#
+# CONFIG_DEBUG_IRQ is not set
+
+#
+# Driver Debug Options
+#
+# CONFIG_DEBUG_LEDS is not set
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_DEBUG_I2C is not set
+# CONFIG_DEBUG_SPI is not set
+# CONFIG_DEBUG_TIMER is not set
+CONFIG_ARCH_HAVE_STACKCHECK=y
+# CONFIG_STACK_COLORATION is not set
+CONFIG_ARCH_HAVE_HEAPCHECK=y
+# CONFIG_HEAP_COLORATION is not set
+CONFIG_DEBUG_SYMBOLS=y
+CONFIG_ARCH_HAVE_CUSTOMOPT=y
+# CONFIG_DEBUG_NOOPT is not set
+# CONFIG_DEBUG_CUSTOMOPT is not set
+CONFIG_DEBUG_FULLOPT=y
+
+#
+# System Type
+#
+CONFIG_ARCH_ARM=y
+# CONFIG_ARCH_AVR is not set
+# CONFIG_ARCH_HC is not set
+# CONFIG_ARCH_MIPS is not set
+# CONFIG_ARCH_MISOC is not set
+# CONFIG_ARCH_RENESAS is not set
+# CONFIG_ARCH_RISCV is not set
+# CONFIG_ARCH_SIM is not set
+# CONFIG_ARCH_X86 is not set
+# CONFIG_ARCH_XTENSA is not set
+# CONFIG_ARCH_Z16 is not set
+# CONFIG_ARCH_Z80 is not set
+CONFIG_ARCH="arm"
+
+#
+# ARM Options
+#
+# CONFIG_ARCH_CHIP_A1X is not set
+# CONFIG_ARCH_CHIP_C5471 is not set
+# CONFIG_ARCH_CHIP_DM320 is not set
+# CONFIG_ARCH_CHIP_EFM32 is not set
+# CONFIG_ARCH_CHIP_IMX1 is not set
+# CONFIG_ARCH_CHIP_IMX6 is not set
+# CONFIG_ARCH_CHIP_KINETIS is not set
+# CONFIG_ARCH_CHIP_KL is not set
+# CONFIG_ARCH_CHIP_LM is not set
+# CONFIG_ARCH_CHIP_TIVA is not set
+# CONFIG_ARCH_CHIP_LPC11XX is not set
+# CONFIG_ARCH_CHIP_LPC17XX is not set
+# CONFIG_ARCH_CHIP_LPC214X is not set
+# CONFIG_ARCH_CHIP_LPC2378 is not set
+# CONFIG_ARCH_CHIP_LPC31XX is not set
+# CONFIG_ARCH_CHIP_LPC43XX is not set
+# CONFIG_ARCH_CHIP_MOXART is not set
+# CONFIG_ARCH_CHIP_NUC1XX is not set
+# CONFIG_ARCH_CHIP_SAMA5 is not set
+# CONFIG_ARCH_CHIP_SAMD is not set
+# CONFIG_ARCH_CHIP_SAML is not set
+# CONFIG_ARCH_CHIP_SAM34 is not set
+# CONFIG_ARCH_CHIP_SAMV7 is not set
+# CONFIG_ARCH_CHIP_STM32 is not set
+# CONFIG_ARCH_CHIP_STM32F7 is not set
+# CONFIG_ARCH_CHIP_STM32L4 is not set
+CONFIG_ARCH_CHIP_NRF52=y
+# CONFIG_ARCH_CHIP_STR71X is not set
+# CONFIG_ARCH_CHIP_TMS570 is not set
+# CONFIG_ARCH_ARM7TDMI is not set
+# CONFIG_ARCH_ARM926EJS is not set
+# CONFIG_ARCH_ARM920T is not set
+# CONFIG_ARCH_CORTEXM0 is not set
+# CONFIG_ARCH_CORTEXM23 is not set
+# CONFIG_ARCH_CORTEXM3 is not set
+# CONFIG_ARCH_CORTEXM33 is not set
+CONFIG_ARCH_CORTEXM4=y
+# CONFIG_ARCH_CORTEXM7 is not set
+# CONFIG_ARCH_CORTEXA5 is not set
+# CONFIG_ARCH_CORTEXA8 is not set
+# CONFIG_ARCH_CORTEXA9 is not set
+# CONFIG_ARCH_CORTEXR4 is not set
+# CONFIG_ARCH_CORTEXR4F is not set
+# CONFIG_ARCH_CORTEXR5 is not set
+# CONFIG_ARCH_CORTEX5F is not set
+# CONFIG_ARCH_CORTEXR7 is not set
+# CONFIG_ARCH_CORTEXR7F is not set
+CONFIG_ARCH_FAMILY="armv7-m"
+CONFIG_ARCH_CHIP="nrf52"
+# CONFIG_ARM_TOOLCHAIN_IAR is not set
+CONFIG_ARM_TOOLCHAIN_GNU=y
+CONFIG_ARMV7M_USEBASEPRI=y
+CONFIG_ARCH_HAVE_CMNVECTOR=y
+CONFIG_ARMV7M_CMNVECTOR=y
+# CONFIG_ARMV7M_LAZYFPU is not set
+CONFIG_ARCH_HAVE_FPU=y
+# CONFIG_ARCH_HAVE_DPFPU is not set
+CONFIG_ARCH_FPU=y
+# CONFIG_ARCH_HAVE_TRUSTZONE is not set
+CONFIG_ARM_HAVE_MPU_UNIFIED=y
+CONFIG_ARM_MPU=y
+CONFIG_ARM_MPU_NREGIONS=8
+# CONFIG_DEBUG_HARDFAULT is not set
+
+#
+# ARMV7M Configuration Options
+#
+# CONFIG_ARMV7M_HAVE_ICACHE is not set
+# CONFIG_ARMV7M_HAVE_DCACHE is not set
+# CONFIG_ARMV7M_HAVE_ITCM is not set
+# CONFIG_ARMV7M_HAVE_DTCM is not set
+# CONFIG_ARMV7M_TOOLCHAIN_IARL is not set
+# CONFIG_ARMV7M_TOOLCHAIN_BUILDROOT is not set
+# CONFIG_ARMV7M_TOOLCHAIN_CODEREDL is not set
+# CONFIG_ARMV7M_TOOLCHAIN_CODESOURCERYL is not set
+CONFIG_ARMV7M_TOOLCHAIN_GNU_EABIL=y
+CONFIG_ARMV7M_HAVE_STACKCHECK=y
+# CONFIG_ARMV7M_STACKCHECK is not set
+# CONFIG_ARMV7M_ITMSYSLOG is not set
+CONFIG_SERIAL_TERMIOS=y
+# CONFIG_SERIAL_DISABLE_REORDERING is not set
+
+#
+# NRF52 Configuration Options
+#
+CONFIG_ARCH_CHIP_NRF52832=y
+# CONFIG_ARCH_CHIP_NRF52840 is not set
+CONFIG_NRF52_NRF52832_HAVE_PERIPH=y
+# CONFIG_NRF52_NRF52840_HAVE_PERIPH is not set
+# CONFIG_NRF52832_FLASH_256KB is not set
+CONFIG_NRF52832_FLASH_512KB=y
+
+CONFIG_WIRELESS_BT=y
+CONFIG_BT_LIBUTILS=y
+CONFIG_BT_MSG_Q_STACKSIZE=1024
+CONFIG_BT_MSG_Q_MAX_MSG_NUMBER=32
+CONFIG_BT_MSG_Q_PRIORITY=64
+CONFIG_BT_NRF=y
+#
+# NRF52 Peripherals
+#
+
+#
+# NRF52 Peripheral Support
+#
+# CONFIG_NRF52_HAVE_LTDC is not set
+CONFIG_NRF52_HAVE_LPTIM1=y
+CONFIG_NRF52_HAVE_LPTIM2=y
+CONFIG_NRF52_HAVE_COMP=y
+CONFIG_NRF52_HAVE_SAI1=y
+CONFIG_NRF52_HAVE_SAI2=y
+CONFIG_NRF52_HAVE_UART0=y
+CONFIG_NRF52_HAVE_BLUETOOTH=y
+CONFIG_NRF52_BLUETOOTH=y
+
+#
+# Nordic Bluetooth Settings
+#
+# CONFIG_NRF_SOFTDEVICE_S132_V4_0_2=y
+# CONFIG_NRF_SOFTDEVICE_S132_V5_0_0_1 is not set
+CONFIG_NRF_SOFTDEVICE="s132_nrf52_5.0.0-1.alpha"
+CONFIG_BLE_GATT_MTU_SIZE_DEFAULT=23
+CONFIG_NRF_SD_BLE_API_VERSION=5
+CONFIG_BLE__STACK_SIZE=2048
+CONFIG_BLE__HEAP_SIZE=1024
+CONFIG_GPIO_AS_PINRESET=1
+CONFIG_FLASH_ORIGIN="0x20000"
+CONFIG_FLASH_LENGTH="0x60000"
+CONFIG_SRAM_ORIGIN="0x20002168"
+CONFIG_SRAM_LENGTH="0xde98"
+
+
+# CONFIG_NRF52_ADC is not set
+# CONFIG_NRF52_DAC is not set
+# CONFIG_NRF52_DMA is not set
+# CONFIG_NRF52_I2C is not set
+CONFIG_NRF52_GPIOTE=y
+# CONFIG_NRF52_SPI is not set
+CONFIG_NRF52_UART=y
+# CONFIG_NRF52_LPTIM is not set
+
+#
+# AHB1 Peripherals
+#
+# CONFIG_NRF52_DMA1 is not set
+# CONFIG_NRF52_DMA2 is not set
+# CONFIG_NRF52_CRC is not set
+# CONFIG_NRF52_TSC is not set
+
+#
+# AHB2 Peripherals
+#
+# CONFIG_NRF52_OTGFS is not set
+# CONFIG_NRF52_ADC1 is not set
+# CONFIG_NRF52_ADC2 is not set
+# CONFIG_NRF52_ADC3 is not set
+CONFIG_NRF52_AES=y
+CONFIG_NRF52_RNG=y
+# CONFIG_NRF52_SAI1_A is not set
+# CONFIG_NRF52_SAI1_B is not set
+# CONFIG_NRF52_SAI2_A is not set
+# CONFIG_NRF52_SAI2_B is not set
+
+#
+# AHB3 Peripherals
+#
+# CONFIG_NRF52_FMC is not set
+
+#
+# APB1 Peripherals
+#
+CONFIG_NRF52_PWR=y
+# CONFIG_NRF52_TIM0 is not set
+# CONFIG_NRF52_TIM1 is not set
+# CONFIG_NRF52_TIM2 is not set
+# CONFIG_NRF52_TIM3 is not set
+# CONFIG_NRF52_TIM4 is not set
+CONFIG_NRF52_RTC0=y
+CONFIG_NRF52_RTC1=y
+CONFIG_NRF52_RTC2=y
+# CONFIG_NRF52_SPI0 is not set
+# CONFIG_NRF52_SPI1 is not set
+# CONFIG_NRF52_SPI2 is not set
+CONFIG_NRF52_UART0=y
+# CONFIG_NRF52_I2C0 is not set
+# CONFIG_NRF52_I2C1 is not set
+# CONFIG_NRF52_DAC1 is not set
+# CONFIG_NRF52_DAC2 is not set
+# CONFIG_NRF52_OPAMP is not set
+# CONFIG_NRF52_LPTIM1 is not set
+# CONFIG_NRF52_LPUART1 is not set
+# CONFIG_NRF52_SWPMI is not set
+# CONFIG_NRF52_LPTIM2 is not set
+
+#
+# APB2 Peripherals
+#
+CONFIG_NRF52_SYSCFG=y
+CONFIG_NRF52_FIREWALL=y
+# CONFIG_NRF52_SDMMC1 is not set
+# CONFIG_NRF52_UART1 is not set
+# CONFIG_NRF52_COMP is not set
+# CONFIG_NRF52_SAI1 is not set
+# CONFIG_NRF52_SAI2 is not set
+# CONFIG_NRF52_DFSDM is not set
+
+#
+# Other Peripherals
+#
+# CONFIG_NRF52_BKPSRAM is not set
+# CONFIG_NRF52_IWDG is not set
+# CONFIG_NRF52_WWDG is not set
+CONFIG_NRF52_FLASH_PREFETCH=y
+CONFIG_NRF52_DISABLE_IDLE_SLEEP_DURING_DEBUG=y
+# CONFIG_ARCH_BOARD_NRF52_CUSTOM_CLOCKCONFIG is not set
+# CONFIG_NRF52_SAI1PLL is not set
+# CONFIG_NRF52_SAI2PLL is not set
+
+#
+# Timer Configuration
+#
+# CONFIG_NRF52_ONESHOT is not set
+# CONFIG_NRF52_FREERUN is not set
+CONFIG_NRF52_HAVE_UART1=y
+
+#
+# U[S]ART Configuration
+#
+# CONFIG_NRF52_FLOWCONTROL_BROKEN is not set
+# CONFIG_NRF52_UART_BREAKS is not set
+
+# Architecture Options
+#
+# CONFIG_ARCH_NOINTC is not set
+# CONFIG_ARCH_VECNOTIRQ is not set
+# CONFIG_ARCH_DMA is not set
+CONFIG_ARCH_HAVE_IRQPRIO=y
+# CONFIG_ARCH_L2CACHE is not set
+# CONFIG_ARCH_HAVE_COHERENT_DCACHE is not set
+# CONFIG_ARCH_HAVE_ADDRENV is not set
+# CONFIG_ARCH_NEED_ADDRENV_MAPPING is not set
+# CONFIG_ARCH_HAVE_MULTICPU is not set
+CONFIG_ARCH_HAVE_VFORK=y
+# CONFIG_ARCH_HAVE_MMU is not set
+CONFIG_ARCH_HAVE_MPU=y
+# CONFIG_ARCH_NAND_HWECC is not set
+# CONFIG_ARCH_HAVE_EXTCLK is not set
+# CONFIG_ARCH_HAVE_POWEROFF is not set
+CONFIG_ARCH_HAVE_RESET=y
+CONFIG_ARCH_USE_MPU=y
+CONFIG_ARCH_IRQPRIO=y
+CONFIG_ARCH_STACKDUMP=y
+# CONFIG_ENDIAN_BIG is not set
+# CONFIG_ARCH_IDLE_CUSTOM is not set
+# CONFIG_ARCH_HAVE_RAMFUNCS is not set
+CONFIG_ARCH_HAVE_RAMVECTORS=y
+# CONFIG_ARCH_RAMVECTORS is not set
+# CONFIG_ARCH_MINIMAL_VECTORTABLE is not set
+
+#
+# Board Settings
+#
+CONFIG_BOARD_LOOPSPERMSEC=8499
+# CONFIG_ARCH_CALIBRATION is not set
+
+#
+# Interrupt options
+#
+CONFIG_ARCH_HAVE_INTERRUPTSTACK=y
+CONFIG_ARCH_INTERRUPTSTACK=2048
+CONFIG_ARCH_HAVE_HIPRI_INTERRUPT=y
+# CONFIG_ARCH_HIPRI_INTERRUPT is not set
+
+#
+# Boot options
+#
+# CONFIG_BOOT_RUNFROMEXTSRAM is not set
+CONFIG_BOOT_RUNFROMFLASH=y
+# CONFIG_BOOT_RUNFROMISRAM is not set
+# CONFIG_BOOT_RUNFROMSDRAM is not set
+# CONFIG_BOOT_COPYTORAM is not set
+
+#
+# Boot Memory Configuration
+#
+CONFIG_RAM_START=0x20000000
+CONFIG_RAM_SIZE=65536
+# CONFIG_ARCH_HAVE_SDRAM is not set
+
+#
+# Board Selection
+#
+CONFIG_ARCH_BOARD_NRF52832_DK=y
+# CONFIG_ARCH_BOARD_CUSTOM is not set
+CONFIG_ARCH_BOARD="nrf52832_dk"
+
+#
+# Common Board Options
+#
+CONFIG_ARCH_HAVE_LEDS=y
+CONFIG_ARCH_LEDS=y
+CONFIG_ARCH_HAVE_BUTTONS=y
+# CONFIG_ARCH_BUTTONS is not set
+CONFIG_ARCH_HAVE_IRQBUTTONS=y
+
+#
+# Board-Specific Options
+#
+# CONFIG_BOARD_CRASHDUMP is not set
+CONFIG_LIB_BOARDCTL=y
+# CONFIG_BOARDCTL_RESET is not set
+# CONFIG_BOARDCTL_UNIQUEID is not set
+# CONFIG_BOARDCTL_TSCTEST is not set
+# CONFIG_BOARDCTL_GRAPHICS is not set
+# CONFIG_BOARDCTL_IOCTL is not set
+
+#
+# RTOS Features
+#
+CONFIG_DISABLE_OS_API=y
+# CONFIG_DISABLE_POSIX_TIMERS is not set
+# CONFIG_DISABLE_PTHREAD is not set
+# CONFIG_DISABLE_SIGNALS is not set
+# CONFIG_DISABLE_MQUEUE is not set
+# CONFIG_DISABLE_ENVIRON is not set
+
+#
+# Clocks and Timers
+#
+CONFIG_ARCH_HAVE_TICKLESS=y
+# CONFIG_SCHED_TICKLESS is not set
+CONFIG_USEC_PER_TICK=10000
+# CONFIG_SYSTEM_TIME64 is not set
+# CONFIG_CLOCK_MONOTONIC is not set
+# CONFIG_ARCH_HAVE_TIMEKEEPING is not set
+# CONFIG_JULIAN_TIME is not set
+CONFIG_START_YEAR=2017
+CONFIG_START_MONTH=1
+CONFIG_START_DAY=1
+CONFIG_MAX_WDOGPARMS=2
+CONFIG_PREALLOC_WDOGS=8
+CONFIG_WDOG_INTRESERVE=1
+CONFIG_PREALLOC_TIMERS=4
+
+#
+# Tasks and Scheduling
+#
+# CONFIG_SPINLOCK is not set
+# CONFIG_INIT_NONE is not set
+CONFIG_INIT_ENTRYPOINT=y
+# CONFIG_INIT_FILEPATH is not set
+CONFIG_USER_ENTRYPOINT="rtc_main"
+CONFIG_RR_INTERVAL=200
+# CONFIG_SCHED_SPORADIC is not set
+CONFIG_TASK_NAME_SIZE=0
+CONFIG_MAX_TASKS=16
+# CONFIG_SCHED_HAVE_PARENT is not set
+CONFIG_SCHED_WAITPID=y
+
+#
+# Pthread Options
+#
+# CONFIG_MUTEX_TYPES is not set
+CONFIG_NPTHREAD_KEYS=4
+# CONFIG_PTHREAD_CLEANUP is not set
+# CONFIG_CANCELLATION_POINTS is not set
+
+#
+# Performance Monitoring
+#
+# CONFIG_SCHED_CPULOAD is not set
+# CONFIG_SCHED_INSTRUMENTATION is not set
+
+#
+# Files and I/O
+#
+CONFIG_DEV_CONSOLE=y
+# CONFIG_FDCLONE_DISABLE is not set
+# CONFIG_FDCLONE_STDIO is not set
+CONFIG_SDCLONE_DISABLE=y
+CONFIG_NFILE_DESCRIPTORS=8
+CONFIG_NFILE_STREAMS=8
+CONFIG_NAME_MAX=32
+# CONFIG_PRIORITY_INHERITANCE is not set
+
+#
+# RTOS hooks
+#
+CONFIG_BOARD_INITIALIZE=y
+# CONFIG_SCHED_STARTHOOK is not set
+# CONFIG_SCHED_ATEXIT is not set
+# CONFIG_SCHED_ONEXIT is not set
+
+#
+# Signal Numbers
+#
+CONFIG_SIG_SIGUSR1=1
+CONFIG_SIG_SIGUSR2=2
+CONFIG_SIG_SIGALARM=3
+CONFIG_SIG_SIGCONDTIMEDOUT=16
+
+#
+# POSIX Message Queue Options
+#
+CONFIG_PREALLOC_MQ_MSGS=4
+CONFIG_MQ_MAXMSGSIZE=32
+# CONFIG_MODULE is not set
+
+#
+# Work queue support
+#
+# CONFIG_SCHED_WORKQUEUE is not set
+# CONFIG_SCHED_HPWORK is not set
+# CONFIG_SCHED_LPWORK is not set
+
+#
+# Stack and heap information
+#
+CONFIG_IDLETHREAD_STACKSIZE=1024
+CONFIG_USERMAIN_STACKSIZE=2048
+CONFIG_PTHREAD_STACK_MIN=256
+CONFIG_PTHREAD_STACK_DEFAULT=2048
+# CONFIG_LIB_SYSCALL is not set
+
+#
+# Device Drivers
+#
+CONFIG_DISABLE_POLL=y
+CONFIG_DEV_NULL=y
+CONFIG_DEV_ZERO=y
+CONFIG_ARCH_HAVE_RNG=y
+# CONFIG_DEV_RANDOM is not set
+# CONFIG_DEV_URANDOM is not set
+CONFIG_DEV_LOOP=y
+
+#
+# Buffering
+#
+# CONFIG_DRVR_WRITEBUFFER is not set
+# CONFIG_DRVR_READAHEAD is not set
+# CONFIG_RAMDISK is not set
+# CONFIG_CAN is not set
+# CONFIG_ARCH_HAVE_PWM_PULSECOUNT is not set
+# CONFIG_ARCH_HAVE_PWM_MULTICHAN is not set
+# CONFIG_PWM is not set
+CONFIG_ARCH_HAVE_I2CRESET=y
+CONFIG_I2C=y
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_POLLED is not set
+# CONFIG_I2C_RESET is not set
+# CONFIG_I2C_TRACE is not set
+# CONFIG_I2C_DRIVER is not set
+# CONFIG_ARCH_HAVE_SPI_CRCGENERATION is not set
+# CONFIG_ARCH_HAVE_SPI_CS_CONTROL is not set
+CONFIG_ARCH_HAVE_SPI_BITORDER=y
+CONFIG_SPI=y
+# CONFIG_SPI_SLAVE is not set
+CONFIG_SPI_EXCHANGE=y
+# CONFIG_SPI_CMDDATA is not set
+# CONFIG_SPI_CALLBACK is not set
+# CONFIG_SPI_HWFEATURES is not set
+# CONFIG_SPI_BITORDER is not set
+# CONFIG_SPI_CS_DELAY_CONTROL is not set
+# CONFIG_SPI_DRIVER is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_I2S is not set
+
+#
+# Timer Driver Support
+#
+CONFIG_TIMER=y
+# CONFIG_ONESHOT is not set
+CONFIG_RTC=y
+CONFIG_COUNTER=y
+# CONFIG_WATCHDOG is not set
+# CONFIG_TIMERS_CS2100CP is not set
+# CONFIG_ANALOG is not set
+# CONFIG_AUDIO_DEVICES is not set
+# CONFIG_VIDEO_DEVICES is not set
+# CONFIG_BCH is not set
+# CONFIG_INPUT is not set
+
+#
+# IO Expander/GPIO Support
+#
+# CONFIG_IOEXPANDER is not set
+# CONFIG_DEV_GPIO is not set
+
+#
+# LCD Driver Support
+#
+# CONFIG_LCD is not set
+# CONFIG_SLCD is not set
+
+#
+# LED Support
+#
+# CONFIG_USERLED is not set
+# CONFIG_RGBLED is not set
+# CONFIG_PCA9635PW is not set
+# CONFIG_NCP5623C is not set
+# CONFIG_MMCSD is not set
+# CONFIG_MODEM is not set
+# CONFIG_MTD is not set
+# CONFIG_EEPROM is not set
+# CONFIG_PIPES is not set
+# CONFIG_PM is not set
+# CONFIG_POWER is not set
+# CONFIG_SENSORS is not set
+CONFIG_SERIAL=y
+# CONFIG_DEV_LOWCONSOLE is not set
+# CONFIG_SERIAL_REMOVABLE is not set
+CONFIG_SERIAL_CONSOLE=y
+# CONFIG_16550_UART is not set
+# CONFIG_UART_SERIALDRIVER is not set
+CONFIG_UART0_SERIALDRIVER=y
+# CONFIG_UART1_SERIALDRIVER is not set
+# CONFIG_UART2_SERIALDRIVER is not set
+# CONFIG_UART3_SERIALDRIVER is not set
+# CONFIG_UART4_SERIALDRIVER is not set
+# CONFIG_UART5_SERIALDRIVER is not set
+# CONFIG_UART6_SERIALDRIVER is not set
+# CONFIG_UART7_SERIALDRIVER is not set
+# CONFIG_UART8_SERIALDRIVER is not set
+# CONFIG_SCI0_SERIALDRIVER is not set
+# CONFIG_SCI1_SERIALDRIVER is not set
+# CONFIG_USART0_SERIALDRIVER is not set
+# CONFIG_USART1_SERIALDRIVER is not set
+# CONFIG_USART2_SERIALDRIVER is not set
+# CONFIG_USART3_SERIALDRIVER is not set
+# CONFIG_USART4_SERIALDRIVER is not set
+# CONFIG_USART5_SERIALDRIVER is not set
+# CONFIG_USART6_SERIALDRIVER is not set
+# CONFIG_USART7_SERIALDRIVER is not set
+# CONFIG_USART8_SERIALDRIVER is not set
+# CONFIG_OTHER_UART_SERIALDRIVER is not set
+CONFIG_MCU_SERIAL=y
+CONFIG_STANDARD_SERIAL=y
+# CONFIG_SERIAL_IFLOWCONTROL is not set
+# CONFIG_SERIAL_OFLOWCONTROL is not set
+# CONFIG_SERIAL_DMA is not set
+# CONFIG_SERIAL_TIOCSERGSTRUCT is not set
+CONFIG_ARCH_HAVE_SERIAL_TERMIOS=y
+CONFIG_UART0_SERIAL_CONSOLE=y
+# CONFIG_OTHER_SERIAL_CONSOLE is not set
+# CONFIG_NO_SERIAL_CONSOLE is not set
+
+#
+# UART0 Configuration
+#
+CONFIG_UART0_RXBUFSIZE=256
+CONFIG_UART0_TXBUFSIZE=256
+CONFIG_UART0_BAUD=115200
+CONFIG_UART0_BITS=8
+CONFIG_UART0_PARITY=0
+CONFIG_UART0_2STOP=0
+# CONFIG_UART0_IFLOWCONTROL is not set
+# CONFIG_UART0_OFLOWCONTROL is not set
+# CONFIG_UART0_DMA is not set
+# CONFIG_PSEUDOTERM is not set
+# CONFIG_USBDEV is not set
+# CONFIG_USBHOST is not set
+# CONFIG_HAVE_USBTRACE is not set
+# CONFIG_DRIVERS_WIRELESS is not set
+# CONFIG_DRIVERS_CONTACTLESS is not set
+
+#
+# System Logging
+#
+# CONFIG_ARCH_SYSLOG is not set
+# CONFIG_RAMLOG is not set
+# CONFIG_SYSLOG_INTBUFFER is not set
+# CONFIG_SYSLOG_TIMESTAMP is not set
+CONFIG_SYSLOG_SERIAL_CONSOLE=y
+# CONFIG_SYSLOG_CHAR is not set
+CONFIG_SYSLOG_CONSOLE=y
+# CONFIG_SYSLOG_NONE is not set
+# CONFIG_SYSLOG_FILE is not set
+# CONFIG_SYSLOG_CHARDEV is not set
+
+#
+# Networking Support
+#
+# CONFIG_ARCH_HAVE_NET is not set
+# CONFIG_ARCH_HAVE_PHY is not set
+# CONFIG_NET is not set
+
+#
+# Crypto API
+#
+# CONFIG_CRYPTO is not set
+
+#
+# File Systems
+#
+
+#
+# File system configuration
+#
+# CONFIG_DISABLE_MOUNTPOINT is not set
+# CONFIG_FS_AUTOMOUNTER is not set
+# CONFIG_DISABLE_PSEUDOFS_OPERATIONS is not set
+# CONFIG_PSEUDOFS_SOFTLINKS is not set
+CONFIG_FS_READABLE=y
+CONFIG_FS_WRITABLE=y
+# CONFIG_FS_NAMED_SEMAPHORES is not set
+CONFIG_FS_MQUEUE_MPATH="/var/mqueue"
+# CONFIG_FS_RAMMAP is not set
+# CONFIG_FS_FAT is not set
+# CONFIG_FS_NXFFS is not set
+CONFIG_FS_ROMFS=y
+CONFIG_FS_TMPFS=y
+CONFIG_FS_TMPFS_BLOCKSIZE=512
+CONFIG_FS_TMPFS_DIRECTORY_ALLOCGUARD=64
+CONFIG_FS_TMPFS_DIRECTORY_FREEGUARD=128
+CONFIG_FS_TMPFS_FILE_ALLOCGUARD=512
+CONFIG_FS_TMPFS_FILE_FREEGUARD=1024
+# CONFIG_FS_SMARTFS is not set
+# CONFIG_FS_BINFS is not set
+CONFIG_FS_PROCFS=y
+CONFIG_FS_PROCFS_REGISTER=y
+
+#
+# Exclude individual procfs entries
+#
+# CONFIG_FS_PROCFS_EXCLUDE_PROCESS is not set
+# CONFIG_FS_PROCFS_EXCLUDE_UPTIME is not set
+# CONFIG_FS_PROCFS_EXCLUDE_MOUNTS is not set
+# CONFIG_FS_UNIONFS is not set
+
+#
+# Graphics Support
+#
+# CONFIG_NX is not set
+
+#
+# Memory Management
+#
+# CONFIG_MM_SMALL is not set
+CONFIG_MM_REGIONS=1
+# CONFIG_ARCH_HAVE_HEAP2 is not set
+# CONFIG_GRAN is not set
+
+#
+# Audio Support
+#
+# CONFIG_AUDIO is not set
+
+#
+# Wireless Support
+#
+
+#
+# Binary Loader
+#
+# CONFIG_BINFMT_DISABLE is not set
+# CONFIG_BINFMT_EXEPATH is not set
+# CONFIG_NXFLAT is not set
+# CONFIG_ELF is not set
+CONFIG_BUILTIN=y
+# CONFIG_PIC is not set
+# CONFIG_SYMTAB_ORDEREDBYNAME is not set
+
+#
+# Library Routines
+#
+
+#
+# Standard C Library Options
+#
+
+#
+# Standard C I/O
+#
+# CONFIG_STDIO_DISABLE_BUFFERING is not set
+CONFIG_STDIO_BUFFER_SIZE=64
+CONFIG_STDIO_LINEBUFFER=y
+CONFIG_NUNGET_CHARS=2
+# CONFIG_NOPRINTF_FIELDWIDTH is not set
+# CONFIG_LIBC_FLOATINGPOINT is not set
+CONFIG_LIBC_LONG_LONG=y
+# CONFIG_LIBC_SCANSET is not set
+# CONFIG_EOL_IS_CR is not set
+# CONFIG_EOL_IS_LF is not set
+# CONFIG_EOL_IS_BOTH_CRLF is not set
+CONFIG_EOL_IS_EITHER_CRLF=y
+# CONFIG_MEMCPY_VIK is not set
+CONFIG_LIBM=y
+
+#
+# Architecture-Specific Support
+#
+CONFIG_ARCH_LOWPUTC=y
+# CONFIG_ARCH_ROMGETC is not set
+# CONFIG_LIBC_ARCH_MEMCPY is not set
+# CONFIG_LIBC_ARCH_MEMCMP is not set
+# CONFIG_LIBC_ARCH_MEMMOVE is not set
+# CONFIG_LIBC_ARCH_MEMSET is not set
+# CONFIG_LIBC_ARCH_STRCHR is not set
+# CONFIG_LIBC_ARCH_STRCMP is not set
+# CONFIG_LIBC_ARCH_STRCPY is not set
+# CONFIG_LIBC_ARCH_STRNCPY is not set
+# CONFIG_LIBC_ARCH_STRLEN is not set
+# CONFIG_LIBC_ARCH_STRNLEN is not set
+# CONFIG_LIBC_ARCH_ELF is not set
+# CONFIG_ARMV7M_MEMCPY is not set
+
+#
+# stdlib Options
+#
+CONFIG_LIB_RAND_ORDER=1
+CONFIG_LIB_HOMEDIR="/"
+CONFIG_LIBC_TMPDIR="/tmp"
+CONFIG_LIBC_MAX_TMPFILE=32
+
+#
+# Program Execution Options
+#
+# CONFIG_LIBC_EXECFUNCS is not set
+CONFIG_POSIX_SPAWN_PROXY_STACKSIZE=1024
+CONFIG_TASK_SPAWN_DEFAULT_STACKSIZE=2048
+
+#
+# errno Decode Support
+#
+# CONFIG_LIBC_STRERROR is not set
+# CONFIG_LIBC_PERROR_STDOUT is not set
+
+#
+# memcpy/memset Options
+#
+# CONFIG_MEMSET_OPTSPEED is not set
+# CONFIG_LIBC_DLLFCN is not set
+# CONFIG_LIBC_MODLIB is not set
+# CONFIG_LIBC_WCHAR is not set
+# CONFIG_LIBC_LOCALE is not set
+
+#
+# Time/Time Zone Support
+#
+# CONFIG_LIBC_LOCALTIME is not set
+# CONFIG_TIME_EXTENDED is not set
+CONFIG_ARCH_HAVE_TLS=y
+
+#
+# Thread Local Storage (TLS)
+#
+# CONFIG_TLS is not set
+
+#
+# Network-Related Options
+#
+# CONFIG_LIBC_IPv4_ADDRCONV is not set
+# CONFIG_LIBC_IPv6_ADDRCONV is not set
+# CONFIG_LIBC_NETDB is not set
+
+#
+# NETDB Support
+#
+# CONFIG_NETDB_HOSTFILE is not set
+# CONFIG_LIBC_IOCTL_VARIADIC is not set
+CONFIG_LIB_SENDFILE_BUFSIZE=512
+
+#
+# Non-standard Library Support
+#
+# CONFIG_LIB_CRC64_FAST is not set
+# CONFIG_LIB_KBDCODEC is not set
+# CONFIG_LIB_SLCDCODEC is not set
+# CONFIG_LIB_HEX2BIN is not set
+
+#
+# Basic CXX Support
+#
+# CONFIG_C99_BOOL8 is not set
+CONFIG_HAVE_CXX=y
+# CONFIG_HAVE_CXXINITIALIZE is not set
+# CONFIG_CXX_NEWLONG is not set
+
+#
+# uClibc++ Standard C++ Library
+#
+# CONFIG_UCLIBCXX is not set
+
+#
+# Application Configuration
+#
+
+#
+# Built-In Applications
+#
+CONFIG_BUILTIN_PROXY_STACKSIZE=1024
+
+#
+# CAN Utilities
+#
+
+#
+# Examples
+#
+# CONFIG_EXAMPLES_BLE_HELLO is not set
+# CONFIG_EXAMPLES_BUTTONS is not set
+# CONFIG_EXAMPLES_CCTYPE is not set
+# CONFIG_EXAMPLES_CHAT is not set
+# CONFIG_EXAMPLES_CONFIGDATA is not set
+# CONFIG_EXAMPLES_CXXTEST is not set
+# CONFIG_EXAMPLES_DHCPD is not set
+# CONFIG_EXAMPLES_ELF is not set
+# CONFIG_EXAMPLES_FSTEST is not set
+# CONFIG_EXAMPLES_FTPC is not set
+# CONFIG_EXAMPLES_FTPD is not set
+# CONFIG_EXAMPLES_HELLO is not set
+# CONFIG_EXAMPLES_HELLOXX is not set
+# CONFIG_EXAMPLES_HIDKBD is not set
+# CONFIG_EXAMPLES_IGMP is not set
+# CONFIG_EXAMPLES_JSON is not set
+# CONFIG_EXAMPLES_KEYPADTEST is not set
+# CONFIG_EXAMPLES_MEDIA is not set
+# CONFIG_EXAMPLES_MM is not set
+# CONFIG_EXAMPLES_MODBUS is not set
+# CONFIG_EXAMPLES_MOUNT is not set
+# CONFIG_EXAMPLES_NRF24L01TERM is not set
+# CONFIG_EXAMPLES_NSH is not set
+# CONFIG_EXAMPLES_NULL is not set
+# CONFIG_EXAMPLES_NXFFS is not set
+# CONFIG_EXAMPLES_NXHELLO is not set
+# CONFIG_EXAMPLES_NXIMAGE is not set
+# CONFIG_EXAMPLES_NX is not set
+# CONFIG_EXAMPLES_NXLINES is not set
+# CONFIG_EXAMPLES_NXTERM is not set
+# CONFIG_EXAMPLES_NXTEXT is not set
+# CONFIG_EXAMPLES_OSTEST is not set
+# CONFIG_EXAMPLES_PCA9635 is not set
+# CONFIG_EXAMPLES_POSIXSPAWN is not set
+# CONFIG_EXAMPLES_PPPD is not set
+# CONFIG_EXAMPLES_RFID_READUID is not set
+# CONFIG_EXAMPLES_RGBLED is not set
+# CONFIG_EXAMPLES_ROMFS is not set
+CONFIG_EXAMPLES_RTC=y
+CONFIG_EXAMPLE_COUNTER_DEVNAME="/dev/rtc2"
+# CONFIG_EXAMPLES_SENDMAIL is not set
+# CONFIG_EXAMPLES_SERIALBLASTER is not set
+# CONFIG_EXAMPLES_SERIALRX is not set
+# CONFIG_EXAMPLES_SERLOOP is not set
+# CONFIG_EXAMPLES_SLCD is not set
+# CONFIG_EXAMPLES_SMART is not set
+# CONFIG_EXAMPLES_SMP is not set
+# CONFIG_EXAMPLES_STAT is not set
+# CONFIG_EXAMPLES_TCPECHO is not set
+# CONFIG_EXAMPLES_TELNETD is not set
+# CONFIG_EXAMPLES_THTTPD is not set
+# CONFIG_EXAMPLES_TIFF is not set
+# CONFIG_EXAMPLES_TIMER is not set
+# CONFIG_EXAMPLES_TOUCHSCREEN is not set
+# CONFIG_EXAMPLES_UNIONFS is not set
+# CONFIG_EXAMPLES_USBSERIAL is not set
+# CONFIG_EXAMPLES_WATCHDOG is not set
+# CONFIG_EXAMPLES_WEBSERVER is not set
+# CONFIG_EXAMPLES_XBC_TEST is not set
+
+#
+# File System Utilities
+#
+# CONFIG_FSUTILS_INIFILE is not set
+# CONFIG_FSUTILS_PASSWD is not set
+
+#
+# GPS Utilities
+#
+# CONFIG_GPSUTILS_MINMEA_LIB is not set
+
+#
+# Graphics Support
+#
+# CONFIG_TIFF is not set
+# CONFIG_GRAPHICS_TRAVELER is not set
+
+#
+# Interpreters
+#
+# CONFIG_INTERPRETERS_BAS is not set
+# CONFIG_INTERPRETERS_FICL is not set
+# CONFIG_INTERPRETERS_MICROPYTHON is not set
+# CONFIG_INTERPRETERS_MINIBASIC is not set
+# CONFIG_INTERPRETERS_PCODE is not set
+
+#
+# FreeModBus
+#
+# CONFIG_MODBUS is not set
+
+#
+# Network Utilities
+#
+# CONFIG_NETUTILS_CODECS is not set
+# CONFIG_NETUTILS_ESP8266 is not set
+# CONFIG_NETUTILS_FTPC is not set
+# CONFIG_NETUTILS_JSON is not set
+# CONFIG_NETUTILS_SMTP is not set
+
+#
+# NSH Library
+#
+# CONFIG_NSH_LIBRARY is not set
+
+#
+# NxWidgets/NxWM
+#
+
+#
+# Platform-specific Support
+#
+# CONFIG_PLATFORM_CONFIGDATA is not set
+
+#
+# System Libraries and NSH Add-Ons
+#
+# CONFIG_SYSTEM_CLE is not set
+# CONFIG_SYSTEM_CUTERM is not set
+# CONFIG_SYSTEM_FREE is not set
+# CONFIG_SYSTEM_HEX2BIN is not set
+# CONFIG_SYSTEM_HEXED is not set
+# CONFIG_SYSTEM_I2CTOOL is not set
+# CONFIG_SYSTEM_INSTALL is not set
+# CONFIG_SYSTEM_RAMTEST is not set
+# CONFIG_READLINE_HAVE_EXTMATCH is not set
+CONFIG_SYSTEM_READLINE=y
+CONFIG_READLINE_ECHO=y
+# CONFIG_READLINE_TABCOMPLETION is not set
+# CONFIG_READLINE_CMD_HISTORY is not set
+# CONFIG_SYSTEM_SUDOKU is not set
+# CONFIG_SYSTEM_TEE is not set
+# CONFIG_SYSTEM_UBLOXMODEM is not set
+# CONFIG_SYSTEM_VI is not set
+# CONFIG_SYSTEM_ZMODEM is not set
diff --git a/configs/nrf52832_dk/src/nrf52_appinit.c b/configs/nrf52832_dk/src/nrf52_appinit.c
index 700bfbf600..19e7954a57 100644
--- a/configs/nrf52832_dk/src/nrf52_appinit.c
+++ b/configs/nrf52832_dk/src/nrf52_appinit.c
@@ -321,17 +321,7 @@ int nrf52_internal_flash_fs_initialize(void)
 int board_app_initialize(uintptr_t arg)
 {
 
-  int ret;
-
-  ret = nrf_drv_clock_init();
-  if (ret != OK)
-    {
-      syslog(LOG_ERR,
-             "ERROR: Failed to do nrf clock init: %d\n",
-             ret);
-      return ret;
-    }
-
+  int ret = OK;
 
 #ifdef HAVE_RTC_DRIVER
   FAR struct rtc_lowerhalf_s *rtclower;
@@ -339,7 +329,6 @@ int board_app_initialize(uintptr_t arg)
 
 
 #ifdef CONFIG_COUNTER
-  nrf_drv_clock_lfclk_request(NULL);
 #ifdef CONFIG_NRF52_RTC0
   ret = nrf52_rtc_initialize("/dev/rtc0", 0);
   if (ret != OK)
@@ -349,7 +338,7 @@ int board_app_initialize(uintptr_t arg)
              ret);
       return ret;
     }
-#endif
+#endif //CONFIG_NRF52_RTC0
 #ifdef CONFIG_NRF52_RTC1
   ret = nrf52_rtc_initialize("/dev/rtc1", 1);
   if (ret != OK)
@@ -359,7 +348,8 @@ int board_app_initialize(uintptr_t arg)
              ret);
       return ret;
     }
-#endif
+#endif //CONFIG_NRF52_RTC1  
+
 #ifdef CONFIG_NRF52_RTC2
   ret = nrf52_rtc_initialize("/dev/rtc2", 2);
   if (ret != OK)
@@ -369,8 +359,8 @@ int board_app_initialize(uintptr_t arg)
              ret);
       return ret;
     }
-#endif
-#endif
+#endif //CONFIG_NRF52_RTC2
+#endif //CONFIG_COUNTER
 
 #ifdef CONFIG_TIMER
   /* Initialize and register the timer driver */
@@ -574,8 +564,8 @@ int board_app_initialize(uintptr_t arg)
     {
       serr("ERROR: PWM initialize Fail\n");
     }
-#endif
-#endif
+#endif //CONFIG_NRF52_RTC2
+#endif //CONFIG_COUNTER
 
 #ifdef CONFIG_QDECODER
 #ifdef CONFIG_NRF52_QDECODER
@@ -591,7 +581,7 @@ int board_app_initialize(uintptr_t arg)
 
   nrf52_internal_flash_fs_initialize();
 
-  return OK;
+  return ret;
 }
 #endif /* CONFIG_LIB_BOARDCTL */
 
diff --git a/drivers/sensors/mc3672.c b/drivers/sensors/mc3672.c
old mode 100755
new mode 100644
index fe44d4017f..2203560d6b
--- a/drivers/sensors/mc3672.c
+++ b/drivers/sensors/mc3672.c
@@ -37,7 +37,7 @@
  * POSSIBILITY OF SUCH DAMAGE.
  *
  ****************************************************************************/
- #include <nuttx/config.h>
+#include <nuttx/config.h>
 
 #include <stdlib.h>
 #include <fixedmath.h>
@@ -59,7 +59,7 @@
 /****************************************************************************
  * Pre-processor Definitions
  ****************************************************************************/
- 
+
 /*******************************************************************************
  *** CONSTANT / DEFINE
  *******************************************************************************/
@@ -72,8 +72,8 @@
 #define MC3672_RETCODE_ERROR_IDENTIFICATION    (-6)
 #define MC3672_RETCODE_ERROR_NO_DATA           (-7)
 #define MC3672_RETCODE_ERROR_WRONG_ARGUMENT    (-8)
-#define MC3672_FIFO_DEPTH    					32
-#define MC3672_REG_MAP_SIZE    					64
+#define MC3672_FIFO_DEPTH             32
+#define MC3672_REG_MAP_SIZE             64
 
 
 
@@ -85,8 +85,8 @@
 #define MC3672_INTR_C_IPP_MODE_OPEN_DRAIN    (0x00)
 #define MC3672_INTR_C_IPP_MODE_PUSH_PULL     (0x01)
 
-#define MC3672_INTR_C_IAH_ACTIVE_LOW     	(0x00)
-#define MC3672_INTR_C_IAH_ACTIVE_HIGH    	(0x02)
+#define MC3672_INTR_C_IAH_ACTIVE_LOW      (0x00)
+#define MC3672_INTR_C_IAH_ACTIVE_HIGH     (0x02)
 
 
 /*******************************************************************************
@@ -132,27 +132,27 @@
 #define MC3672_REG_LOT_dAOFSZ       (0x3E)
 #define MC3672_REG_WAF_LOT          (0x3F)
 
-#define MC3672_NULL_ADDR    		(0)
+#define MC3672_NULL_ADDR        (0)
+
 
-	
-#ifdef MC3672_CFG_BUS_I2C 
-	#define MC3672_CFG_I2C_ADDR		(0x4C)
+#ifdef MC3672_CFG_BUS_I2C
+#define MC3672_CFG_I2C_ADDR   (0x4C)
 #endif
-#define MC3672_CFG_MODE_DEFAULT			MC3672_MODE_CWAKE
-#define MC3672_CFG_GA_MODE_DEFAULT			GA_MODE_NORMAL
+#define MC3672_CFG_MODE_DEFAULT     MC3672_MODE_CWAKE
+#define MC3672_CFG_GA_MODE_DEFAULT      GA_MODE_NORMAL
 
 #define MC3672_CFG_SAMPLE_RATE_CWAKE_DEFAULT    MC3672_CWAKE_SR_DEFAULT_54Hz
 #define MC3672_CFG_GA_SAMPLE_RATE_DEFAULT    GA_SAMPRATE_50Hz
 
 #define MC3672_CFG_SAMPLE_RATE_SNIFF_DEFAULT    MC3672_SNIFF_SR_7Hz
 
-#define MC3672_CFG_RANGE_DEFAULT		MC3672_RANGE_8G
-#define MC3672_CFG_GA_RANGE_DEFAULT		GA_RANGE_8G
+#define MC3672_CFG_RANGE_DEFAULT    MC3672_RANGE_8G
+#define MC3672_CFG_GA_RANGE_DEFAULT   GA_RANGE_8G
 
-#define MC3672_CFG_RESOLUTION_DEFAULT		MC3672_RESOLUTION_14BIT
-#define MC3672_CFG_GA_RESOLUTION_DEFAULT		GA_RESOLUTION_14BIT
+#define MC3672_CFG_RESOLUTION_DEFAULT   MC3672_RESOLUTION_14BIT
+#define MC3672_CFG_GA_RESOLUTION_DEFAULT    GA_RESOLUTION_14BIT
 
-#define MC3672_CFG_ORIENTATION_MAP_DEFAULT    	ORIENTATION_TOP_RIGHT_UP
+#define MC3672_CFG_ORIENTATION_MAP_DEFAULT      ORIENTATION_TOP_RIGHT_UP
 
 /****************************************************************************
  * Private Type Definitions
@@ -167,108 +167,108 @@ struct mc3672_dev_s
 
 typedef enum
 {
-    MC3672_GAIN_DEFAULT    = 0b00,
-    MC3672_GAIN_4X         = 0b01,
-    MC3672_GAIN_1X         = 0b10,
-    MC3672_GAIN_NOT_USED   = 0b11,   
+  MC3672_GAIN_DEFAULT    = 0b00,
+  MC3672_GAIN_4X         = 0b01,
+  MC3672_GAIN_1X         = 0b10,
+  MC3672_GAIN_NOT_USED   = 0b11,
 }   MC3672_gain_t;
 
 typedef enum
 {
-    MC3672_MODE_SLEEP 	   = 0b000,
-    MC3672_MODE_STANDBY    = 0b001,
-    MC3672_MODE_SNIFF      = 0b010,
-    MC3672_MODE_CWAKE      = 0b101, 
-    MC3672_MODE_TRIG       = 0b111,  
+  MC3672_MODE_SLEEP      = 0b000,
+  MC3672_MODE_STANDBY    = 0b001,
+  MC3672_MODE_SNIFF      = 0b010,
+  MC3672_MODE_CWAKE      = 0b101,
+  MC3672_MODE_TRIG       = 0b111,
 }   MC3672_mode_t;
 
 typedef enum
 {
-    MC3672_RANGE_2G    = 0b000,
-    MC3672_RANGE_4G    = 0b001,
-    MC3672_RANGE_8G	   = 0b010,
-    MC3672_RANGE_16G   = 0b011,
-    MC3672_RANGE_12G   = 0b100,
-    MC3672_RANGE_END,
+  MC3672_RANGE_2G    = 0b000,
+  MC3672_RANGE_4G    = 0b001,
+  MC3672_RANGE_8G    = 0b010,
+  MC3672_RANGE_16G   = 0b011,
+  MC3672_RANGE_12G   = 0b100,
+  MC3672_RANGE_END,
 }   MC3672_range_t;
 
 typedef enum
 {
-    MC3672_RESOLUTION_6BIT    = 0b000, 
-    MC3672_RESOLUTION_7BIT    = 0b001, 
-    MC3672_RESOLUTION_8BIT    = 0b010, 
-    MC3672_RESOLUTION_10BIT   = 0b011, 
-    MC3672_RESOLUTION_12BIT   = 0b100, 
-    MC3672_RESOLUTION_14BIT   = 0b101,  //(Do not select if FIFO enabled)
-    MC3672_RESOLUTION_END,
+  MC3672_RESOLUTION_6BIT    = 0b000,
+  MC3672_RESOLUTION_7BIT    = 0b001,
+  MC3672_RESOLUTION_8BIT    = 0b010,
+  MC3672_RESOLUTION_10BIT   = 0b011,
+  MC3672_RESOLUTION_12BIT   = 0b100,
+  MC3672_RESOLUTION_14BIT   = 0b101,  //(Do not select if FIFO enabled)
+  MC3672_RESOLUTION_END,
 }   MC3672_resolution_t;
 
 typedef enum
 {
-    MC3672_CWAKE_SR_DEFAULT_54Hz = 0b0000,
-    MC3672_CWAKE_SR_14Hz         = 0b0101,
-    MC3672_CWAKE_SR_28Hz         = 0b0110,
-    MC3672_CWAKE_SR_54Hz         = 0b0111,
-    MC3672_CWAKE_SR_105Hz        = 0b1000,
-    MC3672_CWAKE_SR_210Hz        = 0b1001,
-    MC3672_CWAKE_SR_400Hz        = 0b1010,
-    MC3672_CWAKE_SR_600Hz        = 0b1011,
-    MC3672_CWAKE_SR_END,
+  MC3672_CWAKE_SR_DEFAULT_54Hz = 0b0000,
+  MC3672_CWAKE_SR_14Hz         = 0b0101,
+  MC3672_CWAKE_SR_28Hz         = 0b0110,
+  MC3672_CWAKE_SR_54Hz         = 0b0111,
+  MC3672_CWAKE_SR_105Hz        = 0b1000,
+  MC3672_CWAKE_SR_210Hz        = 0b1001,
+  MC3672_CWAKE_SR_400Hz        = 0b1010,
+  MC3672_CWAKE_SR_600Hz        = 0b1011,
+  MC3672_CWAKE_SR_END,
 }   MC3672_cwake_sr_t;
 
 typedef enum
 {
-    MC3672_SNIFF_SR_DEFAULT_7Hz = 0b0000,
-    MC3672_SNIFF_SR_0p4Hz       = 0b0001,
-    MC3672_SNIFF_SR_0p8Hz       = 0b0010,
-    MC3672_SNIFF_SR_1p5Hz       = 0b0011,
-    MC3672_SNIFF_SR_7Hz         = 0b0100,
-    MC3672_SNIFF_SR_14Hz        = 0b0101,
-    MC3672_SNIFF_SR_28Hz        = 0b0110,
-    MC3672_SNIFF_SR_54Hz        = 0b0111,
-    MC3672_SNIFF_SR_105Hz       = 0b1000,
-    MC3672_SNIFF_SR_210Hz       = 0b1001,
-    MC3672_SNIFF_SR_400Hz       = 0b1010,
-    MC3672_SNIFF_SR_600Hz       = 0b1011,
-    MC3672_SNIFF_SR_END,
+  MC3672_SNIFF_SR_DEFAULT_7Hz = 0b0000,
+  MC3672_SNIFF_SR_0p4Hz       = 0b0001,
+  MC3672_SNIFF_SR_0p8Hz       = 0b0010,
+  MC3672_SNIFF_SR_1p5Hz       = 0b0011,
+  MC3672_SNIFF_SR_7Hz         = 0b0100,
+  MC3672_SNIFF_SR_14Hz        = 0b0101,
+  MC3672_SNIFF_SR_28Hz        = 0b0110,
+  MC3672_SNIFF_SR_54Hz        = 0b0111,
+  MC3672_SNIFF_SR_105Hz       = 0b1000,
+  MC3672_SNIFF_SR_210Hz       = 0b1001,
+  MC3672_SNIFF_SR_400Hz       = 0b1010,
+  MC3672_SNIFF_SR_600Hz       = 0b1011,
+  MC3672_SNIFF_SR_END,
 }   MC3672_sniff_sr_t;
 
 typedef enum
 {
-    MC3672_FIFO_CONTROL_DISABLE = 0,
-    MC3672_FIFO_CONTROL_ENABLE,
-    MC3672_FIFO_CONTROL_END,
+  MC3672_FIFO_CONTROL_DISABLE = 0,
+  MC3672_FIFO_CONTROL_ENABLE,
+  MC3672_FIFO_CONTROL_END,
 }   MC3672_fifo_control_t;
 
 typedef enum
 {
-    MC3672_FIFO_MODE_NORMAL = 0,
-    MC3672_FIFO_MODE_WATERMARK,
-    MC3672_FIFO_MODE_END,
+  MC3672_FIFO_MODE_NORMAL = 0,
+  MC3672_FIFO_MODE_WATERMARK,
+  MC3672_FIFO_MODE_END,
 }   MC3672_fifo_mode_t;
 
 typedef struct
 {
-    unsigned char    bWAKE;              // Sensor wakes from sniff mode.
-    unsigned char    bACQ;               // New sample is ready and acquired.
-    unsigned char    bFIFO_EMPTY;        // FIFO is empty.
-    unsigned char    bFIFO_FULL;         // FIFO is full.
-    unsigned char    bFIFO_THRESHOLD;    // FIFO sample count is equal to or greater than the threshold count.
-    unsigned char    bRESV;
-    unsigned char    baPadding[2];
+  unsigned char    bWAKE;              // Sensor wakes from sniff mode.
+  unsigned char    bACQ;               // New sample is ready and acquired.
+  unsigned char    bFIFO_EMPTY;        // FIFO is empty.
+  unsigned char    bFIFO_FULL;         // FIFO is full.
+  unsigned char    bFIFO_THRESHOLD;    // FIFO sample count is equal to or greater than the threshold count.
+  unsigned char    bRESV;
+  unsigned char    baPadding[2];
 }   MC3672_InterruptEvent;
 
 
 /****************************************************************************
  * Private Function Prototypes
  ****************************************************************************/
-static  uint8_t mc3672_readRegister8(FAR struct mc3672_dev_s *priv,uint8_t reg);
+static  uint8_t mc3672_readRegister8(FAR struct mc3672_dev_s *priv, uint8_t reg);
 static void mc3672_writeRegister8(FAR struct mc3672_dev_s *priv, uint8_t reg, uint8_t value);
-static int mc3672_readRegisters(FAR struct mc3672_dev_s *priv,uint8_t reg, uint8_t* buffer, uint8_t len);
+static int mc3672_readRegisters(FAR struct mc3672_dev_s *priv, uint8_t reg, uint8_t *buffer, uint8_t len);
 static int mc3672_open(FAR struct file *filep);
 static int mc3672_close(FAR struct file *filep);
-static ssize_t mc3672_read(FAR struct file *filep, FAR char *buffer,size_t buflen);
-static ssize_t mc3672_write(FAR struct file *filep, FAR const char *buffer,size_t buflen);
+static ssize_t mc3672_read(FAR struct file *filep, FAR char *buffer, size_t buflen);
+static ssize_t mc3672_write(FAR struct file *filep, FAR const char *buffer, size_t buflen);
 static ssize_t mc3672_ioctl(FAR struct file *filep, int cmd, unsigned long arg);
 
 /****************************************************************************
@@ -297,7 +297,7 @@ static sn_ga_param_s g_param =
   .mode = MC3672_CFG_GA_MODE_DEFAULT
 };
 
-uint8_t CfgRange, CfgResolution, CfgSampRate;	
+uint8_t CfgRange, CfgResolution, CfgSampRate;
 MC3672_acc_t AccRaw; // Raw Accelerometer data
 
 
@@ -310,13 +310,13 @@ MC3672_acc_t AccRaw; // Raw Accelerometer data
  ****************************************************************************/
 
 // Read 8-bit from register
-static  uint8_t mc3672_readRegister8(FAR struct mc3672_dev_s *priv,uint8_t reg)
+static  uint8_t mc3672_readRegister8(FAR struct mc3672_dev_s *priv, uint8_t reg)
 {
-    uint8_t value;
-	
-#ifdef MC3672_CFG_BUS_I2C 	
+  uint8_t value;
+
+#ifdef MC3672_CFG_BUS_I2C
   int ret;
-  
+
   struct i2c_msg_s msg[2];
 
   /* Setup 8-bit MC3672 address write message */
@@ -330,8 +330,8 @@ static  uint8_t mc3672_readRegister8(FAR struct mc3672_dev_s *priv,uint8_t reg)
 
   /* Set up the 8-bit MC3672 data read message */
 
-  msg[1].frequency = priv->freq; 	/* I2C frequency */
-  msg[1].addr      = priv->addr;   	/* 7-bit address */
+  msg[1].frequency = priv->freq;  /* I2C frequency */
+  msg[1].addr      = priv->addr;    /* 7-bit address */
   msg[1].flags     = I2C_M_READ;    /* Read transaction, beginning with Re-START */
   msg[1].buffer    = &value;        /* Transfer to this address */
   msg[1].length    = 1;             /* Receive 1 bytesfollowing the address
@@ -345,17 +345,17 @@ static  uint8_t mc3672_readRegister8(FAR struct mc3672_dev_s *priv,uint8_t reg)
       snerr("ERROR: I2C_TRANSFER failed: %d\n", ret);
       return 0;
     }
-	
+
 
 #else  //Reads an 8-bit register with the SPI port.
-	digitalWrite(chipSelectPin, LOW); 	//Set active-low CS low to start the SPI cycle
-	SPI.transfer(reg | 0x80 | 0x40); 	//Send the register address
-	value = SPI.transfer(0x00); 		//Read the value from the register
-	digitalWrite(chipSelectPin, HIGH); 	//Raise CS
-#endif	
+  digitalWrite(chipSelectPin, LOW);   //Set active-low CS low to start the SPI cycle
+  SPI.transfer(reg | 0x80 | 0x40);  //Send the register address
+  value = SPI.transfer(0x00);     //Read the value from the register
+  digitalWrite(chipSelectPin, HIGH);  //Raise CS
+#endif
 
-    return value;
-} 
+  return value;
+}
 
 /****************************************************************************
  * Name: mc3672_writeRegister8
@@ -366,7 +366,7 @@ static  uint8_t mc3672_readRegister8(FAR struct mc3672_dev_s *priv,uint8_t reg)
  ****************************************************************************/
 static void mc3672_writeRegister8(FAR struct mc3672_dev_s *priv, uint8_t reg, uint8_t value)
 {
-#ifdef MC3672_CFG_BUS_I2C	
+#ifdef MC3672_CFG_BUS_I2C
   struct i2c_config_s config;
   uint8_t data[2];
   int ret;
@@ -389,11 +389,11 @@ static void mc3672_writeRegister8(FAR struct mc3672_dev_s *priv, uint8_t reg, ui
       return;
     }
 #else
-	digitalWrite(chipSelectPin, LOW); 	//Set active-low CS low to start the SPI cycle
-	SPI.transfer(reg | 0x40); 		//Send the register address
-	SPI.transfer(value);  			//Send value to write into register
-	digitalWrite(chipSelectPin, HIGH); 	//Raise CS
-#endif	
+  digitalWrite(chipSelectPin, LOW);   //Set active-low CS low to start the SPI cycle
+  SPI.transfer(reg | 0x40);     //Send the register address
+  SPI.transfer(value);        //Send value to write into register
+  digitalWrite(chipSelectPin, HIGH);  //Raise CS
+#endif
 }
 
 /*
@@ -418,7 +418,7 @@ static void mc3672_writeRegisterBit(uint8_t reg, uint8_t pos, bool state)
 
     writeRegister8(reg, value);
 }
-*/
+ */
 
 
 /****************************************************************************
@@ -429,9 +429,9 @@ static void mc3672_writeRegisterBit(uint8_t reg, uint8_t pos, bool state)
  *
  ****************************************************************************/
 // Repeated Read Byte(s) from register
-static int mc3672_readRegisters(FAR struct mc3672_dev_s *priv,uint8_t reg, uint8_t* buffer, uint8_t len)
+static int mc3672_readRegisters(FAR struct mc3672_dev_s *priv, uint8_t reg, uint8_t *buffer, uint8_t len)
 {
-#ifdef MC3672_CFG_BUS_I2C 	
+#ifdef MC3672_CFG_BUS_I2C
   int ret;
   struct i2c_msg_s msg[2];
 
@@ -446,8 +446,8 @@ static int mc3672_readRegisters(FAR struct mc3672_dev_s *priv,uint8_t reg, uint8
 
   /* Set up the 8-bit MC3672 data read message */
 
-  msg[1].frequency = priv->freq; 	/* I2C frequency */
-  msg[1].addr      = priv->addr;   	/* 7-bit address */
+  msg[1].frequency = priv->freq;  /* I2C frequency */
+  msg[1].addr      = priv->addr;    /* 7-bit address */
   msg[1].flags     = I2C_M_READ;    /* Read transaction, beginning with Re-START */
   msg[1].buffer    = buffer;        /* Transfer to this address */
   msg[1].length    = len;           /* Receive bytes following the address
@@ -458,40 +458,43 @@ static int mc3672_readRegisters(FAR struct mc3672_dev_s *priv,uint8_t reg, uint8
   ret = I2C_TRANSFER(priv->i2c, msg, 2);
   if (ret < 0)
     {
-	  while(1) {
-	  }
+      while (1)
+        {
+        }
       snerr("ERROR: I2C_TRANSFER failed: %d\n", ret);
       return ret;
     }
 #else
-	digitalWrite(chipSelectPin, LOW); 		//Set active-low CS low to start the SPI cycle
-	SPI.transfer(reg | 0x80 | 0x40); 		//send the device the register you want to read
-	
-	for(int cnt = 0 ; cnt < len ; cnt++)              	//Prepare to clock in the data to be read
-		buffer[cnt] = SPI.transfer(0x00);
-	digitalWrite(chipSelectPin, HIGH); 		//Raise CS
-#endif	
-   return OK;
+  digitalWrite(chipSelectPin, LOW);     //Set active-low CS low to start the SPI cycle
+  SPI.transfer(reg | 0x80 | 0x40);    //send the device the register you want to read
+
+  for (int cnt = 0 ; cnt < len ; cnt++)               //Prepare to clock in the data to be read
+    {
+      buffer[cnt] = SPI.transfer(0x00);
+    }
+  digitalWrite(chipSelectPin, HIGH);    //Raise CS
+#endif
+  return OK;
 }
 
 /****************************************************************************
  * Public Functions
  ****************************************************************************/
- 
+
 /****************************************************************************
  * Name: mc3672_SetMode
  *
  * Description:
  *   Set the operation mode
  *
- ****************************************************************************/  
-void mc3672_SetMode(FAR struct mc3672_dev_s *priv,MC3672_mode_t mode)
+ ****************************************************************************/
+void mc3672_SetMode(FAR struct mc3672_dev_s *priv, MC3672_mode_t mode)
 {
-    uint8_t value;
-    value = mc3672_readRegister8(priv,MC3672_REG_MODE_C);
-    value &= 0b11110000;
-    value |= mode;
-    mc3672_writeRegister8(priv,MC3672_REG_MODE_C, value);
+  uint8_t value;
+  value = mc3672_readRegister8(priv, MC3672_REG_MODE_C);
+  value &= 0b11110000;
+  value |= mode;
+  mc3672_writeRegister8(priv, MC3672_REG_MODE_C, value);
 }
 
 /****************************************************************************
@@ -500,16 +503,16 @@ void mc3672_SetMode(FAR struct mc3672_dev_s *priv,MC3672_mode_t mode)
  * Description:
  *   Set the range control
  *
- ****************************************************************************/  
-void mc3672_SetRangeCtrl(FAR struct mc3672_dev_s *priv,MC3672_range_t range)
+ ****************************************************************************/
+void mc3672_SetRangeCtrl(FAR struct mc3672_dev_s *priv, MC3672_range_t range)
 {
-    uint8_t value;    
-    CfgRange = range;
-    mc3672_SetMode(priv,MC3672_MODE_STANDBY);
-    value = mc3672_readRegister8(priv,MC3672_REG_RANGE_C);
-    value &= 0b00000111;
-    value |= (range << 4)&0x70 ;
-    mc3672_writeRegister8(priv,MC3672_REG_RANGE_C, value);
+  uint8_t value;
+  CfgRange = range;
+  mc3672_SetMode(priv, MC3672_MODE_STANDBY);
+  value = mc3672_readRegister8(priv, MC3672_REG_RANGE_C);
+  value &= 0b00000111;
+  value |= (range << 4) & 0x70 ;
+  mc3672_writeRegister8(priv, MC3672_REG_RANGE_C, value);
 }
 
 /****************************************************************************
@@ -518,50 +521,50 @@ void mc3672_SetRangeCtrl(FAR struct mc3672_dev_s *priv,MC3672_range_t range)
  * Description:
  *   Initial reset
  *
- ****************************************************************************/  
+ ****************************************************************************/
 void mc3672_reset(FAR struct mc3672_dev_s *priv)
 {
-    mc3672_writeRegister8(priv,0x10, 0x01);
-	
-	up_mdelay(10);
-	
-	mc3672_writeRegister8(priv,0x24, 0x40);
-
-	up_mdelay(50);	
-	
-	mc3672_writeRegister8(priv,0x09, 0x00); 
-	up_mdelay(10);
-	mc3672_writeRegister8(priv,0x0F, 0x42);
-	up_mdelay(10);
-	mc3672_writeRegister8(priv,0x20, 0x01);
-	up_mdelay(10);
-	mc3672_writeRegister8(priv,0x21, 0x80);
-	up_mdelay(10);
-	mc3672_writeRegister8(priv,0x28, 0x00);
-	up_mdelay(10);
-	mc3672_writeRegister8(priv,0x1a, 0x00);	
-	
-	up_mdelay(50);	
-	
-	uint8_t _bRegIO_C = 0;
-
-	_bRegIO_C = mc3672_readRegister8(priv,0x0D);
-
-	#ifdef MC3672_CFG_BUS_I2C
-		_bRegIO_C &= 0x3F;
-		_bRegIO_C |= 0x40;
-	#else   
-		_bRegIO_C &= 0x3F;
-		_bRegIO_C |= 0x80;
-	#endif
-
-	mc3672_writeRegister8(priv,0x0D, _bRegIO_C);
-	
-	up_mdelay(50);
-
-	mc3672_writeRegister8(priv,0x10, 0x01);
-	
-	up_mdelay(10);
+  mc3672_writeRegister8(priv, 0x10, 0x01);
+
+  up_mdelay(10);
+
+  mc3672_writeRegister8(priv, 0x24, 0x40);
+
+  up_mdelay(50);
+
+  mc3672_writeRegister8(priv, 0x09, 0x00);
+  up_mdelay(10);
+  mc3672_writeRegister8(priv, 0x0F, 0x42);
+  up_mdelay(10);
+  mc3672_writeRegister8(priv, 0x20, 0x01);
+  up_mdelay(10);
+  mc3672_writeRegister8(priv, 0x21, 0x80);
+  up_mdelay(10);
+  mc3672_writeRegister8(priv, 0x28, 0x00);
+  up_mdelay(10);
+  mc3672_writeRegister8(priv, 0x1a, 0x00);
+
+  up_mdelay(50);
+
+  uint8_t _bRegIO_C = 0;
+
+  _bRegIO_C = mc3672_readRegister8(priv, 0x0D);
+
+#ifdef MC3672_CFG_BUS_I2C
+  _bRegIO_C &= 0x3F;
+  _bRegIO_C |= 0x40;
+#else
+  _bRegIO_C &= 0x3F;
+  _bRegIO_C |= 0x80;
+#endif
+
+  mc3672_writeRegister8(priv, 0x0D, _bRegIO_C);
+
+  up_mdelay(50);
+
+  mc3672_writeRegister8(priv, 0x10, 0x01);
+
+  up_mdelay(10);
 }
 
 /****************************************************************************
@@ -570,15 +573,15 @@ void mc3672_reset(FAR struct mc3672_dev_s *priv)
  * Description:
  *   Set Sniff Analog Gain
  *
- ****************************************************************************/  
-void mc3672_SetSniffAGAIN(FAR struct mc3672_dev_s *priv,MC3672_gain_t gain)
+ ****************************************************************************/
+void mc3672_SetSniffAGAIN(FAR struct mc3672_dev_s *priv, MC3672_gain_t gain)
 {
-    mc3672_writeRegister8(priv,0x20, 0x00);
-    uint8_t value;
-    value = mc3672_readRegister8(priv,MC3672_REG_GAIN);
-    value &= 0b00111111;
-    value |= (gain << 6);
-    mc3672_writeRegister8(priv,MC3672_REG_GAIN, value);
+  mc3672_writeRegister8(priv, 0x20, 0x00);
+  uint8_t value;
+  value = mc3672_readRegister8(priv, MC3672_REG_GAIN);
+  value &= 0b00111111;
+  value |= (gain << 6);
+  mc3672_writeRegister8(priv, MC3672_REG_GAIN, value);
 }
 
 /****************************************************************************
@@ -587,15 +590,15 @@ void mc3672_SetSniffAGAIN(FAR struct mc3672_dev_s *priv,MC3672_gain_t gain)
  * Description:
  *   Set CWake Analog Gain
  *
- ****************************************************************************/  
-void mc3672_SetWakeAGAIN(FAR struct mc3672_dev_s *priv,MC3672_gain_t gain)
+ ****************************************************************************/
+void mc3672_SetWakeAGAIN(FAR struct mc3672_dev_s *priv, MC3672_gain_t gain)
 {
-    mc3672_writeRegister8(priv,0x20, 0x01);
-    uint8_t value;
-    value = mc3672_readRegister8(priv,MC3672_REG_GAIN);
-    value &= 0b00111111;
-    value |= (gain << 6);
-    mc3672_writeRegister8(priv,MC3672_REG_GAIN, value);
+  mc3672_writeRegister8(priv, 0x20, 0x01);
+  uint8_t value;
+  value = mc3672_readRegister8(priv, MC3672_REG_GAIN);
+  value &= 0b00111111;
+  value |= (gain << 6);
+  mc3672_writeRegister8(priv, MC3672_REG_GAIN, value);
 }
 
 /****************************************************************************
@@ -604,16 +607,16 @@ void mc3672_SetWakeAGAIN(FAR struct mc3672_dev_s *priv,MC3672_gain_t gain)
  * Description:
  *   Set the resolution control
  *
- ****************************************************************************/  
-void mc3672_SetResolutionCtrl(FAR struct mc3672_dev_s *priv,MC3672_resolution_t resolution)
+ ****************************************************************************/
+void mc3672_SetResolutionCtrl(FAR struct mc3672_dev_s *priv, MC3672_resolution_t resolution)
 {
-	uint8_t value;
-	CfgResolution = resolution;
-	mc3672_SetMode(priv,MC3672_MODE_STANDBY);
-	value = mc3672_readRegister8(priv,MC3672_REG_RANGE_C);
-	value &= 0b01110000;
-	value |= resolution;
-	mc3672_writeRegister8(priv,MC3672_REG_RANGE_C, value);
+  uint8_t value;
+  CfgResolution = resolution;
+  mc3672_SetMode(priv, MC3672_MODE_STANDBY);
+  value = mc3672_readRegister8(priv, MC3672_REG_RANGE_C);
+  value &= 0b01110000;
+  value |= resolution;
+  mc3672_writeRegister8(priv, MC3672_REG_RANGE_C, value);
 }
 
 
@@ -623,15 +626,15 @@ void mc3672_SetResolutionCtrl(FAR struct mc3672_dev_s *priv,MC3672_resolution_t
  * Description:
  *   Set the sampling rate
  *
- ****************************************************************************/  
-void mc3672_SetCWakeSampleRate(FAR struct mc3672_dev_s *priv,MC3672_cwake_sr_t sample_rate)
+ ****************************************************************************/
+void mc3672_SetCWakeSampleRate(FAR struct mc3672_dev_s *priv, MC3672_cwake_sr_t sample_rate)
 {
-	uint8_t value;
-	mc3672_SetMode(priv,MC3672_MODE_STANDBY);
-	value = mc3672_readRegister8(priv,MC3672_REG_WAKE_C); 
-	value &= 0b00000000;
-	value |= sample_rate;
-	mc3672_writeRegister8(priv,MC3672_REG_WAKE_C, value);
+  uint8_t value;
+  mc3672_SetMode(priv, MC3672_MODE_STANDBY);
+  value = mc3672_readRegister8(priv, MC3672_REG_WAKE_C);
+  value &= 0b00000000;
+  value |= sample_rate;
+  mc3672_writeRegister8(priv, MC3672_REG_WAKE_C, value);
 }
 
 /****************************************************************************
@@ -640,14 +643,14 @@ void mc3672_SetCWakeSampleRate(FAR struct mc3672_dev_s *priv,MC3672_cwake_sr_t s
  * Description:
  *   Get the output sampling rate
  *
- ****************************************************************************/  
+ ****************************************************************************/
 MC3672_cwake_sr_t mc3672_GetCWakeSampleRate(FAR struct mc3672_dev_s *priv)
 {
-	/* Read the data format register to preserve bits */
-	uint8_t value;
-	value = mc3672_readRegister8(priv,MC3672_REG_WAKE_C);
-	value &= 0b00001111;
-	return (MC3672_cwake_sr_t) (value);
+  /* Read the data format register to preserve bits */
+  uint8_t value;
+  value = mc3672_readRegister8(priv, MC3672_REG_WAKE_C);
+  value &= 0b00001111;
+  return (MC3672_cwake_sr_t) (value);
 }
 
 /****************************************************************************
@@ -656,15 +659,15 @@ MC3672_cwake_sr_t mc3672_GetCWakeSampleRate(FAR struct mc3672_dev_s *priv)
  * Description:
  *   Get the output sampling rate
  *
- ****************************************************************************/  
+ ****************************************************************************/
 //Get the range control
 MC3672_range_t mc3672_GetRangeCtrl(FAR struct mc3672_dev_s *priv)
 {
-	/* Read the data format register to preserve bits */
-	uint8_t value;
-	value = mc3672_readRegister8(priv,MC3672_REG_RANGE_C);
-	value &= 0x70;
-	return (MC3672_range_t) (value >> 4);
+  /* Read the data format register to preserve bits */
+  uint8_t value;
+  value = mc3672_readRegister8(priv, MC3672_REG_RANGE_C);
+  value &= 0x70;
+  return (MC3672_range_t) (value >> 4);
 }
 
 /****************************************************************************
@@ -673,14 +676,14 @@ MC3672_range_t mc3672_GetRangeCtrl(FAR struct mc3672_dev_s *priv)
  * Description:
  *   Get the range control
  *
- ****************************************************************************/ 
+ ****************************************************************************/
 MC3672_resolution_t mc3672_GetResolutionCtrl(FAR struct mc3672_dev_s *priv)
 {
-	/* Read the data format register to preserve bits */
-	uint8_t value;
-	value = mc3672_readRegister8(priv,MC3672_REG_RANGE_C);
-	value &= 0x07;
-	return (MC3672_resolution_t) (value);
+  /* Read the data format register to preserve bits */
+  uint8_t value;
+  value = mc3672_readRegister8(priv, MC3672_REG_RANGE_C);
+  value &= 0x07;
+  return (MC3672_resolution_t) (value);
 }
 
 /****************************************************************************
@@ -689,46 +692,46 @@ MC3672_resolution_t mc3672_GetResolutionCtrl(FAR struct mc3672_dev_s *priv)
  * Description:
  *   Initialize the MC3672 sensor and set as the default configuration
  *
- ****************************************************************************/ 
+ ****************************************************************************/
 bool mc3672_start(FAR struct mc3672_dev_s *priv)
-{ 
-    volatile uint8_t id = 0;
-	//Init Reset
-	mc3672_reset(priv);
-	mc3672_SetMode(priv,MC3672_MODE_STANDBY);
-
-	//SetWakeAGAIN
-	mc3672_SetWakeAGAIN(priv,MC3672_GAIN_1X);
-	//SetSniffAGAIN
-	mc3672_SetSniffAGAIN(priv,MC3672_GAIN_1X);	
-
-	/* Check I2C connection */
-	id = mc3672_readRegister8(priv,MC3672_REG_PROD);
-	if ((id != 0x71) && (id != 0x70))
-	{
-		/* No MC3672 detected ... return false */
-		return -ENODEV;
-	}
+{
+  volatile uint8_t id = 0;
+  //Init Reset
+  mc3672_reset(priv);
+  mc3672_SetMode(priv, MC3672_MODE_STANDBY);
+
+  //SetWakeAGAIN
+  mc3672_SetWakeAGAIN(priv, MC3672_GAIN_1X);
+  //SetSniffAGAIN
+  mc3672_SetSniffAGAIN(priv, MC3672_GAIN_1X);
+
+  /* Check I2C connection */
+  id = mc3672_readRegister8(priv, MC3672_REG_PROD);
+  if ((id != 0x71) && (id != 0x70))
+    {
+      /* No MC3672 detected ... return false */
+      return -ENODEV;
+    }
 
-	/* Range: 8g */
+  /* Range: 8g */
 
-	mc3672_SetRangeCtrl(priv,MC3672_CFG_RANGE_DEFAULT);
+  mc3672_SetRangeCtrl(priv, MC3672_CFG_RANGE_DEFAULT);
 
   /* Resolution: 14bit */
 
-	mc3672_SetResolutionCtrl(priv,MC3672_CFG_RESOLUTION_DEFAULT);
+  mc3672_SetResolutionCtrl(priv, MC3672_CFG_RESOLUTION_DEFAULT);
 
- 	/* Sampling Rate: 50Hz */
+  /* Sampling Rate: 50Hz */
 
-	mc3672_SetCWakeSampleRate(priv,MC3672_CFG_SAMPLE_RATE_CWAKE_DEFAULT);
+  mc3672_SetCWakeSampleRate(priv, MC3672_CFG_SAMPLE_RATE_CWAKE_DEFAULT);
 
   /* Mode: Active */
 
-	mc3672_SetMode(priv,MC3672_CFG_MODE_DEFAULT);
+  mc3672_SetMode(priv, MC3672_CFG_MODE_DEFAULT);
 
-	up_mdelay(50);	  
-	  
-	return OK;
+  up_mdelay(50);
+
+  return OK;
 }
 
 /****************************************************************************
@@ -737,10 +740,10 @@ bool mc3672_start(FAR struct mc3672_dev_s *priv)
  * Description:
  *   stop the mc3672 sensor
  *
- ****************************************************************************/ 
+ ****************************************************************************/
 void mc3672_stop(FAR struct mc3672_dev_s *priv)
 {
-	mc3672_SetMode(priv,MC3672_MODE_SLEEP); //Set mode as Sleep
+  mc3672_SetMode(priv, MC3672_MODE_SLEEP); //Set mode as Sleep
 }
 
 /****************************************************************************
@@ -749,37 +752,37 @@ void mc3672_stop(FAR struct mc3672_dev_s *priv)
  * Description:
  *   Read the raw counts and SI units mearsurement data
  *
- ****************************************************************************/ 
+ ****************************************************************************/
 static int mc3672_readRawAccel(FAR struct mc3672_dev_s *priv, MC3672_acc_t *raw)
 {
-	float faRange[5] = { 19.614f, 39.228f, 78.456f, 156.912f, 117.684f}; //{2g, 4g, 8g, 16g, 12g}
-	float faResolution[6] = { 32.0f, 64.0f, 128.0f, 512.0f, 2048.0f, 8192.0f}; //{6bit, 7bit, 8bit, 10bit, 12bit, 14bit}
+  float faRange[5] = { 19.614f, 39.228f, 78.456f, 156.912f, 117.684f}; //{2g, 4g, 8g, 16g, 12g}
+  float faResolution[6] = { 32.0f, 64.0f, 128.0f, 512.0f, 2048.0f, 8192.0f}; //{6bit, 7bit, 8bit, 10bit, 12bit, 14bit}
   short mc3672_x, mc3672_y, mc3672_z;
   int ret = -1;
-	uint8_t rawData[6];
+  uint8_t rawData[6];
 
   /* Read the six raw data registers into data array */
-  
-	ret = mc3672_readRegisters(priv,MC3672_REG_XOUT_LSB, rawData, 6);
 
-  if(OK == ret)
+  ret = mc3672_readRegisters(priv, MC3672_REG_XOUT_LSB, rawData, 6);
+
+  if (OK == ret)
     {
       mc3672_x = (short)((((unsigned short)rawData[1]) << 8) | rawData[0]);
-    	mc3672_y = (short)((((unsigned short)rawData[3]) << 8) | rawData[2]);
-    	mc3672_z = (short)((((unsigned short)rawData[5]) << 8) | rawData[4]);
+      mc3672_y = (short)((((unsigned short)rawData[3]) << 8) | rawData[2]);
+      mc3672_z = (short)((((unsigned short)rawData[5]) << 8) | rawData[4]);
 
-    	raw->XAxis = (short) (mc3672_x);
-    	raw->YAxis = (short) (mc3672_y);
-    	raw->ZAxis = (short) (mc3672_z);
-    	raw->XAxis_g = (float) (mc3672_x)*faRange[CfgRange] / faResolution[CfgResolution];
-    	raw->YAxis_g = (float) (mc3672_y)*faRange[CfgRange] / faResolution[CfgResolution];
-    	raw->ZAxis_g = (float) (mc3672_z)*faRange[CfgRange] / faResolution[CfgResolution];
+      raw->XAxis = (short) (mc3672_x);
+      raw->YAxis = (short) (mc3672_y);
+      raw->ZAxis = (short) (mc3672_z);
+      raw->XAxis_g = (float) (mc3672_x) * faRange[CfgRange] / faResolution[CfgResolution];
+      raw->YAxis_g = (float) (mc3672_y) * faRange[CfgRange] / faResolution[CfgResolution];
+      raw->ZAxis_g = (float) (mc3672_z) * faRange[CfgRange] / faResolution[CfgResolution];
 
 
       ret = sizeof(MC3672_acc_t);
-      sninfo("%S: read %d data\n",__FUNCTION__, ret);
+      sninfo("%S: read %d data\n", __FUNCTION__, ret);
     }
-	return ret;
+  return ret;
 }
 
 /****************************************************************************
@@ -842,7 +845,7 @@ static int mc3672_open(FAR struct file *filep)
   FAR struct inode        *inode = filep->f_inode;
   FAR struct mc3672_dev_s *priv  = inode->i_private;
   int ret = 0;
-  
+
   /* Check Device ID */
   ret = mc3672_start(priv);
   if (ret < 0)
@@ -895,16 +898,16 @@ static ssize_t mc3672_read(FAR struct file *filep, FAR char *buffer,
 
   if (buflen != sizeof(MC3672_acc_t))
     {
-      snerr("ERROR: You can't read something other than %d\n",sizeof(MC3672_acc_t));
+      snerr("ERROR: You can't read something other than %d\n", sizeof(MC3672_acc_t));
       return -EINVAL;
     }
 
   /* Initialize the memory */
 
-  memset((uint8_t*)raw,0x00,sizeof(MC3672_acc_t));
+  memset((uint8_t *)raw, 0x00, sizeof(MC3672_acc_t));
 
   /* Get the raw accelerometer values */
-  
+
   len = mc3672_readRawAccel(priv, raw);
 
   return len;
@@ -930,13 +933,13 @@ static ssize_t mc3672_ioctl(FAR struct file *filep, int cmd, unsigned long arg)
   FAR struct mc3672_dev_s *priv  = inode->i_private;
   ssize_t ret = -ENOSYS;
 
-  if(NULL== (void *)arg)
+  if (NULL == (void *)arg)
     {
       snerr("[%s]: parameter is NULL.\n", __FUNCTION__);
       return -EINVAL;
     }
 
-  switch(cmd)
+  switch (cmd)
     {
       case SNIOC_GA_SPARAM:
         {
@@ -946,8 +949,8 @@ static ssize_t mc3672_ioctl(FAR struct file *filep, int cmd, unsigned long arg)
           MC3672_cwake_sr_t rate;
 
           sninfo("Set: range:%d, resolution:%d, Samplerate:%d, mode:%d\n",
-            param->range, param->resolution, param->sample_rate, param->mode);
-          switch(param->range)
+                 param->range, param->resolution, param->sample_rate, param->mode);
+          switch (param->range)
             {
               case GA_RANGE_2G:
                 range = MC3672_RANGE_2G;
@@ -970,7 +973,7 @@ static ssize_t mc3672_ioctl(FAR struct file *filep, int cmd, unsigned long arg)
 
             }
 
-          switch(param->resolution)
+          switch (param->resolution)
             {
               case GA_RESOLUTION_6BIT:
                 resolution = MC3672_RESOLUTION_6BIT;
@@ -993,7 +996,7 @@ static ssize_t mc3672_ioctl(FAR struct file *filep, int cmd, unsigned long arg)
 
             }
 
-          switch(param->sample_rate)
+          switch (param->sample_rate)
             {
               case GA_SAMPRATE_25Hz:
                 rate = MC3672_CWAKE_SR_28Hz;
@@ -1014,9 +1017,9 @@ static ssize_t mc3672_ioctl(FAR struct file *filep, int cmd, unsigned long arg)
             }
 
           memcpy(&g_param, param, sizeof(sn_ga_param_s));
-        	mc3672_SetRangeCtrl(priv, range);
-        	mc3672_SetResolutionCtrl(priv, resolution);
-        	mc3672_SetCWakeSampleRate(priv, rate);
+          mc3672_SetRangeCtrl(priv, range);
+          mc3672_SetResolutionCtrl(priv, resolution);
+          mc3672_SetCWakeSampleRate(priv, rate);
           ret = OK;
         }
         break;
@@ -1026,30 +1029,30 @@ static ssize_t mc3672_ioctl(FAR struct file *filep, int cmd, unsigned long arg)
 
           memcpy(param, &g_param, sizeof(sn_ga_param_s));
           sninfo("Get: range:%d, resolution:%d, Samplerate:%d, mode:%d\n",
-            param->range, param->resolution, param->sample_rate, param->mode);
+                 param->range, param->resolution, param->sample_rate, param->mode);
 
           ret = OK;
         }
         break;
       case SNIOC_GA_GRAW:
         {
-            sn_ga_raw_s *raw = (sn_ga_raw_s *)arg;
-            uint8_t rawData[6];
-
-            /* Read the six raw data registers into data array */
-
-            ret = mc3672_readRegisters(priv,MC3672_REG_XOUT_LSB, rawData, 6);
-            if (OK == ret)
-              {
-                raw->x_axis = (short)(((uint16_t)rawData[1] << 8) | rawData[0]);
-                raw->y_axis = (short)(((uint16_t)rawData[3] << 8) | rawData[2]);
-                raw->z_axis = (short)(((uint16_t)rawData[5] << 8) | rawData[4]);
-              }
-            else
-              {
-                snerr("[%s] Read Raw Data Error [%d]\n", __FUNCTION__, ret);
-                return ret;
-              }
+          sn_ga_raw_s *raw = (sn_ga_raw_s *)arg;
+          uint8_t rawData[6];
+
+          /* Read the six raw data registers into data array */
+
+          ret = mc3672_readRegisters(priv, MC3672_REG_XOUT_LSB, rawData, 6);
+          if (OK == ret)
+            {
+              raw->x_axis = (short)(((uint16_t)rawData[1] << 8) | rawData[0]);
+              raw->y_axis = (short)(((uint16_t)rawData[3] << 8) | rawData[2]);
+              raw->z_axis = (short)(((uint16_t)rawData[5] << 8) | rawData[4]);
+            }
+          else
+            {
+              snerr("[%s] Read Raw Data Error [%d]\n", __FUNCTION__, ret);
+              return ret;
+            }
         }
         break;
       default:
diff --git a/drivers/timers/Kconfig b/drivers/timers/Kconfig
old mode 100644
new mode 100755
index 164234741c..8e04cf837a
--- a/drivers/timers/Kconfig
+++ b/drivers/timers/Kconfig
@@ -21,14 +21,6 @@ config ONESHOT
 		driver. See include/nuttx/timers/oneshot.h for further oneshot timer
 		driver information.
 
-config COUNTER
-	bool "Counter Support"
-	default n
-	---help---
-		This selection enables building of the "upper-half" counter
-		driver. See include/nuttx/timers/counter.h for further counter driver
-		information.
-
 menuconfig RTC
 	bool "RTC Driver Support"
 	default n
@@ -79,6 +71,20 @@ config RTC_FREQUENCY
 
 endif # !RTC_DATETIME
 
+config COUNTER
+	bool "Counter Support"
+	default n
+	---help---
+		This selection enables building of the "upper-half" counter
+		driver. See include/nuttx/timers/counter.h for further counter driver
+		information.
+		
+config RTC_TICKS
+	bool "RTC Ticks Support"
+	default n
+	---help---
+		This selection enables RTC TICKS
+
 config RTC_ALARM
 	bool "RTC Alarm Support"
 	default n
diff --git a/drivers/timers/counter.c b/drivers/timers/counter.c
old mode 100644
new mode 100755
index d2b57e48b9..12646c5614
--- a/drivers/timers/counter.c
+++ b/drivers/timers/counter.c
@@ -85,11 +85,11 @@ static bool    rtc_notifier(FAR uint32_t *next_interval_us, FAR void *arg);
 static int     rtc_open(FAR struct file *filep);
 static int     rtc_close(FAR struct file *filep);
 static ssize_t rtc_read(FAR struct file *filep, FAR char *buffer,
-                 size_t buflen);
+                        size_t buflen);
 static ssize_t rtc_write(FAR struct file *filep, FAR const char *buffer,
-                 size_t buflen);
+                         size_t buflen);
 static int     rtc_ioctl(FAR struct file *filep, int cmd,
-                 unsigned long arg);
+                         unsigned long arg);
 
 /****************************************************************************
  * Private Data
@@ -171,7 +171,7 @@ static int rtc_open(FAR struct file *filep)
   if (tmp == 0)
     {
       /* More than 255 opens; uint8_t overflows to zero */
-      
+
       ret = -EMFILE;
       goto errout;
     }
@@ -235,7 +235,7 @@ static ssize_t rtc_read(FAR struct file *filep, FAR char *buffer, size_t buflen)
  ************************************************************************************/
 
 static ssize_t rtc_write(FAR struct file *filep, FAR const char *buffer,
-                           size_t buflen)
+                         size_t buflen)
 {
   return 0;
 }
@@ -262,148 +262,148 @@ static int rtc_ioctl(FAR struct file *filep, int cmd, unsigned long arg)
 
   switch (cmd)
     {
-    /* cmd:         TCIOC_START
-     * Description: Start the rtc
-     * Argument:    Ignored
-     */
-
-    case TCIOC_START:
-      {
-        /* Start the rtc, resetting the time to the current timeout */
-
-        if (lower->ops->start)
-          {
-            ret = lower->ops->start(lower);
-          }
-        else
-          {
-            ret = -ENOSYS;
-          }
-      }
-      break;
-
-    /* cmd:         TCIOC_STOP
-     * Description: Stop the rtc
-     * Argument:    Ignored
-     */
-
-    case TCIOC_STOP:
-      {
-        /* Stop the rtc */
-
-        if (lower->ops->stop)
-          {
-            ret = lower->ops->stop(lower);
-          }
-        else
-          {
-            ret = -ENOSYS;
-          }
-      }
-      break;
-
-    /* cmd:         TCIOC_GETSTATUS
-     * Description: Get the status of the rtc.
-     * Argument:    A writeable pointer to struct rtc_status_s.
-     */
-
-    case TCIOC_GETSTATUS:
-      {
-        FAR struct rtc_status_s *status;
-
-        /* Get the current rtc status */
-
-        if (lower->ops->getstatus) /* Optional */
-          {
-            status = (FAR struct rtc_status_s *)((uintptr_t)arg);
-            if (status)
-              {
-                ret = lower->ops->getstatus(lower, status);
-              }
-            else
-              {
-                ret = -EINVAL;
-              }
-          }
-        else
-          {
-            ret = -ENOSYS;
-          }
-      }
-      break;
-
-    /* cmd:         TCIOC_SETTIMEOUT
-     * Description: Reset the timeout to this value
-     * Argument:    A 32-bit timeout value in microseconds.
-     *
-     * TODO: pass pointer to uint64 ns? Need to determine if these RTCs
-     * are 16 or 32 bit...
-     */
-
-    case TCIOC_SETTIMEOUT:
-      {
-        /* Set a new timeout value (and reset the rtc) */
-
-        if (lower->ops->settimeout) /* Optional */
-          {
-            ret = lower->ops->settimeout(lower, (uint32_t)arg);
-          }
-        else
-          {
-            ret = -ENOSYS;
-          }
-      }
-      break;
-
-    /* cmd:         TCIOC_NOTIFICATION
-     * Description: Notify application via a signal when the rtc expires.
-     * Argument:    signal number
-     *
-     * NOTE: This ioctl cannot be support in the kernel build mode. In that
-     * case direct callbacks from kernel space into user space is forbidden.
-     */
-
-    case TCIOC_NOTIFICATION:
-      {
-        FAR struct rtc_notify_s *notify =
-          (FAR struct rtc_notify_s *)((uintptr_t)arg);
-
-        if (notify != NULL)
-          {
-            upper->signo = notify->signo;
-            upper->pid   = notify->pid;
-            upper->arg   = notify->arg;
-
-            ret = rtc_setcallback((FAR void *)upper, rtc_notifier, upper);
-          }
-        else
-          {
-            ret = -EINVAL;
-          }
-      }
-      break;
-
-    /* Any unrecognized IOCTL commands might be platform-specific ioctl commands */
-
-    default:
-      {
-        tmrinfo("Forwarding unrecognized cmd: %d arg: %ld\n", cmd, arg);
-
-        /* An ioctl commands that are not recognized by the "upper-half"
-         * driver are forwarded to the lower half driver through this
-         * method.
-         */
-
-        if (lower->ops->ioctl) /* Optional */
-          {
-            ret = lower->ops->ioctl(lower, cmd, arg);
-          }
-        else
-          {
-            ret = -ENOSYS;
-          }
-      }
-      break;
+      /* cmd:         TCIOC_START
+       * Description: Start the rtc
+       * Argument:    Ignored
+       */
+
+      case RTCIOC_START:
+        {
+          /* Start the rtc, resetting the time to the current timeout */
+
+          if (lower->ops->start)
+            {
+              ret = lower->ops->start(lower);
+            }
+          else
+            {
+              ret = -ENOSYS;
+            }
+        }
+        break;
+
+      /* cmd:         TCIOC_STOP
+       * Description: Stop the rtc
+       * Argument:    Ignored
+       */
+
+      case RTCIOC_STOP:
+        {
+          /* Stop the rtc */
+
+          if (lower->ops->stop)
+            {
+              ret = lower->ops->stop(lower);
+            }
+          else
+            {
+              ret = -ENOSYS;
+            }
+        }
+        break;
+
+      /* cmd:         TCIOC_GETSTATUS
+       * Description: Get the status of the rtc.
+       * Argument:    A writeable pointer to struct rtc_status_s.
+       */
+
+      case RTCIOC_GETSTATUS:
+        {
+          FAR struct rtc_status_s *status;
+
+          /* Get the current rtc status */
+
+          if (lower->ops->getstatus) /* Optional */
+            {
+              status = (FAR struct rtc_status_s *)((uintptr_t)arg);
+              if (status)
+                {
+                  ret = lower->ops->getstatus(lower, status);
+                }
+              else
+                {
+                  ret = -EINVAL;
+                }
+            }
+          else
+            {
+              ret = -ENOSYS;
+            }
+        }
+        break;
+
+      /* cmd:         TCIOC_SETTIMEOUT
+       * Description: Reset the timeout to this value
+       * Argument:    A 32-bit timeout value in microseconds.
+       *
+       * TODO: pass pointer to uint64 ns? Need to determine if these RTCs
+       * are 16 or 32 bit...
+       */
+
+      case RTCIOC_SETTIMEOUT:
+        {
+          /* Set a new timeout value (and reset the rtc) */
+
+          if (lower->ops->settimeout) /* Optional */
+            {
+              ret = lower->ops->settimeout(lower, (uint32_t)arg);
+            }
+          else
+            {
+              ret = -ENOSYS;
+            }
+        }
+        break;
+
+      /* cmd:         TCIOC_NOTIFICATION
+       * Description: Notify application via a signal when the rtc expires.
+       * Argument:    signal number
+       *
+       * NOTE: This ioctl cannot be support in the kernel build mode. In that
+       * case direct callbacks from kernel space into user space is forbidden.
+       */
+
+      case RTCIOC_NOTIFICATION:
+        {
+          FAR struct rtc_notify_s *notify =
+            (FAR struct rtc_notify_s *)((uintptr_t)arg);
+
+          if (notify != NULL)
+            {
+              upper->signo = notify->signo;
+              upper->pid   = notify->pid;
+              upper->arg   = notify->arg;
+
+              ret = rtc_setcallback((FAR void *)upper, rtc_notifier, upper);
+            }
+          else
+            {
+              ret = -EINVAL;
+            }
+        }
+        break;
+
+      /* Any unrecognized IOCTL commands might be platform-specific ioctl commands */
+
+      default:
+        {
+          tmrinfo("Forwarding unrecognized cmd: %d arg: %ld\n", cmd, arg);
+
+          /* An ioctl commands that are not recognized by the "upper-half"
+           * driver are forwarded to the lower half driver through this
+           * method.
+           */
+
+          if (lower->ops->ioctl) /* Optional */
+            {
+              ret = lower->ops->ioctl(lower, cmd, arg);
+            }
+          else
+            {
+              ret = -ENOSYS;
+            }
+        }
+        break;
     }
 
   return ret;
@@ -427,7 +427,7 @@ static int rtc_ioctl(FAR struct file *filep, int cmd, unsigned long arg)
  * Input parameters:
  *   dev path - The full path to the driver to be registers in the NuttX
  *     pseudo-filesystem.  The recommended convention is to name all rtc
- *     drivers as "/dev/tc0", "/dev/tc1", etc.  where the driver
+ *     drivers as "/dev/rtc0", "/dev/rtc1", etc.  where the driver
  *     path differs only in the "minor" number at the end of the device name.
  *   lower - A pointer to an instance of lower half rtc driver.  This
  *     instance is bound to the rtc driver and must persists as long as
@@ -440,7 +440,7 @@ static int rtc_ioctl(FAR struct file *filep, int cmd, unsigned long arg)
  ****************************************************************************/
 
 FAR void *rtc_register(FAR const char *path,
-                         FAR struct rtc_lowerhalf_s *lower)
+                       FAR struct rtc_lowerhalf_s *lower)
 {
   FAR struct rtc_upperhalf_s *upper;
   int ret;
@@ -451,7 +451,7 @@ FAR void *rtc_register(FAR const char *path,
   /* Allocate the upper-half data structure */
 
   upper = (FAR struct rtc_upperhalf_s *)
-    kmm_zalloc(sizeof(struct rtc_upperhalf_s));
+          kmm_zalloc(sizeof(struct rtc_upperhalf_s));
   if (!upper)
     {
       tmrerr("ERROR: Upper half allocation failed\n");
diff --git a/include/nuttx/sensors/ioctl.h b/include/nuttx/sensors/ioctl.h
index e23d4df46d..d63007e2ca 100755
--- a/include/nuttx/sensors/ioctl.h
+++ b/include/nuttx/sensors/ioctl.h
@@ -125,7 +125,7 @@ typedef enum
   GA_RANGE_12G,
   GA_RANGE_16G,
   GA_RANGE_END
-}sn_ga_range_s;
+} sn_ga_range_s;
 
 typedef enum
 {
@@ -137,7 +137,7 @@ typedef enum
   GA_RESOLUTION_14BIT,
   GA_RESOLUTION_16BIT,
   GA_RESOLUTION_END
-}sn_ga_res_s;
+} sn_ga_res_s;
 
 typedef enum
 {
@@ -150,13 +150,13 @@ typedef enum
   GA_SAMPRATE_800Hz,
   GA_SAMPRATE_1000Hz,
   GA_SAMPRATE_END
-}sn_ga_samprate_s;
+} sn_ga_samprate_s;
 
 typedef enum
 {
   GA_MODE_STANDBY,
   GA_MODE_NORMAL,
-}sn_ga_mode_s;
+} sn_ga_mode_s;
 
 typedef struct _sn_ga_param
 {
@@ -164,7 +164,7 @@ typedef struct _sn_ga_param
   sn_ga_res_s       resolution;
   sn_ga_samprate_s  sample_rate;
   sn_ga_mode_s      mode;
-}sn_ga_param_s;
+} sn_ga_param_s;
 
 #define SNIOC_GA_SPARAM   _SNIOC(0x002a) /* set Gyro or accelerometer param */
 #define SNIOC_GA_GPARAM   _SNIOC(0x002b) /* get Gyro or accelerometer param */
@@ -177,7 +177,7 @@ typedef struct _sn_ga_raw
   int16_t x_axis;
   int16_t y_axis;
   int16_t z_axis;
-}sn_ga_raw_s;
+} sn_ga_raw_s;
 
 #define SNIOC_GA_GRAW     _SNIOC(0x002c) /* get Gyro or accelerometer raw data */
 
diff --git a/include/nuttx/timers/counter.h b/include/nuttx/timers/counter.h
old mode 100644
new mode 100755
index c82cbf43f7..e6557772f1
--- a/include/nuttx/timers/counter.h
+++ b/include/nuttx/timers/counter.h
@@ -62,15 +62,15 @@
  *
  * These are detected and handled by the "upper half" rtc driver.
  *
- * TCIOC_START        - Start the rtc
+ * RTCIOC_START        - Start the rtc
  *                      Argument: Ignored
- * TCIOC_STOP         - Stop the rtc
+ * RTCIOC_STOP         - Stop the rtc
  *                      Argument: Ignored
- * TCIOC_GETSTATUS    - Get the status of the rtc.
+ * RTCIOC_GETSTATUS    - Get the status of the rtc.
  *                      Argument:  A writeable pointer to struct rtc_status_s.
- * TCIOC_SETTIMEOUT   - Reset the rtc timeout to this value
+ * RTCIOC_SETTIMEOUT   - Reset the rtc timeout to this value
  *                      Argument: A 32-bit timeout value in microseconds.
- * TCIOC_NOTIFICATION - Set up to notify an application via a signal when
+ * RTCIOC_NOTIFICATION - Set up to notify an application via a signal when
  *                      the rtc expires.
  *                      Argument: A read-only pointer to an instance of
  *                      stuct rtc_notify_s.
@@ -88,13 +88,14 @@
  * range.
  */
 
-#define TCIOC_START        _RTCIOC(0x0001)
-#define TCIOC_STOP         _RTCIOC(0x0002)
-#define TCIOC_GETSTATUS    _RTCIOC(0x0003)
-#define TCIOC_SETTIMEOUT   _RTCIOC(0x0004)
-#define TCIOC_NOTIFICATION _RTCIOC(0x0005)
+#define RTCIOC_START        _RTCIOC(0x0001)
+#define RTCIOC_STOP         _RTCIOC(0x0002)
+#define RTCIOC_GETSTATUS    _RTCIOC(0x0003)
+#define RTCIOC_SETTIMEOUT   _RTCIOC(0x0004)
+#define RTCIOC_NOTIFICATION _RTCIOC(0x0005)
+#define RTCIOC_GET_COUNTER  _RTCIOC(0x0006)
 
-#define TC_FIRST           0x0006         /* First required command */
+#define TC_FIRST           0x0007         /* First required command */
 #define TC_NCMDS           4              /* six required commands */
 
 /* User defined ioctl commands are also supported. These will be forwarded
@@ -256,7 +257,7 @@ extern "C"
  ****************************************************************************/
 
 FAR void *rtc_register(FAR const char *path,
-                         FAR struct rtc_lowerhalf_s *lower);
+                       FAR struct rtc_lowerhalf_s *lower);
 
 /****************************************************************************
  * Name: rtc_unregister
