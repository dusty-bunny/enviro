#!/bin/bash

#
# This script will run make from the configs/nrf52832_dk directory against every
# example directory contiaining the file defconfig.
#
# Standard practice is to peform a distclean, <example app>, > out.<example>, and to cycle
# through each of the possible examples.
#
COLOR="${COLOR:-0}"
DEBUG="${DEBUG:-0}"
V=${V:-0}
Q=${Q:-@}
BOARD="${BOARD:-nrf52832_dk}"
FILE_KEY=defconfig
ARG_LIST=( DEBUG BOARD FILE_KEY TARGET_DIRS NO_ERRORS Q V VERBOSE RELOCATE )
RED='\033[1;31m'
YELLOW='\033[1;33m'
GREEN='\033[1;32m'
BLUE='\033[1;34m'
PURPLE='\033[1;35m'
LT_BLUE='\033[1;36m'

HELP_COLOR='\033[3;36m'
RESET='\033[0;39;49m'
OUT=/tmp/out
declare -A make_targets
#
# Setup targets that are not actual apps but
# are still directives to make.
#
declare -A pseudo_targets
pseudo_targets["cscope"]=1
pseudo_targets["help"]=1
pseudo_targets["config"]=1
pseudo_targets["clean"]=1
pseudo_targets["distclean"]=1
pseudo_targets["clean_scope"]=1
pseudo_targets["clean_out"]=1

# fa=( $(cd $RELOCATE && make list_apps) )
# for i in "${fa[@]}" ; do
#         make_targets["$i"]=1
# done

#
# Trap all exits.
#
on_exit()
{
        RV=$?
        [ $RV -ne 0 ] && echo_e "${RED}=============== Error exit: ${RESET}"
        exit $RV
}

#
# Wrap echo with echo_e() and use /bin/echo instead.  This allows invoking
# this script using sh as in "sh $(basename $0)"
#
echo_e()
{
        local Bin=

        Bin="/bin/echo -e"
        $Bin "$@" >&2
}

#
# Debug prints.  Print if DEBUG==1
#
echo_dbg()
{
        [ "$DEBUG" != "1" ] && return 1

        echo_e "$@"
}

#
# Filter out everything but the while loop and the two boundary markers.
# Then filter out anything that does not have a ')' in it.  Voila, instant
# help message!
#
help_msg()
{
        [ "$COLOR" = "1" ] && echo -e "${HELP_COLOR}"
        sed -n -e '/^### HELP.*start/,/^### HELP.*end/p' "$0" | 
                sed -n -e '/) /p' -e '/  #/p'
        echo -e "${RESET}"
}

#
# Output var and contents and
# do some modest alignment by
# adding a space at the beginning
# and an extra tab for shorter
# vars.
#
print_keyval()
{
        declare -a Arg_List=
        local CLR0=
        local CLR1=
        local RST=

        Arg_List=( "$@" )
        [ "$COLOR" = "1" ] && CLR0="${LT_BLUE}" \
                           && CLR1="${GREEN}" \
                               RST="${RESET}"
        for var in "${Arg_List[@]}" ; do
                echo_e -n " ${CLR0}$var${RST}\t"
                [ "${#var}" -lt 7 ]  && echo_e -n "\t"
                echo_e "(${CLR1}${!var}${RST})"
        done
}

find_repo_root()
{
        if ! git rev-parse >/dev/null 2>&1 ; then
                echo_e "Not running within a git repo.  Please relocate."
                exit 1
        fi
        git rev-parse --show-toplevel
}

set_app_list()
{
        local Board_Cfg=
        local File_Key=
        local count=
        local fresults=
        declare -a pieces=

   (
        cd $(git rev-parse --show-toplevel) || return 1
        [ "$#" -ne 2 ] && return 1
        Board_Cfg="$1" ; shift
        File_Key="$1" ; shift

        fresults="$(find . -type d -name $Board_Cfg)"
        [ -z "$fresults" ] && return 1

        pieces=( $(echo $fresults | sed -e 's/\// /g') )
        count=$(( "${#pieces[@]}" + 1 ))
        [ "$DEBUG" = "1" ] && echo_e "== fresults: ($fresults), count: $count"

        pieces=( $(ls $fresults/*/$File_Key | cut --delim='/' -f $count) )
        echo "${pieces[@]}"
   )
}

for target in $(set_app_list $BOARD $FILE_KEY) ; do
        make_targets["$target"]=1
done
DEFAULT_APPS="${!make_targets[@]}"

### HELP message start
while [ $# -ne 0 ] ; do
        case "$1" in
        #
        # Specify the directory to build from
        -b) BOARD="$2"; shift
                ;;
        #
        # Specify the use of color for the print_vars message
        # Must occur on the command line before -p.
        -c) COLOR=1
                ;;
        #
        # Disable -Werror (warnings are errors)
        -e) NO_ERRORS="NO_ERRORS=1"
        #
                ;;
        -h) help_msg && exit 0
                ;;
        -p) print_keyval "${ARG_LIST[@]}" && exit 0
                ;;
        #
        # Expose the raw commands that make issues.
        -Q) Q="";
                ;;
        #
        # Specify build target. May specify multiple times.
        -t) TARGET_DIRS="$TARGET_DIRS ${2%/}"; shift
                ;;
        #
        # Print info beyond success/failure. May specify multiple times.
        -v) VERBOSE="${VERBOSE}V"
                ;;
        #
        # More info on make processing
        -V) V=2
                ;;
        #
        # Specify build target. May specify multiple times.
        *) if [ -n "${pseudo_targets["$1"]}" ] ; then
                TARGET_DIRS="$TARGET_DIRS ${1%/}" ;
           elif [ -n "${make_targets["$1"]}" ] ; then
                TARGET_DIRS="$TARGET_DIRS ${1%/}" ;
           else
                ARGS_UNXP="$ARGS_UNXP \"$1\""
           fi
                ;;
        esac
        shift
done
if [ -n "$ARGS_UNXP" ] ; then
        echo_e -n "Unexpected args were encountered. Stop.  "
        echo_e "$ARGS_UNXP"
        echo_e "Perhaps you need to prefix this with '-t'. See help (-h)"
        exit 1
fi
### HELP message end


trap on_exit EXIT

(
    RELOCATE="$(find_repo_root)/configs/$BOARD"
    cd $RELOCATE >/dev/null || exit 1
    declare -a OUT_FILE=

    TARGET_DIRS=${TARGET_DIRS:-$DEFAULT_APPS}
    [ "${VERBOSE:0:1}" = "V" ] && print_vars

    for build in $TARGET_DIRS ; do
            CMD="make distclean"
            ftmp="${pseudo_targets[$build]}"
            if [ -z "$ftmp" ] ; then
                   echo_e -n "Make distclean ...\r"
                   $CMD > ${OUT}.distclean 2>&1
            fi
            [ -z "$ftmp" ] &&  OUT_FILE=( ">" ${OUT}.$build "2>&1"  ) && _N="-n"

            CMD="make V=\"$V\"  $NO_ERRORS $build"

            echo_e "$_N"  "Building for $build: ... "
            eval $CMD ${OUT_FILE[*]}
            if [ $? -ne 0 ] ; then
                    echo_e "Failed."
                    continue
            fi
            echo_e "Succeeded."
    done
)


