#!/bin/bash

#
# This script will run make from the configs/nrf52832_dk directory against every
# example directory contiaining the file defconfig.
#
# Standard practice is to peform a distclean, <example app>, > out.<example>, and to cycle
# through each of the possible examples.
#
COLOR="${COLOR:-0}"
DEBUG="${DEBUG:-0}"
V=${V:-0}
Q=${Q:-@}
BOARD="${BOARD:-nrf52832_dk}"
FILE_KEY=defconfig
ARG_LIST=( DEBUG BOARD FILE_KEY TARGET_DIRS NO_ERRORS Q V VERBOSE RELOCATE )
RED='\033[1;31m'
YELLOW='\033[1;33m'
GREEN='\033[1;32m'
BLUE='\033[1;34m'
PURPLE='\033[1;35m'
LT_BLUE='\033[1;36m'

HELP_COLOR='\033[3;36m'
RESET='\033[0;39;49m'
### COLORS Begin
### COLORS End
OUT=/tmp/out
declare -A make_targets
#
# Setup targets that are not actual apps but
# are still directives to make.
#
declare -A pseudo_targets
pseudo_targets["cscope"]=1
pseudo_targets["help"]=1
pseudo_targets["config"]=1
pseudo_targets["clean"]=1
pseudo_targets["distclean"]=1
pseudo_targets["clean_scope"]=1
pseudo_targets["clean_out"]=1

# fa=( $(cd $RELOCATE && make list_apps) )
# for i in "${fa[@]}" ; do
#         make_targets["$i"]=1
# done

#
# Trap all exits.
#
on_exit()
{
        RV=$?
        [ $RV -ne 0 ] && echo_e "${RED}=============== Error exit: ${RESET}"
        exit $RV
}

#
# Wrap echo with echo_e() and use /bin/echo instead.  This allows invoking
# this script using sh as in "sh $(basename $0)"
#
echo_e()
{
        local Bin=

        Bin="/bin/echo -e"
        $Bin "$@" >&2
}

#
# Debug prints.  Print if DEBUG==1
#
echo_dbg()
{
        [ "$DEBUG" != "1" ] && return 1

        echo_e "$@"
}

#
# Filter out everything but the while loop and the two boundary markers.
# Then filter out anything that does not have a ')' in it.  Voila, instant
# help message!
#
help_msg()
{
        local CLR0=

        CLR0="${!1}" ; shift
        echo -e "${CLR0}"
        sed -n -e '/^### HELP.*start/,/^### HELP.*end/p' "$0" |
               sed -e '/^### HELP/,/case/d' -e '/esac/,/^### HELP/d' -e '/;;/d'
        echo -e "${RESET}"
}

#
# Output var and contents and
# do some modest alignment by
# adding a space at the beginning
# and an extra tab for shorter
# vars.
#
print_keyval()
{
        declare -a Arg_List=
        local CLR0=
        local CLR1=

        Arg_List=( "$@" )
        CLR0="${!1}" ; shift
        CLR1="${!1}" ; shift

        for var in "${Arg_List[@]}" ; do
                echo_e -n " ${CLR0}$var${RESET}\t"
                [ "${#var}" -lt 7 ]  && echo_e -n "\t"
                echo_e "(${CLR1}${!var}${RESET})"
        done
}

find_repo_root()
{
        if ! git rev-parse >/dev/null 2>&1 ; then
                echo_e "Not running within a git repo.  Please relocate."
                exit 1
        fi
        git rev-parse --show-toplevel
}

set_app_list()
{
        local Board_Cfg=
        local File_Key=
        local count=
        local fresults=
        declare -a pieces=

   (
        cd $(git rev-parse --show-toplevel) || return 1
        [ "$#" -ne 2 ] && return 1
        Board_Cfg="$1" ; shift
        File_Key="$1" ; shift

        fresults="$(find . -type d -name $Board_Cfg)"
        [ -z "$fresults" ] && return 1

        pieces=( $(echo $fresults | sed -e 's/\// /g') )
        count=$(( "${#pieces[@]}" + 1 ))
        [ "$DEBUG" = "1" ] && echo_e "== fresults: ($fresults), count: $count"

        pieces=( $(ls $fresults/*/$File_Key | cut --delim='/' -f $count) )
        echo "${pieces[@]}"
   )
}

#
# Take care of generating the requested output.
#
run_output()
{
        local COLOR0=
        local COLOR1=

        COLOR0="${!1}" ; shift
        COLOR1="${!1}" ; shift

        if [ "$RUN_HELP" = "yes" ] ; then
                help_msg COLOR0
        fi
        if [ "$PRINT_KV" = "yes" ] ; then
                print_keyval  COLOR0 COLOR1 "${ARG_LIST[@]}"
        fi
}

for target in $(set_app_list $BOARD $FILE_KEY) ; do
        make_targets["$target"]=1
done
DEFAULT_APPS="${!make_targets[@]}"

CONTRAST=0
COLOR=0

### HELP message start
while [ $# -ne 0 ] ; do
        case "$1" in
        #
        # Specify the directory to build from
        -b) BOARD="$2"; shift
                ;;
        #
        # Specify the use of color for the print_vars message
        # Must occur on the command line before -p.
        -c) COLOR=1
            CONTRAST=0
                ;;
        +c) COLOR=1
            CONTRAST=1
                ;;
        -C) COLOR=1     ## Enhanced background suitable for screens with light backgrounds
            CONTRAST=1
                ;;
        #
        # Disable -Werror (warnings are errors)
        -e) NO_ERRORS="NO_ERRORS=1"
        #
                ;;
        -h) RUN_HELP="yes";# help_msg && exit 0
                ;;
        -p) PRINT_KV="yes";# print_keyval "${ARG_LIST[@]}" && exit 0
                ;;
        #
        # Expose the raw commands that make issues.
        -Q) Q="";
                ;;
        #
        # Specify build target. May specify multiple times.
        -t) TARGET_DIRS="$TARGET_DIRS ${2%/}"; shift
                ;;
        #
        # Print info beyond success/failure. May specify multiple times.
        -v) VERBOSE="${VERBOSE}V"
                ;;
        #
        # More info on make processing
        -V) V=2
                ;;
        #
        # Specify build target. May specify multiple times.
        *) if [ -n "${pseudo_targets["$1"]}" ] ; then
                TARGET_DIRS="$TARGET_DIRS ${1%/}" ;
           elif [ -n "${make_targets["$1"]}" ] ; then
                TARGET_DIRS="$TARGET_DIRS ${1%/}" ;
           else
                ARGS_UNXP="$ARGS_UNXP \"$1\""
           fi
                ;;
        esac
        shift
done
### HELP message end
if [ -n "$ARGS_UNXP" ] ; then
        echo_e -n "Unexpected args were encountered. Stop.  "
        echo_e "$ARGS_UNXP"
        echo_e "Perhaps you need to prefix this with '-t'. See help (-h)"
        exit 1
fi

if [ "$RUN_HELP" = "yes" ] || [ "$PRINT_KV" = "yes" ] ; then
        [ "$CONTRAST" = "0" ] && run_output LT_BLUE GREEN
        [ "$CONTRAST" = "1" ] && run_output BLUE PURPLE
        exit 0
fi


trap on_exit EXIT

#
# Main()
#
(
    RELOCATE="$(find_repo_root)/configs/$BOARD"
    [ ! -d "$RELOCATE" ] && exit 1

    cd $RELOCATE >/dev/null
    declare -a OUT_FILE=

    TARGET_DIRS=${TARGET_DIRS:-$DEFAULT_APPS}
    [ "${VERBOSE:0:1}" = "V" ] && print_vars

    for build in $TARGET_DIRS ; do
            CMD="make distclean"
            ftmp="${pseudo_targets[$build]}"
            if [ -z "$ftmp" ] ; then
                   echo_e -n "Make distclean ...\r"
                   $CMD > ${OUT}.distclean 2>&1
            fi
            [ -z "$ftmp" ] &&  OUT_FILE=( ">" ${OUT}.$build "2>&1"  ) && _N="-n"

            CMD="make V=\"$V\"  $NO_ERRORS $build"

            echo_e "$_N"  "Building for $build: ... "
            eval $CMD ${OUT_FILE[*]}
            if [ $? -ne 0 ] ; then
                    echo_e "Failed."
                    continue
            fi
            echo_e "Succeeded."
    done
)


