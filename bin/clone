#!/bin/bash

ASTYLE_CO="svn checkout https://svn.code.sf.net/p/astyle/code/trunk astyle-code"
ZGLUE_BILL_HOST=git@github.com/zglue-bill
GIT_UNAME=bill
GERRIT_HOST=101.132.142.37
GERRIT_SSH_PORT=30149
GERRIT_HTTP_PORT=14586
GERRIT_HOST_URL="$GIT_UNAME@$GERRIT_HOST:$GERRIT_SSH_PORT"
GITHUB_HOST_URL="https://github.com/andre-simon/highlight.git"
BITBUCKET_URL="https://bitbucket.org"
SDK_13="SDK_13.0.0-1"
SDK_13_1="SDK_13.1.0"
SDK_14="SDK_14.0.0"
DIALOG_SDK=dialog_585_sdk_dev
NORDIC_SDK="$SDK_13_1"
SRC_REPO_URL="$GERRIT_HOST_URL"

declare -A OfferRepos
declare -A Repo2Host
declare -A RepoRename
declare -A CONFIGS
declare -A svn_backed
declare -A FinalCmds

DOXYGEN="1.18.14"
OfferRepos["NuttX"]="Official repo for Nuttx rtos for branch master"
OfferRepos["AppsX"]="Official repo for Nuttx apps for branch master"
OfferRepos["nuttx"]="zGlue repo for nuttx rtos for branch zdk"
OfferRepos["apps"]="zGlue repo for nuttx_apps for branch zdk"
OfferRepos["nuttx_apps"]="zGlue repo for nuttx_apps for branch zdk"
OfferRepos["tools"]="Official repo for Nuttx tools, branch master"
OfferRepos["fast"]="zGlue repo for fast_api repo branch fast_api_dev".
OfferRepos["auto_test"]="zGlue repo for auto_test tools for Gerrit branch=master."
OfferRepos["dialog"]="zGlue repo for Dialog sdk  branch $DIALOG_SDK"
OfferRepos["nordic"]="zGlue repo for Nordic sdk branch $NORDIC_SDK" 
OfferRepos["Doxygen"]="zGlue repo for Doxygen branch $DOXYGEN" 
OfferRepos["upgrade"]="zGlue-bill's repo for moving to nuttx TOT." 

#
# Repos which are svn based are added here along with the command
# required to "clone" them.
#
svn_backed["astyle-code"]="svn checkout"
svn_backed["xpra"]="svn checkout"
svn_backed["FreeImage-svn"]="svn checkout"
svn_backed["Moritz"]="svn checkout"

#
# Hash to match informal repo names to the canonical ones.
#
# RepoRename["freeimage"]="FreeImage-git"
RepoRename["upgrade"]="nuttx-upgrade"
RepoRename["repo"]="git-repo"
RepoRename["astyle"]="astyle-code"
RepoRename["review"]="git-review"
RepoRename["mynewt"]="mynewt-core"
RepoRename["nimble"]="NimBLE"
RepoRename["fast"]="fast_api"
RepoRename["NuttX"]="bknuttx"
RepoRename["AppsX"]="bkapps"
RepoRename["tools"]="bktools"
RepoRename["riot"]="RIOT"
RepoRename["apps"]="nuttx_apps"
# Setup in setup_repo_table() ## RepoRename["dialog"]="dialog_585_sdk_dev@3rd_Party_SDK"
# Setup in setup_repo_table() ## RepoRename["dallas"]="dialog_585_sdk_dev@3rd_Party_SDK"
# Setup in setup_repo_table() ## RepoRename["nordic"]="#$NORDIC_SDK"@3rd_Party_SDK"
# Setup in setup_repo_table() ## RepoRename["sdk_13_1"]="SDK_13.1.0@3rd_Party_SDK"
# Setup in setup_repo_table() ## RepoRename["sdk_14"]="SDK_14.0.0@3rd_Party_SDK"
RepoRename["bme280"]="BME280_driver"
RepoRename["bmi160"]="BMI160_driver"
RepoRename["bmm050"]="BMM050_driver"
RepoRename["notepad"]="notepad-plus-plus"
RepoRename["Doxygen"]="doxygen"

#
# Hash translation from canonical repo target to  URI crafted to
# hold enough info to clone/checkout the source.
#
Repo2Host["nuttx-upgrade"]="master@git@github.com/zglue-bill/nuttx-upgrade.git"
Repo2Host["notepad-plus-plus"]="master@https://github.com/notepad-plus-plus/notepad-plus-plus.git"
Repo2Host["mbed-os"]="master@git@github.com/ARMmbed/mbed-os.git"
Repo2Host["qemu"]="master@git://git.qemu.org/qemu.git"
Repo2Host["oclint"]="master@git@github.com/oclint::oclint.git, ocling-docs.git"
Repo2Host["tinyara"]="master@git@github.com/Samsung/TinyAra.git"
Repo2Host["tizen"]="master@git@github.com/Samsung/TizenRT.git"
Repo2Host["blah"]="z@git@github.com/zglue-bill/blah.git"
Repo2Host["blah_apps"]="zapps@git@github.com/zglue-bill/blah_apps.git"
Repo2Host["texworks"]="master@git@github.com/Texworks/texworks.git,manual.git,website.git"
Repo2Host["mynewt-core"]="master@git@github.com/apache/mynewt-core.git"
Repo2Host["NimBLE"]="master@git@github.com/apache/mynewt-nimble.git"
Repo2Host["micro-ecc"]="master@git@github.com/kmackay/micro-ecc.git"
Repo2Host["zephyr"]="master@git@github.com/zephyrproject-rtos/zephyr.git"
Repo2Host["RIOT"]="master@github.com/RIOT-OS"
Repo2Host["bknuttx"]="master@${BITBUCKET_URL}/nuttx/nuttx.git"
Repo2Host["bktools"]="master@${BITBUCKET_URL}/nuttx/tools.git"
Repo2Host["bkapps"]="master@${BITBUCKET_URL}/nuttx/apps.git"
Repo2Host["fw_devtools"]="master@$ZGLUE_BILL_HOST/fw_devtools.git"
Repo2Host["home-env"]="master@$ZGLUE_BILL_HOST/home-env.git"
Repo2Host["nuttx-local"]="zdk@$ZGLUE_BILL_HOST/nuttx-local.git"
Repo2Host["apps-local"]="zdk@$ZGLUE_BILL_HOST/apps-local.git"
Repo2Host["linux"]="master@git@github.com/torvalds/linux.git"
Repo2Host["git-review"]="master@https://github.com/openstack-infra/git-review.git"
Repo2Host["poppler"]="master@https://anongit.freedesktop.org/git/poppler/poppler.git"
Repo2Host["xpra"]="https://www.xpra.org/svn/Xpra/trunk xpra"
Repo2Host["astyle-code"]="https://svn.code.sf.net/p/astyle/code/trunk astyle-code"
Repo2Host["FreeImage-svn"]="https://svn.code.sf.net/p/freeimage/svn/ freeimage-svn"
Repo2Host["Moritz"]="https://svn.code.sf.net/p/moritz/Archive_SVN/ moritz-Archive_SVN"
# Repo2Host["FreeImage-git"]="master@https://git.code.sf.net/p/freeimage/git freeimage-git"
Repo2Host["git-repo"]="master@https://gerrit.googlesource.com/git-repo.git"
Repo2Host["BMI160_driver"]="master@https://github.com/BoschSensortec/BMI160_driver.git"
Repo2Host["BME280_driver"]="master@https://github.com/BoschSensortec/BME280_driver.git"
Repo2Host["BMM050_driver"]="master@https://github.com/BoschSensortec/BMM050_driver.git"
Repo2Host["doxygen"]="master@https://github.com/doxygen/doxygen.git"

FinalCmds=()
FinalCmds["nuttx"]="setup_repo"
FinalCmds["apps"]="setup_repo"
FinalCmds["nuttx_apps"]="setup_repo"
FinalCmds["fast_api"]="setup_repo"
FinalCmds["auto_test"]="setup_repo"
#
# Table of color codes for vt100.  To be imported
# into any shell script wanting to display color
#

#
#
# Simple color names are setting the forground color.
#
# Weird names are setting the forground to the first
# part of the name and the background to the second.
#
# E.G.  REDBLK == Red lettering on a black background
#       regardless of terminal settings.
#
# E.G.  YLWLtBLU == Yellow lettering on a light blue background.
#
# shellcheck disable=2034
RED='\033[1;31m'
# shellcheck disable=2034
REDBLK='\033[1;31;40m'
# shellcheck disable=2034
REDYLW='\033[1;31;43m'
# shellcheck disable=2034
REDBLU='\033[1;31;46m'
# shellcheck disable=2034
GREEN='\033[1;32m'
# shellcheck disable=2034
GRNBLK='\033[1;32;40m'
# shellcheck disable=2034
GRNGRN='\033[1;32;42m'
# shellcheck disable=2034
YELLOW='\033[1;33m'
# shellcheck disable=2034
YLWBLK='\033[1;33;40m'
# shellcheck disable=2034
YLWRED='\033[1;33;41m'
# shellcheck disable=2034
YLWGRN='\033[1;33;42m'
# shellcheck disable=2034
YLWBLU='\033[1;33;44m'
# shellcheck disable=2034
YLWltBLU='\033[1;33;46m'
# shellcheck disable=2034
BLUE='\033[1;34m'
# shellcheck disable=2034
RESET='\033[0;39;49m'

echo_err()
{
        echo -e "$@${RESET}" >&2
}

dbg_echo()
{
        debug || return 0

        echo_err "$@"
}

#
# Print the name of the function and how deeply nested.
#
Func()
{
        dbg_echo "${#FUNCNAME[@]} : ${FUNCNAME[1]}( $@ )"
}

#
# Returns true if TRACE=1.  I.E. "trace && set -x" will set the '-x'
# shell option forcing the script to run in tracing mode.
#
trace()
{
        [ "$TRACE" = "1" ] && return 0
        return  1
}

#
# Provide an in-line check for debug status to conditionally enable calls.
# e.g. debug && echo "This is a test" will only fire if DEBUG=1 otherwise
#      it is a no-op.
#
#
debug()
{
        [ "$DEBUG" = "1" ] && return 0
        return 1
}

#
# Setup the repo table with a repo host url
#
setup_repo_table()
{
        Func $@
        local repo_host_url=

        [ -z "$1" ] && dbg_echo "No repo provided." && return 1
        repo_host_url="$1"; shift
        dbg_echo "repo_host_url ($repo_host_url)"
	Repo2Host["fast_api"]=fast_api_dev@$repo_host_url/fast_api
	Repo2Host["sdk_13"]=$SDK_13@$repo_host_url/3rd_Party_SDK
	Repo2Host["sdk_14"]=$SDK_14@$repo_host_url/3rd_Party_SDK
	Repo2Host["nordic"]=$NORDIC_SDK@$repo_host_url/3rd_Party_SDK
	Repo2Host["dialog"]=$DIALOG_SDK@$repo_host_url/3rd_Party_SDK
	Repo2Host["nuttx"]=zdk@$repo_host_url/nuttx.git
	Repo2Host["nuttx-ext"]=zdk@$repo_host_url/nuttx.git,zdk@$repo_host_url/external.git,zdk@$repo_host_url/nuttx_apps.git
	Repo2Host["nuttx_apps"]=zdk@$repo_host_url/nuttx_apps.git
#	Repo2Host["apps"]=zdk@$repo_host_url/nuttx_apps.git
	Repo2Host["apps"]="${Repo2Host["nuttx_apps"]}"
	Repo2Host["external"]=zdk@$repo_host_url/external.git
	Repo2Host["auto_test"]=master@$repo_host_url/auto_test.git
	Repo2Host["3rd_Party_SDK"]=dialog_585_sdk_dev@$repo_host_url/3rd_Party_SDK.git
}

#
#
#
dump_Repo2Host()
{
        Func $@
        echo_err  "\tRepo names to clone and their repo urls"
        echo_err  "\tFormat of repo url:  branch@name@url/x.git"
        for key in ${!Repo2Host[@]} ; do
                echo_err -n "Repo: ${YELLOW}$key\t"
                [ "${#key}" -le 9 ] && echo_err -n "\t"
                echo_err "${BLUE}${Repo2Host[$key]}${RESET}"
        done
        echo_err -e "\t\tAliases"
        for key in ${!RepoRename[@]} ; do
                for="${RepoRename[$key]}"
                echo_err -e "alias: ${BLUE}$key\t\t${RED}${for#*@}${RESET}"
        done
}

dump_OfferRepos()
{
        Func $@

        echo_err "\t${YLWGRN}\tRepos supported"
        echo_err "\t${YLWGRN}\t               "
        echo_err "\t${YLWGRN}Repo:\t\t\tDescription"
        echo_err "\t${YLWGRN}     \t\t\t           "
        for key in ${!OfferRepos[@]} ; do
                echo_err -n "      ${YEllOW}$key\t"
                [ "${#key}" -le 9 ] && echo_err -n -e "\t"
                echo_err "${BLUE}${OfferRepos[$key]}"
        done
}

dump_targets()
{
        Func $@

        for target in ${TARGETS[@]} ; do
                echo_err "\ttarget\t$target"
        done
}

#
# Quick writeup of what keywords map to what repos.
#
info()
{
        Func $@
        echo_err "\tKeyword\t\tRepo\t\tBranch"
        echo_err "\t3rd_Party_SDK\t3rd_Party_SDK :: master"
        echo_err "\tnordic\t\t3rd_Party_SDK :: SDK_13.1.0"
        echo_err "\tsdk_13_1\t3rd_Party_SDK :: SDK_13.1.0"
        echo_err "\tsdk_13\t\t3rd_Party_SDK :: SDK_13.0.0-1"
        echo_err "\tsdk_14\t\t3rd_Party_SDK :: SDK_14.0.0"
        echo_err ""
        echo_err "\tdallas\t\t3rd_Party_SDK :: dialog_585_sdk_dev"
        echo_err ""
        echo_err -e "\tapps\t\tnuttx_apps :: zdk"
        echo_err -e "\tnuttx_apps\tnuttx_apps :: zdk"
        echo_err -e "\tnuttx\t\tnuttx :: zdk"
        echo_err -e "\tbknuttx\t\toffcial nuttx :: master"
        echo_err -e "\tauto_test\tauto_test :: master"
}

#
# Fill in the GERRIT_* variables using the current repo's info.
#
setup_GERRIT_vars()
{
        Func $@
#       GERRIT_UNAME="$(git config --local gitreview.username)"
        GERRIT_UNAME="$(git config --global user.name)"
        GERRIT_HOST="$(git config --local gitreview.host)"
}

#
# Perform any setup for this repo such as config settings,
# adding remotes, renaming remotes.
#
# Arg1 : The repo to configure
# Arg2 : The branch involved (may not be used)
#
setup_repo()
{
        Func $@
        local Repo=
        local tmp=

        [ ! -d "$1" ] && echo_err "No directory specified to setup." && return 1
        Repo="$1"
    (
        cd "$Repo" || return 1
        git config --local pull.rebase true
        gitrev-setup.sh
    )
}

#
# Setup remotes so that one points to gerrit and the other
# points to git-hub.  The idea is to develop with git-hub
# updating along the way from gerrit, and then push to gerrit
# when ready.
#
# reset_remotes()
# {
# }

#
# Given a user/branch/host/repo tuple break it apart
# and output back to the caller over stdout.
#
break_apart()
{
        Func $@
        local Branch=

        Branch="$@"

        # The branch name
        echo -n "${Branch%%@*}"
        echo -n "  "
        # The uri pointing to the repo
        echo -e -n "${Repo2Host[$Key]#*@}\t"

        # The repo directory
        echo    "${Repo2Host[$Key]##*/}"
}

#
# Given a repo id figure out the branch and url to clone
#
get_info()
{
        Func $@
        local Key=
        local Branch=


        [ -z "$1" ] && return 1
        Key=${1%%.git}
        dbg_echo -n "Key: (${Key})\t"
        if [ "${Key}" = "astyle" ] ; then
                $ASTYLE_CO
                return
        fi
        if [ "${Key%%@*}" != "${Key}" ] ; then
                Branch=${Key##@*}
        else
                Branch=${Repo2Host[$Key]}
                dbg_echo "Repo2Host[$Key] : <$Branch>"
        fi
        [ -z "$Branch" ] && echo_err "No repo info found." && return 1
        dbg_echo "Branch: <$Branch>"
        break_apart "$Branch"
}

#
# Check RepoRename[] for any translation of the target repo
# provided on the cli.
#
resolve_clone_id()
{
        Func $@
        local Target=

        Target="$1"
        ALTNAME=${RepoRename[$Target]}
        if [ -n "$ALTNAME" ] ; then
                echo "$ALTNAME"
        else
                echo "$Target"
        fi
}

#
# Assemble the complete git command for cloning
#
set_cmd_git()
{
        local target=
        local Proto=
        local URL=1
        declare -a Info=

        target="$1"
        if ! Info=( $(get_info $target) ) ; then
                echo_err "Repo not found <$target>"
                return 1
        fi
        dbg_echo "Info: <$Info>"

        Proto=ssh
        Uri=${Info[$URL]}
        tmp="${Uri#*://}"
        dbg_echo "Uri: <$Uri>, tmp <$tmp>"

        [ "$tmp" != "${Uri}" ] && Proto="${Uri%://*}"
        Uri="${Uri#*://}"
        [ -z "$Proto" ] && Proto=ssh
        echo "git clone -b "${Info[$Branch]}" $Proto://$Uri"
}

#
# Given a keyword or hint from the user find the branch,
# repo, and URI associated and clone.
#
clone_one()
{
        Func $@
        local CMD=
        local TrueTarget=

        [ -z "$1" ] && return 1
        TrueTarget="$(resolve_clone_id $1)"
        dbg_echo "Target to clone: $TrueTarget"
        if [ -n "${svn_backed[$TrueTarget]}" ] ; then
                CMD="${svn_backed[$TrueTarget]} ${Repo2Host[$TrueTarget]}"
        else
                CMD="$(set_cmd_git $TrueTarget)"
        fi

        #
        # Setup message to output for success.
        #
        if [ "${CMD:0:3}" = "git" ] ; then
                MSG="Cloned:"
        elif [ "${CMD:0:3}" = "svn" ] ; then
                MSG="Checked out:"
        elif [ "${CMD:0:2}" = "hg" ] ; then
                MSG="Checked out:"
        fi

        dbg_echo "$CMD"
        if ! $CMD ; then
                echo_err "Not cloned."
                return 1
        fi
        [ -n "$MSG" ] && dbg_echo "== ${MSG} $TrueTarget"

        dbg_echo "=== TrueTarget: $TrueTarget,  Final Cmd : ${FinalCmds[${TrueTarget%.git}]}"
        CMD="${FinalCmds["${TrueTarget%.git}"]}"
        [ -z "${CMD}" ] && dbg_echo "No final command to run: <$CMD>" && return 0
        CMD="$CMD ${TrueTarget%.git}"
        dbg_echo "Final Command: <$CMD>"
        $CMD
}

clone()
{
        Func $@
        [ -z "$1" ] && return 1

        local Target=
        local cell_line=
        local Key=

        for Target in $@ ; do
                dbg_echo "Clone target ${Target%%.git}"
                Key=${Target%%.git}

                if ! clone_one "$Target" ; then
                        echo_err "Not cloned: [$Target]"
                        exit 5
                fi
        done
}

dual_source_repos()
{
        Func $@
        git remote rename origin gerrit
        git remote add github ssh://git@github.com/zglue-bill
}

hhelp()
{
        Func $@
        sed    -e '1,/^#Help/d' -e '/^#Help/,$d' "$0" | \
                        sed -n -e '/^[ 	]\+[^A-Za-z0-9+=);_-]\+#/p' -e '/)/p'
}

set_dir_aside()
{
        local CUR_DIR

        CUR_DIR="$1"
        mv "$CUR_DIR" ".${CUR_DIR}"
}

make_a_dir()
{
        local Dir=

        [ -z "$1" ] && return 1

        Dir="$1"
        [ -d $Dir ] && set_dir_aside $Dir
        mkdir -p $Dir
}

help()
{
        cat <<  EOF 
    $(basename $0) : [h]  [-d <dir>] [ -c <repo1 ... > ]
EOF
        cat << "EOF"
        -c :    Clone.  Clone from a repo specified by the arguments
                The flag must be the last flag and immediately precede
                the list and of repos.
        -d :    Create a new parent directory of the cloned repos. If the
                directory already exists then it will be set aside and a
                new directory created.
        -h :    Print this text to stdout.
        -l :    Print the list of repos available to clone.
EOF
}

parse_cli()
{
        Func $@

        while [ $# -ne 0 ] ; do
                dbg_echo "\$1 == ($1)"
                case "$1" in
                 -c)   shift ; TARGETS=( $@ )
                        dbg_echo "Target based on $@"
                        shift ${#TARGETS[@]}
                        dbg_echo "\$# = $#, shifted ${#TARGETS[@]}, Target(s): ${TARGETS[*]}"
                ;;
                 -d)   [ -n "$2" ] && dbg_echo "Found a \$2: $2"
                        if ! make_a_dir "$2" ; then
                                echo_err "Unable to create directory path $2"
                                exit 1
                        fi
                        PARENT_DIR="$2" ; shift
                        dbg_echo "PARENT_DIR set to $PARENT_DIR"
                ;;
                 -h)   help && exit
                ;;
                 -hh)  hhelp && exit
                ;;
                 -l)   [ "$(basename $0)" != "clone" ] && dump_Repo2Host && exit
                        dump_OfferRepos && exit
                ;;
        # Rename origin to something else.
                -O | --no-origin)
                        CONFIG_TWO_REPOS="dual_source_repo" # TBD
                ;;
                -p | --print) dump_Repo2Host && exit 0
                ;;
        # set a particular url to clone the desired repo from.
                -R | --repo) SRC_REPO_URL="$2"; shift # set the repo to init with.
                ;;
                *)
                        [ -z "${OfferRepos[$1]}" ] && echo_err "Not a supported repo: $1." && exit
                        dbg_echo "Adding target $1 to TARGETS"
                        TARGETS[${#TARGETS[@]}]="$1"; # The repo name to clone.
                ;;
                esac
                shift
        done
  dbg_echo done
}

if [ "$(basename $0)" = "clone" ] ; then
        if ! setup_repo_table $SRC_REPO_URL ; then
                exit 1
        fi
        parse_cli $@

        [ -z "${TARGETS[*]}" ] && echo_err "Nothing to clone." >&2 && exit
        [ -n "$PARENT_DIR" ] && dbg_echo "Create <$PARENT_DIR>" && mkdir -p "$PARENT_DIR"
        [ -z "$PARENT_DIR" ] && dbg_echo "set PARENT_DIR to  './'" && PARENT_DIR="./"
        (
                cd $PARENT_DIR || exit -2
                dbg_echo "cd to $PARENT_DIR: <$(pwd)>"
                if ! clone "${TARGETS[@]}" ; then
                        rm -rf $PARENT_DIR
                        RV="-1"
                fi
                exit $RV
        )
        exit
fi

[ "$#" -eq 0 ] && help && exit 1
#Help
while [ $# -ne 0 ] ; do
        case "$1" in
        -h | --help) help; exit
                ;;
        # Rename origin to something else.
        -O | --no-origin)
                     CONFIG_TWO_REPOS="dual_source_repo" # TBD
                ;;
        -p | --print) dump_Repo2Host && exit 0
                ;;
        # set a particular url to clone the desired repo from.
        -R | --repo ) SRC_REPO_URL="$2"; shift # set the repo to init with.
                ;;
        *) TARGETS[${#TARGETS[@]}]="$1"; # The repo name to clone.
                [ -z "$1" ] && help && exit
                ;;
        esac
        shift
done
#Help

if ! setup_repo_table $SRC_REPO_URL ; then
        exit 1
fi

[ "$PRINT" = "YES" ] && dump_Repo2Host && exit 0

[ -z "${TARGETS[*]}" ] && echo _err"Nothing to clone." && exit

clone "${TARGETS[@]}"

$CONFIG_TWO_REPOS

