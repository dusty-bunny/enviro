#!/bin/bash

#
# Create a tmp file to be used by a 'find' call to operate on every
# file of *.[ch]. See style_file() and style_dir().
#
setup_flip_hashmark()
{
        if [ -z "$1" ] ; then
                echo "Is this a file? ($1)?" >&2
                return -1
        fi
        cat >$1 <<"EOF"
#!/bin/bash
#
# For every line that starts with some whitespace leading up to a hash (#)
# replace that set with a leading hash and a space where the original hash
# was
#
# For every instance of '*const', convert to '* const'
#
flip_hashmark()
{
        sed -i  -e '/^  *#/s/^./#/' -e '/^#  *#/s/ #/  /' \
                -e '/^\/\*/,/\*\//s/^\*/ \*/' \
                -e 's/  \*const/ \* const/g'  \
                -e 's/\([^ ]\) \*const/\1 \* const/g' $@
}

if [ -f "$1" ] ; then
        flip_hashmark "$@"
fi

EOF
        chmod +x $1
}


set_files()
{
        local Files=
        local AGAINST=
        local Action=
        local GIT_CMD=

        Action="diff --cached"
        GIT_CMD="git \$Action --name-status --diff-filter=d \$AGAINST | \
                        awk '{print \$NF}'"
        #
        # See if there are any staged files to check:
        #
        Files="$(eval $GIT_CMD)"
        [ -n "$Files" ] && echo $Files && return 0

        #
        # Pick out the files updated in this commit that are c source files.
        #
        AGAINST="HEAD^"
        Files="$(eval $GIT_CMD)"
        [ -n "$Files" ] && echo $Files && return 0

        return 1
}

#
# Given a file path find the repo covering that file.
#
find_repo()
{
        local TDIR=
        local CMD=
        local RECMD=

        TDIR=$(dirname "$1")

        CMD="TDIR=$(dirname \$TDIR)"
        if [ -n "$(echo $TDIR | sed -n -e '/^\//p')" ] ; then
#       if [ "${TDIR:0:1}" != '/' ] ; then
                TDIR=.
                CMD='TDIR="../$TDIR"'
                RECMD='$(cd $TDIR && pwd)'
        fi

        [ -n "$DEBUG" ] && echo ":: TDIR is [$TDIR]" >&2
        [ -n "$DEBUG" ] && echo ":: CMD is [$CMD]" >&2
        while [ ! -d $TDIR/.git ] && [ ! -d $TDIR/boot/grub ] ; do
                eval $CMD
                [ -n "$DEBUG" ] && sleep 1
        done
        [ -n "$RECMD" ] && eval TDIR=$RECMD
        #
        # Send the results back through stdout.
        #
        [ -d $TDIR/.git ] && echo $TDIR || return 1

        return 0
}

style_files()
{
        local RepoRoot=
        local Files=
        local TMPFILE=
        local RESULTS=
        local ZGLUE_OPTS_DIR=
        local STYLE=
        local CMD=
        local ASTYLE=
        local ASTYLE_OPTS=
        local RV=

        RV=1

        #
        # Make sure this script is running from the repo root.
        #
        [ -d "$1"/.git ] || return 1

        RepoRoot=$1; shift
        [ ! -f "$1" ] && echo "No files to style." >&2 && exit 1
        Files=$@

        ASTYLE=${ORIGIN}astyle
        [ ! -x "$ASTYLE" ] && ASTYLE=$(which astyle)
        [ ! -x "$ASTYLE" ] && echo "No astyle binary found." >&2 && return 1

        ASTYLE_OPTS=astyle-nuttx
        RESULTS=${ORIGIN}style.errs
        STYLE_OPTIONS=${ORIGIN}${ASTYLE_OPTS}
        ZGLUE_OPTS_DIR=/usr/share/zglue/styles
        [ ! -f $STYLE_OPTIONS ] && STYLE_OPTIONS=$ZGLUE_OPTS_DIR/${ASTYLE_OPTS}

        [ -z "$DEBUG" ]  && QUIET='-q'
        [ -n "$DEBUG" ] && echo ":: ASTYLE:         [$ASTYLE]" >&2
        [ -n "$DEBUG" ] && echo ":: STYLE_OPTIONS:  [$STYLE_OPTIONS]" >&2
        [ -f "$STYLE_OPTIONS" ] || echo "Missing [$STYLE_OPTIONS]" >&2 || return 1

        #
        # style check the files to commit, quietly unless DEBUG is set.
        #
        CMD="$ASTYLE --options=$STYLE_OPTIONS $QUIET $Files"
        [ -n "$DEBUG" ] && echo ":: CMD: [$CMD]" >&2
        cd $RepoRoot
        $CMD

        #
        # Adjust the results to account for minor variations from astyle
        # Create temp script to post process files styled by astyle
        #
        TMPFILE=$(mktemp -p /tmp .cleanup_astyle.XXX)
        setup_flip_hashmark $TMPFILE

        CMD="$TMPFILE $Files"
        $CMD

        git diff $Files > $RESULTS 2>&1

        # Remove incidental files generated by astyle and this script.
        #
        find . -type f -name "*.orig" -exec rm {} \;
        cd $ORIGIN

        rm $TMPFILE
        #
        # Set return value based on size of output file.
        #
        [ ! -s $RESULTS ] && RV=0 && echo "Remove $RESULTS" >&2 && rm $RESULTS

        return $RV
}

#
# Return the file list containing only *.[ch] files
#
strip_files()
{
        local file=
        local tmp=

        for file in "$@" ; do
#               [ "${file:0:1}" != "/" ] && file=$REPOROOT/$file
                tmp=${file%%*.[ch]}
                [ -z "$tmp" ] && echo -n "$file "
                [ -n "$DEBUG" ] && [ -z "$tmp" ] && echo ":: $file" >&2
        done
}

#
# Use the output of git status to create a set of files to process.
#
git_committed()
{
        git status --porcelain=v1 | sed -n -e '/^[AMC]/s/^.*  *//p' \
                                           -e '/^[R]/s/^.*  *//p' | \
                                                awk '{print $NF}'
}

#
# Help nessage describing the command line options
#
help()
{
        cat <<"EOF"

        style_file: [-h] [--git] [--add] [--file|-f] [<file 1> <file2> ... ]

        -h           Display this message

        --git        Look to the git index and repo for the
                     set of files to format

        --add        Run 'git add ' on the files formatted

        --file/-f    Provide the list of files to format as a file
                     conbtaining the set of files to format

        *            Files provided on the command line

        Each of these means of collecting files to process are
        mutually exclusive

EOF
}

#
# Parse the command line args passed in and set variables
# according to args.  Because this is wrapped into a routine
# the variables set mmust be exported from the main env.
#
set_env()
{
        while [ $# -ne 0 ] ; do
                case $1 in
                --git|-g) FILES="$(git_committed)"
                        [ -n "$DEBUG" ] && echo ":: FILES is ($FILES)" >&2
                        break
                        ;;
                --add) GIT_ADD=yes;
                        ;;
                -h) help; exit 0;
                        ;;
                -f|--file) [ ! -f "$2" ] && echo "No file? [$2]" >&2 && exit 1
                        if ! FILES=$(cat "$2" | sed -e 's/^[ 	]*//') ;\
                         then
                                echo "Failed to read files from "$2""
                                exit 1
                        fi
                        ;;
                *) [ -z "$1" ] && echo "No arg specified." && exit 1;
                   [ ! -f "$1" ] && echo "No such file: ($1)" && exit 1
                        FILES="$FILES $1"
                        ;;
                esac
                shift
        done
}

ORIGIN=$(pwd)/
NULL2="2>/dev/null"
RERR2=">&2"
export GIT_ADD=
export FILES=
RED='\033[1;31m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
BLUE='\033[1;34m'
RESET='\033[39;49m'

if [ "$(basename $0)" = "style_file" ] ; then
        set_env $@
elif [ "$#" -ne 0 ] ; then
        echo "Ignoring command line arguments"
fi

[ -z "$FILES" ] && FILES=$(set_files)
if [ -z "$FILES" ] ; then
        /bin/echo -e "${GREEN}\tFound no files to process." >&2
        #
        # If there are no files to process there weren't any style errors!
        #
        exit 0
fi

[ -n "$DEBUG" -a -n "$FILES" ] && echo ":: FILES    [$FILES]" >&2
[ -n "$REPOROOT" ] && cd $REPOROOT && REPOROOT=$(pwd) && cd $(ORIGIN)
REPOROOT=$(find_repo $FILES)

#
# Assume the first file represents the location
# of the repo for all files processed.
#
SRCS=$(strip_files $FILES)

# If there are no SRCS to format then by default there are no style errors.
#
[ -z "$SRCS" ] && /bin/echo -e "${GREEN}\tNo style errors found." >&2 && exit 0
[ -n "$DEBUG" ] && echo ":: SRCS:  [$SRCS]" >&2
[ -n "$DEBUG" ] && echo ":: REPOROOT is [$REPOROOT]" >&2
[ -n "$DEBUG" ] && echo ":: ORIGIN is [$ORIGIN]" >&2

if ! style_files $REPOROOT $SRCS ; then
        [ -n "$DEBUG" ] && VERBOSE=--verbose
        [ -n "$GIT_ADD" ] && git add $VERBOSE $SRCS
        /bin/echo -e "${RED}\tNuttx style errors: Please correct." >&2
        /bin/echo -e "${RED}\tSee style.errs in the root of this repo." >&2
        /bin/echo -e "${RESET}"
        exit 2
fi
/bin/echo -e "${GREEN}Success!  There are no style errors.${RESET}" >&2

