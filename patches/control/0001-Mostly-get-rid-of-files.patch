From a33e0fcdfdc9090f20dadca3f65e3959b0c3a019 Mon Sep 17 00:00:00 2001
From: Bill Rees <bill@zglue.com>
Date: Fri, 5 Jan 2018 03:04:31 -0800
Subject:     Mostly get rid of files.

Change-Id: I393d014413834f236a324e5611e9115bad750af9
---
 arch/arm/src/nrf52/Make.defs                       |     2 +-
 .../src/nrf52/components/device/nrf51_to_nrf52.h   |   952 --
 .../nrf52/components/device/nrf52832_peripherals.h |   218 -
 .../src/nrf52/components/device/nrf52_bitfields.h  | 12642 -------------------
 .../src/nrf52/components/drivers_nrf/hal/nrf_i2s.h |   536 -
 .../nrf52/components/drivers_nrf/hal/nrf_nvmc.c    |     4 +-
 .../src/nrf52/components/drivers_nrf/hal/nrf_rtc.h |   316 -
 .../toolchain/cmsis/include/cmsis_armcc.h          |   734 --
 .../toolchain/cmsis/include/cmsis_armcc_V6.h       |  1812 ---
 .../toolchain/cmsis/include/core_sc000.h           |   926 --
 .../toolchain/cmsis/include/core_sc300.h           |  1752 ---
 arch/arm/src/nrf52/nrf52_adc.c                     |     3 +-
 arch/arm/src/nrf52/nrf52_exti.h                    |   145 -
 arch/arm/src/nrf52/nrf52_exti_alarm.c              |   159 -
 arch/arm/src/nrf52/nrf52_exti_comp.c               |   180 -
 arch/arm/src/nrf52/nrf52_exti_gpio.c               |   389 -
 arch/arm/src/nrf52/nrf52_exti_pwr.c                |   161 -
 arch/arm/src/nrf52/nrf52_exti_pwr.h                |    71 -
 arch/arm/src/nrf52/nrf52_flash.c                   |    11 +-
 arch/arm/src/nrf52/nrf52_freerun.c                 |   288 -
 arch/arm/src/nrf52/nrf52_freerun.h                 |   159 -
 arch/arm/src/nrf52/nrf52_lse.c                     |    93 -
 arch/arm/src/nrf52/nrf52_oneshot.c                 |   475 -
 arch/arm/src/nrf52/nrf52_oneshot.h                 |   212 -
 arch/arm/src/nrf52/nrf52_oneshot_lowerhalf.c       |   345 -
 arch/arm/src/nrf52/nrf52_otgfs.h                   |   128 -
 arch/arm/src/nrf52/nrf52_otgfsdev.c                |  5811 ---------
 arch/arm/src/nrf52/nrf52_otgfshost.c               |  5410 --------
 arch/arm/src/nrf52/nrf52_qencoder.c                |  1157 --
 arch/arm/src/nrf52/nrf52_qencoder.h                |   141 -
 arch/arm/src/nrf52/nrf52_rcc.c                     |   906 --
 arch/arm/src/nrf52/nrf52_rcc.h                     |   230 -
 arch/arm/src/nrf52/nrf52_sai.c                     |  1452 ---
 arch/arm/src/nrf52/nrf52_sai.h                     |    94 -
 arch/arm/src/nrf52/nrf52_tickless.c                |   351 -
 arch/arm/src/nrf52/nrf52_waste.c                   |    57 -
 arch/arm/src/nrf52/nrf52_waste.h                   |    79 -
 arch/arm/src/nrf52/nrf52_wdg.c                     |     2 -
 arch/arm/src/nrf52/nrf_uarte.h                     |   547 -
 configs/nrf52832_dk/defaults.mk                    |     3 +-
 40 files changed, 11 insertions(+), 38942 deletions(-)
 delete mode 100644 arch/arm/src/nrf52/components/device/nrf51_to_nrf52.h
 delete mode 100644 arch/arm/src/nrf52/components/device/nrf52832_peripherals.h
 delete mode 100644 arch/arm/src/nrf52/components/device/nrf52_bitfields.h
 delete mode 100644 arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_i2s.h
 delete mode 100644 arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_rtc.h
 delete mode 100644 arch/arm/src/nrf52/components/toolchain/cmsis/include/cmsis_armcc.h
 delete mode 100644 arch/arm/src/nrf52/components/toolchain/cmsis/include/cmsis_armcc_V6.h
 delete mode 100644 arch/arm/src/nrf52/components/toolchain/cmsis/include/core_sc000.h
 delete mode 100644 arch/arm/src/nrf52/components/toolchain/cmsis/include/core_sc300.h
 delete mode 100644 arch/arm/src/nrf52/nrf52_exti.h
 delete mode 100644 arch/arm/src/nrf52/nrf52_exti_alarm.c
 delete mode 100644 arch/arm/src/nrf52/nrf52_exti_comp.c
 delete mode 100644 arch/arm/src/nrf52/nrf52_exti_gpio.c
 delete mode 100644 arch/arm/src/nrf52/nrf52_exti_pwr.c
 delete mode 100644 arch/arm/src/nrf52/nrf52_exti_pwr.h
 delete mode 100644 arch/arm/src/nrf52/nrf52_freerun.c
 delete mode 100644 arch/arm/src/nrf52/nrf52_freerun.h
 delete mode 100644 arch/arm/src/nrf52/nrf52_lse.c
 delete mode 100644 arch/arm/src/nrf52/nrf52_oneshot.c
 delete mode 100644 arch/arm/src/nrf52/nrf52_oneshot.h
 delete mode 100644 arch/arm/src/nrf52/nrf52_oneshot_lowerhalf.c
 delete mode 100644 arch/arm/src/nrf52/nrf52_otgfs.h
 delete mode 100644 arch/arm/src/nrf52/nrf52_otgfsdev.c
 delete mode 100644 arch/arm/src/nrf52/nrf52_otgfshost.c
 delete mode 100644 arch/arm/src/nrf52/nrf52_qencoder.c
 delete mode 100644 arch/arm/src/nrf52/nrf52_qencoder.h
 delete mode 100644 arch/arm/src/nrf52/nrf52_rcc.c
 delete mode 100644 arch/arm/src/nrf52/nrf52_rcc.h
 delete mode 100644 arch/arm/src/nrf52/nrf52_sai.c
 delete mode 100644 arch/arm/src/nrf52/nrf52_sai.h
 delete mode 100644 arch/arm/src/nrf52/nrf52_tickless.c
 delete mode 100644 arch/arm/src/nrf52/nrf52_waste.c
 delete mode 100644 arch/arm/src/nrf52/nrf52_waste.h
 delete mode 100644 arch/arm/src/nrf52/nrf_uarte.h

diff --git a/arch/arm/src/nrf52/Make.defs b/arch/arm/src/nrf52/Make.defs
index 123d521ec0..0252c64be2 100755
--- a/arch/arm/src/nrf52/Make.defs
+++ b/arch/arm/src/nrf52/Make.defs
@@ -119,7 +119,7 @@ CHIP_CSRCS  += app_util_platform.c
 VPATH  += $(HAL_HEADERS)
 CHIP_CSRCS  += nrf_nvmc.c
 CHIP_CSRCS  += nrf52_flash.c
-CHIP_CSRCS  += nrf52_waste.c
+# CHIP_CSRCS  += nrf52_waste.c
 
 ifeq ($(CONFIG_NRF52_BLUETOOTH),y)
 
diff --git a/arch/arm/src/nrf52/components/device/nrf51_to_nrf52.h b/arch/arm/src/nrf52/components/device/nrf51_to_nrf52.h
deleted file mode 100644
index 8a4ff21666..0000000000
--- a/arch/arm/src/nrf52/components/device/nrf51_to_nrf52.h
+++ /dev/null
@@ -1,952 +0,0 @@
-/* Copyright (c) 2016, Nordic Semiconductor ASA
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *   * Redistributions of source code must retain the above copyright notice, this
- *     list of conditions and the following disclaimer.
- *
- *   * Redistributions in binary form must reproduce the above copyright notice,
- *     this list of conditions and the following disclaimer in the documentation
- *     and/or other materials provided with the distribution.
- *
- *   * Neither the name of Nordic Semiconductor ASA nor the names of its
- *     contributors may be used to endorse or promote products derived from
- *     this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#ifndef NRF51_TO_NRF52_H
-#define NRF51_TO_NRF52_H
-
-/*lint ++flb "Enter library region */
-
-/* This file is given to prevent your SW from not compiling with the name changes between nRF51 and nRF52 devices.
- * It redefines the old nRF51 names into the new ones as long as the functionality is still supported. If the
- * functionality is gone, there old names are not defined, so compilation will fail. Note that also includes macros
- * from the nrf51_deprecated.h file. */
-
-
-/* IRQ */
-/* Several peripherals have been added to several indexes. Names of IRQ handlers and IRQ numbers have changed. */
-#define UART0_IRQHandler        UARTE0_UART0_IRQHandler
-#define SPI0_TWI0_IRQHandler    SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQHandler
-#define SPI1_TWI1_IRQHandler    SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQHandler
-#define ADC_IRQHandler          SAADC_IRQHandler
-#define LPCOMP_IRQHandler       COMP_LPCOMP_IRQHandler
-#define SWI0_IRQHandler         SWI0_EGU0_IRQHandler
-#define SWI1_IRQHandler         SWI1_EGU1_IRQHandler
-#define SWI2_IRQHandler         SWI2_EGU2_IRQHandler
-#define SWI3_IRQHandler         SWI3_EGU3_IRQHandler
-#define SWI4_IRQHandler         SWI4_EGU4_IRQHandler
-#define SWI5_IRQHandler         SWI5_EGU5_IRQHandler
-
-#define UART0_IRQn              UARTE0_UART0_IRQn
-#define SPI0_TWI0_IRQn          SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQn
-#define SPI1_TWI1_IRQn          SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQn
-#define ADC_IRQn                SAADC_IRQn
-#define LPCOMP_IRQn             COMP_LPCOMP_IRQn
-#define SWI0_IRQn               SWI0_EGU0_IRQn
-#define SWI1_IRQn               SWI1_EGU1_IRQn
-#define SWI2_IRQn               SWI2_EGU2_IRQn
-#define SWI3_IRQn               SWI3_EGU3_IRQn
-#define SWI4_IRQn               SWI4_EGU4_IRQn
-#define SWI5_IRQn               SWI5_EGU5_IRQn
-
-
-/* UICR */
-/* Register RBPCONF was renamed to APPROTECT. */
-#define RBPCONF     APPROTECT
-
-#define UICR_RBPCONF_PALL_Pos           UICR_APPROTECT_PALL_Pos
-#define UICR_RBPCONF_PALL_Msk           UICR_APPROTECT_PALL_Msk
-#define UICR_RBPCONF_PALL_Enabled       UICR_APPROTECT_PALL_Enabled
-#define UICR_RBPCONF_PALL_Disabled      UICR_APPROTECT_PALL_Disabled
-
-
-/* GPIO */
-/* GPIO port was renamed to P0. */
-#define NRF_GPIO        NRF_P0
-#define NRF_GPIO_BASE   NRF_P0_BASE
-
-
-/* QDEC */
-/* The registers PSELA, PSELB and PSELLED were restructured into a struct. */
-#define PSELLED     PSEL.LED
-#define PSELA       PSEL.A
-#define PSELB       PSEL.B
-
-
-/* SPIS */
-/* The registers PSELSCK, PSELMISO, PSELMOSI, PSELCSN were restructured into a struct. */
-#define PSELSCK       PSEL.SCK
-#define PSELMISO      PSEL.MISO
-#define PSELMOSI      PSEL.MOSI
-#define PSELCSN       PSEL.CSN
-
-/* The registers RXDPTR, MAXRX, AMOUNTRX were restructured into a struct */
-#define RXDPTR        RXD.PTR
-#define MAXRX         RXD.MAXCNT
-#define AMOUNTRX      RXD.AMOUNT
-
-#define SPIS_MAXRX_MAXRX_Pos        SPIS_RXD_MAXCNT_MAXCNT_Pos
-#define SPIS_MAXRX_MAXRX_Msk        SPIS_RXD_MAXCNT_MAXCNT_Msk
-
-#define SPIS_AMOUNTRX_AMOUNTRX_Pos  SPIS_RXD_AMOUNT_AMOUNT_Pos
-#define SPIS_AMOUNTRX_AMOUNTRX_Msk  SPIS_RXD_AMOUNT_AMOUNT_Msk
-
-/* The registers TXDPTR, MAXTX, AMOUNTTX were restructured into a struct */
-#define TXDPTR        TXD.PTR
-#define MAXTX         TXD.MAXCNT
-#define AMOUNTTX      TXD.AMOUNT
-
-#define SPIS_MAXTX_MAXTX_Pos        SPIS_TXD_MAXCNT_MAXCNT_Pos
-#define SPIS_MAXTX_MAXTX_Msk        SPIS_TXD_MAXCNT_MAXCNT_Msk
-
-#define SPIS_AMOUNTTX_AMOUNTTX_Pos  SPIS_TXD_AMOUNT_AMOUNT_Pos
-#define SPIS_AMOUNTTX_AMOUNTTX_Msk  SPIS_TXD_AMOUNT_AMOUNT_Msk
-
-
-/* MPU */
-/* Part of MPU module was renamed BPROT, while the rest was eliminated. */
-#define NRF_MPU     NRF_BPROT
-
-/* Register DISABLEINDEBUG macros were affected. */
-#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Pos       BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Pos
-#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Msk       BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Msk
-#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Enabled   BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Enabled
-#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Disabled  BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Disabled
-
-/* Registers PROTENSET0 and PROTENSET1 were affected and renamed as CONFIG0 and CONFIG1. */
-#define PROTENSET0  CONFIG0
-#define PROTENSET1  CONFIG1
-
-#define MPU_PROTENSET1_PROTREG63_Pos        BPROT_CONFIG1_REGION63_Pos
-#define MPU_PROTENSET1_PROTREG63_Msk        BPROT_CONFIG1_REGION63_Msk
-#define MPU_PROTENSET1_PROTREG63_Disabled   BPROT_CONFIG1_REGION63_Disabled
-#define MPU_PROTENSET1_PROTREG63_Enabled    BPROT_CONFIG1_REGION63_Enabled
-#define MPU_PROTENSET1_PROTREG63_Set        BPROT_CONFIG1_REGION63_Enabled
-
-#define MPU_PROTENSET1_PROTREG62_Pos        BPROT_CONFIG1_REGION62_Pos
-#define MPU_PROTENSET1_PROTREG62_Msk        BPROT_CONFIG1_REGION62_Msk
-#define MPU_PROTENSET1_PROTREG62_Disabled   BPROT_CONFIG1_REGION62_Disabled
-#define MPU_PROTENSET1_PROTREG62_Enabled    BPROT_CONFIG1_REGION62_Enabled
-#define MPU_PROTENSET1_PROTREG62_Set        BPROT_CONFIG1_REGION62_Enabled
-
-#define MPU_PROTENSET1_PROTREG61_Pos        BPROT_CONFIG1_REGION61_Pos
-#define MPU_PROTENSET1_PROTREG61_Msk        BPROT_CONFIG1_REGION61_Msk
-#define MPU_PROTENSET1_PROTREG61_Disabled   BPROT_CONFIG1_REGION61_Disabled
-#define MPU_PROTENSET1_PROTREG61_Enabled    BPROT_CONFIG1_REGION61_Enabled
-#define MPU_PROTENSET1_PROTREG61_Set        BPROT_CONFIG1_REGION61_Enabled
-
-#define MPU_PROTENSET1_PROTREG60_Pos        BPROT_CONFIG1_REGION60_Pos
-#define MPU_PROTENSET1_PROTREG60_Msk        BPROT_CONFIG1_REGION60_Msk
-#define MPU_PROTENSET1_PROTREG60_Disabled   BPROT_CONFIG1_REGION60_Disabled
-#define MPU_PROTENSET1_PROTREG60_Enabled    BPROT_CONFIG1_REGION60_Enabled
-#define MPU_PROTENSET1_PROTREG60_Set        BPROT_CONFIG1_REGION60_Enabled
-
-#define MPU_PROTENSET1_PROTREG59_Pos        BPROT_CONFIG1_REGION59_Pos
-#define MPU_PROTENSET1_PROTREG59_Msk        BPROT_CONFIG1_REGION59_Msk
-#define MPU_PROTENSET1_PROTREG59_Disabled   BPROT_CONFIG1_REGION59_Disabled
-#define MPU_PROTENSET1_PROTREG59_Enabled    BPROT_CONFIG1_REGION59_Enabled
-#define MPU_PROTENSET1_PROTREG59_Set        BPROT_CONFIG1_REGION59_Enabled
-
-#define MPU_PROTENSET1_PROTREG58_Pos        BPROT_CONFIG1_REGION58_Pos
-#define MPU_PROTENSET1_PROTREG58_Msk        BPROT_CONFIG1_REGION58_Msk
-#define MPU_PROTENSET1_PROTREG58_Disabled   BPROT_CONFIG1_REGION58_Disabled
-#define MPU_PROTENSET1_PROTREG58_Enabled    BPROT_CONFIG1_REGION58_Enabled
-#define MPU_PROTENSET1_PROTREG58_Set        BPROT_CONFIG1_REGION58_Enabled
-
-#define MPU_PROTENSET1_PROTREG57_Pos        BPROT_CONFIG1_REGION57_Pos
-#define MPU_PROTENSET1_PROTREG57_Msk        BPROT_CONFIG1_REGION57_Msk
-#define MPU_PROTENSET1_PROTREG57_Disabled   BPROT_CONFIG1_REGION57_Disabled
-#define MPU_PROTENSET1_PROTREG57_Enabled    BPROT_CONFIG1_REGION57_Enabled
-#define MPU_PROTENSET1_PROTREG57_Set        BPROT_CONFIG1_REGION57_Enabled
-
-#define MPU_PROTENSET1_PROTREG56_Pos        BPROT_CONFIG1_REGION56_Pos
-#define MPU_PROTENSET1_PROTREG56_Msk        BPROT_CONFIG1_REGION56_Msk
-#define MPU_PROTENSET1_PROTREG56_Disabled   BPROT_CONFIG1_REGION56_Disabled
-#define MPU_PROTENSET1_PROTREG56_Enabled    BPROT_CONFIG1_REGION56_Enabled
-#define MPU_PROTENSET1_PROTREG56_Set        BPROT_CONFIG1_REGION56_Enabled
-
-#define MPU_PROTENSET1_PROTREG55_Pos        BPROT_CONFIG1_REGION55_Pos
-#define MPU_PROTENSET1_PROTREG55_Msk        BPROT_CONFIG1_REGION55_Msk
-#define MPU_PROTENSET1_PROTREG55_Disabled   BPROT_CONFIG1_REGION55_Disabled
-#define MPU_PROTENSET1_PROTREG55_Enabled    BPROT_CONFIG1_REGION55_Enabled
-#define MPU_PROTENSET1_PROTREG55_Set        BPROT_CONFIG1_REGION55_Enabled
-
-#define MPU_PROTENSET1_PROTREG54_Pos        BPROT_CONFIG1_REGION54_Pos
-#define MPU_PROTENSET1_PROTREG54_Msk        BPROT_CONFIG1_REGION54_Msk
-#define MPU_PROTENSET1_PROTREG54_Disabled   BPROT_CONFIG1_REGION54_Disabled
-#define MPU_PROTENSET1_PROTREG54_Enabled    BPROT_CONFIG1_REGION54_Enabled
-#define MPU_PROTENSET1_PROTREG54_Set        BPROT_CONFIG1_REGION54_Enabled
-
-#define MPU_PROTENSET1_PROTREG53_Pos        BPROT_CONFIG1_REGION53_Pos
-#define MPU_PROTENSET1_PROTREG53_Msk        BPROT_CONFIG1_REGION53_Msk
-#define MPU_PROTENSET1_PROTREG53_Disabled   BPROT_CONFIG1_REGION53_Disabled
-#define MPU_PROTENSET1_PROTREG53_Enabled    BPROT_CONFIG1_REGION53_Enabled
-#define MPU_PROTENSET1_PROTREG53_Set        BPROT_CONFIG1_REGION53_Enabled
-
-#define MPU_PROTENSET1_PROTREG52_Pos        BPROT_CONFIG1_REGION52_Pos
-#define MPU_PROTENSET1_PROTREG52_Msk        BPROT_CONFIG1_REGION52_Msk
-#define MPU_PROTENSET1_PROTREG52_Disabled   BPROT_CONFIG1_REGION52_Disabled
-#define MPU_PROTENSET1_PROTREG52_Enabled    BPROT_CONFIG1_REGION52_Enabled
-#define MPU_PROTENSET1_PROTREG52_Set        BPROT_CONFIG1_REGION52_Enabled
-
-#define MPU_PROTENSET1_PROTREG51_Pos        BPROT_CONFIG1_REGION51_Pos
-#define MPU_PROTENSET1_PROTREG51_Msk        BPROT_CONFIG1_REGION51_Msk
-#define MPU_PROTENSET1_PROTREG51_Disabled   BPROT_CONFIG1_REGION51_Disabled
-#define MPU_PROTENSET1_PROTREG51_Enabled    BPROT_CONFIG1_REGION51_Enabled
-#define MPU_PROTENSET1_PROTREG51_Set        BPROT_CONFIG1_REGION51_Enabled
-
-#define MPU_PROTENSET1_PROTREG50_Pos        BPROT_CONFIG1_REGION50_Pos
-#define MPU_PROTENSET1_PROTREG50_Msk        BPROT_CONFIG1_REGION50_Msk
-#define MPU_PROTENSET1_PROTREG50_Disabled   BPROT_CONFIG1_REGION50_Disabled
-#define MPU_PROTENSET1_PROTREG50_Enabled    BPROT_CONFIG1_REGION50_Enabled
-#define MPU_PROTENSET1_PROTREG50_Set        BPROT_CONFIG1_REGION50_Enabled
-
-#define MPU_PROTENSET1_PROTREG49_Pos        BPROT_CONFIG1_REGION49_Pos
-#define MPU_PROTENSET1_PROTREG49_Msk        BPROT_CONFIG1_REGION49_Msk
-#define MPU_PROTENSET1_PROTREG49_Disabled   BPROT_CONFIG1_REGION49_Disabled
-#define MPU_PROTENSET1_PROTREG49_Enabled    BPROT_CONFIG1_REGION49_Enabled
-#define MPU_PROTENSET1_PROTREG49_Set        BPROT_CONFIG1_REGION49_Enabled
-
-#define MPU_PROTENSET1_PROTREG48_Pos        BPROT_CONFIG1_REGION48_Pos
-#define MPU_PROTENSET1_PROTREG48_Msk        BPROT_CONFIG1_REGION48_Msk
-#define MPU_PROTENSET1_PROTREG48_Disabled   BPROT_CONFIG1_REGION48_Disabled
-#define MPU_PROTENSET1_PROTREG48_Enabled    BPROT_CONFIG1_REGION48_Enabled
-#define MPU_PROTENSET1_PROTREG48_Set        BPROT_CONFIG1_REGION48_Enabled
-
-#define MPU_PROTENSET1_PROTREG47_Pos        BPROT_CONFIG1_REGION47_Pos
-#define MPU_PROTENSET1_PROTREG47_Msk        BPROT_CONFIG1_REGION47_Msk
-#define MPU_PROTENSET1_PROTREG47_Disabled   BPROT_CONFIG1_REGION47_Disabled
-#define MPU_PROTENSET1_PROTREG47_Enabled    BPROT_CONFIG1_REGION47_Enabled
-#define MPU_PROTENSET1_PROTREG47_Set        BPROT_CONFIG1_REGION47_Enabled
-
-#define MPU_PROTENSET1_PROTREG46_Pos        BPROT_CONFIG1_REGION46_Pos
-#define MPU_PROTENSET1_PROTREG46_Msk        BPROT_CONFIG1_REGION46_Msk
-#define MPU_PROTENSET1_PROTREG46_Disabled   BPROT_CONFIG1_REGION46_Disabled
-#define MPU_PROTENSET1_PROTREG46_Enabled    BPROT_CONFIG1_REGION46_Enabled
-#define MPU_PROTENSET1_PROTREG46_Set        BPROT_CONFIG1_REGION46_Enabled
-
-#define MPU_PROTENSET1_PROTREG45_Pos        BPROT_CONFIG1_REGION45_Pos
-#define MPU_PROTENSET1_PROTREG45_Msk        BPROT_CONFIG1_REGION45_Msk
-#define MPU_PROTENSET1_PROTREG45_Disabled   BPROT_CONFIG1_REGION45_Disabled
-#define MPU_PROTENSET1_PROTREG45_Enabled    BPROT_CONFIG1_REGION45_Enabled
-#define MPU_PROTENSET1_PROTREG45_Set        BPROT_CONFIG1_REGION45_Enabled
-
-#define MPU_PROTENSET1_PROTREG44_Pos        BPROT_CONFIG1_REGION44_Pos
-#define MPU_PROTENSET1_PROTREG44_Msk        BPROT_CONFIG1_REGION44_Msk
-#define MPU_PROTENSET1_PROTREG44_Disabled   BPROT_CONFIG1_REGION44_Disabled
-#define MPU_PROTENSET1_PROTREG44_Enabled    BPROT_CONFIG1_REGION44_Enabled
-#define MPU_PROTENSET1_PROTREG44_Set        BPROT_CONFIG1_REGION44_Enabled
-
-#define MPU_PROTENSET1_PROTREG43_Pos        BPROT_CONFIG1_REGION43_Pos
-#define MPU_PROTENSET1_PROTREG43_Msk        BPROT_CONFIG1_REGION43_Msk
-#define MPU_PROTENSET1_PROTREG43_Disabled   BPROT_CONFIG1_REGION43_Disabled
-#define MPU_PROTENSET1_PROTREG43_Enabled    BPROT_CONFIG1_REGION43_Enabled
-#define MPU_PROTENSET1_PROTREG43_Set        BPROT_CONFIG1_REGION43_Enabled
-
-#define MPU_PROTENSET1_PROTREG42_Pos        BPROT_CONFIG1_REGION42_Pos
-#define MPU_PROTENSET1_PROTREG42_Msk        BPROT_CONFIG1_REGION42_Msk
-#define MPU_PROTENSET1_PROTREG42_Disabled   BPROT_CONFIG1_REGION42_Disabled
-#define MPU_PROTENSET1_PROTREG42_Enabled    BPROT_CONFIG1_REGION42_Enabled
-#define MPU_PROTENSET1_PROTREG42_Set        BPROT_CONFIG1_REGION42_Enabled
-
-#define MPU_PROTENSET1_PROTREG41_Pos        BPROT_CONFIG1_REGION41_Pos
-#define MPU_PROTENSET1_PROTREG41_Msk        BPROT_CONFIG1_REGION41_Msk
-#define MPU_PROTENSET1_PROTREG41_Disabled   BPROT_CONFIG1_REGION41_Disabled
-#define MPU_PROTENSET1_PROTREG41_Enabled    BPROT_CONFIG1_REGION41_Enabled
-#define MPU_PROTENSET1_PROTREG41_Set        BPROT_CONFIG1_REGION41_Enabled
-
-#define MPU_PROTENSET1_PROTREG40_Pos        BPROT_CONFIG1_REGION40_Pos
-#define MPU_PROTENSET1_PROTREG40_Msk        BPROT_CONFIG1_REGION40_Msk
-#define MPU_PROTENSET1_PROTREG40_Disabled   BPROT_CONFIG1_REGION40_Disabled
-#define MPU_PROTENSET1_PROTREG40_Enabled    BPROT_CONFIG1_REGION40_Enabled
-#define MPU_PROTENSET1_PROTREG40_Set        BPROT_CONFIG1_REGION40_Enabled
-
-#define MPU_PROTENSET1_PROTREG39_Pos        BPROT_CONFIG1_REGION39_Pos
-#define MPU_PROTENSET1_PROTREG39_Msk        BPROT_CONFIG1_REGION39_Msk
-#define MPU_PROTENSET1_PROTREG39_Disabled   BPROT_CONFIG1_REGION39_Disabled
-#define MPU_PROTENSET1_PROTREG39_Enabled    BPROT_CONFIG1_REGION39_Enabled
-#define MPU_PROTENSET1_PROTREG39_Set        BPROT_CONFIG1_REGION39_Enabled
-
-#define MPU_PROTENSET1_PROTREG38_Pos        BPROT_CONFIG1_REGION38_Pos
-#define MPU_PROTENSET1_PROTREG38_Msk        BPROT_CONFIG1_REGION38_Msk
-#define MPU_PROTENSET1_PROTREG38_Disabled   BPROT_CONFIG1_REGION38_Disabled
-#define MPU_PROTENSET1_PROTREG38_Enabled    BPROT_CONFIG1_REGION38_Enabled
-#define MPU_PROTENSET1_PROTREG38_Set        BPROT_CONFIG1_REGION38_Enabled
-
-#define MPU_PROTENSET1_PROTREG37_Pos        BPROT_CONFIG1_REGION37_Pos
-#define MPU_PROTENSET1_PROTREG37_Msk        BPROT_CONFIG1_REGION37_Msk
-#define MPU_PROTENSET1_PROTREG37_Disabled   BPROT_CONFIG1_REGION37_Disabled
-#define MPU_PROTENSET1_PROTREG37_Enabled    BPROT_CONFIG1_REGION37_Enabled
-#define MPU_PROTENSET1_PROTREG37_Set        BPROT_CONFIG1_REGION37_Enabled
-
-#define MPU_PROTENSET1_PROTREG36_Pos        BPROT_CONFIG1_REGION36_Pos
-#define MPU_PROTENSET1_PROTREG36_Msk        BPROT_CONFIG1_REGION36_Msk
-#define MPU_PROTENSET1_PROTREG36_Disabled   BPROT_CONFIG1_REGION36_Disabled
-#define MPU_PROTENSET1_PROTREG36_Enabled    BPROT_CONFIG1_REGION36_Enabled
-#define MPU_PROTENSET1_PROTREG36_Set        BPROT_CONFIG1_REGION36_Enabled
-
-#define MPU_PROTENSET1_PROTREG35_Pos        BPROT_CONFIG1_REGION35_Pos
-#define MPU_PROTENSET1_PROTREG35_Msk        BPROT_CONFIG1_REGION35_Msk
-#define MPU_PROTENSET1_PROTREG35_Disabled   BPROT_CONFIG1_REGION35_Disabled
-#define MPU_PROTENSET1_PROTREG35_Enabled    BPROT_CONFIG1_REGION35_Enabled
-#define MPU_PROTENSET1_PROTREG35_Set        BPROT_CONFIG1_REGION35_Enabled
-
-#define MPU_PROTENSET1_PROTREG34_Pos        BPROT_CONFIG1_REGION34_Pos
-#define MPU_PROTENSET1_PROTREG34_Msk        BPROT_CONFIG1_REGION34_Msk
-#define MPU_PROTENSET1_PROTREG34_Disabled   BPROT_CONFIG1_REGION34_Disabled
-#define MPU_PROTENSET1_PROTREG34_Enabled    BPROT_CONFIG1_REGION34_Enabled
-#define MPU_PROTENSET1_PROTREG34_Set        BPROT_CONFIG1_REGION34_Enabled
-
-#define MPU_PROTENSET1_PROTREG33_Pos        BPROT_CONFIG1_REGION33_Pos
-#define MPU_PROTENSET1_PROTREG33_Msk        BPROT_CONFIG1_REGION33_Msk
-#define MPU_PROTENSET1_PROTREG33_Disabled   BPROT_CONFIG1_REGION33_Disabled
-#define MPU_PROTENSET1_PROTREG33_Enabled    BPROT_CONFIG1_REGION33_Enabled
-#define MPU_PROTENSET1_PROTREG33_Set        BPROT_CONFIG1_REGION33_Enabled
-
-#define MPU_PROTENSET1_PROTREG32_Pos        BPROT_CONFIG1_REGION32_Pos
-#define MPU_PROTENSET1_PROTREG32_Msk        BPROT_CONFIG1_REGION32_Msk
-#define MPU_PROTENSET1_PROTREG32_Disabled   BPROT_CONFIG1_REGION32_Disabled
-#define MPU_PROTENSET1_PROTREG32_Enabled    BPROT_CONFIG1_REGION32_Enabled
-#define MPU_PROTENSET1_PROTREG32_Set        BPROT_CONFIG1_REGION32_Enabled
-
-#define MPU_PROTENSET0_PROTREG31_Pos        BPROT_CONFIG0_REGION31_Pos
-#define MPU_PROTENSET0_PROTREG31_Msk        BPROT_CONFIG0_REGION31_Msk
-#define MPU_PROTENSET0_PROTREG31_Disabled   BPROT_CONFIG0_REGION31_Disabled
-#define MPU_PROTENSET0_PROTREG31_Enabled    BPROT_CONFIG0_REGION31_Enabled
-#define MPU_PROTENSET0_PROTREG31_Set        BPROT_CONFIG0_REGION31_Enabled
-
-#define MPU_PROTENSET0_PROTREG30_Pos        BPROT_CONFIG0_REGION30_Pos
-#define MPU_PROTENSET0_PROTREG30_Msk        BPROT_CONFIG0_REGION30_Msk
-#define MPU_PROTENSET0_PROTREG30_Disabled   BPROT_CONFIG0_REGION30_Disabled
-#define MPU_PROTENSET0_PROTREG30_Enabled    BPROT_CONFIG0_REGION30_Enabled
-#define MPU_PROTENSET0_PROTREG30_Set        BPROT_CONFIG0_REGION30_Enabled
-
-#define MPU_PROTENSET0_PROTREG29_Pos        BPROT_CONFIG0_REGION29_Pos
-#define MPU_PROTENSET0_PROTREG29_Msk        BPROT_CONFIG0_REGION29_Msk
-#define MPU_PROTENSET0_PROTREG29_Disabled   BPROT_CONFIG0_REGION29_Disabled
-#define MPU_PROTENSET0_PROTREG29_Enabled    BPROT_CONFIG0_REGION29_Enabled
-#define MPU_PROTENSET0_PROTREG29_Set        BPROT_CONFIG0_REGION29_Enabled
-
-#define MPU_PROTENSET0_PROTREG28_Pos        BPROT_CONFIG0_REGION28_Pos
-#define MPU_PROTENSET0_PROTREG28_Msk        BPROT_CONFIG0_REGION28_Msk
-#define MPU_PROTENSET0_PROTREG28_Disabled   BPROT_CONFIG0_REGION28_Disabled
-#define MPU_PROTENSET0_PROTREG28_Enabled    BPROT_CONFIG0_REGION28_Enabled
-#define MPU_PROTENSET0_PROTREG28_Set        BPROT_CONFIG0_REGION28_Enabled
-
-#define MPU_PROTENSET0_PROTREG27_Pos        BPROT_CONFIG0_REGION27_Pos
-#define MPU_PROTENSET0_PROTREG27_Msk        BPROT_CONFIG0_REGION27_Msk
-#define MPU_PROTENSET0_PROTREG27_Disabled   BPROT_CONFIG0_REGION27_Disabled
-#define MPU_PROTENSET0_PROTREG27_Enabled    BPROT_CONFIG0_REGION27_Enabled
-#define MPU_PROTENSET0_PROTREG27_Set        BPROT_CONFIG0_REGION27_Enabled
-
-#define MPU_PROTENSET0_PROTREG26_Pos        BPROT_CONFIG0_REGION26_Pos
-#define MPU_PROTENSET0_PROTREG26_Msk        BPROT_CONFIG0_REGION26_Msk
-#define MPU_PROTENSET0_PROTREG26_Disabled   BPROT_CONFIG0_REGION26_Disabled
-#define MPU_PROTENSET0_PROTREG26_Enabled    BPROT_CONFIG0_REGION26_Enabled
-#define MPU_PROTENSET0_PROTREG26_Set        BPROT_CONFIG0_REGION26_Enabled
-
-#define MPU_PROTENSET0_PROTREG25_Pos        BPROT_CONFIG0_REGION25_Pos
-#define MPU_PROTENSET0_PROTREG25_Msk        BPROT_CONFIG0_REGION25_Msk
-#define MPU_PROTENSET0_PROTREG25_Disabled   BPROT_CONFIG0_REGION25_Disabled
-#define MPU_PROTENSET0_PROTREG25_Enabled    BPROT_CONFIG0_REGION25_Enabled
-#define MPU_PROTENSET0_PROTREG25_Set        BPROT_CONFIG0_REGION25_Enabled
-
-#define MPU_PROTENSET0_PROTREG24_Pos        BPROT_CONFIG0_REGION24_Pos
-#define MPU_PROTENSET0_PROTREG24_Msk        BPROT_CONFIG0_REGION24_Msk
-#define MPU_PROTENSET0_PROTREG24_Disabled   BPROT_CONFIG0_REGION24_Disabled
-#define MPU_PROTENSET0_PROTREG24_Enabled    BPROT_CONFIG0_REGION24_Enabled
-#define MPU_PROTENSET0_PROTREG24_Set        BPROT_CONFIG0_REGION24_Enabled
-
-#define MPU_PROTENSET0_PROTREG23_Pos        BPROT_CONFIG0_REGION23_Pos
-#define MPU_PROTENSET0_PROTREG23_Msk        BPROT_CONFIG0_REGION23_Msk
-#define MPU_PROTENSET0_PROTREG23_Disabled   BPROT_CONFIG0_REGION23_Disabled
-#define MPU_PROTENSET0_PROTREG23_Enabled    BPROT_CONFIG0_REGION23_Enabled
-#define MPU_PROTENSET0_PROTREG23_Set        BPROT_CONFIG0_REGION23_Enabled
-
-#define MPU_PROTENSET0_PROTREG22_Pos        BPROT_CONFIG0_REGION22_Pos
-#define MPU_PROTENSET0_PROTREG22_Msk        BPROT_CONFIG0_REGION22_Msk
-#define MPU_PROTENSET0_PROTREG22_Disabled   BPROT_CONFIG0_REGION22_Disabled
-#define MPU_PROTENSET0_PROTREG22_Enabled    BPROT_CONFIG0_REGION22_Enabled
-#define MPU_PROTENSET0_PROTREG22_Set        BPROT_CONFIG0_REGION22_Enabled
-
-#define MPU_PROTENSET0_PROTREG21_Pos        BPROT_CONFIG0_REGION21_Pos
-#define MPU_PROTENSET0_PROTREG21_Msk        BPROT_CONFIG0_REGION21_Msk
-#define MPU_PROTENSET0_PROTREG21_Disabled   BPROT_CONFIG0_REGION21_Disabled
-#define MPU_PROTENSET0_PROTREG21_Enabled    BPROT_CONFIG0_REGION21_Enabled
-#define MPU_PROTENSET0_PROTREG21_Set        BPROT_CONFIG0_REGION21_Enabled
-
-#define MPU_PROTENSET0_PROTREG20_Pos        BPROT_CONFIG0_REGION20_Pos
-#define MPU_PROTENSET0_PROTREG20_Msk        BPROT_CONFIG0_REGION20_Msk
-#define MPU_PROTENSET0_PROTREG20_Disabled   BPROT_CONFIG0_REGION20_Disabled
-#define MPU_PROTENSET0_PROTREG20_Enabled    BPROT_CONFIG0_REGION20_Enabled
-#define MPU_PROTENSET0_PROTREG20_Set        BPROT_CONFIG0_REGION20_Enabled
-
-#define MPU_PROTENSET0_PROTREG19_Pos        BPROT_CONFIG0_REGION19_Pos
-#define MPU_PROTENSET0_PROTREG19_Msk        BPROT_CONFIG0_REGION19_Msk
-#define MPU_PROTENSET0_PROTREG19_Disabled   BPROT_CONFIG0_REGION19_Disabled
-#define MPU_PROTENSET0_PROTREG19_Enabled    BPROT_CONFIG0_REGION19_Enabled
-#define MPU_PROTENSET0_PROTREG19_Set        BPROT_CONFIG0_REGION19_Enabled
-
-#define MPU_PROTENSET0_PROTREG18_Pos        BPROT_CONFIG0_REGION18_Pos
-#define MPU_PROTENSET0_PROTREG18_Msk        BPROT_CONFIG0_REGION18_Msk
-#define MPU_PROTENSET0_PROTREG18_Disabled   BPROT_CONFIG0_REGION18_Disabled
-#define MPU_PROTENSET0_PROTREG18_Enabled    BPROT_CONFIG0_REGION18_Enabled
-#define MPU_PROTENSET0_PROTREG18_Set        BPROT_CONFIG0_REGION18_Enabled
-
-#define MPU_PROTENSET0_PROTREG17_Pos        BPROT_CONFIG0_REGION17_Pos
-#define MPU_PROTENSET0_PROTREG17_Msk        BPROT_CONFIG0_REGION17_Msk
-#define MPU_PROTENSET0_PROTREG17_Disabled   BPROT_CONFIG0_REGION17_Disabled
-#define MPU_PROTENSET0_PROTREG17_Enabled    BPROT_CONFIG0_REGION17_Enabled
-#define MPU_PROTENSET0_PROTREG17_Set        BPROT_CONFIG0_REGION17_Enabled
-
-#define MPU_PROTENSET0_PROTREG16_Pos        BPROT_CONFIG0_REGION16_Pos
-#define MPU_PROTENSET0_PROTREG16_Msk        BPROT_CONFIG0_REGION16_Msk
-#define MPU_PROTENSET0_PROTREG16_Disabled   BPROT_CONFIG0_REGION16_Disabled
-#define MPU_PROTENSET0_PROTREG16_Enabled    BPROT_CONFIG0_REGION16_Enabled
-#define MPU_PROTENSET0_PROTREG16_Set        BPROT_CONFIG0_REGION16_Enabled
-
-#define MPU_PROTENSET0_PROTREG15_Pos        BPROT_CONFIG0_REGION15_Pos
-#define MPU_PROTENSET0_PROTREG15_Msk        BPROT_CONFIG0_REGION15_Msk
-#define MPU_PROTENSET0_PROTREG15_Disabled   BPROT_CONFIG0_REGION15_Disabled
-#define MPU_PROTENSET0_PROTREG15_Enabled    BPROT_CONFIG0_REGION15_Enabled
-#define MPU_PROTENSET0_PROTREG15_Set        BPROT_CONFIG0_REGION15_Enabled
-
-#define MPU_PROTENSET0_PROTREG14_Pos        BPROT_CONFIG0_REGION14_Pos
-#define MPU_PROTENSET0_PROTREG14_Msk        BPROT_CONFIG0_REGION14_Msk
-#define MPU_PROTENSET0_PROTREG14_Disabled   BPROT_CONFIG0_REGION14_Disabled
-#define MPU_PROTENSET0_PROTREG14_Enabled    BPROT_CONFIG0_REGION14_Enabled
-#define MPU_PROTENSET0_PROTREG14_Set        BPROT_CONFIG0_REGION14_Enabled
-
-#define MPU_PROTENSET0_PROTREG13_Pos        BPROT_CONFIG0_REGION13_Pos
-#define MPU_PROTENSET0_PROTREG13_Msk        BPROT_CONFIG0_REGION13_Msk
-#define MPU_PROTENSET0_PROTREG13_Disabled   BPROT_CONFIG0_REGION13_Disabled
-#define MPU_PROTENSET0_PROTREG13_Enabled    BPROT_CONFIG0_REGION13_Enabled
-#define MPU_PROTENSET0_PROTREG13_Set        BPROT_CONFIG0_REGION13_Enabled
-
-#define MPU_PROTENSET0_PROTREG12_Pos        BPROT_CONFIG0_REGION12_Pos
-#define MPU_PROTENSET0_PROTREG12_Msk        BPROT_CONFIG0_REGION12_Msk
-#define MPU_PROTENSET0_PROTREG12_Disabled   BPROT_CONFIG0_REGION12_Disabled
-#define MPU_PROTENSET0_PROTREG12_Enabled    BPROT_CONFIG0_REGION12_Enabled
-#define MPU_PROTENSET0_PROTREG12_Set        BPROT_CONFIG0_REGION12_Enabled
-
-#define MPU_PROTENSET0_PROTREG11_Pos        BPROT_CONFIG0_REGION11_Pos
-#define MPU_PROTENSET0_PROTREG11_Msk        BPROT_CONFIG0_REGION11_Msk
-#define MPU_PROTENSET0_PROTREG11_Disabled   BPROT_CONFIG0_REGION11_Disabled
-#define MPU_PROTENSET0_PROTREG11_Enabled    BPROT_CONFIG0_REGION11_Enabled
-#define MPU_PROTENSET0_PROTREG11_Set        BPROT_CONFIG0_REGION11_Enabled
-
-#define MPU_PROTENSET0_PROTREG10_Pos        BPROT_CONFIG0_REGION10_Pos
-#define MPU_PROTENSET0_PROTREG10_Msk        BPROT_CONFIG0_REGION10_Msk
-#define MPU_PROTENSET0_PROTREG10_Disabled   BPROT_CONFIG0_REGION10_Disabled
-#define MPU_PROTENSET0_PROTREG10_Enabled    BPROT_CONFIG0_REGION10_Enabled
-#define MPU_PROTENSET0_PROTREG10_Set        BPROT_CONFIG0_REGION10_Enabled
-
-#define MPU_PROTENSET0_PROTREG9_Pos        BPROT_CONFIG0_REGION9_Pos
-#define MPU_PROTENSET0_PROTREG9_Msk        BPROT_CONFIG0_REGION9_Msk
-#define MPU_PROTENSET0_PROTREG9_Disabled   BPROT_CONFIG0_REGION9_Disabled
-#define MPU_PROTENSET0_PROTREG9_Enabled    BPROT_CONFIG0_REGION9_Enabled
-#define MPU_PROTENSET0_PROTREG9_Set        BPROT_CONFIG0_REGION9_Enabled
-
-#define MPU_PROTENSET0_PROTREG8_Pos        BPROT_CONFIG0_REGION8_Pos
-#define MPU_PROTENSET0_PROTREG8_Msk        BPROT_CONFIG0_REGION8_Msk
-#define MPU_PROTENSET0_PROTREG8_Disabled   BPROT_CONFIG0_REGION8_Disabled
-#define MPU_PROTENSET0_PROTREG8_Enabled    BPROT_CONFIG0_REGION8_Enabled
-#define MPU_PROTENSET0_PROTREG8_Set        BPROT_CONFIG0_REGION8_Enabled
-
-#define MPU_PROTENSET0_PROTREG7_Pos        BPROT_CONFIG0_REGION7_Pos
-#define MPU_PROTENSET0_PROTREG7_Msk        BPROT_CONFIG0_REGION7_Msk
-#define MPU_PROTENSET0_PROTREG7_Disabled   BPROT_CONFIG0_REGION7_Disabled
-#define MPU_PROTENSET0_PROTREG7_Enabled    BPROT_CONFIG0_REGION7_Enabled
-#define MPU_PROTENSET0_PROTREG7_Set        BPROT_CONFIG0_REGION7_Enabled
-
-#define MPU_PROTENSET0_PROTREG6_Pos        BPROT_CONFIG0_REGION6_Pos
-#define MPU_PROTENSET0_PROTREG6_Msk        BPROT_CONFIG0_REGION6_Msk
-#define MPU_PROTENSET0_PROTREG6_Disabled   BPROT_CONFIG0_REGION6_Disabled
-#define MPU_PROTENSET0_PROTREG6_Enabled    BPROT_CONFIG0_REGION6_Enabled
-#define MPU_PROTENSET0_PROTREG6_Set        BPROT_CONFIG0_REGION6_Enabled
-
-#define MPU_PROTENSET0_PROTREG5_Pos        BPROT_CONFIG0_REGION5_Pos
-#define MPU_PROTENSET0_PROTREG5_Msk        BPROT_CONFIG0_REGION5_Msk
-#define MPU_PROTENSET0_PROTREG5_Disabled   BPROT_CONFIG0_REGION5_Disabled
-#define MPU_PROTENSET0_PROTREG5_Enabled    BPROT_CONFIG0_REGION5_Enabled
-#define MPU_PROTENSET0_PROTREG5_Set        BPROT_CONFIG0_REGION5_Enabled
-
-#define MPU_PROTENSET0_PROTREG4_Pos        BPROT_CONFIG0_REGION4_Pos
-#define MPU_PROTENSET0_PROTREG4_Msk        BPROT_CONFIG0_REGION4_Msk
-#define MPU_PROTENSET0_PROTREG4_Disabled   BPROT_CONFIG0_REGION4_Disabled
-#define MPU_PROTENSET0_PROTREG4_Enabled    BPROT_CONFIG0_REGION4_Enabled
-#define MPU_PROTENSET0_PROTREG4_Set        BPROT_CONFIG0_REGION4_Enabled
-
-#define MPU_PROTENSET0_PROTREG3_Pos        BPROT_CONFIG0_REGION3_Pos
-#define MPU_PROTENSET0_PROTREG3_Msk        BPROT_CONFIG0_REGION3_Msk
-#define MPU_PROTENSET0_PROTREG3_Disabled   BPROT_CONFIG0_REGION3_Disabled
-#define MPU_PROTENSET0_PROTREG3_Enabled    BPROT_CONFIG0_REGION3_Enabled
-#define MPU_PROTENSET0_PROTREG3_Set        BPROT_CONFIG0_REGION3_Enabled
-
-#define MPU_PROTENSET0_PROTREG2_Pos        BPROT_CONFIG0_REGION2_Pos
-#define MPU_PROTENSET0_PROTREG2_Msk        BPROT_CONFIG0_REGION2_Msk
-#define MPU_PROTENSET0_PROTREG2_Disabled   BPROT_CONFIG0_REGION2_Disabled
-#define MPU_PROTENSET0_PROTREG2_Enabled    BPROT_CONFIG0_REGION2_Enabled
-#define MPU_PROTENSET0_PROTREG2_Set        BPROT_CONFIG0_REGION2_Enabled
-
-#define MPU_PROTENSET0_PROTREG1_Pos        BPROT_CONFIG0_REGION1_Pos
-#define MPU_PROTENSET0_PROTREG1_Msk        BPROT_CONFIG0_REGION1_Msk
-#define MPU_PROTENSET0_PROTREG1_Disabled   BPROT_CONFIG0_REGION1_Disabled
-#define MPU_PROTENSET0_PROTREG1_Enabled    BPROT_CONFIG0_REGION1_Enabled
-#define MPU_PROTENSET0_PROTREG1_Set        BPROT_CONFIG0_REGION1_Enabled
-
-#define MPU_PROTENSET0_PROTREG0_Pos        BPROT_CONFIG0_REGION0_Pos
-#define MPU_PROTENSET0_PROTREG0_Msk        BPROT_CONFIG0_REGION0_Msk
-#define MPU_PROTENSET0_PROTREG0_Disabled   BPROT_CONFIG0_REGION0_Disabled
-#define MPU_PROTENSET0_PROTREG0_Enabled    BPROT_CONFIG0_REGION0_Enabled
-#define MPU_PROTENSET0_PROTREG0_Set        BPROT_CONFIG0_REGION0_Enabled
-
-
-/* From nrf51_deprecated.h */
-
-/* NVMC */
-/* The register ERASEPROTECTEDPAGE changed name to ERASEPCR0 in the documentation. */
-#define ERASEPROTECTEDPAGE      ERASEPCR0
-
-
-/* IRQ */
-/* COMP module was eliminated. Adapted to nrf52 headers. */
-#define LPCOMP_COMP_IRQHandler  COMP_LPCOMP_IRQHandler
-#define LPCOMP_COMP_IRQn        COMP_LPCOMP_IRQn
-
-
-/* REFSEL register redefined enumerated values and added some more. */
-#define LPCOMP_REFSEL_REFSEL_SupplyOneEighthPrescaling          LPCOMP_REFSEL_REFSEL_Ref1_8Vdd
-#define LPCOMP_REFSEL_REFSEL_SupplyTwoEighthsPrescaling         LPCOMP_REFSEL_REFSEL_Ref2_8Vdd
-#define LPCOMP_REFSEL_REFSEL_SupplyThreeEighthsPrescaling       LPCOMP_REFSEL_REFSEL_Ref3_8Vdd
-#define LPCOMP_REFSEL_REFSEL_SupplyFourEighthsPrescaling        LPCOMP_REFSEL_REFSEL_Ref4_8Vdd
-#define LPCOMP_REFSEL_REFSEL_SupplyFiveEighthsPrescaling        LPCOMP_REFSEL_REFSEL_Ref5_8Vdd
-#define LPCOMP_REFSEL_REFSEL_SupplySixEighthsPrescaling         LPCOMP_REFSEL_REFSEL_Ref6_8Vdd
-#define LPCOMP_REFSEL_REFSEL_SupplySevenEighthsPrescaling       LPCOMP_REFSEL_REFSEL_Ref7_8Vdd
-
-
-/* RADIO */
-/* The name of the field SKIPADDR was corrected. Old macros added for compatibility. */
-#define RADIO_CRCCNF_SKIP_ADDR_Pos      RADIO_CRCCNF_SKIPADDR_Pos
-#define RADIO_CRCCNF_SKIP_ADDR_Msk      RADIO_CRCCNF_SKIPADDR_Msk
-#define RADIO_CRCCNF_SKIP_ADDR_Include  RADIO_CRCCNF_SKIPADDR_Include
-#define RADIO_CRCCNF_SKIP_ADDR_Skip     RADIO_CRCCNF_SKIPADDR_Skip
-
-
-/* FICR */
-/* The registers FICR.DEVICEID0 and FICR.DEVICEID1 were renamed into an array. */
-#define DEVICEID0       DEVICEID[0]
-#define DEVICEID1       DEVICEID[1]
-
-/* The registers FICR.ER0, FICR.ER1, FICR.ER2 and FICR.ER3 were renamed into an array. */
-#define ER0             ER[0]
-#define ER1             ER[1]
-#define ER2             ER[2]
-#define ER3             ER[3]
-
-/* The registers FICR.IR0, FICR.IR1, FICR.IR2 and FICR.IR3 were renamed into an array. */
-#define IR0             IR[0]
-#define IR1             IR[1]
-#define IR2             IR[2]
-#define IR3             IR[3]
-
-/* The registers FICR.DEVICEADDR0 and FICR.DEVICEADDR1 were renamed into an array. */
-#define DEVICEADDR0     DEVICEADDR[0]
-#define DEVICEADDR1     DEVICEADDR[1]
-
-
-/* PPI */
-/* The tasks PPI.TASKS_CHGxEN and PPI.TASKS_CHGxDIS were renamed into an array of structs. */
-#define TASKS_CHG0EN     TASKS_CHG[0].EN
-#define TASKS_CHG0DIS    TASKS_CHG[0].DIS
-#define TASKS_CHG1EN     TASKS_CHG[1].EN
-#define TASKS_CHG1DIS    TASKS_CHG[1].DIS
-#define TASKS_CHG2EN     TASKS_CHG[2].EN
-#define TASKS_CHG2DIS    TASKS_CHG[2].DIS
-#define TASKS_CHG3EN     TASKS_CHG[3].EN
-#define TASKS_CHG3DIS    TASKS_CHG[3].DIS
-
-/* The registers PPI.CHx_EEP and PPI.CHx_TEP were renamed into an array of structs. */
-#define CH0_EEP          CH[0].EEP
-#define CH0_TEP          CH[0].TEP
-#define CH1_EEP          CH[1].EEP
-#define CH1_TEP          CH[1].TEP
-#define CH2_EEP          CH[2].EEP
-#define CH2_TEP          CH[2].TEP
-#define CH3_EEP          CH[3].EEP
-#define CH3_TEP          CH[3].TEP
-#define CH4_EEP          CH[4].EEP
-#define CH4_TEP          CH[4].TEP
-#define CH5_EEP          CH[5].EEP
-#define CH5_TEP          CH[5].TEP
-#define CH6_EEP          CH[6].EEP
-#define CH6_TEP          CH[6].TEP
-#define CH7_EEP          CH[7].EEP
-#define CH7_TEP          CH[7].TEP
-#define CH8_EEP          CH[8].EEP
-#define CH8_TEP          CH[8].TEP
-#define CH9_EEP          CH[9].EEP
-#define CH9_TEP          CH[9].TEP
-#define CH10_EEP         CH[10].EEP
-#define CH10_TEP         CH[10].TEP
-#define CH11_EEP         CH[11].EEP
-#define CH11_TEP         CH[11].TEP
-#define CH12_EEP         CH[12].EEP
-#define CH12_TEP         CH[12].TEP
-#define CH13_EEP         CH[13].EEP
-#define CH13_TEP         CH[13].TEP
-#define CH14_EEP         CH[14].EEP
-#define CH14_TEP         CH[14].TEP
-#define CH15_EEP         CH[15].EEP
-#define CH15_TEP         CH[15].TEP
-
-/* The registers PPI.CHG0, PPI.CHG1, PPI.CHG2 and PPI.CHG3 were renamed into an array. */
-#define CHG0             CHG[0]
-#define CHG1             CHG[1]
-#define CHG2             CHG[2]
-#define CHG3             CHG[3]
-
-/* All bitfield macros for the CHGx registers therefore changed name. */
-#define PPI_CHG0_CH15_Pos       PPI_CHG_CH15_Pos
-#define PPI_CHG0_CH15_Msk       PPI_CHG_CH15_Msk
-#define PPI_CHG0_CH15_Excluded  PPI_CHG_CH15_Excluded
-#define PPI_CHG0_CH15_Included  PPI_CHG_CH15_Included
-
-#define PPI_CHG0_CH14_Pos       PPI_CHG_CH14_Pos
-#define PPI_CHG0_CH14_Msk       PPI_CHG_CH14_Msk
-#define PPI_CHG0_CH14_Excluded  PPI_CHG_CH14_Excluded
-#define PPI_CHG0_CH14_Included  PPI_CHG_CH14_Included
-
-#define PPI_CHG0_CH13_Pos       PPI_CHG_CH13_Pos
-#define PPI_CHG0_CH13_Msk       PPI_CHG_CH13_Msk
-#define PPI_CHG0_CH13_Excluded  PPI_CHG_CH13_Excluded
-#define PPI_CHG0_CH13_Included  PPI_CHG_CH13_Included
-
-#define PPI_CHG0_CH12_Pos       PPI_CHG_CH12_Pos
-#define PPI_CHG0_CH12_Msk       PPI_CHG_CH12_Msk
-#define PPI_CHG0_CH12_Excluded  PPI_CHG_CH12_Excluded
-#define PPI_CHG0_CH12_Included  PPI_CHG_CH12_Included
-
-#define PPI_CHG0_CH11_Pos       PPI_CHG_CH11_Pos
-#define PPI_CHG0_CH11_Msk       PPI_CHG_CH11_Msk
-#define PPI_CHG0_CH11_Excluded  PPI_CHG_CH11_Excluded
-#define PPI_CHG0_CH11_Included  PPI_CHG_CH11_Included
-
-#define PPI_CHG0_CH10_Pos       PPI_CHG_CH10_Pos
-#define PPI_CHG0_CH10_Msk       PPI_CHG_CH10_Msk
-#define PPI_CHG0_CH10_Excluded  PPI_CHG_CH10_Excluded
-#define PPI_CHG0_CH10_Included  PPI_CHG_CH10_Included
-
-#define PPI_CHG0_CH9_Pos        PPI_CHG_CH9_Pos
-#define PPI_CHG0_CH9_Msk        PPI_CHG_CH9_Msk
-#define PPI_CHG0_CH9_Excluded   PPI_CHG_CH9_Excluded
-#define PPI_CHG0_CH9_Included   PPI_CHG_CH9_Included
-
-#define PPI_CHG0_CH8_Pos        PPI_CHG_CH8_Pos
-#define PPI_CHG0_CH8_Msk        PPI_CHG_CH8_Msk
-#define PPI_CHG0_CH8_Excluded   PPI_CHG_CH8_Excluded
-#define PPI_CHG0_CH8_Included   PPI_CHG_CH8_Included
-
-#define PPI_CHG0_CH7_Pos        PPI_CHG_CH7_Pos
-#define PPI_CHG0_CH7_Msk        PPI_CHG_CH7_Msk
-#define PPI_CHG0_CH7_Excluded   PPI_CHG_CH7_Excluded
-#define PPI_CHG0_CH7_Included   PPI_CHG_CH7_Included
-
-#define PPI_CHG0_CH6_Pos        PPI_CHG_CH6_Pos
-#define PPI_CHG0_CH6_Msk        PPI_CHG_CH6_Msk
-#define PPI_CHG0_CH6_Excluded   PPI_CHG_CH6_Excluded
-#define PPI_CHG0_CH6_Included   PPI_CHG_CH6_Included
-
-#define PPI_CHG0_CH5_Pos        PPI_CHG_CH5_Pos
-#define PPI_CHG0_CH5_Msk        PPI_CHG_CH5_Msk
-#define PPI_CHG0_CH5_Excluded   PPI_CHG_CH5_Excluded
-#define PPI_CHG0_CH5_Included   PPI_CHG_CH5_Included
-
-#define PPI_CHG0_CH4_Pos        PPI_CHG_CH4_Pos
-#define PPI_CHG0_CH4_Msk        PPI_CHG_CH4_Msk
-#define PPI_CHG0_CH4_Excluded   PPI_CHG_CH4_Excluded
-#define PPI_CHG0_CH4_Included   PPI_CHG_CH4_Included
-
-#define PPI_CHG0_CH3_Pos        PPI_CHG_CH3_Pos
-#define PPI_CHG0_CH3_Msk        PPI_CHG_CH3_Msk
-#define PPI_CHG0_CH3_Excluded   PPI_CHG_CH3_Excluded
-#define PPI_CHG0_CH3_Included   PPI_CHG_CH3_Included
-
-#define PPI_CHG0_CH2_Pos        PPI_CHG_CH2_Pos
-#define PPI_CHG0_CH2_Msk        PPI_CHG_CH2_Msk
-#define PPI_CHG0_CH2_Excluded   PPI_CHG_CH2_Excluded
-#define PPI_CHG0_CH2_Included   PPI_CHG_CH2_Included
-
-#define PPI_CHG0_CH1_Pos        PPI_CHG_CH1_Pos
-#define PPI_CHG0_CH1_Msk        PPI_CHG_CH1_Msk
-#define PPI_CHG0_CH1_Excluded   PPI_CHG_CH1_Excluded
-#define PPI_CHG0_CH1_Included   PPI_CHG_CH1_Included
-
-#define PPI_CHG0_CH0_Pos        PPI_CHG_CH0_Pos
-#define PPI_CHG0_CH0_Msk        PPI_CHG_CH0_Msk
-#define PPI_CHG0_CH0_Excluded   PPI_CHG_CH0_Excluded
-#define PPI_CHG0_CH0_Included   PPI_CHG_CH0_Included
-
-#define PPI_CHG1_CH15_Pos       PPI_CHG_CH15_Pos
-#define PPI_CHG1_CH15_Msk       PPI_CHG_CH15_Msk
-#define PPI_CHG1_CH15_Excluded  PPI_CHG_CH15_Excluded
-#define PPI_CHG1_CH15_Included  PPI_CHG_CH15_Included
-
-#define PPI_CHG1_CH14_Pos       PPI_CHG_CH14_Pos
-#define PPI_CHG1_CH14_Msk       PPI_CHG_CH14_Msk
-#define PPI_CHG1_CH14_Excluded  PPI_CHG_CH14_Excluded
-#define PPI_CHG1_CH14_Included  PPI_CHG_CH14_Included
-
-#define PPI_CHG1_CH13_Pos       PPI_CHG_CH13_Pos
-#define PPI_CHG1_CH13_Msk       PPI_CHG_CH13_Msk
-#define PPI_CHG1_CH13_Excluded  PPI_CHG_CH13_Excluded
-#define PPI_CHG1_CH13_Included  PPI_CHG_CH13_Included
-
-#define PPI_CHG1_CH12_Pos       PPI_CHG_CH12_Pos
-#define PPI_CHG1_CH12_Msk       PPI_CHG_CH12_Msk
-#define PPI_CHG1_CH12_Excluded  PPI_CHG_CH12_Excluded
-#define PPI_CHG1_CH12_Included  PPI_CHG_CH12_Included
-
-#define PPI_CHG1_CH11_Pos       PPI_CHG_CH11_Pos
-#define PPI_CHG1_CH11_Msk       PPI_CHG_CH11_Msk
-#define PPI_CHG1_CH11_Excluded  PPI_CHG_CH11_Excluded
-#define PPI_CHG1_CH11_Included  PPI_CHG_CH11_Included
-
-#define PPI_CHG1_CH10_Pos       PPI_CHG_CH10_Pos
-#define PPI_CHG1_CH10_Msk       PPI_CHG_CH10_Msk
-#define PPI_CHG1_CH10_Excluded  PPI_CHG_CH10_Excluded
-#define PPI_CHG1_CH10_Included  PPI_CHG_CH10_Included
-
-#define PPI_CHG1_CH9_Pos        PPI_CHG_CH9_Pos
-#define PPI_CHG1_CH9_Msk        PPI_CHG_CH9_Msk
-#define PPI_CHG1_CH9_Excluded   PPI_CHG_CH9_Excluded
-#define PPI_CHG1_CH9_Included   PPI_CHG_CH9_Included
-
-#define PPI_CHG1_CH8_Pos        PPI_CHG_CH8_Pos
-#define PPI_CHG1_CH8_Msk        PPI_CHG_CH8_Msk
-#define PPI_CHG1_CH8_Excluded   PPI_CHG_CH8_Excluded
-#define PPI_CHG1_CH8_Included   PPI_CHG_CH8_Included
-
-#define PPI_CHG1_CH7_Pos        PPI_CHG_CH7_Pos
-#define PPI_CHG1_CH7_Msk        PPI_CHG_CH7_Msk
-#define PPI_CHG1_CH7_Excluded   PPI_CHG_CH7_Excluded
-#define PPI_CHG1_CH7_Included   PPI_CHG_CH7_Included
-
-#define PPI_CHG1_CH6_Pos        PPI_CHG_CH6_Pos
-#define PPI_CHG1_CH6_Msk        PPI_CHG_CH6_Msk
-#define PPI_CHG1_CH6_Excluded   PPI_CHG_CH6_Excluded
-#define PPI_CHG1_CH6_Included   PPI_CHG_CH6_Included
-
-#define PPI_CHG1_CH5_Pos        PPI_CHG_CH5_Pos
-#define PPI_CHG1_CH5_Msk        PPI_CHG_CH5_Msk
-#define PPI_CHG1_CH5_Excluded   PPI_CHG_CH5_Excluded
-#define PPI_CHG1_CH5_Included   PPI_CHG_CH5_Included
-
-#define PPI_CHG1_CH4_Pos        PPI_CHG_CH4_Pos
-#define PPI_CHG1_CH4_Msk        PPI_CHG_CH4_Msk
-#define PPI_CHG1_CH4_Excluded   PPI_CHG_CH4_Excluded
-#define PPI_CHG1_CH4_Included   PPI_CHG_CH4_Included
-
-#define PPI_CHG1_CH3_Pos        PPI_CHG_CH3_Pos
-#define PPI_CHG1_CH3_Msk        PPI_CHG_CH3_Msk
-#define PPI_CHG1_CH3_Excluded   PPI_CHG_CH3_Excluded
-#define PPI_CHG1_CH3_Included   PPI_CHG_CH3_Included
-
-#define PPI_CHG1_CH2_Pos        PPI_CHG_CH2_Pos
-#define PPI_CHG1_CH2_Msk        PPI_CHG_CH2_Msk
-#define PPI_CHG1_CH2_Excluded   PPI_CHG_CH2_Excluded
-#define PPI_CHG1_CH2_Included   PPI_CHG_CH2_Included
-
-#define PPI_CHG1_CH1_Pos        PPI_CHG_CH1_Pos
-#define PPI_CHG1_CH1_Msk        PPI_CHG_CH1_Msk
-#define PPI_CHG1_CH1_Excluded   PPI_CHG_CH1_Excluded
-#define PPI_CHG1_CH1_Included   PPI_CHG_CH1_Included
-
-#define PPI_CHG1_CH0_Pos        PPI_CHG_CH0_Pos
-#define PPI_CHG1_CH0_Msk        PPI_CHG_CH0_Msk
-#define PPI_CHG1_CH0_Excluded   PPI_CHG_CH0_Excluded
-#define PPI_CHG1_CH0_Included   PPI_CHG_CH0_Included
-
-#define PPI_CHG2_CH15_Pos       PPI_CHG_CH15_Pos
-#define PPI_CHG2_CH15_Msk       PPI_CHG_CH15_Msk
-#define PPI_CHG2_CH15_Excluded  PPI_CHG_CH15_Excluded
-#define PPI_CHG2_CH15_Included  PPI_CHG_CH15_Included
-
-#define PPI_CHG2_CH14_Pos       PPI_CHG_CH14_Pos
-#define PPI_CHG2_CH14_Msk       PPI_CHG_CH14_Msk
-#define PPI_CHG2_CH14_Excluded  PPI_CHG_CH14_Excluded
-#define PPI_CHG2_CH14_Included  PPI_CHG_CH14_Included
-
-#define PPI_CHG2_CH13_Pos       PPI_CHG_CH13_Pos
-#define PPI_CHG2_CH13_Msk       PPI_CHG_CH13_Msk
-#define PPI_CHG2_CH13_Excluded  PPI_CHG_CH13_Excluded
-#define PPI_CHG2_CH13_Included  PPI_CHG_CH13_Included
-
-#define PPI_CHG2_CH12_Pos       PPI_CHG_CH12_Pos
-#define PPI_CHG2_CH12_Msk       PPI_CHG_CH12_Msk
-#define PPI_CHG2_CH12_Excluded  PPI_CHG_CH12_Excluded
-#define PPI_CHG2_CH12_Included  PPI_CHG_CH12_Included
-
-#define PPI_CHG2_CH11_Pos       PPI_CHG_CH11_Pos
-#define PPI_CHG2_CH11_Msk       PPI_CHG_CH11_Msk
-#define PPI_CHG2_CH11_Excluded  PPI_CHG_CH11_Excluded
-#define PPI_CHG2_CH11_Included  PPI_CHG_CH11_Included
-
-#define PPI_CHG2_CH10_Pos       PPI_CHG_CH10_Pos
-#define PPI_CHG2_CH10_Msk       PPI_CHG_CH10_Msk
-#define PPI_CHG2_CH10_Excluded  PPI_CHG_CH10_Excluded
-#define PPI_CHG2_CH10_Included  PPI_CHG_CH10_Included
-
-#define PPI_CHG2_CH9_Pos        PPI_CHG_CH9_Pos
-#define PPI_CHG2_CH9_Msk        PPI_CHG_CH9_Msk
-#define PPI_CHG2_CH9_Excluded   PPI_CHG_CH9_Excluded
-#define PPI_CHG2_CH9_Included   PPI_CHG_CH9_Included
-
-#define PPI_CHG2_CH8_Pos        PPI_CHG_CH8_Pos
-#define PPI_CHG2_CH8_Msk        PPI_CHG_CH8_Msk
-#define PPI_CHG2_CH8_Excluded   PPI_CHG_CH8_Excluded
-#define PPI_CHG2_CH8_Included   PPI_CHG_CH8_Included
-
-#define PPI_CHG2_CH7_Pos        PPI_CHG_CH7_Pos
-#define PPI_CHG2_CH7_Msk        PPI_CHG_CH7_Msk
-#define PPI_CHG2_CH7_Excluded   PPI_CHG_CH7_Excluded
-#define PPI_CHG2_CH7_Included   PPI_CHG_CH7_Included
-
-#define PPI_CHG2_CH6_Pos        PPI_CHG_CH6_Pos
-#define PPI_CHG2_CH6_Msk        PPI_CHG_CH6_Msk
-#define PPI_CHG2_CH6_Excluded   PPI_CHG_CH6_Excluded
-#define PPI_CHG2_CH6_Included   PPI_CHG_CH6_Included
-
-#define PPI_CHG2_CH5_Pos        PPI_CHG_CH5_Pos
-#define PPI_CHG2_CH5_Msk        PPI_CHG_CH5_Msk
-#define PPI_CHG2_CH5_Excluded   PPI_CHG_CH5_Excluded
-#define PPI_CHG2_CH5_Included   PPI_CHG_CH5_Included
-
-#define PPI_CHG2_CH4_Pos        PPI_CHG_CH4_Pos
-#define PPI_CHG2_CH4_Msk        PPI_CHG_CH4_Msk
-#define PPI_CHG2_CH4_Excluded   PPI_CHG_CH4_Excluded
-#define PPI_CHG2_CH4_Included   PPI_CHG_CH4_Included
-
-#define PPI_CHG2_CH3_Pos        PPI_CHG_CH3_Pos
-#define PPI_CHG2_CH3_Msk        PPI_CHG_CH3_Msk
-#define PPI_CHG2_CH3_Excluded   PPI_CHG_CH3_Excluded
-#define PPI_CHG2_CH3_Included   PPI_CHG_CH3_Included
-
-#define PPI_CHG2_CH2_Pos        PPI_CHG_CH2_Pos
-#define PPI_CHG2_CH2_Msk        PPI_CHG_CH2_Msk
-#define PPI_CHG2_CH2_Excluded   PPI_CHG_CH2_Excluded
-#define PPI_CHG2_CH2_Included   PPI_CHG_CH2_Included
-
-#define PPI_CHG2_CH1_Pos        PPI_CHG_CH1_Pos
-#define PPI_CHG2_CH1_Msk        PPI_CHG_CH1_Msk
-#define PPI_CHG2_CH1_Excluded   PPI_CHG_CH1_Excluded
-#define PPI_CHG2_CH1_Included   PPI_CHG_CH1_Included
-
-#define PPI_CHG2_CH0_Pos        PPI_CHG_CH0_Pos
-#define PPI_CHG2_CH0_Msk        PPI_CHG_CH0_Msk
-#define PPI_CHG2_CH0_Excluded   PPI_CHG_CH0_Excluded
-#define PPI_CHG2_CH0_Included   PPI_CHG_CH0_Included
-
-#define PPI_CHG3_CH15_Pos       PPI_CHG_CH15_Pos
-#define PPI_CHG3_CH15_Msk       PPI_CHG_CH15_Msk
-#define PPI_CHG3_CH15_Excluded  PPI_CHG_CH15_Excluded
-#define PPI_CHG3_CH15_Included  PPI_CHG_CH15_Included
-
-#define PPI_CHG3_CH14_Pos       PPI_CHG_CH14_Pos
-#define PPI_CHG3_CH14_Msk       PPI_CHG_CH14_Msk
-#define PPI_CHG3_CH14_Excluded  PPI_CHG_CH14_Excluded
-#define PPI_CHG3_CH14_Included  PPI_CHG_CH14_Included
-
-#define PPI_CHG3_CH13_Pos       PPI_CHG_CH13_Pos
-#define PPI_CHG3_CH13_Msk       PPI_CHG_CH13_Msk
-#define PPI_CHG3_CH13_Excluded  PPI_CHG_CH13_Excluded
-#define PPI_CHG3_CH13_Included  PPI_CHG_CH13_Included
-
-#define PPI_CHG3_CH12_Pos       PPI_CHG_CH12_Pos
-#define PPI_CHG3_CH12_Msk       PPI_CHG_CH12_Msk
-#define PPI_CHG3_CH12_Excluded  PPI_CHG_CH12_Excluded
-#define PPI_CHG3_CH12_Included  PPI_CHG_CH12_Included
-
-#define PPI_CHG3_CH11_Pos       PPI_CHG_CH11_Pos
-#define PPI_CHG3_CH11_Msk       PPI_CHG_CH11_Msk
-#define PPI_CHG3_CH11_Excluded  PPI_CHG_CH11_Excluded
-#define PPI_CHG3_CH11_Included  PPI_CHG_CH11_Included
-
-#define PPI_CHG3_CH10_Pos       PPI_CHG_CH10_Pos
-#define PPI_CHG3_CH10_Msk       PPI_CHG_CH10_Msk
-#define PPI_CHG3_CH10_Excluded  PPI_CHG_CH10_Excluded
-#define PPI_CHG3_CH10_Included  PPI_CHG_CH10_Included
-
-#define PPI_CHG3_CH9_Pos        PPI_CHG_CH9_Pos
-#define PPI_CHG3_CH9_Msk        PPI_CHG_CH9_Msk
-#define PPI_CHG3_CH9_Excluded   PPI_CHG_CH9_Excluded
-#define PPI_CHG3_CH9_Included   PPI_CHG_CH9_Included
-
-#define PPI_CHG3_CH8_Pos        PPI_CHG_CH8_Pos
-#define PPI_CHG3_CH8_Msk        PPI_CHG_CH8_Msk
-#define PPI_CHG3_CH8_Excluded   PPI_CHG_CH8_Excluded
-#define PPI_CHG3_CH8_Included   PPI_CHG_CH8_Included
-
-#define PPI_CHG3_CH7_Pos        PPI_CHG_CH7_Pos
-#define PPI_CHG3_CH7_Msk        PPI_CHG_CH7_Msk
-#define PPI_CHG3_CH7_Excluded   PPI_CHG_CH7_Excluded
-#define PPI_CHG3_CH7_Included   PPI_CHG_CH7_Included
-
-#define PPI_CHG3_CH6_Pos        PPI_CHG_CH6_Pos
-#define PPI_CHG3_CH6_Msk        PPI_CHG_CH6_Msk
-#define PPI_CHG3_CH6_Excluded   PPI_CHG_CH6_Excluded
-#define PPI_CHG3_CH6_Included   PPI_CHG_CH6_Included
-
-#define PPI_CHG3_CH5_Pos        PPI_CHG_CH5_Pos
-#define PPI_CHG3_CH5_Msk        PPI_CHG_CH5_Msk
-#define PPI_CHG3_CH5_Excluded   PPI_CHG_CH5_Excluded
-#define PPI_CHG3_CH5_Included   PPI_CHG_CH5_Included
-
-#define PPI_CHG3_CH4_Pos        PPI_CHG_CH4_Pos
-#define PPI_CHG3_CH4_Msk        PPI_CHG_CH4_Msk
-#define PPI_CHG3_CH4_Excluded   PPI_CHG_CH4_Excluded
-#define PPI_CHG3_CH4_Included   PPI_CHG_CH4_Included
-
-#define PPI_CHG3_CH3_Pos        PPI_CHG_CH3_Pos
-#define PPI_CHG3_CH3_Msk        PPI_CHG_CH3_Msk
-#define PPI_CHG3_CH3_Excluded   PPI_CHG_CH3_Excluded
-#define PPI_CHG3_CH3_Included   PPI_CHG_CH3_Included
-
-#define PPI_CHG3_CH2_Pos        PPI_CHG_CH2_Pos
-#define PPI_CHG3_CH2_Msk        PPI_CHG_CH2_Msk
-#define PPI_CHG3_CH2_Excluded   PPI_CHG_CH2_Excluded
-#define PPI_CHG3_CH2_Included   PPI_CHG_CH2_Included
-
-#define PPI_CHG3_CH1_Pos        PPI_CHG_CH1_Pos
-#define PPI_CHG3_CH1_Msk        PPI_CHG_CH1_Msk
-#define PPI_CHG3_CH1_Excluded   PPI_CHG_CH1_Excluded
-#define PPI_CHG3_CH1_Included   PPI_CHG_CH1_Included
-
-#define PPI_CHG3_CH0_Pos        PPI_CHG_CH0_Pos
-#define PPI_CHG3_CH0_Msk        PPI_CHG_CH0_Msk
-#define PPI_CHG3_CH0_Excluded   PPI_CHG_CH0_Excluded
-#define PPI_CHG3_CH0_Included   PPI_CHG_CH0_Included
-
-
-
-
-/*lint --flb "Leave library region" */
-
-#endif /* NRF51_TO_NRF52_H */
-
diff --git a/arch/arm/src/nrf52/components/device/nrf52832_peripherals.h b/arch/arm/src/nrf52/components/device/nrf52832_peripherals.h
deleted file mode 100644
index 16dd9c421b..0000000000
--- a/arch/arm/src/nrf52/components/device/nrf52832_peripherals.h
+++ /dev/null
@@ -1,218 +0,0 @@
-/* Copyright (c) 2016, Nordic Semiconductor ASA
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *   * Redistributions of source code must retain the above copyright notice, this
- *     list of conditions and the following disclaimer.
- *
- *   * Redistributions in binary form must reproduce the above copyright notice,
- *     this list of conditions and the following disclaimer in the documentation
- *     and/or other materials provided with the distribution.
- *
- *   * Neither the name of Nordic Semiconductor ASA nor the names of its
- *     contributors may be used to endorse or promote products derived from
- *     this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#ifndef _NRF52832_PERIPHERALS_H
-#define _NRF52832_PERIPHERALS_H
-
-
-/* Floating Point Unit */
-#define FPU_PRESENT
-#define FPU_COUNT 1
-
-/* Systick timer */
-#define SYSTICK_PRESENT
-#define SYSTICK_COUNT 1
-
-/* Software Interrupts */
-#define SWI_PRESENT
-#define SWI_COUNT 6
-
-/* Memory Watch Unit */
-#define MWU_PRESENT
-#define MWU_COUNT 1
-
-/* GPIO */
-#define GPIO_PRESENT
-#define GPIO_COUNT 1
-
-#define P0_PIN_NUM 32
-
-/* MPU and BPROT */
-#define BPROT_PRESENT
-
-#define BPROT_REGIONS_SIZE 4096
-#define BPROT_REGIONS_NUM 128
-
-/* Radio */
-#define RADIO_PRESENT
-#define RADIO_COUNT 1
-
-/* Accelerated Address Resolver */
-#define AAR_PRESENT
-#define AAR_COUNT 1
-
-#define AAR_MAX_IRK_NUM 16
-
-/* AES Electronic CodeBook mode encryption */
-#define ECB_PRESENT
-#define ECB_COUNT 1
-
-/* AES CCM mode encryption */
-#define CCM_PRESENT
-#define CCM_COUNT 1
-
-/* NFC Tag */
-#define NFCT_PRESENT
-#define NFCT_COUNT 1
-
-/* Peripheral to Peripheral Interconnect */
-#define PPI_PRESENT
-#define PPI_COUNT 1
-
-#define PPI_CH_NUM 20
-#define PPI_GROUP_NUM 6
-#define PPI_FEATURE_FORKS_PRESENT
-
-/* Event Generator Unit */
-#define EGU_PRESENT
-#define EGU_COUNT 6
-
-#define EGU0_CH_NUM 16
-#define EGU1_CH_NUM 16
-#define EGU2_CH_NUM 16
-#define EGU3_CH_NUM 16
-#define EGU4_CH_NUM 16
-#define EGU5_CH_NUM 16
-
-/* Timer/Counter */
-#define TIMER_PRESENT
-#define TIMER_COUNT 5
-
-#define TIMER0_MAX_SIZE 32
-#define TIMER1_MAX_SIZE 32
-#define TIMER2_MAX_SIZE 32
-#define TIMER3_MAX_SIZE 32
-#define TIMER4_MAX_SIZE 32
-
-#define TIMER0_CC_NUM 4
-#define TIMER1_CC_NUM 4
-#define TIMER2_CC_NUM 4
-#define TIMER3_CC_NUM 6
-#define TIMER4_CC_NUM 6
-
-/* Real Time Counter */
-#define RTC_PRESENT
-#define RTC_COUNT 3
-
-#define RTC0_CC_NUM 3
-#define RTC1_CC_NUM 4
-#define RTC2_CC_NUM 4
-
-/* RNG */
-#define RNG_PRESENT
-#define RNG_COUNT 1
-
-/* Watchdog Timer */
-#define WDT_PRESENT
-#define WDT_COUNT 1
-
-/* Temperature Sensor */
-#define TEMP_PRESENT
-#define TEMP_COUNT 1
-
-/* Serial Peripheral Interface Master */
-#define SPI_PRESENT
-#define SPI_COUNT 3
-
-/* Serial Peripheral Interface Master with DMA */
-#define SPIM_PRESENT
-#define SPIM_COUNT 3
-
-/* Serial Peripheral Interface Slave with DMA*/
-#define SPIS_PRESENT
-#define SPIS_COUNT 3
-
-/* Two Wire Interface Master */
-#define TWI_PRESENT
-#define TWI_COUNT 2
-
-/* Two Wire Interface Master with DMA */
-#define TWIM_PRESENT
-#define TWIM_COUNT 2
-
-/* Two Wire Interface Slave with DMA */
-#define TWIS_PRESENT
-#define TWIS_COUNT 2
-
-/* Universal Asynchronous Receiver-Transmitter */
-#define UART_PRESENT
-#define UART_COUNT 1
-
-/* Universal Asynchronous Receiver-Transmitter with DMA */
-#define UARTE_PRESENT
-#define UARTE_COUNT 1
-
-/* Quadrature Decoder */
-#define QDEC_PRESENT
-#define QDEC_COUNT 1
-
-/* Successive Approximation Analog to Digital Converter */
-#define SAADC_PRESENT
-#define SAADC_COUNT 1
-
-/* GPIO Tasks and Events */
-#define GPIOTE_PRESENT
-#define GPIOTE_COUNT 1
-
-#define GPIOTE_CH_NUM 8
-
-#define GPIOTE_FEATURE_SET_PRESENT
-#define GPIOTE_FEATURE_CLR_PRESENT
-
-/* Low Power Comparator */
-#define LPCOMP_PRESENT
-#define LPCOMP_COUNT 1
-
-#define LPCOMP_REFSEL_RESOLUTION 16
-
-#define LPCOMP_FEATURE_HYST_PRESENT
-
-/* Comparator */
-#define COMP_PRESENT
-#define COMP_COUNT 1
-
-/* Pulse Width Modulator */
-#define PWM_PRESENT
-#define PWM_COUNT 3
-
-#define PWM0_CH_NUM 4
-#define PWM1_CH_NUM 4
-#define PWM2_CH_NUM 4
-
-/* Pulse Density Modulator */
-#define PDM_PRESENT
-#define PDM_COUNT 1
-
-/* Inter-IC Sound Interface */
-#define I2S_PRESENT
-#define I2S_COUNT 1
-
-
-#endif      // _NRF52832_PERIPHERALS_H
diff --git a/arch/arm/src/nrf52/components/device/nrf52_bitfields.h b/arch/arm/src/nrf52/components/device/nrf52_bitfields.h
deleted file mode 100644
index 5c1b6ba334..0000000000
--- a/arch/arm/src/nrf52/components/device/nrf52_bitfields.h
+++ /dev/null
@@ -1,12642 +0,0 @@
-/* Copyright (c) 2016, Nordic Semiconductor ASA
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *   * Redistributions of source code must retain the above copyright notice, this
- *     list of conditions and the following disclaimer.
- *
- *   * Redistributions in binary form must reproduce the above copyright notice,
- *     this list of conditions and the following disclaimer in the documentation
- *     and/or other materials provided with the distribution.
- *
- *   * Neither the name of Nordic Semiconductor ASA nor the names of its
- *     contributors may be used to endorse or promote products derived from
- *     this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#ifndef __NRF52_BITS_H
-#define __NRF52_BITS_H
-
-/*lint ++flb "Enter library region" */
-
-/* Peripheral: AAR */
-/* Description: Accelerated Address Resolver */
-
-/* Register: AAR_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 2 : Write '1' to Enable interrupt for NOTRESOLVED event */
-#define AAR_INTENSET_NOTRESOLVED_Pos (2UL) /*!< Position of NOTRESOLVED field. */
-#define AAR_INTENSET_NOTRESOLVED_Msk (0x1UL << AAR_INTENSET_NOTRESOLVED_Pos) /*!< Bit mask of NOTRESOLVED field. */
-#define AAR_INTENSET_NOTRESOLVED_Disabled (0UL) /*!< Read: Disabled */
-#define AAR_INTENSET_NOTRESOLVED_Enabled (1UL) /*!< Read: Enabled */
-#define AAR_INTENSET_NOTRESOLVED_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for RESOLVED event */
-#define AAR_INTENSET_RESOLVED_Pos (1UL) /*!< Position of RESOLVED field. */
-#define AAR_INTENSET_RESOLVED_Msk (0x1UL << AAR_INTENSET_RESOLVED_Pos) /*!< Bit mask of RESOLVED field. */
-#define AAR_INTENSET_RESOLVED_Disabled (0UL) /*!< Read: Disabled */
-#define AAR_INTENSET_RESOLVED_Enabled (1UL) /*!< Read: Enabled */
-#define AAR_INTENSET_RESOLVED_Set (1UL) /*!< Enable */
-
-/* Bit 0 : Write '1' to Enable interrupt for END event */
-#define AAR_INTENSET_END_Pos (0UL) /*!< Position of END field. */
-#define AAR_INTENSET_END_Msk (0x1UL << AAR_INTENSET_END_Pos) /*!< Bit mask of END field. */
-#define AAR_INTENSET_END_Disabled (0UL) /*!< Read: Disabled */
-#define AAR_INTENSET_END_Enabled (1UL) /*!< Read: Enabled */
-#define AAR_INTENSET_END_Set (1UL) /*!< Enable */
-
-/* Register: AAR_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 2 : Write '1' to Disable interrupt for NOTRESOLVED event */
-#define AAR_INTENCLR_NOTRESOLVED_Pos (2UL) /*!< Position of NOTRESOLVED field. */
-#define AAR_INTENCLR_NOTRESOLVED_Msk (0x1UL << AAR_INTENCLR_NOTRESOLVED_Pos) /*!< Bit mask of NOTRESOLVED field. */
-#define AAR_INTENCLR_NOTRESOLVED_Disabled (0UL) /*!< Read: Disabled */
-#define AAR_INTENCLR_NOTRESOLVED_Enabled (1UL) /*!< Read: Enabled */
-#define AAR_INTENCLR_NOTRESOLVED_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for RESOLVED event */
-#define AAR_INTENCLR_RESOLVED_Pos (1UL) /*!< Position of RESOLVED field. */
-#define AAR_INTENCLR_RESOLVED_Msk (0x1UL << AAR_INTENCLR_RESOLVED_Pos) /*!< Bit mask of RESOLVED field. */
-#define AAR_INTENCLR_RESOLVED_Disabled (0UL) /*!< Read: Disabled */
-#define AAR_INTENCLR_RESOLVED_Enabled (1UL) /*!< Read: Enabled */
-#define AAR_INTENCLR_RESOLVED_Clear (1UL) /*!< Disable */
-
-/* Bit 0 : Write '1' to Disable interrupt for END event */
-#define AAR_INTENCLR_END_Pos (0UL) /*!< Position of END field. */
-#define AAR_INTENCLR_END_Msk (0x1UL << AAR_INTENCLR_END_Pos) /*!< Bit mask of END field. */
-#define AAR_INTENCLR_END_Disabled (0UL) /*!< Read: Disabled */
-#define AAR_INTENCLR_END_Enabled (1UL) /*!< Read: Enabled */
-#define AAR_INTENCLR_END_Clear (1UL) /*!< Disable */
-
-/* Register: AAR_STATUS */
-/* Description: Resolution status */
-
-/* Bits 3..0 : The IRK that was used last time an address was resolved */
-#define AAR_STATUS_STATUS_Pos (0UL) /*!< Position of STATUS field. */
-#define AAR_STATUS_STATUS_Msk (0xFUL << AAR_STATUS_STATUS_Pos) /*!< Bit mask of STATUS field. */
-
-/* Register: AAR_ENABLE */
-/* Description: Enable AAR */
-
-/* Bits 1..0 : Enable or disable AAR */
-#define AAR_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
-#define AAR_ENABLE_ENABLE_Msk (0x3UL << AAR_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
-#define AAR_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
-#define AAR_ENABLE_ENABLE_Enabled (3UL) /*!< Enable */
-
-/* Register: AAR_NIRK */
-/* Description: Number of IRKs */
-
-/* Bits 4..0 : Number of Identity root keys available in the IRK data structure */
-#define AAR_NIRK_NIRK_Pos (0UL) /*!< Position of NIRK field. */
-#define AAR_NIRK_NIRK_Msk (0x1FUL << AAR_NIRK_NIRK_Pos) /*!< Bit mask of NIRK field. */
-
-/* Register: AAR_IRKPTR */
-/* Description: Pointer to IRK data structure */
-
-/* Bits 31..0 : Pointer to the IRK data structure */
-#define AAR_IRKPTR_IRKPTR_Pos (0UL) /*!< Position of IRKPTR field. */
-#define AAR_IRKPTR_IRKPTR_Msk (0xFFFFFFFFUL << AAR_IRKPTR_IRKPTR_Pos) /*!< Bit mask of IRKPTR field. */
-
-/* Register: AAR_ADDRPTR */
-/* Description: Pointer to the resolvable address */
-
-/* Bits 31..0 : Pointer to the resolvable address (6-bytes) */
-#define AAR_ADDRPTR_ADDRPTR_Pos (0UL) /*!< Position of ADDRPTR field. */
-#define AAR_ADDRPTR_ADDRPTR_Msk (0xFFFFFFFFUL << AAR_ADDRPTR_ADDRPTR_Pos) /*!< Bit mask of ADDRPTR field. */
-
-/* Register: AAR_SCRATCHPTR */
-/* Description: Pointer to data area used for temporary storage */
-
-/* Bits 31..0 : Pointer to a scratch data area used for temporary storage during resolution.A space of minimum 3 bytes must be reserved. */
-#define AAR_SCRATCHPTR_SCRATCHPTR_Pos (0UL) /*!< Position of SCRATCHPTR field. */
-#define AAR_SCRATCHPTR_SCRATCHPTR_Msk (0xFFFFFFFFUL << AAR_SCRATCHPTR_SCRATCHPTR_Pos) /*!< Bit mask of SCRATCHPTR field. */
-
-
-/* Peripheral: BPROT */
-/* Description: Block Protect */
-
-/* Register: BPROT_CONFIG0 */
-/* Description: Block protect configuration register 0 */
-
-/* Bit 31 : Enable protection for region 31. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION31_Pos (31UL) /*!< Position of REGION31 field. */
-#define BPROT_CONFIG0_REGION31_Msk (0x1UL << BPROT_CONFIG0_REGION31_Pos) /*!< Bit mask of REGION31 field. */
-#define BPROT_CONFIG0_REGION31_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION31_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 30 : Enable protection for region 30. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION30_Pos (30UL) /*!< Position of REGION30 field. */
-#define BPROT_CONFIG0_REGION30_Msk (0x1UL << BPROT_CONFIG0_REGION30_Pos) /*!< Bit mask of REGION30 field. */
-#define BPROT_CONFIG0_REGION30_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION30_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 29 : Enable protection for region 29. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION29_Pos (29UL) /*!< Position of REGION29 field. */
-#define BPROT_CONFIG0_REGION29_Msk (0x1UL << BPROT_CONFIG0_REGION29_Pos) /*!< Bit mask of REGION29 field. */
-#define BPROT_CONFIG0_REGION29_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION29_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 28 : Enable protection for region 28. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION28_Pos (28UL) /*!< Position of REGION28 field. */
-#define BPROT_CONFIG0_REGION28_Msk (0x1UL << BPROT_CONFIG0_REGION28_Pos) /*!< Bit mask of REGION28 field. */
-#define BPROT_CONFIG0_REGION28_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION28_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 27 : Enable protection for region 27. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION27_Pos (27UL) /*!< Position of REGION27 field. */
-#define BPROT_CONFIG0_REGION27_Msk (0x1UL << BPROT_CONFIG0_REGION27_Pos) /*!< Bit mask of REGION27 field. */
-#define BPROT_CONFIG0_REGION27_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION27_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 26 : Enable protection for region 26. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION26_Pos (26UL) /*!< Position of REGION26 field. */
-#define BPROT_CONFIG0_REGION26_Msk (0x1UL << BPROT_CONFIG0_REGION26_Pos) /*!< Bit mask of REGION26 field. */
-#define BPROT_CONFIG0_REGION26_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION26_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 25 : Enable protection for region 25. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION25_Pos (25UL) /*!< Position of REGION25 field. */
-#define BPROT_CONFIG0_REGION25_Msk (0x1UL << BPROT_CONFIG0_REGION25_Pos) /*!< Bit mask of REGION25 field. */
-#define BPROT_CONFIG0_REGION25_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION25_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 24 : Enable protection for region 24. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION24_Pos (24UL) /*!< Position of REGION24 field. */
-#define BPROT_CONFIG0_REGION24_Msk (0x1UL << BPROT_CONFIG0_REGION24_Pos) /*!< Bit mask of REGION24 field. */
-#define BPROT_CONFIG0_REGION24_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION24_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 23 : Enable protection for region 23. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION23_Pos (23UL) /*!< Position of REGION23 field. */
-#define BPROT_CONFIG0_REGION23_Msk (0x1UL << BPROT_CONFIG0_REGION23_Pos) /*!< Bit mask of REGION23 field. */
-#define BPROT_CONFIG0_REGION23_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION23_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 22 : Enable protection for region 22. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION22_Pos (22UL) /*!< Position of REGION22 field. */
-#define BPROT_CONFIG0_REGION22_Msk (0x1UL << BPROT_CONFIG0_REGION22_Pos) /*!< Bit mask of REGION22 field. */
-#define BPROT_CONFIG0_REGION22_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION22_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 21 : Enable protection for region 21. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION21_Pos (21UL) /*!< Position of REGION21 field. */
-#define BPROT_CONFIG0_REGION21_Msk (0x1UL << BPROT_CONFIG0_REGION21_Pos) /*!< Bit mask of REGION21 field. */
-#define BPROT_CONFIG0_REGION21_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION21_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 20 : Enable protection for region 20. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION20_Pos (20UL) /*!< Position of REGION20 field. */
-#define BPROT_CONFIG0_REGION20_Msk (0x1UL << BPROT_CONFIG0_REGION20_Pos) /*!< Bit mask of REGION20 field. */
-#define BPROT_CONFIG0_REGION20_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION20_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 19 : Enable protection for region 19. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION19_Pos (19UL) /*!< Position of REGION19 field. */
-#define BPROT_CONFIG0_REGION19_Msk (0x1UL << BPROT_CONFIG0_REGION19_Pos) /*!< Bit mask of REGION19 field. */
-#define BPROT_CONFIG0_REGION19_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION19_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 18 : Enable protection for region 18. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION18_Pos (18UL) /*!< Position of REGION18 field. */
-#define BPROT_CONFIG0_REGION18_Msk (0x1UL << BPROT_CONFIG0_REGION18_Pos) /*!< Bit mask of REGION18 field. */
-#define BPROT_CONFIG0_REGION18_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION18_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 17 : Enable protection for region 17. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION17_Pos (17UL) /*!< Position of REGION17 field. */
-#define BPROT_CONFIG0_REGION17_Msk (0x1UL << BPROT_CONFIG0_REGION17_Pos) /*!< Bit mask of REGION17 field. */
-#define BPROT_CONFIG0_REGION17_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION17_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 16 : Enable protection for region 16. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION16_Pos (16UL) /*!< Position of REGION16 field. */
-#define BPROT_CONFIG0_REGION16_Msk (0x1UL << BPROT_CONFIG0_REGION16_Pos) /*!< Bit mask of REGION16 field. */
-#define BPROT_CONFIG0_REGION16_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION16_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 15 : Enable protection for region 15. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION15_Pos (15UL) /*!< Position of REGION15 field. */
-#define BPROT_CONFIG0_REGION15_Msk (0x1UL << BPROT_CONFIG0_REGION15_Pos) /*!< Bit mask of REGION15 field. */
-#define BPROT_CONFIG0_REGION15_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION15_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 14 : Enable protection for region 14. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION14_Pos (14UL) /*!< Position of REGION14 field. */
-#define BPROT_CONFIG0_REGION14_Msk (0x1UL << BPROT_CONFIG0_REGION14_Pos) /*!< Bit mask of REGION14 field. */
-#define BPROT_CONFIG0_REGION14_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION14_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 13 : Enable protection for region 13. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION13_Pos (13UL) /*!< Position of REGION13 field. */
-#define BPROT_CONFIG0_REGION13_Msk (0x1UL << BPROT_CONFIG0_REGION13_Pos) /*!< Bit mask of REGION13 field. */
-#define BPROT_CONFIG0_REGION13_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION13_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 12 : Enable protection for region 12. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION12_Pos (12UL) /*!< Position of REGION12 field. */
-#define BPROT_CONFIG0_REGION12_Msk (0x1UL << BPROT_CONFIG0_REGION12_Pos) /*!< Bit mask of REGION12 field. */
-#define BPROT_CONFIG0_REGION12_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION12_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 11 : Enable protection for region 11. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION11_Pos (11UL) /*!< Position of REGION11 field. */
-#define BPROT_CONFIG0_REGION11_Msk (0x1UL << BPROT_CONFIG0_REGION11_Pos) /*!< Bit mask of REGION11 field. */
-#define BPROT_CONFIG0_REGION11_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION11_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 10 : Enable protection for region 10. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION10_Pos (10UL) /*!< Position of REGION10 field. */
-#define BPROT_CONFIG0_REGION10_Msk (0x1UL << BPROT_CONFIG0_REGION10_Pos) /*!< Bit mask of REGION10 field. */
-#define BPROT_CONFIG0_REGION10_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION10_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 9 : Enable protection for region 9. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION9_Pos (9UL) /*!< Position of REGION9 field. */
-#define BPROT_CONFIG0_REGION9_Msk (0x1UL << BPROT_CONFIG0_REGION9_Pos) /*!< Bit mask of REGION9 field. */
-#define BPROT_CONFIG0_REGION9_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION9_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 8 : Enable protection for region 8. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION8_Pos (8UL) /*!< Position of REGION8 field. */
-#define BPROT_CONFIG0_REGION8_Msk (0x1UL << BPROT_CONFIG0_REGION8_Pos) /*!< Bit mask of REGION8 field. */
-#define BPROT_CONFIG0_REGION8_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION8_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 7 : Enable protection for region 7. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION7_Pos (7UL) /*!< Position of REGION7 field. */
-#define BPROT_CONFIG0_REGION7_Msk (0x1UL << BPROT_CONFIG0_REGION7_Pos) /*!< Bit mask of REGION7 field. */
-#define BPROT_CONFIG0_REGION7_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION7_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 6 : Enable protection for region 6. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION6_Pos (6UL) /*!< Position of REGION6 field. */
-#define BPROT_CONFIG0_REGION6_Msk (0x1UL << BPROT_CONFIG0_REGION6_Pos) /*!< Bit mask of REGION6 field. */
-#define BPROT_CONFIG0_REGION6_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION6_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 5 : Enable protection for region 5. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION5_Pos (5UL) /*!< Position of REGION5 field. */
-#define BPROT_CONFIG0_REGION5_Msk (0x1UL << BPROT_CONFIG0_REGION5_Pos) /*!< Bit mask of REGION5 field. */
-#define BPROT_CONFIG0_REGION5_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION5_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 4 : Enable protection for region 4. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION4_Pos (4UL) /*!< Position of REGION4 field. */
-#define BPROT_CONFIG0_REGION4_Msk (0x1UL << BPROT_CONFIG0_REGION4_Pos) /*!< Bit mask of REGION4 field. */
-#define BPROT_CONFIG0_REGION4_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION4_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 3 : Enable protection for region 3. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION3_Pos (3UL) /*!< Position of REGION3 field. */
-#define BPROT_CONFIG0_REGION3_Msk (0x1UL << BPROT_CONFIG0_REGION3_Pos) /*!< Bit mask of REGION3 field. */
-#define BPROT_CONFIG0_REGION3_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION3_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 2 : Enable protection for region 2. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION2_Pos (2UL) /*!< Position of REGION2 field. */
-#define BPROT_CONFIG0_REGION2_Msk (0x1UL << BPROT_CONFIG0_REGION2_Pos) /*!< Bit mask of REGION2 field. */
-#define BPROT_CONFIG0_REGION2_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION2_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 1 : Enable protection for region 1. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION1_Pos (1UL) /*!< Position of REGION1 field. */
-#define BPROT_CONFIG0_REGION1_Msk (0x1UL << BPROT_CONFIG0_REGION1_Pos) /*!< Bit mask of REGION1 field. */
-#define BPROT_CONFIG0_REGION1_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION1_Enabled (1UL) /*!< Protection enable */
-
-/* Bit 0 : Enable protection for region 0. Write '0' has no effect. */
-#define BPROT_CONFIG0_REGION0_Pos (0UL) /*!< Position of REGION0 field. */
-#define BPROT_CONFIG0_REGION0_Msk (0x1UL << BPROT_CONFIG0_REGION0_Pos) /*!< Bit mask of REGION0 field. */
-#define BPROT_CONFIG0_REGION0_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG0_REGION0_Enabled (1UL) /*!< Protection enable */
-
-/* Register: BPROT_CONFIG1 */
-/* Description: Block protect configuration register 1 */
-
-/* Bit 31 : Enable protection for region 63. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION63_Pos (31UL) /*!< Position of REGION63 field. */
-#define BPROT_CONFIG1_REGION63_Msk (0x1UL << BPROT_CONFIG1_REGION63_Pos) /*!< Bit mask of REGION63 field. */
-#define BPROT_CONFIG1_REGION63_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION63_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 30 : Enable protection for region 62. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION62_Pos (30UL) /*!< Position of REGION62 field. */
-#define BPROT_CONFIG1_REGION62_Msk (0x1UL << BPROT_CONFIG1_REGION62_Pos) /*!< Bit mask of REGION62 field. */
-#define BPROT_CONFIG1_REGION62_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION62_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 29 : Enable protection for region 61. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION61_Pos (29UL) /*!< Position of REGION61 field. */
-#define BPROT_CONFIG1_REGION61_Msk (0x1UL << BPROT_CONFIG1_REGION61_Pos) /*!< Bit mask of REGION61 field. */
-#define BPROT_CONFIG1_REGION61_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION61_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 28 : Enable protection for region 60. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION60_Pos (28UL) /*!< Position of REGION60 field. */
-#define BPROT_CONFIG1_REGION60_Msk (0x1UL << BPROT_CONFIG1_REGION60_Pos) /*!< Bit mask of REGION60 field. */
-#define BPROT_CONFIG1_REGION60_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION60_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 27 : Enable protection for region 59. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION59_Pos (27UL) /*!< Position of REGION59 field. */
-#define BPROT_CONFIG1_REGION59_Msk (0x1UL << BPROT_CONFIG1_REGION59_Pos) /*!< Bit mask of REGION59 field. */
-#define BPROT_CONFIG1_REGION59_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION59_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 26 : Enable protection for region 58. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION58_Pos (26UL) /*!< Position of REGION58 field. */
-#define BPROT_CONFIG1_REGION58_Msk (0x1UL << BPROT_CONFIG1_REGION58_Pos) /*!< Bit mask of REGION58 field. */
-#define BPROT_CONFIG1_REGION58_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION58_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 25 : Enable protection for region 57. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION57_Pos (25UL) /*!< Position of REGION57 field. */
-#define BPROT_CONFIG1_REGION57_Msk (0x1UL << BPROT_CONFIG1_REGION57_Pos) /*!< Bit mask of REGION57 field. */
-#define BPROT_CONFIG1_REGION57_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION57_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 24 : Enable protection for region 56. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION56_Pos (24UL) /*!< Position of REGION56 field. */
-#define BPROT_CONFIG1_REGION56_Msk (0x1UL << BPROT_CONFIG1_REGION56_Pos) /*!< Bit mask of REGION56 field. */
-#define BPROT_CONFIG1_REGION56_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION56_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 23 : Enable protection for region 55. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION55_Pos (23UL) /*!< Position of REGION55 field. */
-#define BPROT_CONFIG1_REGION55_Msk (0x1UL << BPROT_CONFIG1_REGION55_Pos) /*!< Bit mask of REGION55 field. */
-#define BPROT_CONFIG1_REGION55_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION55_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 22 : Enable protection for region 54. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION54_Pos (22UL) /*!< Position of REGION54 field. */
-#define BPROT_CONFIG1_REGION54_Msk (0x1UL << BPROT_CONFIG1_REGION54_Pos) /*!< Bit mask of REGION54 field. */
-#define BPROT_CONFIG1_REGION54_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION54_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 21 : Enable protection for region 53. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION53_Pos (21UL) /*!< Position of REGION53 field. */
-#define BPROT_CONFIG1_REGION53_Msk (0x1UL << BPROT_CONFIG1_REGION53_Pos) /*!< Bit mask of REGION53 field. */
-#define BPROT_CONFIG1_REGION53_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION53_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 20 : Enable protection for region 52. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION52_Pos (20UL) /*!< Position of REGION52 field. */
-#define BPROT_CONFIG1_REGION52_Msk (0x1UL << BPROT_CONFIG1_REGION52_Pos) /*!< Bit mask of REGION52 field. */
-#define BPROT_CONFIG1_REGION52_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION52_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 19 : Enable protection for region 51. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION51_Pos (19UL) /*!< Position of REGION51 field. */
-#define BPROT_CONFIG1_REGION51_Msk (0x1UL << BPROT_CONFIG1_REGION51_Pos) /*!< Bit mask of REGION51 field. */
-#define BPROT_CONFIG1_REGION51_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION51_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 18 : Enable protection for region 50. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION50_Pos (18UL) /*!< Position of REGION50 field. */
-#define BPROT_CONFIG1_REGION50_Msk (0x1UL << BPROT_CONFIG1_REGION50_Pos) /*!< Bit mask of REGION50 field. */
-#define BPROT_CONFIG1_REGION50_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION50_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 17 : Enable protection for region 49. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION49_Pos (17UL) /*!< Position of REGION49 field. */
-#define BPROT_CONFIG1_REGION49_Msk (0x1UL << BPROT_CONFIG1_REGION49_Pos) /*!< Bit mask of REGION49 field. */
-#define BPROT_CONFIG1_REGION49_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION49_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 16 : Enable protection for region 48. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION48_Pos (16UL) /*!< Position of REGION48 field. */
-#define BPROT_CONFIG1_REGION48_Msk (0x1UL << BPROT_CONFIG1_REGION48_Pos) /*!< Bit mask of REGION48 field. */
-#define BPROT_CONFIG1_REGION48_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION48_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 15 : Enable protection for region 47. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION47_Pos (15UL) /*!< Position of REGION47 field. */
-#define BPROT_CONFIG1_REGION47_Msk (0x1UL << BPROT_CONFIG1_REGION47_Pos) /*!< Bit mask of REGION47 field. */
-#define BPROT_CONFIG1_REGION47_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION47_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 14 : Enable protection for region 46. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION46_Pos (14UL) /*!< Position of REGION46 field. */
-#define BPROT_CONFIG1_REGION46_Msk (0x1UL << BPROT_CONFIG1_REGION46_Pos) /*!< Bit mask of REGION46 field. */
-#define BPROT_CONFIG1_REGION46_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION46_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 13 : Enable protection for region 45. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION45_Pos (13UL) /*!< Position of REGION45 field. */
-#define BPROT_CONFIG1_REGION45_Msk (0x1UL << BPROT_CONFIG1_REGION45_Pos) /*!< Bit mask of REGION45 field. */
-#define BPROT_CONFIG1_REGION45_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION45_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 12 : Enable protection for region 44. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION44_Pos (12UL) /*!< Position of REGION44 field. */
-#define BPROT_CONFIG1_REGION44_Msk (0x1UL << BPROT_CONFIG1_REGION44_Pos) /*!< Bit mask of REGION44 field. */
-#define BPROT_CONFIG1_REGION44_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION44_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 11 : Enable protection for region 43. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION43_Pos (11UL) /*!< Position of REGION43 field. */
-#define BPROT_CONFIG1_REGION43_Msk (0x1UL << BPROT_CONFIG1_REGION43_Pos) /*!< Bit mask of REGION43 field. */
-#define BPROT_CONFIG1_REGION43_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION43_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 10 : Enable protection for region 42. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION42_Pos (10UL) /*!< Position of REGION42 field. */
-#define BPROT_CONFIG1_REGION42_Msk (0x1UL << BPROT_CONFIG1_REGION42_Pos) /*!< Bit mask of REGION42 field. */
-#define BPROT_CONFIG1_REGION42_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION42_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 9 : Enable protection for region 41. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION41_Pos (9UL) /*!< Position of REGION41 field. */
-#define BPROT_CONFIG1_REGION41_Msk (0x1UL << BPROT_CONFIG1_REGION41_Pos) /*!< Bit mask of REGION41 field. */
-#define BPROT_CONFIG1_REGION41_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION41_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 8 : Enable protection for region 40. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION40_Pos (8UL) /*!< Position of REGION40 field. */
-#define BPROT_CONFIG1_REGION40_Msk (0x1UL << BPROT_CONFIG1_REGION40_Pos) /*!< Bit mask of REGION40 field. */
-#define BPROT_CONFIG1_REGION40_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION40_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 7 : Enable protection for region 39. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION39_Pos (7UL) /*!< Position of REGION39 field. */
-#define BPROT_CONFIG1_REGION39_Msk (0x1UL << BPROT_CONFIG1_REGION39_Pos) /*!< Bit mask of REGION39 field. */
-#define BPROT_CONFIG1_REGION39_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION39_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 6 : Enable protection for region 38. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION38_Pos (6UL) /*!< Position of REGION38 field. */
-#define BPROT_CONFIG1_REGION38_Msk (0x1UL << BPROT_CONFIG1_REGION38_Pos) /*!< Bit mask of REGION38 field. */
-#define BPROT_CONFIG1_REGION38_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION38_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 5 : Enable protection for region 37. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION37_Pos (5UL) /*!< Position of REGION37 field. */
-#define BPROT_CONFIG1_REGION37_Msk (0x1UL << BPROT_CONFIG1_REGION37_Pos) /*!< Bit mask of REGION37 field. */
-#define BPROT_CONFIG1_REGION37_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION37_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 4 : Enable protection for region 36. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION36_Pos (4UL) /*!< Position of REGION36 field. */
-#define BPROT_CONFIG1_REGION36_Msk (0x1UL << BPROT_CONFIG1_REGION36_Pos) /*!< Bit mask of REGION36 field. */
-#define BPROT_CONFIG1_REGION36_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION36_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 3 : Enable protection for region 35. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION35_Pos (3UL) /*!< Position of REGION35 field. */
-#define BPROT_CONFIG1_REGION35_Msk (0x1UL << BPROT_CONFIG1_REGION35_Pos) /*!< Bit mask of REGION35 field. */
-#define BPROT_CONFIG1_REGION35_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION35_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 2 : Enable protection for region 34. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION34_Pos (2UL) /*!< Position of REGION34 field. */
-#define BPROT_CONFIG1_REGION34_Msk (0x1UL << BPROT_CONFIG1_REGION34_Pos) /*!< Bit mask of REGION34 field. */
-#define BPROT_CONFIG1_REGION34_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION34_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 1 : Enable protection for region 33. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION33_Pos (1UL) /*!< Position of REGION33 field. */
-#define BPROT_CONFIG1_REGION33_Msk (0x1UL << BPROT_CONFIG1_REGION33_Pos) /*!< Bit mask of REGION33 field. */
-#define BPROT_CONFIG1_REGION33_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION33_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 0 : Enable protection for region 32. Write '0' has no effect. */
-#define BPROT_CONFIG1_REGION32_Pos (0UL) /*!< Position of REGION32 field. */
-#define BPROT_CONFIG1_REGION32_Msk (0x1UL << BPROT_CONFIG1_REGION32_Pos) /*!< Bit mask of REGION32 field. */
-#define BPROT_CONFIG1_REGION32_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG1_REGION32_Enabled (1UL) /*!< Protection enabled */
-
-/* Register: BPROT_DISABLEINDEBUG */
-/* Description: Disable protection mechanism in debug interface mode */
-
-/* Bit 0 : Disable the protection mechanism for NVM regions while in debug interface mode. This register will only disable the protection mechanism if the device is in debug interface mode. */
-#define BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Pos (0UL) /*!< Position of DISABLEINDEBUG field. */
-#define BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Msk (0x1UL << BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Pos) /*!< Bit mask of DISABLEINDEBUG field. */
-#define BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Enabled (0UL) /*!< Enable in debug */
-#define BPROT_DISABLEINDEBUG_DISABLEINDEBUG_Disabled (1UL) /*!< Disable in debug */
-
-/* Register: BPROT_CONFIG2 */
-/* Description: Block protect configuration register 2 */
-
-/* Bit 31 : Enable protection for region 95. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION95_Pos (31UL) /*!< Position of REGION95 field. */
-#define BPROT_CONFIG2_REGION95_Msk (0x1UL << BPROT_CONFIG2_REGION95_Pos) /*!< Bit mask of REGION95 field. */
-#define BPROT_CONFIG2_REGION95_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION95_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 30 : Enable protection for region 94. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION94_Pos (30UL) /*!< Position of REGION94 field. */
-#define BPROT_CONFIG2_REGION94_Msk (0x1UL << BPROT_CONFIG2_REGION94_Pos) /*!< Bit mask of REGION94 field. */
-#define BPROT_CONFIG2_REGION94_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION94_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 29 : Enable protection for region 93. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION93_Pos (29UL) /*!< Position of REGION93 field. */
-#define BPROT_CONFIG2_REGION93_Msk (0x1UL << BPROT_CONFIG2_REGION93_Pos) /*!< Bit mask of REGION93 field. */
-#define BPROT_CONFIG2_REGION93_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION93_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 28 : Enable protection for region 92. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION92_Pos (28UL) /*!< Position of REGION92 field. */
-#define BPROT_CONFIG2_REGION92_Msk (0x1UL << BPROT_CONFIG2_REGION92_Pos) /*!< Bit mask of REGION92 field. */
-#define BPROT_CONFIG2_REGION92_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION92_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 27 : Enable protection for region 91. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION91_Pos (27UL) /*!< Position of REGION91 field. */
-#define BPROT_CONFIG2_REGION91_Msk (0x1UL << BPROT_CONFIG2_REGION91_Pos) /*!< Bit mask of REGION91 field. */
-#define BPROT_CONFIG2_REGION91_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION91_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 26 : Enable protection for region 90. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION90_Pos (26UL) /*!< Position of REGION90 field. */
-#define BPROT_CONFIG2_REGION90_Msk (0x1UL << BPROT_CONFIG2_REGION90_Pos) /*!< Bit mask of REGION90 field. */
-#define BPROT_CONFIG2_REGION90_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION90_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 25 : Enable protection for region 89. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION89_Pos (25UL) /*!< Position of REGION89 field. */
-#define BPROT_CONFIG2_REGION89_Msk (0x1UL << BPROT_CONFIG2_REGION89_Pos) /*!< Bit mask of REGION89 field. */
-#define BPROT_CONFIG2_REGION89_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION89_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 24 : Enable protection for region 88. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION88_Pos (24UL) /*!< Position of REGION88 field. */
-#define BPROT_CONFIG2_REGION88_Msk (0x1UL << BPROT_CONFIG2_REGION88_Pos) /*!< Bit mask of REGION88 field. */
-#define BPROT_CONFIG2_REGION88_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION88_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 23 : Enable protection for region 87. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION87_Pos (23UL) /*!< Position of REGION87 field. */
-#define BPROT_CONFIG2_REGION87_Msk (0x1UL << BPROT_CONFIG2_REGION87_Pos) /*!< Bit mask of REGION87 field. */
-#define BPROT_CONFIG2_REGION87_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION87_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 22 : Enable protection for region 86. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION86_Pos (22UL) /*!< Position of REGION86 field. */
-#define BPROT_CONFIG2_REGION86_Msk (0x1UL << BPROT_CONFIG2_REGION86_Pos) /*!< Bit mask of REGION86 field. */
-#define BPROT_CONFIG2_REGION86_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION86_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 21 : Enable protection for region 85. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION85_Pos (21UL) /*!< Position of REGION85 field. */
-#define BPROT_CONFIG2_REGION85_Msk (0x1UL << BPROT_CONFIG2_REGION85_Pos) /*!< Bit mask of REGION85 field. */
-#define BPROT_CONFIG2_REGION85_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION85_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 20 : Enable protection for region 84. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION84_Pos (20UL) /*!< Position of REGION84 field. */
-#define BPROT_CONFIG2_REGION84_Msk (0x1UL << BPROT_CONFIG2_REGION84_Pos) /*!< Bit mask of REGION84 field. */
-#define BPROT_CONFIG2_REGION84_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION84_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 19 : Enable protection for region 83. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION83_Pos (19UL) /*!< Position of REGION83 field. */
-#define BPROT_CONFIG2_REGION83_Msk (0x1UL << BPROT_CONFIG2_REGION83_Pos) /*!< Bit mask of REGION83 field. */
-#define BPROT_CONFIG2_REGION83_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION83_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 18 : Enable protection for region 82. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION82_Pos (18UL) /*!< Position of REGION82 field. */
-#define BPROT_CONFIG2_REGION82_Msk (0x1UL << BPROT_CONFIG2_REGION82_Pos) /*!< Bit mask of REGION82 field. */
-#define BPROT_CONFIG2_REGION82_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION82_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 17 : Enable protection for region 81. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION81_Pos (17UL) /*!< Position of REGION81 field. */
-#define BPROT_CONFIG2_REGION81_Msk (0x1UL << BPROT_CONFIG2_REGION81_Pos) /*!< Bit mask of REGION81 field. */
-#define BPROT_CONFIG2_REGION81_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION81_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 16 : Enable protection for region 80. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION80_Pos (16UL) /*!< Position of REGION80 field. */
-#define BPROT_CONFIG2_REGION80_Msk (0x1UL << BPROT_CONFIG2_REGION80_Pos) /*!< Bit mask of REGION80 field. */
-#define BPROT_CONFIG2_REGION80_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION80_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 15 : Enable protection for region 79. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION79_Pos (15UL) /*!< Position of REGION79 field. */
-#define BPROT_CONFIG2_REGION79_Msk (0x1UL << BPROT_CONFIG2_REGION79_Pos) /*!< Bit mask of REGION79 field. */
-#define BPROT_CONFIG2_REGION79_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION79_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 14 : Enable protection for region 78. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION78_Pos (14UL) /*!< Position of REGION78 field. */
-#define BPROT_CONFIG2_REGION78_Msk (0x1UL << BPROT_CONFIG2_REGION78_Pos) /*!< Bit mask of REGION78 field. */
-#define BPROT_CONFIG2_REGION78_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION78_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 13 : Enable protection for region 77. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION77_Pos (13UL) /*!< Position of REGION77 field. */
-#define BPROT_CONFIG2_REGION77_Msk (0x1UL << BPROT_CONFIG2_REGION77_Pos) /*!< Bit mask of REGION77 field. */
-#define BPROT_CONFIG2_REGION77_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION77_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 12 : Enable protection for region 76. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION76_Pos (12UL) /*!< Position of REGION76 field. */
-#define BPROT_CONFIG2_REGION76_Msk (0x1UL << BPROT_CONFIG2_REGION76_Pos) /*!< Bit mask of REGION76 field. */
-#define BPROT_CONFIG2_REGION76_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION76_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 11 : Enable protection for region 75. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION75_Pos (11UL) /*!< Position of REGION75 field. */
-#define BPROT_CONFIG2_REGION75_Msk (0x1UL << BPROT_CONFIG2_REGION75_Pos) /*!< Bit mask of REGION75 field. */
-#define BPROT_CONFIG2_REGION75_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION75_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 10 : Enable protection for region 74. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION74_Pos (10UL) /*!< Position of REGION74 field. */
-#define BPROT_CONFIG2_REGION74_Msk (0x1UL << BPROT_CONFIG2_REGION74_Pos) /*!< Bit mask of REGION74 field. */
-#define BPROT_CONFIG2_REGION74_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION74_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 9 : Enable protection for region 73. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION73_Pos (9UL) /*!< Position of REGION73 field. */
-#define BPROT_CONFIG2_REGION73_Msk (0x1UL << BPROT_CONFIG2_REGION73_Pos) /*!< Bit mask of REGION73 field. */
-#define BPROT_CONFIG2_REGION73_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION73_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 8 : Enable protection for region 72. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION72_Pos (8UL) /*!< Position of REGION72 field. */
-#define BPROT_CONFIG2_REGION72_Msk (0x1UL << BPROT_CONFIG2_REGION72_Pos) /*!< Bit mask of REGION72 field. */
-#define BPROT_CONFIG2_REGION72_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION72_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 7 : Enable protection for region 71. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION71_Pos (7UL) /*!< Position of REGION71 field. */
-#define BPROT_CONFIG2_REGION71_Msk (0x1UL << BPROT_CONFIG2_REGION71_Pos) /*!< Bit mask of REGION71 field. */
-#define BPROT_CONFIG2_REGION71_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION71_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 6 : Enable protection for region 70. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION70_Pos (6UL) /*!< Position of REGION70 field. */
-#define BPROT_CONFIG2_REGION70_Msk (0x1UL << BPROT_CONFIG2_REGION70_Pos) /*!< Bit mask of REGION70 field. */
-#define BPROT_CONFIG2_REGION70_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION70_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 5 : Enable protection for region 69. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION69_Pos (5UL) /*!< Position of REGION69 field. */
-#define BPROT_CONFIG2_REGION69_Msk (0x1UL << BPROT_CONFIG2_REGION69_Pos) /*!< Bit mask of REGION69 field. */
-#define BPROT_CONFIG2_REGION69_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION69_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 4 : Enable protection for region 68. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION68_Pos (4UL) /*!< Position of REGION68 field. */
-#define BPROT_CONFIG2_REGION68_Msk (0x1UL << BPROT_CONFIG2_REGION68_Pos) /*!< Bit mask of REGION68 field. */
-#define BPROT_CONFIG2_REGION68_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION68_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 3 : Enable protection for region 67. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION67_Pos (3UL) /*!< Position of REGION67 field. */
-#define BPROT_CONFIG2_REGION67_Msk (0x1UL << BPROT_CONFIG2_REGION67_Pos) /*!< Bit mask of REGION67 field. */
-#define BPROT_CONFIG2_REGION67_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION67_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 2 : Enable protection for region 66. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION66_Pos (2UL) /*!< Position of REGION66 field. */
-#define BPROT_CONFIG2_REGION66_Msk (0x1UL << BPROT_CONFIG2_REGION66_Pos) /*!< Bit mask of REGION66 field. */
-#define BPROT_CONFIG2_REGION66_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION66_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 1 : Enable protection for region 65. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION65_Pos (1UL) /*!< Position of REGION65 field. */
-#define BPROT_CONFIG2_REGION65_Msk (0x1UL << BPROT_CONFIG2_REGION65_Pos) /*!< Bit mask of REGION65 field. */
-#define BPROT_CONFIG2_REGION65_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION65_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 0 : Enable protection for region 64. Write '0' has no effect. */
-#define BPROT_CONFIG2_REGION64_Pos (0UL) /*!< Position of REGION64 field. */
-#define BPROT_CONFIG2_REGION64_Msk (0x1UL << BPROT_CONFIG2_REGION64_Pos) /*!< Bit mask of REGION64 field. */
-#define BPROT_CONFIG2_REGION64_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG2_REGION64_Enabled (1UL) /*!< Protection enabled */
-
-/* Register: BPROT_CONFIG3 */
-/* Description: Block protect configuration register 3 */
-
-/* Bit 31 : Enable protection for region 127. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION127_Pos (31UL) /*!< Position of REGION127 field. */
-#define BPROT_CONFIG3_REGION127_Msk (0x1UL << BPROT_CONFIG3_REGION127_Pos) /*!< Bit mask of REGION127 field. */
-#define BPROT_CONFIG3_REGION127_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION127_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 30 : Enable protection for region 126. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION126_Pos (30UL) /*!< Position of REGION126 field. */
-#define BPROT_CONFIG3_REGION126_Msk (0x1UL << BPROT_CONFIG3_REGION126_Pos) /*!< Bit mask of REGION126 field. */
-#define BPROT_CONFIG3_REGION126_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION126_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 29 : Enable protection for region 125. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION125_Pos (29UL) /*!< Position of REGION125 field. */
-#define BPROT_CONFIG3_REGION125_Msk (0x1UL << BPROT_CONFIG3_REGION125_Pos) /*!< Bit mask of REGION125 field. */
-#define BPROT_CONFIG3_REGION125_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION125_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 28 : Enable protection for region 124. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION124_Pos (28UL) /*!< Position of REGION124 field. */
-#define BPROT_CONFIG3_REGION124_Msk (0x1UL << BPROT_CONFIG3_REGION124_Pos) /*!< Bit mask of REGION124 field. */
-#define BPROT_CONFIG3_REGION124_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION124_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 27 : Enable protection for region 123. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION123_Pos (27UL) /*!< Position of REGION123 field. */
-#define BPROT_CONFIG3_REGION123_Msk (0x1UL << BPROT_CONFIG3_REGION123_Pos) /*!< Bit mask of REGION123 field. */
-#define BPROT_CONFIG3_REGION123_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION123_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 26 : Enable protection for region 122. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION122_Pos (26UL) /*!< Position of REGION122 field. */
-#define BPROT_CONFIG3_REGION122_Msk (0x1UL << BPROT_CONFIG3_REGION122_Pos) /*!< Bit mask of REGION122 field. */
-#define BPROT_CONFIG3_REGION122_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION122_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 25 : Enable protection for region 121. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION121_Pos (25UL) /*!< Position of REGION121 field. */
-#define BPROT_CONFIG3_REGION121_Msk (0x1UL << BPROT_CONFIG3_REGION121_Pos) /*!< Bit mask of REGION121 field. */
-#define BPROT_CONFIG3_REGION121_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION121_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 24 : Enable protection for region 120. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION120_Pos (24UL) /*!< Position of REGION120 field. */
-#define BPROT_CONFIG3_REGION120_Msk (0x1UL << BPROT_CONFIG3_REGION120_Pos) /*!< Bit mask of REGION120 field. */
-#define BPROT_CONFIG3_REGION120_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION120_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 23 : Enable protection for region 119. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION119_Pos (23UL) /*!< Position of REGION119 field. */
-#define BPROT_CONFIG3_REGION119_Msk (0x1UL << BPROT_CONFIG3_REGION119_Pos) /*!< Bit mask of REGION119 field. */
-#define BPROT_CONFIG3_REGION119_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION119_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 22 : Enable protection for region 118. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION118_Pos (22UL) /*!< Position of REGION118 field. */
-#define BPROT_CONFIG3_REGION118_Msk (0x1UL << BPROT_CONFIG3_REGION118_Pos) /*!< Bit mask of REGION118 field. */
-#define BPROT_CONFIG3_REGION118_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION118_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 21 : Enable protection for region 117. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION117_Pos (21UL) /*!< Position of REGION117 field. */
-#define BPROT_CONFIG3_REGION117_Msk (0x1UL << BPROT_CONFIG3_REGION117_Pos) /*!< Bit mask of REGION117 field. */
-#define BPROT_CONFIG3_REGION117_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION117_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 20 : Enable protection for region 116. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION116_Pos (20UL) /*!< Position of REGION116 field. */
-#define BPROT_CONFIG3_REGION116_Msk (0x1UL << BPROT_CONFIG3_REGION116_Pos) /*!< Bit mask of REGION116 field. */
-#define BPROT_CONFIG3_REGION116_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION116_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 19 : Enable protection for region 115. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION115_Pos (19UL) /*!< Position of REGION115 field. */
-#define BPROT_CONFIG3_REGION115_Msk (0x1UL << BPROT_CONFIG3_REGION115_Pos) /*!< Bit mask of REGION115 field. */
-#define BPROT_CONFIG3_REGION115_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION115_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 18 : Enable protection for region 114. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION114_Pos (18UL) /*!< Position of REGION114 field. */
-#define BPROT_CONFIG3_REGION114_Msk (0x1UL << BPROT_CONFIG3_REGION114_Pos) /*!< Bit mask of REGION114 field. */
-#define BPROT_CONFIG3_REGION114_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION114_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 17 : Enable protection for region 113. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION113_Pos (17UL) /*!< Position of REGION113 field. */
-#define BPROT_CONFIG3_REGION113_Msk (0x1UL << BPROT_CONFIG3_REGION113_Pos) /*!< Bit mask of REGION113 field. */
-#define BPROT_CONFIG3_REGION113_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION113_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 16 : Enable protection for region 112. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION112_Pos (16UL) /*!< Position of REGION112 field. */
-#define BPROT_CONFIG3_REGION112_Msk (0x1UL << BPROT_CONFIG3_REGION112_Pos) /*!< Bit mask of REGION112 field. */
-#define BPROT_CONFIG3_REGION112_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION112_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 15 : Enable protection for region 111. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION111_Pos (15UL) /*!< Position of REGION111 field. */
-#define BPROT_CONFIG3_REGION111_Msk (0x1UL << BPROT_CONFIG3_REGION111_Pos) /*!< Bit mask of REGION111 field. */
-#define BPROT_CONFIG3_REGION111_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION111_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 14 : Enable protection for region 110. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION110_Pos (14UL) /*!< Position of REGION110 field. */
-#define BPROT_CONFIG3_REGION110_Msk (0x1UL << BPROT_CONFIG3_REGION110_Pos) /*!< Bit mask of REGION110 field. */
-#define BPROT_CONFIG3_REGION110_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION110_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 13 : Enable protection for region 109. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION109_Pos (13UL) /*!< Position of REGION109 field. */
-#define BPROT_CONFIG3_REGION109_Msk (0x1UL << BPROT_CONFIG3_REGION109_Pos) /*!< Bit mask of REGION109 field. */
-#define BPROT_CONFIG3_REGION109_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION109_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 12 : Enable protection for region 108. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION108_Pos (12UL) /*!< Position of REGION108 field. */
-#define BPROT_CONFIG3_REGION108_Msk (0x1UL << BPROT_CONFIG3_REGION108_Pos) /*!< Bit mask of REGION108 field. */
-#define BPROT_CONFIG3_REGION108_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION108_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 11 : Enable protection for region 107. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION107_Pos (11UL) /*!< Position of REGION107 field. */
-#define BPROT_CONFIG3_REGION107_Msk (0x1UL << BPROT_CONFIG3_REGION107_Pos) /*!< Bit mask of REGION107 field. */
-#define BPROT_CONFIG3_REGION107_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION107_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 10 : Enable protection for region 106. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION106_Pos (10UL) /*!< Position of REGION106 field. */
-#define BPROT_CONFIG3_REGION106_Msk (0x1UL << BPROT_CONFIG3_REGION106_Pos) /*!< Bit mask of REGION106 field. */
-#define BPROT_CONFIG3_REGION106_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION106_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 9 : Enable protection for region 105. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION105_Pos (9UL) /*!< Position of REGION105 field. */
-#define BPROT_CONFIG3_REGION105_Msk (0x1UL << BPROT_CONFIG3_REGION105_Pos) /*!< Bit mask of REGION105 field. */
-#define BPROT_CONFIG3_REGION105_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION105_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 8 : Enable protection for region 104. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION104_Pos (8UL) /*!< Position of REGION104 field. */
-#define BPROT_CONFIG3_REGION104_Msk (0x1UL << BPROT_CONFIG3_REGION104_Pos) /*!< Bit mask of REGION104 field. */
-#define BPROT_CONFIG3_REGION104_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION104_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 7 : Enable protection for region 103. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION103_Pos (7UL) /*!< Position of REGION103 field. */
-#define BPROT_CONFIG3_REGION103_Msk (0x1UL << BPROT_CONFIG3_REGION103_Pos) /*!< Bit mask of REGION103 field. */
-#define BPROT_CONFIG3_REGION103_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION103_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 6 : Enable protection for region 102. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION102_Pos (6UL) /*!< Position of REGION102 field. */
-#define BPROT_CONFIG3_REGION102_Msk (0x1UL << BPROT_CONFIG3_REGION102_Pos) /*!< Bit mask of REGION102 field. */
-#define BPROT_CONFIG3_REGION102_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION102_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 5 : Enable protection for region 101. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION101_Pos (5UL) /*!< Position of REGION101 field. */
-#define BPROT_CONFIG3_REGION101_Msk (0x1UL << BPROT_CONFIG3_REGION101_Pos) /*!< Bit mask of REGION101 field. */
-#define BPROT_CONFIG3_REGION101_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION101_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 4 : Enable protection for region 100. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION100_Pos (4UL) /*!< Position of REGION100 field. */
-#define BPROT_CONFIG3_REGION100_Msk (0x1UL << BPROT_CONFIG3_REGION100_Pos) /*!< Bit mask of REGION100 field. */
-#define BPROT_CONFIG3_REGION100_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION100_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 3 : Enable protection for region 99. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION99_Pos (3UL) /*!< Position of REGION99 field. */
-#define BPROT_CONFIG3_REGION99_Msk (0x1UL << BPROT_CONFIG3_REGION99_Pos) /*!< Bit mask of REGION99 field. */
-#define BPROT_CONFIG3_REGION99_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION99_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 2 : Enable protection for region 98. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION98_Pos (2UL) /*!< Position of REGION98 field. */
-#define BPROT_CONFIG3_REGION98_Msk (0x1UL << BPROT_CONFIG3_REGION98_Pos) /*!< Bit mask of REGION98 field. */
-#define BPROT_CONFIG3_REGION98_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION98_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 1 : Enable protection for region 97. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION97_Pos (1UL) /*!< Position of REGION97 field. */
-#define BPROT_CONFIG3_REGION97_Msk (0x1UL << BPROT_CONFIG3_REGION97_Pos) /*!< Bit mask of REGION97 field. */
-#define BPROT_CONFIG3_REGION97_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION97_Enabled (1UL) /*!< Protection enabled */
-
-/* Bit 0 : Enable protection for region 96. Write '0' has no effect. */
-#define BPROT_CONFIG3_REGION96_Pos (0UL) /*!< Position of REGION96 field. */
-#define BPROT_CONFIG3_REGION96_Msk (0x1UL << BPROT_CONFIG3_REGION96_Pos) /*!< Bit mask of REGION96 field. */
-#define BPROT_CONFIG3_REGION96_Disabled (0UL) /*!< Protection disabled */
-#define BPROT_CONFIG3_REGION96_Enabled (1UL) /*!< Protection enabled */
-
-
-/* Peripheral: CCM */
-/* Description: AES CCM Mode Encryption */
-
-/* Register: CCM_SHORTS */
-/* Description: Shortcut register */
-
-/* Bit 0 : Shortcut between ENDKSGEN event and CRYPT task */
-#define CCM_SHORTS_ENDKSGEN_CRYPT_Pos (0UL) /*!< Position of ENDKSGEN_CRYPT field. */
-#define CCM_SHORTS_ENDKSGEN_CRYPT_Msk (0x1UL << CCM_SHORTS_ENDKSGEN_CRYPT_Pos) /*!< Bit mask of ENDKSGEN_CRYPT field. */
-#define CCM_SHORTS_ENDKSGEN_CRYPT_Disabled (0UL) /*!< Disable shortcut */
-#define CCM_SHORTS_ENDKSGEN_CRYPT_Enabled (1UL) /*!< Enable shortcut */
-
-/* Register: CCM_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 2 : Write '1' to Enable interrupt for ERROR event */
-#define CCM_INTENSET_ERROR_Pos (2UL) /*!< Position of ERROR field. */
-#define CCM_INTENSET_ERROR_Msk (0x1UL << CCM_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
-#define CCM_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
-#define CCM_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
-#define CCM_INTENSET_ERROR_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for ENDCRYPT event */
-#define CCM_INTENSET_ENDCRYPT_Pos (1UL) /*!< Position of ENDCRYPT field. */
-#define CCM_INTENSET_ENDCRYPT_Msk (0x1UL << CCM_INTENSET_ENDCRYPT_Pos) /*!< Bit mask of ENDCRYPT field. */
-#define CCM_INTENSET_ENDCRYPT_Disabled (0UL) /*!< Read: Disabled */
-#define CCM_INTENSET_ENDCRYPT_Enabled (1UL) /*!< Read: Enabled */
-#define CCM_INTENSET_ENDCRYPT_Set (1UL) /*!< Enable */
-
-/* Bit 0 : Write '1' to Enable interrupt for ENDKSGEN event */
-#define CCM_INTENSET_ENDKSGEN_Pos (0UL) /*!< Position of ENDKSGEN field. */
-#define CCM_INTENSET_ENDKSGEN_Msk (0x1UL << CCM_INTENSET_ENDKSGEN_Pos) /*!< Bit mask of ENDKSGEN field. */
-#define CCM_INTENSET_ENDKSGEN_Disabled (0UL) /*!< Read: Disabled */
-#define CCM_INTENSET_ENDKSGEN_Enabled (1UL) /*!< Read: Enabled */
-#define CCM_INTENSET_ENDKSGEN_Set (1UL) /*!< Enable */
-
-/* Register: CCM_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 2 : Write '1' to Disable interrupt for ERROR event */
-#define CCM_INTENCLR_ERROR_Pos (2UL) /*!< Position of ERROR field. */
-#define CCM_INTENCLR_ERROR_Msk (0x1UL << CCM_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
-#define CCM_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
-#define CCM_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
-#define CCM_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for ENDCRYPT event */
-#define CCM_INTENCLR_ENDCRYPT_Pos (1UL) /*!< Position of ENDCRYPT field. */
-#define CCM_INTENCLR_ENDCRYPT_Msk (0x1UL << CCM_INTENCLR_ENDCRYPT_Pos) /*!< Bit mask of ENDCRYPT field. */
-#define CCM_INTENCLR_ENDCRYPT_Disabled (0UL) /*!< Read: Disabled */
-#define CCM_INTENCLR_ENDCRYPT_Enabled (1UL) /*!< Read: Enabled */
-#define CCM_INTENCLR_ENDCRYPT_Clear (1UL) /*!< Disable */
-
-/* Bit 0 : Write '1' to Disable interrupt for ENDKSGEN event */
-#define CCM_INTENCLR_ENDKSGEN_Pos (0UL) /*!< Position of ENDKSGEN field. */
-#define CCM_INTENCLR_ENDKSGEN_Msk (0x1UL << CCM_INTENCLR_ENDKSGEN_Pos) /*!< Bit mask of ENDKSGEN field. */
-#define CCM_INTENCLR_ENDKSGEN_Disabled (0UL) /*!< Read: Disabled */
-#define CCM_INTENCLR_ENDKSGEN_Enabled (1UL) /*!< Read: Enabled */
-#define CCM_INTENCLR_ENDKSGEN_Clear (1UL) /*!< Disable */
-
-/* Register: CCM_MICSTATUS */
-/* Description: MIC check result */
-
-/* Bit 0 : The result of the MIC check performed during the previous decryption operation */
-#define CCM_MICSTATUS_MICSTATUS_Pos (0UL) /*!< Position of MICSTATUS field. */
-#define CCM_MICSTATUS_MICSTATUS_Msk (0x1UL << CCM_MICSTATUS_MICSTATUS_Pos) /*!< Bit mask of MICSTATUS field. */
-#define CCM_MICSTATUS_MICSTATUS_CheckFailed (0UL) /*!< MIC check failed */
-#define CCM_MICSTATUS_MICSTATUS_CheckPassed (1UL) /*!< MIC check passed */
-
-/* Register: CCM_ENABLE */
-/* Description: Enable */
-
-/* Bits 1..0 : Enable or disable CCM */
-#define CCM_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
-#define CCM_ENABLE_ENABLE_Msk (0x3UL << CCM_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
-#define CCM_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
-#define CCM_ENABLE_ENABLE_Enabled (2UL) /*!< Enable */
-
-/* Register: CCM_MODE */
-/* Description: Operation mode */
-
-/* Bit 24 : Packet length configuration */
-#define CCM_MODE_LENGTH_Pos (24UL) /*!< Position of LENGTH field. */
-#define CCM_MODE_LENGTH_Msk (0x1UL << CCM_MODE_LENGTH_Pos) /*!< Bit mask of LENGTH field. */
-#define CCM_MODE_LENGTH_Default (0UL) /*!< Default length. Effective length of LENGTH field is 5-bit */
-#define CCM_MODE_LENGTH_Extended (1UL) /*!< Extended length. Effective length of LENGTH field is 8-bit */
-
-/* Bit 16 : Data rate that the CCM shall run in synch with */
-#define CCM_MODE_DATARATE_Pos (16UL) /*!< Position of DATARATE field. */
-#define CCM_MODE_DATARATE_Msk (0x1UL << CCM_MODE_DATARATE_Pos) /*!< Bit mask of DATARATE field. */
-#define CCM_MODE_DATARATE_1Mbit (0UL) /*!< In synch with 1 Mbit data rate */
-#define CCM_MODE_DATARATE_2Mbit (1UL) /*!< In synch with 2 Mbit data rate */
-
-/* Bit 0 : The mode of operation to be used */
-#define CCM_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
-#define CCM_MODE_MODE_Msk (0x1UL << CCM_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
-#define CCM_MODE_MODE_Encryption (0UL) /*!< AES CCM packet encryption mode */
-#define CCM_MODE_MODE_Decryption (1UL) /*!< AES CCM packet decryption mode */
-
-/* Register: CCM_CNFPTR */
-/* Description: Pointer to data structure holding AES key and NONCE vector */
-
-/* Bits 31..0 : Pointer to the data structure holding the AES key and the CCM NONCE vector (see Table 1 CCM data structure overview) */
-#define CCM_CNFPTR_CNFPTR_Pos (0UL) /*!< Position of CNFPTR field. */
-#define CCM_CNFPTR_CNFPTR_Msk (0xFFFFFFFFUL << CCM_CNFPTR_CNFPTR_Pos) /*!< Bit mask of CNFPTR field. */
-
-/* Register: CCM_INPTR */
-/* Description: Input pointer */
-
-/* Bits 31..0 : Input pointer */
-#define CCM_INPTR_INPTR_Pos (0UL) /*!< Position of INPTR field. */
-#define CCM_INPTR_INPTR_Msk (0xFFFFFFFFUL << CCM_INPTR_INPTR_Pos) /*!< Bit mask of INPTR field. */
-
-/* Register: CCM_OUTPTR */
-/* Description: Output pointer */
-
-/* Bits 31..0 : Output pointer */
-#define CCM_OUTPTR_OUTPTR_Pos (0UL) /*!< Position of OUTPTR field. */
-#define CCM_OUTPTR_OUTPTR_Msk (0xFFFFFFFFUL << CCM_OUTPTR_OUTPTR_Pos) /*!< Bit mask of OUTPTR field. */
-
-/* Register: CCM_SCRATCHPTR */
-/* Description: Pointer to data area used for temporary storage */
-
-/* Bits 31..0 : Pointer to a scratch data area used for temporary storage during key-stream generation, MIC generation and encryption/decryption. */
-#define CCM_SCRATCHPTR_SCRATCHPTR_Pos (0UL) /*!< Position of SCRATCHPTR field. */
-#define CCM_SCRATCHPTR_SCRATCHPTR_Msk (0xFFFFFFFFUL << CCM_SCRATCHPTR_SCRATCHPTR_Pos) /*!< Bit mask of SCRATCHPTR field. */
-
-
-/* Peripheral: CLOCK */
-/* Description: Clock control */
-
-/* Register: CLOCK_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 4 : Write '1' to Enable interrupt for CTTO event */
-#define CLOCK_INTENSET_CTTO_Pos (4UL) /*!< Position of CTTO field. */
-#define CLOCK_INTENSET_CTTO_Msk (0x1UL << CLOCK_INTENSET_CTTO_Pos) /*!< Bit mask of CTTO field. */
-#define CLOCK_INTENSET_CTTO_Disabled (0UL) /*!< Read: Disabled */
-#define CLOCK_INTENSET_CTTO_Enabled (1UL) /*!< Read: Enabled */
-#define CLOCK_INTENSET_CTTO_Set (1UL) /*!< Enable */
-
-/* Bit 3 : Write '1' to Enable interrupt for DONE event */
-#define CLOCK_INTENSET_DONE_Pos (3UL) /*!< Position of DONE field. */
-#define CLOCK_INTENSET_DONE_Msk (0x1UL << CLOCK_INTENSET_DONE_Pos) /*!< Bit mask of DONE field. */
-#define CLOCK_INTENSET_DONE_Disabled (0UL) /*!< Read: Disabled */
-#define CLOCK_INTENSET_DONE_Enabled (1UL) /*!< Read: Enabled */
-#define CLOCK_INTENSET_DONE_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for LFCLKSTARTED event */
-#define CLOCK_INTENSET_LFCLKSTARTED_Pos (1UL) /*!< Position of LFCLKSTARTED field. */
-#define CLOCK_INTENSET_LFCLKSTARTED_Msk (0x1UL << CLOCK_INTENSET_LFCLKSTARTED_Pos) /*!< Bit mask of LFCLKSTARTED field. */
-#define CLOCK_INTENSET_LFCLKSTARTED_Disabled (0UL) /*!< Read: Disabled */
-#define CLOCK_INTENSET_LFCLKSTARTED_Enabled (1UL) /*!< Read: Enabled */
-#define CLOCK_INTENSET_LFCLKSTARTED_Set (1UL) /*!< Enable */
-
-/* Bit 0 : Write '1' to Enable interrupt for HFCLKSTARTED event */
-#define CLOCK_INTENSET_HFCLKSTARTED_Pos (0UL) /*!< Position of HFCLKSTARTED field. */
-#define CLOCK_INTENSET_HFCLKSTARTED_Msk (0x1UL << CLOCK_INTENSET_HFCLKSTARTED_Pos) /*!< Bit mask of HFCLKSTARTED field. */
-#define CLOCK_INTENSET_HFCLKSTARTED_Disabled (0UL) /*!< Read: Disabled */
-#define CLOCK_INTENSET_HFCLKSTARTED_Enabled (1UL) /*!< Read: Enabled */
-#define CLOCK_INTENSET_HFCLKSTARTED_Set (1UL) /*!< Enable */
-
-/* Register: CLOCK_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 4 : Write '1' to Disable interrupt for CTTO event */
-#define CLOCK_INTENCLR_CTTO_Pos (4UL) /*!< Position of CTTO field. */
-#define CLOCK_INTENCLR_CTTO_Msk (0x1UL << CLOCK_INTENCLR_CTTO_Pos) /*!< Bit mask of CTTO field. */
-#define CLOCK_INTENCLR_CTTO_Disabled (0UL) /*!< Read: Disabled */
-#define CLOCK_INTENCLR_CTTO_Enabled (1UL) /*!< Read: Enabled */
-#define CLOCK_INTENCLR_CTTO_Clear (1UL) /*!< Disable */
-
-/* Bit 3 : Write '1' to Disable interrupt for DONE event */
-#define CLOCK_INTENCLR_DONE_Pos (3UL) /*!< Position of DONE field. */
-#define CLOCK_INTENCLR_DONE_Msk (0x1UL << CLOCK_INTENCLR_DONE_Pos) /*!< Bit mask of DONE field. */
-#define CLOCK_INTENCLR_DONE_Disabled (0UL) /*!< Read: Disabled */
-#define CLOCK_INTENCLR_DONE_Enabled (1UL) /*!< Read: Enabled */
-#define CLOCK_INTENCLR_DONE_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for LFCLKSTARTED event */
-#define CLOCK_INTENCLR_LFCLKSTARTED_Pos (1UL) /*!< Position of LFCLKSTARTED field. */
-#define CLOCK_INTENCLR_LFCLKSTARTED_Msk (0x1UL << CLOCK_INTENCLR_LFCLKSTARTED_Pos) /*!< Bit mask of LFCLKSTARTED field. */
-#define CLOCK_INTENCLR_LFCLKSTARTED_Disabled (0UL) /*!< Read: Disabled */
-#define CLOCK_INTENCLR_LFCLKSTARTED_Enabled (1UL) /*!< Read: Enabled */
-#define CLOCK_INTENCLR_LFCLKSTARTED_Clear (1UL) /*!< Disable */
-
-/* Bit 0 : Write '1' to Disable interrupt for HFCLKSTARTED event */
-#define CLOCK_INTENCLR_HFCLKSTARTED_Pos (0UL) /*!< Position of HFCLKSTARTED field. */
-#define CLOCK_INTENCLR_HFCLKSTARTED_Msk (0x1UL << CLOCK_INTENCLR_HFCLKSTARTED_Pos) /*!< Bit mask of HFCLKSTARTED field. */
-#define CLOCK_INTENCLR_HFCLKSTARTED_Disabled (0UL) /*!< Read: Disabled */
-#define CLOCK_INTENCLR_HFCLKSTARTED_Enabled (1UL) /*!< Read: Enabled */
-#define CLOCK_INTENCLR_HFCLKSTARTED_Clear (1UL) /*!< Disable */
-
-/* Register: CLOCK_HFCLKRUN */
-/* Description: Status indicating that HFCLKSTART task has been triggered */
-
-/* Bit 0 : HFCLKSTART task triggered or not */
-#define CLOCK_HFCLKRUN_STATUS_Pos (0UL) /*!< Position of STATUS field. */
-#define CLOCK_HFCLKRUN_STATUS_Msk (0x1UL << CLOCK_HFCLKRUN_STATUS_Pos) /*!< Bit mask of STATUS field. */
-#define CLOCK_HFCLKRUN_STATUS_NotTriggered (0UL) /*!< Task not triggered */
-#define CLOCK_HFCLKRUN_STATUS_Triggered (1UL) /*!< Task triggered */
-
-/* Register: CLOCK_HFCLKSTAT */
-/* Description: HFCLK status */
-
-/* Bit 16 : HFCLK state */
-#define CLOCK_HFCLKSTAT_STATE_Pos (16UL) /*!< Position of STATE field. */
-#define CLOCK_HFCLKSTAT_STATE_Msk (0x1UL << CLOCK_HFCLKSTAT_STATE_Pos) /*!< Bit mask of STATE field. */
-#define CLOCK_HFCLKSTAT_STATE_NotRunning (0UL) /*!< HFCLK not running */
-#define CLOCK_HFCLKSTAT_STATE_Running (1UL) /*!< HFCLK running */
-
-/* Bit 0 : Source of HFCLK */
-#define CLOCK_HFCLKSTAT_SRC_Pos (0UL) /*!< Position of SRC field. */
-#define CLOCK_HFCLKSTAT_SRC_Msk (0x1UL << CLOCK_HFCLKSTAT_SRC_Pos) /*!< Bit mask of SRC field. */
-#define CLOCK_HFCLKSTAT_SRC_RC (0UL) /*!< 64 MHz internal oscillator (HFINT) */
-#define CLOCK_HFCLKSTAT_SRC_Xtal (1UL) /*!< 64 MHz crystal oscillator (HFXO) */
-
-/* Register: CLOCK_LFCLKRUN */
-/* Description: Status indicating that LFCLKSTART task has been triggered */
-
-/* Bit 0 : LFCLKSTART task triggered or not */
-#define CLOCK_LFCLKRUN_STATUS_Pos (0UL) /*!< Position of STATUS field. */
-#define CLOCK_LFCLKRUN_STATUS_Msk (0x1UL << CLOCK_LFCLKRUN_STATUS_Pos) /*!< Bit mask of STATUS field. */
-#define CLOCK_LFCLKRUN_STATUS_NotTriggered (0UL) /*!< Task not triggered */
-#define CLOCK_LFCLKRUN_STATUS_Triggered (1UL) /*!< Task triggered */
-
-/* Register: CLOCK_LFCLKSTAT */
-/* Description: LFCLK status */
-
-/* Bit 16 : LFCLK state */
-#define CLOCK_LFCLKSTAT_STATE_Pos (16UL) /*!< Position of STATE field. */
-#define CLOCK_LFCLKSTAT_STATE_Msk (0x1UL << CLOCK_LFCLKSTAT_STATE_Pos) /*!< Bit mask of STATE field. */
-#define CLOCK_LFCLKSTAT_STATE_NotRunning (0UL) /*!< LFCLK not running */
-#define CLOCK_LFCLKSTAT_STATE_Running (1UL) /*!< LFCLK running */
-
-/* Bits 1..0 : Source of LFCLK */
-#define CLOCK_LFCLKSTAT_SRC_Pos (0UL) /*!< Position of SRC field. */
-#define CLOCK_LFCLKSTAT_SRC_Msk (0x3UL << CLOCK_LFCLKSTAT_SRC_Pos) /*!< Bit mask of SRC field. */
-#define CLOCK_LFCLKSTAT_SRC_RC (0UL) /*!< 32.768 kHz RC oscillator */
-#define CLOCK_LFCLKSTAT_SRC_Xtal (1UL) /*!< 32.768 kHz crystal oscillator */
-#define CLOCK_LFCLKSTAT_SRC_Synth (2UL) /*!< 32.768 kHz synthesized from HFCLK */
-
-/* Register: CLOCK_LFCLKSRCCOPY */
-/* Description: Copy of LFCLKSRC register, set when LFCLKSTART task was triggered */
-
-/* Bits 1..0 : Clock source */
-#define CLOCK_LFCLKSRCCOPY_SRC_Pos (0UL) /*!< Position of SRC field. */
-#define CLOCK_LFCLKSRCCOPY_SRC_Msk (0x3UL << CLOCK_LFCLKSRCCOPY_SRC_Pos) /*!< Bit mask of SRC field. */
-#define CLOCK_LFCLKSRCCOPY_SRC_RC (0UL) /*!< 32.768 kHz RC oscillator */
-#define CLOCK_LFCLKSRCCOPY_SRC_Xtal (1UL) /*!< 32.768 kHz crystal oscillator */
-#define CLOCK_LFCLKSRCCOPY_SRC_Synth (2UL) /*!< 32.768 kHz synthesized from HFCLK */
-
-/* Register: CLOCK_LFCLKSRC */
-/* Description: Clock source for the LFCLK */
-
-/* Bit 17 : Enable or disable external source for LFCLK */
-#define CLOCK_LFCLKSRC_EXTERNAL_Pos (17UL) /*!< Position of EXTERNAL field. */
-#define CLOCK_LFCLKSRC_EXTERNAL_Msk (0x1UL << CLOCK_LFCLKSRC_EXTERNAL_Pos) /*!< Bit mask of EXTERNAL field. */
-#define CLOCK_LFCLKSRC_EXTERNAL_Disabled (0UL) /*!< Disable external source (use with Xtal) */
-#define CLOCK_LFCLKSRC_EXTERNAL_Enabled (1UL) /*!< Enable use of external source instead of Xtal (SRC needs to be set to Xtal) */
-
-/* Bit 16 : Enable or disable bypass of LFCLK crystal oscillator with external clock source */
-#define CLOCK_LFCLKSRC_BYPASS_Pos (16UL) /*!< Position of BYPASS field. */
-#define CLOCK_LFCLKSRC_BYPASS_Msk (0x1UL << CLOCK_LFCLKSRC_BYPASS_Pos) /*!< Bit mask of BYPASS field. */
-#define CLOCK_LFCLKSRC_BYPASS_Disabled (0UL) /*!< Disable (use with Xtal or low-swing external source) */
-#define CLOCK_LFCLKSRC_BYPASS_Enabled (1UL) /*!< Enable (use with rail-to-rail external source) */
-
-/* Bits 1..0 : Clock source */
-#define CLOCK_LFCLKSRC_SRC_Pos (0UL) /*!< Position of SRC field. */
-#define CLOCK_LFCLKSRC_SRC_Msk (0x3UL << CLOCK_LFCLKSRC_SRC_Pos) /*!< Bit mask of SRC field. */
-#define CLOCK_LFCLKSRC_SRC_RC (0UL) /*!< 32.768 kHz RC oscillator */
-#define CLOCK_LFCLKSRC_SRC_Xtal (1UL) /*!< 32.768 kHz crystal oscillator */
-#define CLOCK_LFCLKSRC_SRC_Synth (2UL) /*!< 32.768 kHz synthesized from HFCLK */
-
-/* Register: CLOCK_CTIV */
-/* Description: Calibration timer interval */
-
-/* Bits 6..0 : Calibration timer interval in multiple of 0.25 seconds. Range: 0.25 seconds to 31.75 seconds. */
-#define CLOCK_CTIV_CTIV_Pos (0UL) /*!< Position of CTIV field. */
-#define CLOCK_CTIV_CTIV_Msk (0x7FUL << CLOCK_CTIV_CTIV_Pos) /*!< Bit mask of CTIV field. */
-
-/* Register: CLOCK_TRACECONFIG */
-/* Description: Clocking options for the Trace Port debug interface */
-
-/* Bits 17..16 : Pin multiplexing of trace signals. */
-#define CLOCK_TRACECONFIG_TRACEMUX_Pos (16UL) /*!< Position of TRACEMUX field. */
-#define CLOCK_TRACECONFIG_TRACEMUX_Msk (0x3UL << CLOCK_TRACECONFIG_TRACEMUX_Pos) /*!< Bit mask of TRACEMUX field. */
-#define CLOCK_TRACECONFIG_TRACEMUX_GPIO (0UL) /*!< GPIOs multiplexed onto all trace-pins */
-#define CLOCK_TRACECONFIG_TRACEMUX_Serial (1UL) /*!< SWO multiplexed onto P0.18, GPIO multiplexed onto other trace pins */
-#define CLOCK_TRACECONFIG_TRACEMUX_Parallel (2UL) /*!< TRACECLK and TRACEDATA multiplexed onto P0.20, P0.18, P0.16, P0.15 and P0.14. */
-
-/* Bits 1..0 : Speed of Trace Port clock. Note that the TRACECLK pin will output this clock divided by two. */
-#define CLOCK_TRACECONFIG_TRACEPORTSPEED_Pos (0UL) /*!< Position of TRACEPORTSPEED field. */
-#define CLOCK_TRACECONFIG_TRACEPORTSPEED_Msk (0x3UL << CLOCK_TRACECONFIG_TRACEPORTSPEED_Pos) /*!< Bit mask of TRACEPORTSPEED field. */
-#define CLOCK_TRACECONFIG_TRACEPORTSPEED_32MHz (0UL) /*!< 32 MHz Trace Port clock (TRACECLK = 16 MHz) */
-#define CLOCK_TRACECONFIG_TRACEPORTSPEED_16MHz (1UL) /*!< 16 MHz Trace Port clock (TRACECLK = 8 MHz) */
-#define CLOCK_TRACECONFIG_TRACEPORTSPEED_8MHz (2UL) /*!< 8 MHz Trace Port clock (TRACECLK = 4 MHz) */
-#define CLOCK_TRACECONFIG_TRACEPORTSPEED_4MHz (3UL) /*!< 4 MHz Trace Port clock (TRACECLK = 2 MHz) */
-
-
-/* Peripheral: COMP */
-/* Description: Comparator */
-
-/* Register: COMP_SHORTS */
-/* Description: Shortcut register */
-
-/* Bit 4 : Shortcut between CROSS event and STOP task */
-#define COMP_SHORTS_CROSS_STOP_Pos (4UL) /*!< Position of CROSS_STOP field. */
-#define COMP_SHORTS_CROSS_STOP_Msk (0x1UL << COMP_SHORTS_CROSS_STOP_Pos) /*!< Bit mask of CROSS_STOP field. */
-#define COMP_SHORTS_CROSS_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define COMP_SHORTS_CROSS_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 3 : Shortcut between UP event and STOP task */
-#define COMP_SHORTS_UP_STOP_Pos (3UL) /*!< Position of UP_STOP field. */
-#define COMP_SHORTS_UP_STOP_Msk (0x1UL << COMP_SHORTS_UP_STOP_Pos) /*!< Bit mask of UP_STOP field. */
-#define COMP_SHORTS_UP_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define COMP_SHORTS_UP_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 2 : Shortcut between DOWN event and STOP task */
-#define COMP_SHORTS_DOWN_STOP_Pos (2UL) /*!< Position of DOWN_STOP field. */
-#define COMP_SHORTS_DOWN_STOP_Msk (0x1UL << COMP_SHORTS_DOWN_STOP_Pos) /*!< Bit mask of DOWN_STOP field. */
-#define COMP_SHORTS_DOWN_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define COMP_SHORTS_DOWN_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 1 : Shortcut between READY event and STOP task */
-#define COMP_SHORTS_READY_STOP_Pos (1UL) /*!< Position of READY_STOP field. */
-#define COMP_SHORTS_READY_STOP_Msk (0x1UL << COMP_SHORTS_READY_STOP_Pos) /*!< Bit mask of READY_STOP field. */
-#define COMP_SHORTS_READY_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define COMP_SHORTS_READY_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 0 : Shortcut between READY event and SAMPLE task */
-#define COMP_SHORTS_READY_SAMPLE_Pos (0UL) /*!< Position of READY_SAMPLE field. */
-#define COMP_SHORTS_READY_SAMPLE_Msk (0x1UL << COMP_SHORTS_READY_SAMPLE_Pos) /*!< Bit mask of READY_SAMPLE field. */
-#define COMP_SHORTS_READY_SAMPLE_Disabled (0UL) /*!< Disable shortcut */
-#define COMP_SHORTS_READY_SAMPLE_Enabled (1UL) /*!< Enable shortcut */
-
-/* Register: COMP_INTEN */
-/* Description: Enable or disable interrupt */
-
-/* Bit 3 : Enable or disable interrupt for CROSS event */
-#define COMP_INTEN_CROSS_Pos (3UL) /*!< Position of CROSS field. */
-#define COMP_INTEN_CROSS_Msk (0x1UL << COMP_INTEN_CROSS_Pos) /*!< Bit mask of CROSS field. */
-#define COMP_INTEN_CROSS_Disabled (0UL) /*!< Disable */
-#define COMP_INTEN_CROSS_Enabled (1UL) /*!< Enable */
-
-/* Bit 2 : Enable or disable interrupt for UP event */
-#define COMP_INTEN_UP_Pos (2UL) /*!< Position of UP field. */
-#define COMP_INTEN_UP_Msk (0x1UL << COMP_INTEN_UP_Pos) /*!< Bit mask of UP field. */
-#define COMP_INTEN_UP_Disabled (0UL) /*!< Disable */
-#define COMP_INTEN_UP_Enabled (1UL) /*!< Enable */
-
-/* Bit 1 : Enable or disable interrupt for DOWN event */
-#define COMP_INTEN_DOWN_Pos (1UL) /*!< Position of DOWN field. */
-#define COMP_INTEN_DOWN_Msk (0x1UL << COMP_INTEN_DOWN_Pos) /*!< Bit mask of DOWN field. */
-#define COMP_INTEN_DOWN_Disabled (0UL) /*!< Disable */
-#define COMP_INTEN_DOWN_Enabled (1UL) /*!< Enable */
-
-/* Bit 0 : Enable or disable interrupt for READY event */
-#define COMP_INTEN_READY_Pos (0UL) /*!< Position of READY field. */
-#define COMP_INTEN_READY_Msk (0x1UL << COMP_INTEN_READY_Pos) /*!< Bit mask of READY field. */
-#define COMP_INTEN_READY_Disabled (0UL) /*!< Disable */
-#define COMP_INTEN_READY_Enabled (1UL) /*!< Enable */
-
-/* Register: COMP_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 3 : Write '1' to Enable interrupt for CROSS event */
-#define COMP_INTENSET_CROSS_Pos (3UL) /*!< Position of CROSS field. */
-#define COMP_INTENSET_CROSS_Msk (0x1UL << COMP_INTENSET_CROSS_Pos) /*!< Bit mask of CROSS field. */
-#define COMP_INTENSET_CROSS_Disabled (0UL) /*!< Read: Disabled */
-#define COMP_INTENSET_CROSS_Enabled (1UL) /*!< Read: Enabled */
-#define COMP_INTENSET_CROSS_Set (1UL) /*!< Enable */
-
-/* Bit 2 : Write '1' to Enable interrupt for UP event */
-#define COMP_INTENSET_UP_Pos (2UL) /*!< Position of UP field. */
-#define COMP_INTENSET_UP_Msk (0x1UL << COMP_INTENSET_UP_Pos) /*!< Bit mask of UP field. */
-#define COMP_INTENSET_UP_Disabled (0UL) /*!< Read: Disabled */
-#define COMP_INTENSET_UP_Enabled (1UL) /*!< Read: Enabled */
-#define COMP_INTENSET_UP_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for DOWN event */
-#define COMP_INTENSET_DOWN_Pos (1UL) /*!< Position of DOWN field. */
-#define COMP_INTENSET_DOWN_Msk (0x1UL << COMP_INTENSET_DOWN_Pos) /*!< Bit mask of DOWN field. */
-#define COMP_INTENSET_DOWN_Disabled (0UL) /*!< Read: Disabled */
-#define COMP_INTENSET_DOWN_Enabled (1UL) /*!< Read: Enabled */
-#define COMP_INTENSET_DOWN_Set (1UL) /*!< Enable */
-
-/* Bit 0 : Write '1' to Enable interrupt for READY event */
-#define COMP_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
-#define COMP_INTENSET_READY_Msk (0x1UL << COMP_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
-#define COMP_INTENSET_READY_Disabled (0UL) /*!< Read: Disabled */
-#define COMP_INTENSET_READY_Enabled (1UL) /*!< Read: Enabled */
-#define COMP_INTENSET_READY_Set (1UL) /*!< Enable */
-
-/* Register: COMP_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 3 : Write '1' to Disable interrupt for CROSS event */
-#define COMP_INTENCLR_CROSS_Pos (3UL) /*!< Position of CROSS field. */
-#define COMP_INTENCLR_CROSS_Msk (0x1UL << COMP_INTENCLR_CROSS_Pos) /*!< Bit mask of CROSS field. */
-#define COMP_INTENCLR_CROSS_Disabled (0UL) /*!< Read: Disabled */
-#define COMP_INTENCLR_CROSS_Enabled (1UL) /*!< Read: Enabled */
-#define COMP_INTENCLR_CROSS_Clear (1UL) /*!< Disable */
-
-/* Bit 2 : Write '1' to Disable interrupt for UP event */
-#define COMP_INTENCLR_UP_Pos (2UL) /*!< Position of UP field. */
-#define COMP_INTENCLR_UP_Msk (0x1UL << COMP_INTENCLR_UP_Pos) /*!< Bit mask of UP field. */
-#define COMP_INTENCLR_UP_Disabled (0UL) /*!< Read: Disabled */
-#define COMP_INTENCLR_UP_Enabled (1UL) /*!< Read: Enabled */
-#define COMP_INTENCLR_UP_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for DOWN event */
-#define COMP_INTENCLR_DOWN_Pos (1UL) /*!< Position of DOWN field. */
-#define COMP_INTENCLR_DOWN_Msk (0x1UL << COMP_INTENCLR_DOWN_Pos) /*!< Bit mask of DOWN field. */
-#define COMP_INTENCLR_DOWN_Disabled (0UL) /*!< Read: Disabled */
-#define COMP_INTENCLR_DOWN_Enabled (1UL) /*!< Read: Enabled */
-#define COMP_INTENCLR_DOWN_Clear (1UL) /*!< Disable */
-
-/* Bit 0 : Write '1' to Disable interrupt for READY event */
-#define COMP_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
-#define COMP_INTENCLR_READY_Msk (0x1UL << COMP_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
-#define COMP_INTENCLR_READY_Disabled (0UL) /*!< Read: Disabled */
-#define COMP_INTENCLR_READY_Enabled (1UL) /*!< Read: Enabled */
-#define COMP_INTENCLR_READY_Clear (1UL) /*!< Disable */
-
-/* Register: COMP_RESULT */
-/* Description: Compare result */
-
-/* Bit 0 : Result of last compare. Decision point SAMPLE task. */
-#define COMP_RESULT_RESULT_Pos (0UL) /*!< Position of RESULT field. */
-#define COMP_RESULT_RESULT_Msk (0x1UL << COMP_RESULT_RESULT_Pos) /*!< Bit mask of RESULT field. */
-#define COMP_RESULT_RESULT_Below (0UL) /*!< Input voltage is below the threshold (VIN+ &lt; VIN-) */
-#define COMP_RESULT_RESULT_Above (1UL) /*!< Input voltage is above the threshold (VIN+ &gt; VIN-) */
-
-/* Register: COMP_ENABLE */
-/* Description: COMP enable */
-
-/* Bits 1..0 : Enable or disable COMP */
-#define COMP_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
-#define COMP_ENABLE_ENABLE_Msk (0x3UL << COMP_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
-#define COMP_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
-#define COMP_ENABLE_ENABLE_Enabled (2UL) /*!< Enable */
-
-/* Register: COMP_PSEL */
-/* Description: Pin select */
-
-/* Bits 2..0 : Analog pin select */
-#define COMP_PSEL_PSEL_Pos (0UL) /*!< Position of PSEL field. */
-#define COMP_PSEL_PSEL_Msk (0x7UL << COMP_PSEL_PSEL_Pos) /*!< Bit mask of PSEL field. */
-#define COMP_PSEL_PSEL_AnalogInput0 (0UL) /*!< AIN0 selected as analog input */
-#define COMP_PSEL_PSEL_AnalogInput1 (1UL) /*!< AIN1 selected as analog input */
-#define COMP_PSEL_PSEL_AnalogInput2 (2UL) /*!< AIN2 selected as analog input */
-#define COMP_PSEL_PSEL_AnalogInput3 (3UL) /*!< AIN3 selected as analog input */
-#define COMP_PSEL_PSEL_AnalogInput4 (4UL) /*!< AIN4 selected as analog input */
-#define COMP_PSEL_PSEL_AnalogInput5 (5UL) /*!< AIN5 selected as analog input */
-#define COMP_PSEL_PSEL_AnalogInput6 (6UL) /*!< AIN6 selected as analog input */
-#define COMP_PSEL_PSEL_AnalogInput7 (7UL) /*!< AIN7 selected as analog input */
-
-/* Register: COMP_REFSEL */
-/* Description: Reference source select */
-
-/* Bits 2..0 : Reference select */
-#define COMP_REFSEL_REFSEL_Pos (0UL) /*!< Position of REFSEL field. */
-#define COMP_REFSEL_REFSEL_Msk (0x7UL << COMP_REFSEL_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
-#define COMP_REFSEL_REFSEL_Int1V2 (0UL) /*!< VREF = internal 1.2 V reference (VDD &gt;= 1.7 V) */
-#define COMP_REFSEL_REFSEL_Int1V8 (1UL) /*!< VREF = internal 1.8 V reference (VDD &gt;= VREF + 0.2 V) */
-#define COMP_REFSEL_REFSEL_Int2V4 (2UL) /*!< VREF = internal 2.4 V reference (VDD &gt;= VREF + 0.2 V) */
-#define COMP_REFSEL_REFSEL_VDD (4UL) /*!< VREF = VDD */
-#define COMP_REFSEL_REFSEL_ARef (7UL) /*!< VREF = AREF (VDD &gt;= VREF &gt;= AREFMIN) */
-
-/* Register: COMP_EXTREFSEL */
-/* Description: External reference select */
-
-/* Bit 0 : External analog reference select */
-#define COMP_EXTREFSEL_EXTREFSEL_Pos (0UL) /*!< Position of EXTREFSEL field. */
-#define COMP_EXTREFSEL_EXTREFSEL_Msk (0x1UL << COMP_EXTREFSEL_EXTREFSEL_Pos) /*!< Bit mask of EXTREFSEL field. */
-#define COMP_EXTREFSEL_EXTREFSEL_AnalogReference0 (0UL) /*!< Use AIN0 as external analog reference */
-#define COMP_EXTREFSEL_EXTREFSEL_AnalogReference1 (1UL) /*!< Use AIN1 as external analog reference */
-
-/* Register: COMP_TH */
-/* Description: Threshold configuration for hysteresis unit */
-
-/* Bits 13..8 : VUP = (THUP+1)/64*VREF */
-#define COMP_TH_THUP_Pos (8UL) /*!< Position of THUP field. */
-#define COMP_TH_THUP_Msk (0x3FUL << COMP_TH_THUP_Pos) /*!< Bit mask of THUP field. */
-
-/* Bits 5..0 : VDOWN = (THDOWN+1)/64*VREF */
-#define COMP_TH_THDOWN_Pos (0UL) /*!< Position of THDOWN field. */
-#define COMP_TH_THDOWN_Msk (0x3FUL << COMP_TH_THDOWN_Pos) /*!< Bit mask of THDOWN field. */
-
-/* Register: COMP_MODE */
-/* Description: Mode configuration */
-
-/* Bit 8 : Main operation mode */
-#define COMP_MODE_MAIN_Pos (8UL) /*!< Position of MAIN field. */
-#define COMP_MODE_MAIN_Msk (0x1UL << COMP_MODE_MAIN_Pos) /*!< Bit mask of MAIN field. */
-#define COMP_MODE_MAIN_SE (0UL) /*!< Single ended mode */
-#define COMP_MODE_MAIN_Diff (1UL) /*!< Differential mode */
-
-/* Bits 1..0 : Speed and power mode */
-#define COMP_MODE_SP_Pos (0UL) /*!< Position of SP field. */
-#define COMP_MODE_SP_Msk (0x3UL << COMP_MODE_SP_Pos) /*!< Bit mask of SP field. */
-#define COMP_MODE_SP_Low (0UL) /*!< Low power mode */
-#define COMP_MODE_SP_Normal (1UL) /*!< Normal mode */
-#define COMP_MODE_SP_High (2UL) /*!< High speed mode */
-
-/* Register: COMP_HYST */
-/* Description: Comparator hysteresis enable */
-
-/* Bit 0 : Comparator hysteresis */
-#define COMP_HYST_HYST_Pos (0UL) /*!< Position of HYST field. */
-#define COMP_HYST_HYST_Msk (0x1UL << COMP_HYST_HYST_Pos) /*!< Bit mask of HYST field. */
-#define COMP_HYST_HYST_NoHyst (0UL) /*!< Comparator hysteresis disabled */
-#define COMP_HYST_HYST_Hyst50mV (1UL) /*!< Comparator hysteresis enabled */
-
-/* Register: COMP_ISOURCE */
-/* Description: Current source select on analog input */
-
-/* Bits 1..0 : Comparator hysteresis */
-#define COMP_ISOURCE_ISOURCE_Pos (0UL) /*!< Position of ISOURCE field. */
-#define COMP_ISOURCE_ISOURCE_Msk (0x3UL << COMP_ISOURCE_ISOURCE_Pos) /*!< Bit mask of ISOURCE field. */
-#define COMP_ISOURCE_ISOURCE_Off (0UL) /*!< Current source disabled */
-#define COMP_ISOURCE_ISOURCE_Ien2mA5 (1UL) /*!< Current source enabled (+/- 2.5 uA) */
-#define COMP_ISOURCE_ISOURCE_Ien5mA (2UL) /*!< Current source enabled (+/- 5 uA) */
-#define COMP_ISOURCE_ISOURCE_Ien10mA (3UL) /*!< Current source enabled (+/- 10 uA) */
-
-
-/* Peripheral: ECB */
-/* Description: AES ECB Mode Encryption */
-
-/* Register: ECB_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 1 : Write '1' to Enable interrupt for ERRORECB event */
-#define ECB_INTENSET_ERRORECB_Pos (1UL) /*!< Position of ERRORECB field. */
-#define ECB_INTENSET_ERRORECB_Msk (0x1UL << ECB_INTENSET_ERRORECB_Pos) /*!< Bit mask of ERRORECB field. */
-#define ECB_INTENSET_ERRORECB_Disabled (0UL) /*!< Read: Disabled */
-#define ECB_INTENSET_ERRORECB_Enabled (1UL) /*!< Read: Enabled */
-#define ECB_INTENSET_ERRORECB_Set (1UL) /*!< Enable */
-
-/* Bit 0 : Write '1' to Enable interrupt for ENDECB event */
-#define ECB_INTENSET_ENDECB_Pos (0UL) /*!< Position of ENDECB field. */
-#define ECB_INTENSET_ENDECB_Msk (0x1UL << ECB_INTENSET_ENDECB_Pos) /*!< Bit mask of ENDECB field. */
-#define ECB_INTENSET_ENDECB_Disabled (0UL) /*!< Read: Disabled */
-#define ECB_INTENSET_ENDECB_Enabled (1UL) /*!< Read: Enabled */
-#define ECB_INTENSET_ENDECB_Set (1UL) /*!< Enable */
-
-/* Register: ECB_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 1 : Write '1' to Disable interrupt for ERRORECB event */
-#define ECB_INTENCLR_ERRORECB_Pos (1UL) /*!< Position of ERRORECB field. */
-#define ECB_INTENCLR_ERRORECB_Msk (0x1UL << ECB_INTENCLR_ERRORECB_Pos) /*!< Bit mask of ERRORECB field. */
-#define ECB_INTENCLR_ERRORECB_Disabled (0UL) /*!< Read: Disabled */
-#define ECB_INTENCLR_ERRORECB_Enabled (1UL) /*!< Read: Enabled */
-#define ECB_INTENCLR_ERRORECB_Clear (1UL) /*!< Disable */
-
-/* Bit 0 : Write '1' to Disable interrupt for ENDECB event */
-#define ECB_INTENCLR_ENDECB_Pos (0UL) /*!< Position of ENDECB field. */
-#define ECB_INTENCLR_ENDECB_Msk (0x1UL << ECB_INTENCLR_ENDECB_Pos) /*!< Bit mask of ENDECB field. */
-#define ECB_INTENCLR_ENDECB_Disabled (0UL) /*!< Read: Disabled */
-#define ECB_INTENCLR_ENDECB_Enabled (1UL) /*!< Read: Enabled */
-#define ECB_INTENCLR_ENDECB_Clear (1UL) /*!< Disable */
-
-/* Register: ECB_ECBDATAPTR */
-/* Description: ECB block encrypt memory pointers */
-
-/* Bits 31..0 : Pointer to the ECB data structure (see Table 1 ECB data structure overview) */
-#define ECB_ECBDATAPTR_ECBDATAPTR_Pos (0UL) /*!< Position of ECBDATAPTR field. */
-#define ECB_ECBDATAPTR_ECBDATAPTR_Msk (0xFFFFFFFFUL << ECB_ECBDATAPTR_ECBDATAPTR_Pos) /*!< Bit mask of ECBDATAPTR field. */
-
-
-/* Peripheral: EGU */
-/* Description: Event Generator Unit 0 */
-
-/* Register: EGU_INTEN */
-/* Description: Enable or disable interrupt */
-
-/* Bit 15 : Enable or disable interrupt for TRIGGERED[15] event */
-#define EGU_INTEN_TRIGGERED15_Pos (15UL) /*!< Position of TRIGGERED15 field. */
-#define EGU_INTEN_TRIGGERED15_Msk (0x1UL << EGU_INTEN_TRIGGERED15_Pos) /*!< Bit mask of TRIGGERED15 field. */
-#define EGU_INTEN_TRIGGERED15_Disabled (0UL) /*!< Disable */
-#define EGU_INTEN_TRIGGERED15_Enabled (1UL) /*!< Enable */
-
-/* Bit 14 : Enable or disable interrupt for TRIGGERED[14] event */
-#define EGU_INTEN_TRIGGERED14_Pos (14UL) /*!< Position of TRIGGERED14 field. */
-#define EGU_INTEN_TRIGGERED14_Msk (0x1UL << EGU_INTEN_TRIGGERED14_Pos) /*!< Bit mask of TRIGGERED14 field. */
-#define EGU_INTEN_TRIGGERED14_Disabled (0UL) /*!< Disable */
-#define EGU_INTEN_TRIGGERED14_Enabled (1UL) /*!< Enable */
-
-/* Bit 13 : Enable or disable interrupt for TRIGGERED[13] event */
-#define EGU_INTEN_TRIGGERED13_Pos (13UL) /*!< Position of TRIGGERED13 field. */
-#define EGU_INTEN_TRIGGERED13_Msk (0x1UL << EGU_INTEN_TRIGGERED13_Pos) /*!< Bit mask of TRIGGERED13 field. */
-#define EGU_INTEN_TRIGGERED13_Disabled (0UL) /*!< Disable */
-#define EGU_INTEN_TRIGGERED13_Enabled (1UL) /*!< Enable */
-
-/* Bit 12 : Enable or disable interrupt for TRIGGERED[12] event */
-#define EGU_INTEN_TRIGGERED12_Pos (12UL) /*!< Position of TRIGGERED12 field. */
-#define EGU_INTEN_TRIGGERED12_Msk (0x1UL << EGU_INTEN_TRIGGERED12_Pos) /*!< Bit mask of TRIGGERED12 field. */
-#define EGU_INTEN_TRIGGERED12_Disabled (0UL) /*!< Disable */
-#define EGU_INTEN_TRIGGERED12_Enabled (1UL) /*!< Enable */
-
-/* Bit 11 : Enable or disable interrupt for TRIGGERED[11] event */
-#define EGU_INTEN_TRIGGERED11_Pos (11UL) /*!< Position of TRIGGERED11 field. */
-#define EGU_INTEN_TRIGGERED11_Msk (0x1UL << EGU_INTEN_TRIGGERED11_Pos) /*!< Bit mask of TRIGGERED11 field. */
-#define EGU_INTEN_TRIGGERED11_Disabled (0UL) /*!< Disable */
-#define EGU_INTEN_TRIGGERED11_Enabled (1UL) /*!< Enable */
-
-/* Bit 10 : Enable or disable interrupt for TRIGGERED[10] event */
-#define EGU_INTEN_TRIGGERED10_Pos (10UL) /*!< Position of TRIGGERED10 field. */
-#define EGU_INTEN_TRIGGERED10_Msk (0x1UL << EGU_INTEN_TRIGGERED10_Pos) /*!< Bit mask of TRIGGERED10 field. */
-#define EGU_INTEN_TRIGGERED10_Disabled (0UL) /*!< Disable */
-#define EGU_INTEN_TRIGGERED10_Enabled (1UL) /*!< Enable */
-
-/* Bit 9 : Enable or disable interrupt for TRIGGERED[9] event */
-#define EGU_INTEN_TRIGGERED9_Pos (9UL) /*!< Position of TRIGGERED9 field. */
-#define EGU_INTEN_TRIGGERED9_Msk (0x1UL << EGU_INTEN_TRIGGERED9_Pos) /*!< Bit mask of TRIGGERED9 field. */
-#define EGU_INTEN_TRIGGERED9_Disabled (0UL) /*!< Disable */
-#define EGU_INTEN_TRIGGERED9_Enabled (1UL) /*!< Enable */
-
-/* Bit 8 : Enable or disable interrupt for TRIGGERED[8] event */
-#define EGU_INTEN_TRIGGERED8_Pos (8UL) /*!< Position of TRIGGERED8 field. */
-#define EGU_INTEN_TRIGGERED8_Msk (0x1UL << EGU_INTEN_TRIGGERED8_Pos) /*!< Bit mask of TRIGGERED8 field. */
-#define EGU_INTEN_TRIGGERED8_Disabled (0UL) /*!< Disable */
-#define EGU_INTEN_TRIGGERED8_Enabled (1UL) /*!< Enable */
-
-/* Bit 7 : Enable or disable interrupt for TRIGGERED[7] event */
-#define EGU_INTEN_TRIGGERED7_Pos (7UL) /*!< Position of TRIGGERED7 field. */
-#define EGU_INTEN_TRIGGERED7_Msk (0x1UL << EGU_INTEN_TRIGGERED7_Pos) /*!< Bit mask of TRIGGERED7 field. */
-#define EGU_INTEN_TRIGGERED7_Disabled (0UL) /*!< Disable */
-#define EGU_INTEN_TRIGGERED7_Enabled (1UL) /*!< Enable */
-
-/* Bit 6 : Enable or disable interrupt for TRIGGERED[6] event */
-#define EGU_INTEN_TRIGGERED6_Pos (6UL) /*!< Position of TRIGGERED6 field. */
-#define EGU_INTEN_TRIGGERED6_Msk (0x1UL << EGU_INTEN_TRIGGERED6_Pos) /*!< Bit mask of TRIGGERED6 field. */
-#define EGU_INTEN_TRIGGERED6_Disabled (0UL) /*!< Disable */
-#define EGU_INTEN_TRIGGERED6_Enabled (1UL) /*!< Enable */
-
-/* Bit 5 : Enable or disable interrupt for TRIGGERED[5] event */
-#define EGU_INTEN_TRIGGERED5_Pos (5UL) /*!< Position of TRIGGERED5 field. */
-#define EGU_INTEN_TRIGGERED5_Msk (0x1UL << EGU_INTEN_TRIGGERED5_Pos) /*!< Bit mask of TRIGGERED5 field. */
-#define EGU_INTEN_TRIGGERED5_Disabled (0UL) /*!< Disable */
-#define EGU_INTEN_TRIGGERED5_Enabled (1UL) /*!< Enable */
-
-/* Bit 4 : Enable or disable interrupt for TRIGGERED[4] event */
-#define EGU_INTEN_TRIGGERED4_Pos (4UL) /*!< Position of TRIGGERED4 field. */
-#define EGU_INTEN_TRIGGERED4_Msk (0x1UL << EGU_INTEN_TRIGGERED4_Pos) /*!< Bit mask of TRIGGERED4 field. */
-#define EGU_INTEN_TRIGGERED4_Disabled (0UL) /*!< Disable */
-#define EGU_INTEN_TRIGGERED4_Enabled (1UL) /*!< Enable */
-
-/* Bit 3 : Enable or disable interrupt for TRIGGERED[3] event */
-#define EGU_INTEN_TRIGGERED3_Pos (3UL) /*!< Position of TRIGGERED3 field. */
-#define EGU_INTEN_TRIGGERED3_Msk (0x1UL << EGU_INTEN_TRIGGERED3_Pos) /*!< Bit mask of TRIGGERED3 field. */
-#define EGU_INTEN_TRIGGERED3_Disabled (0UL) /*!< Disable */
-#define EGU_INTEN_TRIGGERED3_Enabled (1UL) /*!< Enable */
-
-/* Bit 2 : Enable or disable interrupt for TRIGGERED[2] event */
-#define EGU_INTEN_TRIGGERED2_Pos (2UL) /*!< Position of TRIGGERED2 field. */
-#define EGU_INTEN_TRIGGERED2_Msk (0x1UL << EGU_INTEN_TRIGGERED2_Pos) /*!< Bit mask of TRIGGERED2 field. */
-#define EGU_INTEN_TRIGGERED2_Disabled (0UL) /*!< Disable */
-#define EGU_INTEN_TRIGGERED2_Enabled (1UL) /*!< Enable */
-
-/* Bit 1 : Enable or disable interrupt for TRIGGERED[1] event */
-#define EGU_INTEN_TRIGGERED1_Pos (1UL) /*!< Position of TRIGGERED1 field. */
-#define EGU_INTEN_TRIGGERED1_Msk (0x1UL << EGU_INTEN_TRIGGERED1_Pos) /*!< Bit mask of TRIGGERED1 field. */
-#define EGU_INTEN_TRIGGERED1_Disabled (0UL) /*!< Disable */
-#define EGU_INTEN_TRIGGERED1_Enabled (1UL) /*!< Enable */
-
-/* Bit 0 : Enable or disable interrupt for TRIGGERED[0] event */
-#define EGU_INTEN_TRIGGERED0_Pos (0UL) /*!< Position of TRIGGERED0 field. */
-#define EGU_INTEN_TRIGGERED0_Msk (0x1UL << EGU_INTEN_TRIGGERED0_Pos) /*!< Bit mask of TRIGGERED0 field. */
-#define EGU_INTEN_TRIGGERED0_Disabled (0UL) /*!< Disable */
-#define EGU_INTEN_TRIGGERED0_Enabled (1UL) /*!< Enable */
-
-/* Register: EGU_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 15 : Write '1' to Enable interrupt for TRIGGERED[15] event */
-#define EGU_INTENSET_TRIGGERED15_Pos (15UL) /*!< Position of TRIGGERED15 field. */
-#define EGU_INTENSET_TRIGGERED15_Msk (0x1UL << EGU_INTENSET_TRIGGERED15_Pos) /*!< Bit mask of TRIGGERED15 field. */
-#define EGU_INTENSET_TRIGGERED15_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENSET_TRIGGERED15_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENSET_TRIGGERED15_Set (1UL) /*!< Enable */
-
-/* Bit 14 : Write '1' to Enable interrupt for TRIGGERED[14] event */
-#define EGU_INTENSET_TRIGGERED14_Pos (14UL) /*!< Position of TRIGGERED14 field. */
-#define EGU_INTENSET_TRIGGERED14_Msk (0x1UL << EGU_INTENSET_TRIGGERED14_Pos) /*!< Bit mask of TRIGGERED14 field. */
-#define EGU_INTENSET_TRIGGERED14_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENSET_TRIGGERED14_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENSET_TRIGGERED14_Set (1UL) /*!< Enable */
-
-/* Bit 13 : Write '1' to Enable interrupt for TRIGGERED[13] event */
-#define EGU_INTENSET_TRIGGERED13_Pos (13UL) /*!< Position of TRIGGERED13 field. */
-#define EGU_INTENSET_TRIGGERED13_Msk (0x1UL << EGU_INTENSET_TRIGGERED13_Pos) /*!< Bit mask of TRIGGERED13 field. */
-#define EGU_INTENSET_TRIGGERED13_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENSET_TRIGGERED13_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENSET_TRIGGERED13_Set (1UL) /*!< Enable */
-
-/* Bit 12 : Write '1' to Enable interrupt for TRIGGERED[12] event */
-#define EGU_INTENSET_TRIGGERED12_Pos (12UL) /*!< Position of TRIGGERED12 field. */
-#define EGU_INTENSET_TRIGGERED12_Msk (0x1UL << EGU_INTENSET_TRIGGERED12_Pos) /*!< Bit mask of TRIGGERED12 field. */
-#define EGU_INTENSET_TRIGGERED12_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENSET_TRIGGERED12_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENSET_TRIGGERED12_Set (1UL) /*!< Enable */
-
-/* Bit 11 : Write '1' to Enable interrupt for TRIGGERED[11] event */
-#define EGU_INTENSET_TRIGGERED11_Pos (11UL) /*!< Position of TRIGGERED11 field. */
-#define EGU_INTENSET_TRIGGERED11_Msk (0x1UL << EGU_INTENSET_TRIGGERED11_Pos) /*!< Bit mask of TRIGGERED11 field. */
-#define EGU_INTENSET_TRIGGERED11_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENSET_TRIGGERED11_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENSET_TRIGGERED11_Set (1UL) /*!< Enable */
-
-/* Bit 10 : Write '1' to Enable interrupt for TRIGGERED[10] event */
-#define EGU_INTENSET_TRIGGERED10_Pos (10UL) /*!< Position of TRIGGERED10 field. */
-#define EGU_INTENSET_TRIGGERED10_Msk (0x1UL << EGU_INTENSET_TRIGGERED10_Pos) /*!< Bit mask of TRIGGERED10 field. */
-#define EGU_INTENSET_TRIGGERED10_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENSET_TRIGGERED10_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENSET_TRIGGERED10_Set (1UL) /*!< Enable */
-
-/* Bit 9 : Write '1' to Enable interrupt for TRIGGERED[9] event */
-#define EGU_INTENSET_TRIGGERED9_Pos (9UL) /*!< Position of TRIGGERED9 field. */
-#define EGU_INTENSET_TRIGGERED9_Msk (0x1UL << EGU_INTENSET_TRIGGERED9_Pos) /*!< Bit mask of TRIGGERED9 field. */
-#define EGU_INTENSET_TRIGGERED9_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENSET_TRIGGERED9_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENSET_TRIGGERED9_Set (1UL) /*!< Enable */
-
-/* Bit 8 : Write '1' to Enable interrupt for TRIGGERED[8] event */
-#define EGU_INTENSET_TRIGGERED8_Pos (8UL) /*!< Position of TRIGGERED8 field. */
-#define EGU_INTENSET_TRIGGERED8_Msk (0x1UL << EGU_INTENSET_TRIGGERED8_Pos) /*!< Bit mask of TRIGGERED8 field. */
-#define EGU_INTENSET_TRIGGERED8_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENSET_TRIGGERED8_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENSET_TRIGGERED8_Set (1UL) /*!< Enable */
-
-/* Bit 7 : Write '1' to Enable interrupt for TRIGGERED[7] event */
-#define EGU_INTENSET_TRIGGERED7_Pos (7UL) /*!< Position of TRIGGERED7 field. */
-#define EGU_INTENSET_TRIGGERED7_Msk (0x1UL << EGU_INTENSET_TRIGGERED7_Pos) /*!< Bit mask of TRIGGERED7 field. */
-#define EGU_INTENSET_TRIGGERED7_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENSET_TRIGGERED7_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENSET_TRIGGERED7_Set (1UL) /*!< Enable */
-
-/* Bit 6 : Write '1' to Enable interrupt for TRIGGERED[6] event */
-#define EGU_INTENSET_TRIGGERED6_Pos (6UL) /*!< Position of TRIGGERED6 field. */
-#define EGU_INTENSET_TRIGGERED6_Msk (0x1UL << EGU_INTENSET_TRIGGERED6_Pos) /*!< Bit mask of TRIGGERED6 field. */
-#define EGU_INTENSET_TRIGGERED6_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENSET_TRIGGERED6_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENSET_TRIGGERED6_Set (1UL) /*!< Enable */
-
-/* Bit 5 : Write '1' to Enable interrupt for TRIGGERED[5] event */
-#define EGU_INTENSET_TRIGGERED5_Pos (5UL) /*!< Position of TRIGGERED5 field. */
-#define EGU_INTENSET_TRIGGERED5_Msk (0x1UL << EGU_INTENSET_TRIGGERED5_Pos) /*!< Bit mask of TRIGGERED5 field. */
-#define EGU_INTENSET_TRIGGERED5_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENSET_TRIGGERED5_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENSET_TRIGGERED5_Set (1UL) /*!< Enable */
-
-/* Bit 4 : Write '1' to Enable interrupt for TRIGGERED[4] event */
-#define EGU_INTENSET_TRIGGERED4_Pos (4UL) /*!< Position of TRIGGERED4 field. */
-#define EGU_INTENSET_TRIGGERED4_Msk (0x1UL << EGU_INTENSET_TRIGGERED4_Pos) /*!< Bit mask of TRIGGERED4 field. */
-#define EGU_INTENSET_TRIGGERED4_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENSET_TRIGGERED4_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENSET_TRIGGERED4_Set (1UL) /*!< Enable */
-
-/* Bit 3 : Write '1' to Enable interrupt for TRIGGERED[3] event */
-#define EGU_INTENSET_TRIGGERED3_Pos (3UL) /*!< Position of TRIGGERED3 field. */
-#define EGU_INTENSET_TRIGGERED3_Msk (0x1UL << EGU_INTENSET_TRIGGERED3_Pos) /*!< Bit mask of TRIGGERED3 field. */
-#define EGU_INTENSET_TRIGGERED3_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENSET_TRIGGERED3_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENSET_TRIGGERED3_Set (1UL) /*!< Enable */
-
-/* Bit 2 : Write '1' to Enable interrupt for TRIGGERED[2] event */
-#define EGU_INTENSET_TRIGGERED2_Pos (2UL) /*!< Position of TRIGGERED2 field. */
-#define EGU_INTENSET_TRIGGERED2_Msk (0x1UL << EGU_INTENSET_TRIGGERED2_Pos) /*!< Bit mask of TRIGGERED2 field. */
-#define EGU_INTENSET_TRIGGERED2_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENSET_TRIGGERED2_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENSET_TRIGGERED2_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for TRIGGERED[1] event */
-#define EGU_INTENSET_TRIGGERED1_Pos (1UL) /*!< Position of TRIGGERED1 field. */
-#define EGU_INTENSET_TRIGGERED1_Msk (0x1UL << EGU_INTENSET_TRIGGERED1_Pos) /*!< Bit mask of TRIGGERED1 field. */
-#define EGU_INTENSET_TRIGGERED1_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENSET_TRIGGERED1_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENSET_TRIGGERED1_Set (1UL) /*!< Enable */
-
-/* Bit 0 : Write '1' to Enable interrupt for TRIGGERED[0] event */
-#define EGU_INTENSET_TRIGGERED0_Pos (0UL) /*!< Position of TRIGGERED0 field. */
-#define EGU_INTENSET_TRIGGERED0_Msk (0x1UL << EGU_INTENSET_TRIGGERED0_Pos) /*!< Bit mask of TRIGGERED0 field. */
-#define EGU_INTENSET_TRIGGERED0_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENSET_TRIGGERED0_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENSET_TRIGGERED0_Set (1UL) /*!< Enable */
-
-/* Register: EGU_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 15 : Write '1' to Disable interrupt for TRIGGERED[15] event */
-#define EGU_INTENCLR_TRIGGERED15_Pos (15UL) /*!< Position of TRIGGERED15 field. */
-#define EGU_INTENCLR_TRIGGERED15_Msk (0x1UL << EGU_INTENCLR_TRIGGERED15_Pos) /*!< Bit mask of TRIGGERED15 field. */
-#define EGU_INTENCLR_TRIGGERED15_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENCLR_TRIGGERED15_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENCLR_TRIGGERED15_Clear (1UL) /*!< Disable */
-
-/* Bit 14 : Write '1' to Disable interrupt for TRIGGERED[14] event */
-#define EGU_INTENCLR_TRIGGERED14_Pos (14UL) /*!< Position of TRIGGERED14 field. */
-#define EGU_INTENCLR_TRIGGERED14_Msk (0x1UL << EGU_INTENCLR_TRIGGERED14_Pos) /*!< Bit mask of TRIGGERED14 field. */
-#define EGU_INTENCLR_TRIGGERED14_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENCLR_TRIGGERED14_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENCLR_TRIGGERED14_Clear (1UL) /*!< Disable */
-
-/* Bit 13 : Write '1' to Disable interrupt for TRIGGERED[13] event */
-#define EGU_INTENCLR_TRIGGERED13_Pos (13UL) /*!< Position of TRIGGERED13 field. */
-#define EGU_INTENCLR_TRIGGERED13_Msk (0x1UL << EGU_INTENCLR_TRIGGERED13_Pos) /*!< Bit mask of TRIGGERED13 field. */
-#define EGU_INTENCLR_TRIGGERED13_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENCLR_TRIGGERED13_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENCLR_TRIGGERED13_Clear (1UL) /*!< Disable */
-
-/* Bit 12 : Write '1' to Disable interrupt for TRIGGERED[12] event */
-#define EGU_INTENCLR_TRIGGERED12_Pos (12UL) /*!< Position of TRIGGERED12 field. */
-#define EGU_INTENCLR_TRIGGERED12_Msk (0x1UL << EGU_INTENCLR_TRIGGERED12_Pos) /*!< Bit mask of TRIGGERED12 field. */
-#define EGU_INTENCLR_TRIGGERED12_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENCLR_TRIGGERED12_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENCLR_TRIGGERED12_Clear (1UL) /*!< Disable */
-
-/* Bit 11 : Write '1' to Disable interrupt for TRIGGERED[11] event */
-#define EGU_INTENCLR_TRIGGERED11_Pos (11UL) /*!< Position of TRIGGERED11 field. */
-#define EGU_INTENCLR_TRIGGERED11_Msk (0x1UL << EGU_INTENCLR_TRIGGERED11_Pos) /*!< Bit mask of TRIGGERED11 field. */
-#define EGU_INTENCLR_TRIGGERED11_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENCLR_TRIGGERED11_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENCLR_TRIGGERED11_Clear (1UL) /*!< Disable */
-
-/* Bit 10 : Write '1' to Disable interrupt for TRIGGERED[10] event */
-#define EGU_INTENCLR_TRIGGERED10_Pos (10UL) /*!< Position of TRIGGERED10 field. */
-#define EGU_INTENCLR_TRIGGERED10_Msk (0x1UL << EGU_INTENCLR_TRIGGERED10_Pos) /*!< Bit mask of TRIGGERED10 field. */
-#define EGU_INTENCLR_TRIGGERED10_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENCLR_TRIGGERED10_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENCLR_TRIGGERED10_Clear (1UL) /*!< Disable */
-
-/* Bit 9 : Write '1' to Disable interrupt for TRIGGERED[9] event */
-#define EGU_INTENCLR_TRIGGERED9_Pos (9UL) /*!< Position of TRIGGERED9 field. */
-#define EGU_INTENCLR_TRIGGERED9_Msk (0x1UL << EGU_INTENCLR_TRIGGERED9_Pos) /*!< Bit mask of TRIGGERED9 field. */
-#define EGU_INTENCLR_TRIGGERED9_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENCLR_TRIGGERED9_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENCLR_TRIGGERED9_Clear (1UL) /*!< Disable */
-
-/* Bit 8 : Write '1' to Disable interrupt for TRIGGERED[8] event */
-#define EGU_INTENCLR_TRIGGERED8_Pos (8UL) /*!< Position of TRIGGERED8 field. */
-#define EGU_INTENCLR_TRIGGERED8_Msk (0x1UL << EGU_INTENCLR_TRIGGERED8_Pos) /*!< Bit mask of TRIGGERED8 field. */
-#define EGU_INTENCLR_TRIGGERED8_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENCLR_TRIGGERED8_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENCLR_TRIGGERED8_Clear (1UL) /*!< Disable */
-
-/* Bit 7 : Write '1' to Disable interrupt for TRIGGERED[7] event */
-#define EGU_INTENCLR_TRIGGERED7_Pos (7UL) /*!< Position of TRIGGERED7 field. */
-#define EGU_INTENCLR_TRIGGERED7_Msk (0x1UL << EGU_INTENCLR_TRIGGERED7_Pos) /*!< Bit mask of TRIGGERED7 field. */
-#define EGU_INTENCLR_TRIGGERED7_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENCLR_TRIGGERED7_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENCLR_TRIGGERED7_Clear (1UL) /*!< Disable */
-
-/* Bit 6 : Write '1' to Disable interrupt for TRIGGERED[6] event */
-#define EGU_INTENCLR_TRIGGERED6_Pos (6UL) /*!< Position of TRIGGERED6 field. */
-#define EGU_INTENCLR_TRIGGERED6_Msk (0x1UL << EGU_INTENCLR_TRIGGERED6_Pos) /*!< Bit mask of TRIGGERED6 field. */
-#define EGU_INTENCLR_TRIGGERED6_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENCLR_TRIGGERED6_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENCLR_TRIGGERED6_Clear (1UL) /*!< Disable */
-
-/* Bit 5 : Write '1' to Disable interrupt for TRIGGERED[5] event */
-#define EGU_INTENCLR_TRIGGERED5_Pos (5UL) /*!< Position of TRIGGERED5 field. */
-#define EGU_INTENCLR_TRIGGERED5_Msk (0x1UL << EGU_INTENCLR_TRIGGERED5_Pos) /*!< Bit mask of TRIGGERED5 field. */
-#define EGU_INTENCLR_TRIGGERED5_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENCLR_TRIGGERED5_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENCLR_TRIGGERED5_Clear (1UL) /*!< Disable */
-
-/* Bit 4 : Write '1' to Disable interrupt for TRIGGERED[4] event */
-#define EGU_INTENCLR_TRIGGERED4_Pos (4UL) /*!< Position of TRIGGERED4 field. */
-#define EGU_INTENCLR_TRIGGERED4_Msk (0x1UL << EGU_INTENCLR_TRIGGERED4_Pos) /*!< Bit mask of TRIGGERED4 field. */
-#define EGU_INTENCLR_TRIGGERED4_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENCLR_TRIGGERED4_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENCLR_TRIGGERED4_Clear (1UL) /*!< Disable */
-
-/* Bit 3 : Write '1' to Disable interrupt for TRIGGERED[3] event */
-#define EGU_INTENCLR_TRIGGERED3_Pos (3UL) /*!< Position of TRIGGERED3 field. */
-#define EGU_INTENCLR_TRIGGERED3_Msk (0x1UL << EGU_INTENCLR_TRIGGERED3_Pos) /*!< Bit mask of TRIGGERED3 field. */
-#define EGU_INTENCLR_TRIGGERED3_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENCLR_TRIGGERED3_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENCLR_TRIGGERED3_Clear (1UL) /*!< Disable */
-
-/* Bit 2 : Write '1' to Disable interrupt for TRIGGERED[2] event */
-#define EGU_INTENCLR_TRIGGERED2_Pos (2UL) /*!< Position of TRIGGERED2 field. */
-#define EGU_INTENCLR_TRIGGERED2_Msk (0x1UL << EGU_INTENCLR_TRIGGERED2_Pos) /*!< Bit mask of TRIGGERED2 field. */
-#define EGU_INTENCLR_TRIGGERED2_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENCLR_TRIGGERED2_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENCLR_TRIGGERED2_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for TRIGGERED[1] event */
-#define EGU_INTENCLR_TRIGGERED1_Pos (1UL) /*!< Position of TRIGGERED1 field. */
-#define EGU_INTENCLR_TRIGGERED1_Msk (0x1UL << EGU_INTENCLR_TRIGGERED1_Pos) /*!< Bit mask of TRIGGERED1 field. */
-#define EGU_INTENCLR_TRIGGERED1_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENCLR_TRIGGERED1_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENCLR_TRIGGERED1_Clear (1UL) /*!< Disable */
-
-/* Bit 0 : Write '1' to Disable interrupt for TRIGGERED[0] event */
-#define EGU_INTENCLR_TRIGGERED0_Pos (0UL) /*!< Position of TRIGGERED0 field. */
-#define EGU_INTENCLR_TRIGGERED0_Msk (0x1UL << EGU_INTENCLR_TRIGGERED0_Pos) /*!< Bit mask of TRIGGERED0 field. */
-#define EGU_INTENCLR_TRIGGERED0_Disabled (0UL) /*!< Read: Disabled */
-#define EGU_INTENCLR_TRIGGERED0_Enabled (1UL) /*!< Read: Enabled */
-#define EGU_INTENCLR_TRIGGERED0_Clear (1UL) /*!< Disable */
-
-
-/* Peripheral: FICR */
-/* Description: Factory Information Configuration Registers */
-
-/* Register: FICR_CODEPAGESIZE */
-/* Description: Code memory page size */
-
-/* Bits 31..0 : Code memory page size */
-#define FICR_CODEPAGESIZE_CODEPAGESIZE_Pos (0UL) /*!< Position of CODEPAGESIZE field. */
-#define FICR_CODEPAGESIZE_CODEPAGESIZE_Msk (0xFFFFFFFFUL << FICR_CODEPAGESIZE_CODEPAGESIZE_Pos) /*!< Bit mask of CODEPAGESIZE field. */
-
-/* Register: FICR_CODESIZE */
-/* Description: Code memory size */
-
-/* Bits 31..0 : Code memory size in number of pages */
-#define FICR_CODESIZE_CODESIZE_Pos (0UL) /*!< Position of CODESIZE field. */
-#define FICR_CODESIZE_CODESIZE_Msk (0xFFFFFFFFUL << FICR_CODESIZE_CODESIZE_Pos) /*!< Bit mask of CODESIZE field. */
-
-/* Register: FICR_DEVICEID */
-/* Description: Description collection[0]:  Device identifier */
-
-/* Bits 31..0 : 64 bit unique device identifier */
-#define FICR_DEVICEID_DEVICEID_Pos (0UL) /*!< Position of DEVICEID field. */
-#define FICR_DEVICEID_DEVICEID_Msk (0xFFFFFFFFUL << FICR_DEVICEID_DEVICEID_Pos) /*!< Bit mask of DEVICEID field. */
-
-/* Register: FICR_ER */
-/* Description: Description collection[0]:  Encryption Root, word 0 */
-
-/* Bits 31..0 : Encryption Root, word n */
-#define FICR_ER_ER_Pos (0UL) /*!< Position of ER field. */
-#define FICR_ER_ER_Msk (0xFFFFFFFFUL << FICR_ER_ER_Pos) /*!< Bit mask of ER field. */
-
-/* Register: FICR_IR */
-/* Description: Description collection[0]:  Identity Root, word 0 */
-
-/* Bits 31..0 : Identity Root, word n */
-#define FICR_IR_IR_Pos (0UL) /*!< Position of IR field. */
-#define FICR_IR_IR_Msk (0xFFFFFFFFUL << FICR_IR_IR_Pos) /*!< Bit mask of IR field. */
-
-/* Register: FICR_DEVICEADDRTYPE */
-/* Description: Device address type */
-
-/* Bit 0 : Device address type */
-#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Pos (0UL) /*!< Position of DEVICEADDRTYPE field. */
-#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Msk (0x1UL << FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Pos) /*!< Bit mask of DEVICEADDRTYPE field. */
-#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Public (0UL) /*!< Public address */
-#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Random (1UL) /*!< Random address */
-
-/* Register: FICR_DEVICEADDR */
-/* Description: Description collection[0]:  Device address 0 */
-
-/* Bits 31..0 : 48 bit device address */
-#define FICR_DEVICEADDR_DEVICEADDR_Pos (0UL) /*!< Position of DEVICEADDR field. */
-#define FICR_DEVICEADDR_DEVICEADDR_Msk (0xFFFFFFFFUL << FICR_DEVICEADDR_DEVICEADDR_Pos) /*!< Bit mask of DEVICEADDR field. */
-
-/* Register: FICR_INFO_PART */
-/* Description: Part code */
-
-/* Bits 31..0 : Part code */
-#define FICR_INFO_PART_PART_Pos (0UL) /*!< Position of PART field. */
-#define FICR_INFO_PART_PART_Msk (0xFFFFFFFFUL << FICR_INFO_PART_PART_Pos) /*!< Bit mask of PART field. */
-#define FICR_INFO_PART_PART_N52832 (0x52832UL) /*!< nRF52832 */
-#define FICR_INFO_PART_PART_Unspecified (0xFFFFFFFFUL) /*!< Unspecified */
-
-/* Register: FICR_INFO_VARIANT */
-/* Description: Part Variant, Hardware version and Production configuration */
-
-/* Bits 31..0 : Part Variant, Hardware version and Production configuration, encoded as ASCII */
-#define FICR_INFO_VARIANT_VARIANT_Pos (0UL) /*!< Position of VARIANT field. */
-#define FICR_INFO_VARIANT_VARIANT_Msk (0xFFFFFFFFUL << FICR_INFO_VARIANT_VARIANT_Pos) /*!< Bit mask of VARIANT field. */
-#define FICR_INFO_VARIANT_VARIANT_AAAA (0x41414141UL) /*!< AAAA */
-#define FICR_INFO_VARIANT_VARIANT_AAAB (0x41414142UL) /*!< AAAB */
-#define FICR_INFO_VARIANT_VARIANT_AABA (0x41414241UL) /*!< AABA */
-#define FICR_INFO_VARIANT_VARIANT_AABB (0x41414242UL) /*!< AABB */
-#define FICR_INFO_VARIANT_VARIANT_Unspecified (0xFFFFFFFFUL) /*!< Unspecified */
-
-/* Register: FICR_INFO_PACKAGE */
-/* Description: Package option */
-
-/* Bits 31..0 : Package option */
-#define FICR_INFO_PACKAGE_PACKAGE_Pos (0UL) /*!< Position of PACKAGE field. */
-#define FICR_INFO_PACKAGE_PACKAGE_Msk (0xFFFFFFFFUL << FICR_INFO_PACKAGE_PACKAGE_Pos) /*!< Bit mask of PACKAGE field. */
-#define FICR_INFO_PACKAGE_PACKAGE_QF (0x2000UL) /*!< QFxx - 48-pin QFN */
-#define FICR_INFO_PACKAGE_PACKAGE_CH (0x2001UL) /*!< CHxx - 7x8 WLCSP 56 balls */
-#define FICR_INFO_PACKAGE_PACKAGE_CI (0x2002UL) /*!< CIxx - 7x8 WLCSP 56 balls */
-#define FICR_INFO_PACKAGE_PACKAGE_Unspecified (0xFFFFFFFFUL) /*!< Unspecified */
-
-/* Register: FICR_INFO_RAM */
-/* Description: RAM variant */
-
-/* Bits 31..0 : RAM variant */
-#define FICR_INFO_RAM_RAM_Pos (0UL) /*!< Position of RAM field. */
-#define FICR_INFO_RAM_RAM_Msk (0xFFFFFFFFUL << FICR_INFO_RAM_RAM_Pos) /*!< Bit mask of RAM field. */
-#define FICR_INFO_RAM_RAM_K16 (0x10UL) /*!< 16 kByte RAM */
-#define FICR_INFO_RAM_RAM_K32 (0x20UL) /*!< 32 kByte RAM */
-#define FICR_INFO_RAM_RAM_K64 (0x40UL) /*!< 64 kByte RAM */
-#define FICR_INFO_RAM_RAM_Unspecified (0xFFFFFFFFUL) /*!< Unspecified */
-
-/* Register: FICR_INFO_FLASH */
-/* Description: Flash variant */
-
-/* Bits 31..0 : Flash variant */
-#define FICR_INFO_FLASH_FLASH_Pos (0UL) /*!< Position of FLASH field. */
-#define FICR_INFO_FLASH_FLASH_Msk (0xFFFFFFFFUL << FICR_INFO_FLASH_FLASH_Pos) /*!< Bit mask of FLASH field. */
-#define FICR_INFO_FLASH_FLASH_K128 (0x80UL) /*!< 128 kByte FLASH */
-#define FICR_INFO_FLASH_FLASH_K256 (0x100UL) /*!< 256 kByte FLASH */
-#define FICR_INFO_FLASH_FLASH_K512 (0x200UL) /*!< 512 kByte FLASH */
-#define FICR_INFO_FLASH_FLASH_Unspecified (0xFFFFFFFFUL) /*!< Unspecified */
-
-/* Register: FICR_TEMP_A0 */
-/* Description: Slope definition A0. */
-
-/* Bits 11..0 : A (slope definition) register. */
-#define FICR_TEMP_A0_A_Pos (0UL) /*!< Position of A field. */
-#define FICR_TEMP_A0_A_Msk (0xFFFUL << FICR_TEMP_A0_A_Pos) /*!< Bit mask of A field. */
-
-/* Register: FICR_TEMP_A1 */
-/* Description: Slope definition A1. */
-
-/* Bits 11..0 : A (slope definition) register. */
-#define FICR_TEMP_A1_A_Pos (0UL) /*!< Position of A field. */
-#define FICR_TEMP_A1_A_Msk (0xFFFUL << FICR_TEMP_A1_A_Pos) /*!< Bit mask of A field. */
-
-/* Register: FICR_TEMP_A2 */
-/* Description: Slope definition A2. */
-
-/* Bits 11..0 : A (slope definition) register. */
-#define FICR_TEMP_A2_A_Pos (0UL) /*!< Position of A field. */
-#define FICR_TEMP_A2_A_Msk (0xFFFUL << FICR_TEMP_A2_A_Pos) /*!< Bit mask of A field. */
-
-/* Register: FICR_TEMP_A3 */
-/* Description: Slope definition A3. */
-
-/* Bits 11..0 : A (slope definition) register. */
-#define FICR_TEMP_A3_A_Pos (0UL) /*!< Position of A field. */
-#define FICR_TEMP_A3_A_Msk (0xFFFUL << FICR_TEMP_A3_A_Pos) /*!< Bit mask of A field. */
-
-/* Register: FICR_TEMP_A4 */
-/* Description: Slope definition A4. */
-
-/* Bits 11..0 : A (slope definition) register. */
-#define FICR_TEMP_A4_A_Pos (0UL) /*!< Position of A field. */
-#define FICR_TEMP_A4_A_Msk (0xFFFUL << FICR_TEMP_A4_A_Pos) /*!< Bit mask of A field. */
-
-/* Register: FICR_TEMP_A5 */
-/* Description: Slope definition A5. */
-
-/* Bits 11..0 : A (slope definition) register. */
-#define FICR_TEMP_A5_A_Pos (0UL) /*!< Position of A field. */
-#define FICR_TEMP_A5_A_Msk (0xFFFUL << FICR_TEMP_A5_A_Pos) /*!< Bit mask of A field. */
-
-/* Register: FICR_TEMP_B0 */
-/* Description: y-intercept B0. */
-
-/* Bits 13..0 : B (y-intercept) */
-#define FICR_TEMP_B0_B_Pos (0UL) /*!< Position of B field. */
-#define FICR_TEMP_B0_B_Msk (0x3FFFUL << FICR_TEMP_B0_B_Pos) /*!< Bit mask of B field. */
-
-/* Register: FICR_TEMP_B1 */
-/* Description: y-intercept B1. */
-
-/* Bits 13..0 : B (y-intercept) */
-#define FICR_TEMP_B1_B_Pos (0UL) /*!< Position of B field. */
-#define FICR_TEMP_B1_B_Msk (0x3FFFUL << FICR_TEMP_B1_B_Pos) /*!< Bit mask of B field. */
-
-/* Register: FICR_TEMP_B2 */
-/* Description: y-intercept B2. */
-
-/* Bits 13..0 : B (y-intercept) */
-#define FICR_TEMP_B2_B_Pos (0UL) /*!< Position of B field. */
-#define FICR_TEMP_B2_B_Msk (0x3FFFUL << FICR_TEMP_B2_B_Pos) /*!< Bit mask of B field. */
-
-/* Register: FICR_TEMP_B3 */
-/* Description: y-intercept B3. */
-
-/* Bits 13..0 : B (y-intercept) */
-#define FICR_TEMP_B3_B_Pos (0UL) /*!< Position of B field. */
-#define FICR_TEMP_B3_B_Msk (0x3FFFUL << FICR_TEMP_B3_B_Pos) /*!< Bit mask of B field. */
-
-/* Register: FICR_TEMP_B4 */
-/* Description: y-intercept B4. */
-
-/* Bits 13..0 : B (y-intercept) */
-#define FICR_TEMP_B4_B_Pos (0UL) /*!< Position of B field. */
-#define FICR_TEMP_B4_B_Msk (0x3FFFUL << FICR_TEMP_B4_B_Pos) /*!< Bit mask of B field. */
-
-/* Register: FICR_TEMP_B5 */
-/* Description: y-intercept B5. */
-
-/* Bits 13..0 : B (y-intercept) */
-#define FICR_TEMP_B5_B_Pos (0UL) /*!< Position of B field. */
-#define FICR_TEMP_B5_B_Msk (0x3FFFUL << FICR_TEMP_B5_B_Pos) /*!< Bit mask of B field. */
-
-/* Register: FICR_TEMP_T0 */
-/* Description: Segment end T0. */
-
-/* Bits 7..0 : T (segment end)register. */
-#define FICR_TEMP_T0_T_Pos (0UL) /*!< Position of T field. */
-#define FICR_TEMP_T0_T_Msk (0xFFUL << FICR_TEMP_T0_T_Pos) /*!< Bit mask of T field. */
-
-/* Register: FICR_TEMP_T1 */
-/* Description: Segment end T1. */
-
-/* Bits 7..0 : T (segment end)register. */
-#define FICR_TEMP_T1_T_Pos (0UL) /*!< Position of T field. */
-#define FICR_TEMP_T1_T_Msk (0xFFUL << FICR_TEMP_T1_T_Pos) /*!< Bit mask of T field. */
-
-/* Register: FICR_TEMP_T2 */
-/* Description: Segment end T2. */
-
-/* Bits 7..0 : T (segment end)register. */
-#define FICR_TEMP_T2_T_Pos (0UL) /*!< Position of T field. */
-#define FICR_TEMP_T2_T_Msk (0xFFUL << FICR_TEMP_T2_T_Pos) /*!< Bit mask of T field. */
-
-/* Register: FICR_TEMP_T3 */
-/* Description: Segment end T3. */
-
-/* Bits 7..0 : T (segment end)register. */
-#define FICR_TEMP_T3_T_Pos (0UL) /*!< Position of T field. */
-#define FICR_TEMP_T3_T_Msk (0xFFUL << FICR_TEMP_T3_T_Pos) /*!< Bit mask of T field. */
-
-/* Register: FICR_TEMP_T4 */
-/* Description: Segment end T4. */
-
-/* Bits 7..0 : T (segment end)register. */
-#define FICR_TEMP_T4_T_Pos (0UL) /*!< Position of T field. */
-#define FICR_TEMP_T4_T_Msk (0xFFUL << FICR_TEMP_T4_T_Pos) /*!< Bit mask of T field. */
-
-/* Register: FICR_NFC_TAGHEADER0 */
-/* Description: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST. */
-
-/* Bits 31..24 : Unique identifier byte 3 */
-#define FICR_NFC_TAGHEADER0_UD3_Pos (24UL) /*!< Position of UD3 field. */
-#define FICR_NFC_TAGHEADER0_UD3_Msk (0xFFUL << FICR_NFC_TAGHEADER0_UD3_Pos) /*!< Bit mask of UD3 field. */
-
-/* Bits 23..16 : Unique identifier byte 2 */
-#define FICR_NFC_TAGHEADER0_UD2_Pos (16UL) /*!< Position of UD2 field. */
-#define FICR_NFC_TAGHEADER0_UD2_Msk (0xFFUL << FICR_NFC_TAGHEADER0_UD2_Pos) /*!< Bit mask of UD2 field. */
-
-/* Bits 15..8 : Unique identifier byte 1 */
-#define FICR_NFC_TAGHEADER0_UD1_Pos (8UL) /*!< Position of UD1 field. */
-#define FICR_NFC_TAGHEADER0_UD1_Msk (0xFFUL << FICR_NFC_TAGHEADER0_UD1_Pos) /*!< Bit mask of UD1 field. */
-
-/* Bits 7..0 : Default Manufacturer ID: Nordic Semiconductor ASA has ICM 0x5F */
-#define FICR_NFC_TAGHEADER0_MFGID_Pos (0UL) /*!< Position of MFGID field. */
-#define FICR_NFC_TAGHEADER0_MFGID_Msk (0xFFUL << FICR_NFC_TAGHEADER0_MFGID_Pos) /*!< Bit mask of MFGID field. */
-
-/* Register: FICR_NFC_TAGHEADER1 */
-/* Description: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST. */
-
-/* Bits 31..24 : Unique identifier byte 7 */
-#define FICR_NFC_TAGHEADER1_UD7_Pos (24UL) /*!< Position of UD7 field. */
-#define FICR_NFC_TAGHEADER1_UD7_Msk (0xFFUL << FICR_NFC_TAGHEADER1_UD7_Pos) /*!< Bit mask of UD7 field. */
-
-/* Bits 23..16 : Unique identifier byte 6 */
-#define FICR_NFC_TAGHEADER1_UD6_Pos (16UL) /*!< Position of UD6 field. */
-#define FICR_NFC_TAGHEADER1_UD6_Msk (0xFFUL << FICR_NFC_TAGHEADER1_UD6_Pos) /*!< Bit mask of UD6 field. */
-
-/* Bits 15..8 : Unique identifier byte 5 */
-#define FICR_NFC_TAGHEADER1_UD5_Pos (8UL) /*!< Position of UD5 field. */
-#define FICR_NFC_TAGHEADER1_UD5_Msk (0xFFUL << FICR_NFC_TAGHEADER1_UD5_Pos) /*!< Bit mask of UD5 field. */
-
-/* Bits 7..0 : Unique identifier byte 4 */
-#define FICR_NFC_TAGHEADER1_UD4_Pos (0UL) /*!< Position of UD4 field. */
-#define FICR_NFC_TAGHEADER1_UD4_Msk (0xFFUL << FICR_NFC_TAGHEADER1_UD4_Pos) /*!< Bit mask of UD4 field. */
-
-/* Register: FICR_NFC_TAGHEADER2 */
-/* Description: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST. */
-
-/* Bits 31..24 : Unique identifier byte 11 */
-#define FICR_NFC_TAGHEADER2_UD11_Pos (24UL) /*!< Position of UD11 field. */
-#define FICR_NFC_TAGHEADER2_UD11_Msk (0xFFUL << FICR_NFC_TAGHEADER2_UD11_Pos) /*!< Bit mask of UD11 field. */
-
-/* Bits 23..16 : Unique identifier byte 10 */
-#define FICR_NFC_TAGHEADER2_UD10_Pos (16UL) /*!< Position of UD10 field. */
-#define FICR_NFC_TAGHEADER2_UD10_Msk (0xFFUL << FICR_NFC_TAGHEADER2_UD10_Pos) /*!< Bit mask of UD10 field. */
-
-/* Bits 15..8 : Unique identifier byte 9 */
-#define FICR_NFC_TAGHEADER2_UD9_Pos (8UL) /*!< Position of UD9 field. */
-#define FICR_NFC_TAGHEADER2_UD9_Msk (0xFFUL << FICR_NFC_TAGHEADER2_UD9_Pos) /*!< Bit mask of UD9 field. */
-
-/* Bits 7..0 : Unique identifier byte 8 */
-#define FICR_NFC_TAGHEADER2_UD8_Pos (0UL) /*!< Position of UD8 field. */
-#define FICR_NFC_TAGHEADER2_UD8_Msk (0xFFUL << FICR_NFC_TAGHEADER2_UD8_Pos) /*!< Bit mask of UD8 field. */
-
-/* Register: FICR_NFC_TAGHEADER3 */
-/* Description: Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST. */
-
-/* Bits 31..24 : Unique identifier byte 15 */
-#define FICR_NFC_TAGHEADER3_UD15_Pos (24UL) /*!< Position of UD15 field. */
-#define FICR_NFC_TAGHEADER3_UD15_Msk (0xFFUL << FICR_NFC_TAGHEADER3_UD15_Pos) /*!< Bit mask of UD15 field. */
-
-/* Bits 23..16 : Unique identifier byte 14 */
-#define FICR_NFC_TAGHEADER3_UD14_Pos (16UL) /*!< Position of UD14 field. */
-#define FICR_NFC_TAGHEADER3_UD14_Msk (0xFFUL << FICR_NFC_TAGHEADER3_UD14_Pos) /*!< Bit mask of UD14 field. */
-
-/* Bits 15..8 : Unique identifier byte 13 */
-#define FICR_NFC_TAGHEADER3_UD13_Pos (8UL) /*!< Position of UD13 field. */
-#define FICR_NFC_TAGHEADER3_UD13_Msk (0xFFUL << FICR_NFC_TAGHEADER3_UD13_Pos) /*!< Bit mask of UD13 field. */
-
-/* Bits 7..0 : Unique identifier byte 12 */
-#define FICR_NFC_TAGHEADER3_UD12_Pos (0UL) /*!< Position of UD12 field. */
-#define FICR_NFC_TAGHEADER3_UD12_Msk (0xFFUL << FICR_NFC_TAGHEADER3_UD12_Pos) /*!< Bit mask of UD12 field. */
-
-
-/* Peripheral: GPIOTE */
-/* Description: GPIO Tasks and Events */
-
-/* Register: GPIOTE_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 31 : Write '1' to Enable interrupt for PORT event */
-#define GPIOTE_INTENSET_PORT_Pos (31UL) /*!< Position of PORT field. */
-#define GPIOTE_INTENSET_PORT_Msk (0x1UL << GPIOTE_INTENSET_PORT_Pos) /*!< Bit mask of PORT field. */
-#define GPIOTE_INTENSET_PORT_Disabled (0UL) /*!< Read: Disabled */
-#define GPIOTE_INTENSET_PORT_Enabled (1UL) /*!< Read: Enabled */
-#define GPIOTE_INTENSET_PORT_Set (1UL) /*!< Enable */
-
-/* Bit 7 : Write '1' to Enable interrupt for IN[7] event */
-#define GPIOTE_INTENSET_IN7_Pos (7UL) /*!< Position of IN7 field. */
-#define GPIOTE_INTENSET_IN7_Msk (0x1UL << GPIOTE_INTENSET_IN7_Pos) /*!< Bit mask of IN7 field. */
-#define GPIOTE_INTENSET_IN7_Disabled (0UL) /*!< Read: Disabled */
-#define GPIOTE_INTENSET_IN7_Enabled (1UL) /*!< Read: Enabled */
-#define GPIOTE_INTENSET_IN7_Set (1UL) /*!< Enable */
-
-/* Bit 6 : Write '1' to Enable interrupt for IN[6] event */
-#define GPIOTE_INTENSET_IN6_Pos (6UL) /*!< Position of IN6 field. */
-#define GPIOTE_INTENSET_IN6_Msk (0x1UL << GPIOTE_INTENSET_IN6_Pos) /*!< Bit mask of IN6 field. */
-#define GPIOTE_INTENSET_IN6_Disabled (0UL) /*!< Read: Disabled */
-#define GPIOTE_INTENSET_IN6_Enabled (1UL) /*!< Read: Enabled */
-#define GPIOTE_INTENSET_IN6_Set (1UL) /*!< Enable */
-
-/* Bit 5 : Write '1' to Enable interrupt for IN[5] event */
-#define GPIOTE_INTENSET_IN5_Pos (5UL) /*!< Position of IN5 field. */
-#define GPIOTE_INTENSET_IN5_Msk (0x1UL << GPIOTE_INTENSET_IN5_Pos) /*!< Bit mask of IN5 field. */
-#define GPIOTE_INTENSET_IN5_Disabled (0UL) /*!< Read: Disabled */
-#define GPIOTE_INTENSET_IN5_Enabled (1UL) /*!< Read: Enabled */
-#define GPIOTE_INTENSET_IN5_Set (1UL) /*!< Enable */
-
-/* Bit 4 : Write '1' to Enable interrupt for IN[4] event */
-#define GPIOTE_INTENSET_IN4_Pos (4UL) /*!< Position of IN4 field. */
-#define GPIOTE_INTENSET_IN4_Msk (0x1UL << GPIOTE_INTENSET_IN4_Pos) /*!< Bit mask of IN4 field. */
-#define GPIOTE_INTENSET_IN4_Disabled (0UL) /*!< Read: Disabled */
-#define GPIOTE_INTENSET_IN4_Enabled (1UL) /*!< Read: Enabled */
-#define GPIOTE_INTENSET_IN4_Set (1UL) /*!< Enable */
-
-/* Bit 3 : Write '1' to Enable interrupt for IN[3] event */
-#define GPIOTE_INTENSET_IN3_Pos (3UL) /*!< Position of IN3 field. */
-#define GPIOTE_INTENSET_IN3_Msk (0x1UL << GPIOTE_INTENSET_IN3_Pos) /*!< Bit mask of IN3 field. */
-#define GPIOTE_INTENSET_IN3_Disabled (0UL) /*!< Read: Disabled */
-#define GPIOTE_INTENSET_IN3_Enabled (1UL) /*!< Read: Enabled */
-#define GPIOTE_INTENSET_IN3_Set (1UL) /*!< Enable */
-
-/* Bit 2 : Write '1' to Enable interrupt for IN[2] event */
-#define GPIOTE_INTENSET_IN2_Pos (2UL) /*!< Position of IN2 field. */
-#define GPIOTE_INTENSET_IN2_Msk (0x1UL << GPIOTE_INTENSET_IN2_Pos) /*!< Bit mask of IN2 field. */
-#define GPIOTE_INTENSET_IN2_Disabled (0UL) /*!< Read: Disabled */
-#define GPIOTE_INTENSET_IN2_Enabled (1UL) /*!< Read: Enabled */
-#define GPIOTE_INTENSET_IN2_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for IN[1] event */
-#define GPIOTE_INTENSET_IN1_Pos (1UL) /*!< Position of IN1 field. */
-#define GPIOTE_INTENSET_IN1_Msk (0x1UL << GPIOTE_INTENSET_IN1_Pos) /*!< Bit mask of IN1 field. */
-#define GPIOTE_INTENSET_IN1_Disabled (0UL) /*!< Read: Disabled */
-#define GPIOTE_INTENSET_IN1_Enabled (1UL) /*!< Read: Enabled */
-#define GPIOTE_INTENSET_IN1_Set (1UL) /*!< Enable */
-
-/* Bit 0 : Write '1' to Enable interrupt for IN[0] event */
-#define GPIOTE_INTENSET_IN0_Pos (0UL) /*!< Position of IN0 field. */
-#define GPIOTE_INTENSET_IN0_Msk (0x1UL << GPIOTE_INTENSET_IN0_Pos) /*!< Bit mask of IN0 field. */
-#define GPIOTE_INTENSET_IN0_Disabled (0UL) /*!< Read: Disabled */
-#define GPIOTE_INTENSET_IN0_Enabled (1UL) /*!< Read: Enabled */
-#define GPIOTE_INTENSET_IN0_Set (1UL) /*!< Enable */
-
-/* Register: GPIOTE_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 31 : Write '1' to Disable interrupt for PORT event */
-#define GPIOTE_INTENCLR_PORT_Pos (31UL) /*!< Position of PORT field. */
-#define GPIOTE_INTENCLR_PORT_Msk (0x1UL << GPIOTE_INTENCLR_PORT_Pos) /*!< Bit mask of PORT field. */
-#define GPIOTE_INTENCLR_PORT_Disabled (0UL) /*!< Read: Disabled */
-#define GPIOTE_INTENCLR_PORT_Enabled (1UL) /*!< Read: Enabled */
-#define GPIOTE_INTENCLR_PORT_Clear (1UL) /*!< Disable */
-
-/* Bit 7 : Write '1' to Disable interrupt for IN[7] event */
-#define GPIOTE_INTENCLR_IN7_Pos (7UL) /*!< Position of IN7 field. */
-#define GPIOTE_INTENCLR_IN7_Msk (0x1UL << GPIOTE_INTENCLR_IN7_Pos) /*!< Bit mask of IN7 field. */
-#define GPIOTE_INTENCLR_IN7_Disabled (0UL) /*!< Read: Disabled */
-#define GPIOTE_INTENCLR_IN7_Enabled (1UL) /*!< Read: Enabled */
-#define GPIOTE_INTENCLR_IN7_Clear (1UL) /*!< Disable */
-
-/* Bit 6 : Write '1' to Disable interrupt for IN[6] event */
-#define GPIOTE_INTENCLR_IN6_Pos (6UL) /*!< Position of IN6 field. */
-#define GPIOTE_INTENCLR_IN6_Msk (0x1UL << GPIOTE_INTENCLR_IN6_Pos) /*!< Bit mask of IN6 field. */
-#define GPIOTE_INTENCLR_IN6_Disabled (0UL) /*!< Read: Disabled */
-#define GPIOTE_INTENCLR_IN6_Enabled (1UL) /*!< Read: Enabled */
-#define GPIOTE_INTENCLR_IN6_Clear (1UL) /*!< Disable */
-
-/* Bit 5 : Write '1' to Disable interrupt for IN[5] event */
-#define GPIOTE_INTENCLR_IN5_Pos (5UL) /*!< Position of IN5 field. */
-#define GPIOTE_INTENCLR_IN5_Msk (0x1UL << GPIOTE_INTENCLR_IN5_Pos) /*!< Bit mask of IN5 field. */
-#define GPIOTE_INTENCLR_IN5_Disabled (0UL) /*!< Read: Disabled */
-#define GPIOTE_INTENCLR_IN5_Enabled (1UL) /*!< Read: Enabled */
-#define GPIOTE_INTENCLR_IN5_Clear (1UL) /*!< Disable */
-
-/* Bit 4 : Write '1' to Disable interrupt for IN[4] event */
-#define GPIOTE_INTENCLR_IN4_Pos (4UL) /*!< Position of IN4 field. */
-#define GPIOTE_INTENCLR_IN4_Msk (0x1UL << GPIOTE_INTENCLR_IN4_Pos) /*!< Bit mask of IN4 field. */
-#define GPIOTE_INTENCLR_IN4_Disabled (0UL) /*!< Read: Disabled */
-#define GPIOTE_INTENCLR_IN4_Enabled (1UL) /*!< Read: Enabled */
-#define GPIOTE_INTENCLR_IN4_Clear (1UL) /*!< Disable */
-
-/* Bit 3 : Write '1' to Disable interrupt for IN[3] event */
-#define GPIOTE_INTENCLR_IN3_Pos (3UL) /*!< Position of IN3 field. */
-#define GPIOTE_INTENCLR_IN3_Msk (0x1UL << GPIOTE_INTENCLR_IN3_Pos) /*!< Bit mask of IN3 field. */
-#define GPIOTE_INTENCLR_IN3_Disabled (0UL) /*!< Read: Disabled */
-#define GPIOTE_INTENCLR_IN3_Enabled (1UL) /*!< Read: Enabled */
-#define GPIOTE_INTENCLR_IN3_Clear (1UL) /*!< Disable */
-
-/* Bit 2 : Write '1' to Disable interrupt for IN[2] event */
-#define GPIOTE_INTENCLR_IN2_Pos (2UL) /*!< Position of IN2 field. */
-#define GPIOTE_INTENCLR_IN2_Msk (0x1UL << GPIOTE_INTENCLR_IN2_Pos) /*!< Bit mask of IN2 field. */
-#define GPIOTE_INTENCLR_IN2_Disabled (0UL) /*!< Read: Disabled */
-#define GPIOTE_INTENCLR_IN2_Enabled (1UL) /*!< Read: Enabled */
-#define GPIOTE_INTENCLR_IN2_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for IN[1] event */
-#define GPIOTE_INTENCLR_IN1_Pos (1UL) /*!< Position of IN1 field. */
-#define GPIOTE_INTENCLR_IN1_Msk (0x1UL << GPIOTE_INTENCLR_IN1_Pos) /*!< Bit mask of IN1 field. */
-#define GPIOTE_INTENCLR_IN1_Disabled (0UL) /*!< Read: Disabled */
-#define GPIOTE_INTENCLR_IN1_Enabled (1UL) /*!< Read: Enabled */
-#define GPIOTE_INTENCLR_IN1_Clear (1UL) /*!< Disable */
-
-/* Bit 0 : Write '1' to Disable interrupt for IN[0] event */
-#define GPIOTE_INTENCLR_IN0_Pos (0UL) /*!< Position of IN0 field. */
-#define GPIOTE_INTENCLR_IN0_Msk (0x1UL << GPIOTE_INTENCLR_IN0_Pos) /*!< Bit mask of IN0 field. */
-#define GPIOTE_INTENCLR_IN0_Disabled (0UL) /*!< Read: Disabled */
-#define GPIOTE_INTENCLR_IN0_Enabled (1UL) /*!< Read: Enabled */
-#define GPIOTE_INTENCLR_IN0_Clear (1UL) /*!< Disable */
-
-/* Register: GPIOTE_CONFIG */
-/* Description: Description collection[0]:  Configuration for OUT[n], SET[n] and CLR[n] tasks and IN[n] event */
-
-/* Bit 20 : When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect. */
-#define GPIOTE_CONFIG_OUTINIT_Pos (20UL) /*!< Position of OUTINIT field. */
-#define GPIOTE_CONFIG_OUTINIT_Msk (0x1UL << GPIOTE_CONFIG_OUTINIT_Pos) /*!< Bit mask of OUTINIT field. */
-#define GPIOTE_CONFIG_OUTINIT_Low (0UL) /*!< Task mode: Initial value of pin before task triggering is low */
-#define GPIOTE_CONFIG_OUTINIT_High (1UL) /*!< Task mode: Initial value of pin before task triggering is high */
-
-/* Bits 17..16 : When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event. */
-#define GPIOTE_CONFIG_POLARITY_Pos (16UL) /*!< Position of POLARITY field. */
-#define GPIOTE_CONFIG_POLARITY_Msk (0x3UL << GPIOTE_CONFIG_POLARITY_Pos) /*!< Bit mask of POLARITY field. */
-#define GPIOTE_CONFIG_POLARITY_None (0UL) /*!< Task mode: No effect on pin from OUT[n] task. Event mode: no IN[n] event generated on pin activity. */
-#define GPIOTE_CONFIG_POLARITY_LoToHi (1UL) /*!< Task mode: Set pin from OUT[n] task. Event mode: Generate IN[n] event when rising edge on pin. */
-#define GPIOTE_CONFIG_POLARITY_HiToLo (2UL) /*!< Task mode: Clear pin from OUT[n] task. Event mode: Generate IN[n] event when falling edge on pin. */
-#define GPIOTE_CONFIG_POLARITY_Toggle (3UL) /*!< Task mode: Toggle pin from OUT[n]. Event mode: Generate IN[n] when any change on pin. */
-
-/* Bits 12..8 : GPIO number associated with SET[n], CLR[n] and OUT[n] tasks and IN[n] event */
-#define GPIOTE_CONFIG_PSEL_Pos (8UL) /*!< Position of PSEL field. */
-#define GPIOTE_CONFIG_PSEL_Msk (0x1FUL << GPIOTE_CONFIG_PSEL_Pos) /*!< Bit mask of PSEL field. */
-
-/* Bits 1..0 : Mode */
-#define GPIOTE_CONFIG_MODE_Pos (0UL) /*!< Position of MODE field. */
-#define GPIOTE_CONFIG_MODE_Msk (0x3UL << GPIOTE_CONFIG_MODE_Pos) /*!< Bit mask of MODE field. */
-#define GPIOTE_CONFIG_MODE_Disabled (0UL) /*!< Disabled. Pin specified by PSEL will not be acquired by the GPIOTE module. */
-#define GPIOTE_CONFIG_MODE_Event (1UL) /*!< Event mode */
-#define GPIOTE_CONFIG_MODE_Task (3UL) /*!< Task mode */
-
-
-/* Peripheral: I2S */
-/* Description: Inter-IC Sound */
-
-/* Register: I2S_INTEN */
-/* Description: Enable or disable interrupt */
-
-/* Bit 5 : Enable or disable interrupt for TXPTRUPD event */
-#define I2S_INTEN_TXPTRUPD_Pos (5UL) /*!< Position of TXPTRUPD field. */
-#define I2S_INTEN_TXPTRUPD_Msk (0x1UL << I2S_INTEN_TXPTRUPD_Pos) /*!< Bit mask of TXPTRUPD field. */
-#define I2S_INTEN_TXPTRUPD_Disabled (0UL) /*!< Disable */
-#define I2S_INTEN_TXPTRUPD_Enabled (1UL) /*!< Enable */
-
-/* Bit 2 : Enable or disable interrupt for STOPPED event */
-#define I2S_INTEN_STOPPED_Pos (2UL) /*!< Position of STOPPED field. */
-#define I2S_INTEN_STOPPED_Msk (0x1UL << I2S_INTEN_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define I2S_INTEN_STOPPED_Disabled (0UL) /*!< Disable */
-#define I2S_INTEN_STOPPED_Enabled (1UL) /*!< Enable */
-
-/* Bit 1 : Enable or disable interrupt for RXPTRUPD event */
-#define I2S_INTEN_RXPTRUPD_Pos (1UL) /*!< Position of RXPTRUPD field. */
-#define I2S_INTEN_RXPTRUPD_Msk (0x1UL << I2S_INTEN_RXPTRUPD_Pos) /*!< Bit mask of RXPTRUPD field. */
-#define I2S_INTEN_RXPTRUPD_Disabled (0UL) /*!< Disable */
-#define I2S_INTEN_RXPTRUPD_Enabled (1UL) /*!< Enable */
-
-/* Register: I2S_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 5 : Write '1' to Enable interrupt for TXPTRUPD event */
-#define I2S_INTENSET_TXPTRUPD_Pos (5UL) /*!< Position of TXPTRUPD field. */
-#define I2S_INTENSET_TXPTRUPD_Msk (0x1UL << I2S_INTENSET_TXPTRUPD_Pos) /*!< Bit mask of TXPTRUPD field. */
-#define I2S_INTENSET_TXPTRUPD_Disabled (0UL) /*!< Read: Disabled */
-#define I2S_INTENSET_TXPTRUPD_Enabled (1UL) /*!< Read: Enabled */
-#define I2S_INTENSET_TXPTRUPD_Set (1UL) /*!< Enable */
-
-/* Bit 2 : Write '1' to Enable interrupt for STOPPED event */
-#define I2S_INTENSET_STOPPED_Pos (2UL) /*!< Position of STOPPED field. */
-#define I2S_INTENSET_STOPPED_Msk (0x1UL << I2S_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define I2S_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define I2S_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define I2S_INTENSET_STOPPED_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for RXPTRUPD event */
-#define I2S_INTENSET_RXPTRUPD_Pos (1UL) /*!< Position of RXPTRUPD field. */
-#define I2S_INTENSET_RXPTRUPD_Msk (0x1UL << I2S_INTENSET_RXPTRUPD_Pos) /*!< Bit mask of RXPTRUPD field. */
-#define I2S_INTENSET_RXPTRUPD_Disabled (0UL) /*!< Read: Disabled */
-#define I2S_INTENSET_RXPTRUPD_Enabled (1UL) /*!< Read: Enabled */
-#define I2S_INTENSET_RXPTRUPD_Set (1UL) /*!< Enable */
-
-/* Register: I2S_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 5 : Write '1' to Disable interrupt for TXPTRUPD event */
-#define I2S_INTENCLR_TXPTRUPD_Pos (5UL) /*!< Position of TXPTRUPD field. */
-#define I2S_INTENCLR_TXPTRUPD_Msk (0x1UL << I2S_INTENCLR_TXPTRUPD_Pos) /*!< Bit mask of TXPTRUPD field. */
-#define I2S_INTENCLR_TXPTRUPD_Disabled (0UL) /*!< Read: Disabled */
-#define I2S_INTENCLR_TXPTRUPD_Enabled (1UL) /*!< Read: Enabled */
-#define I2S_INTENCLR_TXPTRUPD_Clear (1UL) /*!< Disable */
-
-/* Bit 2 : Write '1' to Disable interrupt for STOPPED event */
-#define I2S_INTENCLR_STOPPED_Pos (2UL) /*!< Position of STOPPED field. */
-#define I2S_INTENCLR_STOPPED_Msk (0x1UL << I2S_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define I2S_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define I2S_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define I2S_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for RXPTRUPD event */
-#define I2S_INTENCLR_RXPTRUPD_Pos (1UL) /*!< Position of RXPTRUPD field. */
-#define I2S_INTENCLR_RXPTRUPD_Msk (0x1UL << I2S_INTENCLR_RXPTRUPD_Pos) /*!< Bit mask of RXPTRUPD field. */
-#define I2S_INTENCLR_RXPTRUPD_Disabled (0UL) /*!< Read: Disabled */
-#define I2S_INTENCLR_RXPTRUPD_Enabled (1UL) /*!< Read: Enabled */
-#define I2S_INTENCLR_RXPTRUPD_Clear (1UL) /*!< Disable */
-
-/* Register: I2S_ENABLE */
-/* Description: Enable I2S module. */
-
-/* Bit 0 : Enable I2S module. */
-#define I2S_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
-#define I2S_ENABLE_ENABLE_Msk (0x1UL << I2S_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
-#define I2S_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
-#define I2S_ENABLE_ENABLE_Enabled (1UL) /*!< Enable */
-
-/* Register: I2S_CONFIG_MODE */
-/* Description: I2S mode. */
-
-/* Bit 0 : I2S mode. */
-#define I2S_CONFIG_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
-#define I2S_CONFIG_MODE_MODE_Msk (0x1UL << I2S_CONFIG_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
-#define I2S_CONFIG_MODE_MODE_Master (0UL) /*!< Master mode. SCK and LRCK generated from internal master clcok (MCK) and output on pins defined by PSEL.xxx. */
-#define I2S_CONFIG_MODE_MODE_Slave (1UL) /*!< Slave mode. SCK and LRCK generated by external master and received on pins defined by PSEL.xxx */
-
-/* Register: I2S_CONFIG_RXEN */
-/* Description: Reception (RX) enable. */
-
-/* Bit 0 : Reception (RX) enable. */
-#define I2S_CONFIG_RXEN_RXEN_Pos (0UL) /*!< Position of RXEN field. */
-#define I2S_CONFIG_RXEN_RXEN_Msk (0x1UL << I2S_CONFIG_RXEN_RXEN_Pos) /*!< Bit mask of RXEN field. */
-#define I2S_CONFIG_RXEN_RXEN_Disabled (0UL) /*!< Reception disabled and now data will be written to the RXD.PTR address. */
-#define I2S_CONFIG_RXEN_RXEN_Enabled (1UL) /*!< Reception enabled. */
-
-/* Register: I2S_CONFIG_TXEN */
-/* Description: Transmission (TX) enable. */
-
-/* Bit 0 : Transmission (TX) enable. */
-#define I2S_CONFIG_TXEN_TXEN_Pos (0UL) /*!< Position of TXEN field. */
-#define I2S_CONFIG_TXEN_TXEN_Msk (0x1UL << I2S_CONFIG_TXEN_TXEN_Pos) /*!< Bit mask of TXEN field. */
-#define I2S_CONFIG_TXEN_TXEN_Disabled (0UL) /*!< Transmission disabled and now data will be read from the RXD.TXD address. */
-#define I2S_CONFIG_TXEN_TXEN_Enabled (1UL) /*!< Transmission enabled. */
-
-/* Register: I2S_CONFIG_MCKEN */
-/* Description: Master clock generator enable. */
-
-/* Bit 0 : Master clock generator enable. */
-#define I2S_CONFIG_MCKEN_MCKEN_Pos (0UL) /*!< Position of MCKEN field. */
-#define I2S_CONFIG_MCKEN_MCKEN_Msk (0x1UL << I2S_CONFIG_MCKEN_MCKEN_Pos) /*!< Bit mask of MCKEN field. */
-#define I2S_CONFIG_MCKEN_MCKEN_Disabled (0UL) /*!< Master clock generator disabled and PSEL.MCK not connected(available as GPIO). */
-#define I2S_CONFIG_MCKEN_MCKEN_Enabled (1UL) /*!< Master clock generator running and MCK output on PSEL.MCK. */
-
-/* Register: I2S_CONFIG_MCKFREQ */
-/* Description: Master clock generator frequency. */
-
-/* Bits 31..0 : Master clock generator frequency. */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_Pos (0UL) /*!< Position of MCKFREQ field. */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_Msk (0xFFFFFFFFUL << I2S_CONFIG_MCKFREQ_MCKFREQ_Pos) /*!< Bit mask of MCKFREQ field. */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV125 (0x020C0000UL) /*!< 32 MHz / 125 = 0.256 MHz */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV63 (0x04100000UL) /*!< 32 MHz / 63 = 0.5079365 MHz */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV42 (0x06000000UL) /*!< 32 MHz / 42 = 0.7619048 MHz */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV32 (0x08000000UL) /*!< 32 MHz / 32 = 1.0 MHz */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV31 (0x08400000UL) /*!< 32 MHz / 31 = 1.0322581 MHz */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV30 (0x08800000UL) /*!< 32 MHz / 30 = 1.0666667 MHz */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV23 (0x0B000000UL) /*!< 32 MHz / 23 = 1.3913043 MHz */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV21 (0x0C000000UL) /*!< 32 MHz / 21 = 1.5238095 */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV16 (0x10000000UL) /*!< 32 MHz / 16 = 2.0 MHz */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV15 (0x11000000UL) /*!< 32 MHz / 15 = 2.1333333 MHz */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV11 (0x16000000UL) /*!< 32 MHz / 11 = 2.9090909 MHz */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV10 (0x18000000UL) /*!< 32 MHz / 10 = 3.2 MHz */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV8 (0x20000000UL) /*!< 32 MHz / 8 = 4.0 MHz */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV6 (0x28000000UL) /*!< 32 MHz / 6 = 5.3333333 MHz */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV5 (0x30000000UL) /*!< 32 MHz / 5 = 6.4 MHz */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV4 (0x40000000UL) /*!< 32 MHz / 4 = 8.0 MHz */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV3 (0x50000000UL) /*!< 32 MHz / 3 = 10.6666667 MHz */
-#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV2 (0x80000000UL) /*!< 32 MHz / 2 = 16.0 MHz */
-
-/* Register: I2S_CONFIG_RATIO */
-/* Description: MCK / LRCK ratio. */
-
-/* Bits 3..0 : MCK / LRCK ratio. */
-#define I2S_CONFIG_RATIO_RATIO_Pos (0UL) /*!< Position of RATIO field. */
-#define I2S_CONFIG_RATIO_RATIO_Msk (0xFUL << I2S_CONFIG_RATIO_RATIO_Pos) /*!< Bit mask of RATIO field. */
-#define I2S_CONFIG_RATIO_RATIO_32X (0UL) /*!< LRCK = MCK / 32 */
-#define I2S_CONFIG_RATIO_RATIO_48X (1UL) /*!< LRCK = MCK / 48 */
-#define I2S_CONFIG_RATIO_RATIO_64X (2UL) /*!< LRCK = MCK / 64 */
-#define I2S_CONFIG_RATIO_RATIO_96X (3UL) /*!< LRCK = MCK / 96 */
-#define I2S_CONFIG_RATIO_RATIO_128X (4UL) /*!< LRCK = MCK / 128 */
-#define I2S_CONFIG_RATIO_RATIO_192X (5UL) /*!< LRCK = MCK / 192 */
-#define I2S_CONFIG_RATIO_RATIO_256X (6UL) /*!< LRCK = MCK / 256 */
-#define I2S_CONFIG_RATIO_RATIO_384X (7UL) /*!< LRCK = MCK / 384 */
-#define I2S_CONFIG_RATIO_RATIO_512X (8UL) /*!< LRCK = MCK / 512 */
-
-/* Register: I2S_CONFIG_SWIDTH */
-/* Description: Sample width. */
-
-/* Bits 1..0 : Sample width. */
-#define I2S_CONFIG_SWIDTH_SWIDTH_Pos (0UL) /*!< Position of SWIDTH field. */
-#define I2S_CONFIG_SWIDTH_SWIDTH_Msk (0x3UL << I2S_CONFIG_SWIDTH_SWIDTH_Pos) /*!< Bit mask of SWIDTH field. */
-#define I2S_CONFIG_SWIDTH_SWIDTH_8Bit (0UL) /*!< 8 bit. */
-#define I2S_CONFIG_SWIDTH_SWIDTH_16Bit (1UL) /*!< 16 bit. */
-#define I2S_CONFIG_SWIDTH_SWIDTH_24Bit (2UL) /*!< 24 bit. */
-
-/* Register: I2S_CONFIG_ALIGN */
-/* Description: Alignment of sample within a frame. */
-
-/* Bit 0 : Alignment of sample within a frame. */
-#define I2S_CONFIG_ALIGN_ALIGN_Pos (0UL) /*!< Position of ALIGN field. */
-#define I2S_CONFIG_ALIGN_ALIGN_Msk (0x1UL << I2S_CONFIG_ALIGN_ALIGN_Pos) /*!< Bit mask of ALIGN field. */
-#define I2S_CONFIG_ALIGN_ALIGN_Left (0UL) /*!< Left-aligned. */
-#define I2S_CONFIG_ALIGN_ALIGN_Right (1UL) /*!< Right-aligned. */
-
-/* Register: I2S_CONFIG_FORMAT */
-/* Description: Frame format. */
-
-/* Bit 0 : Frame format. */
-#define I2S_CONFIG_FORMAT_FORMAT_Pos (0UL) /*!< Position of FORMAT field. */
-#define I2S_CONFIG_FORMAT_FORMAT_Msk (0x1UL << I2S_CONFIG_FORMAT_FORMAT_Pos) /*!< Bit mask of FORMAT field. */
-#define I2S_CONFIG_FORMAT_FORMAT_I2S (0UL) /*!< Original I2S format. */
-#define I2S_CONFIG_FORMAT_FORMAT_Aligned (1UL) /*!< Alternate (left- or right-aligned) format. */
-
-/* Register: I2S_CONFIG_CHANNELS */
-/* Description: Enable channels. */
-
-/* Bits 1..0 : Enable channels. */
-#define I2S_CONFIG_CHANNELS_CHANNELS_Pos (0UL) /*!< Position of CHANNELS field. */
-#define I2S_CONFIG_CHANNELS_CHANNELS_Msk (0x3UL << I2S_CONFIG_CHANNELS_CHANNELS_Pos) /*!< Bit mask of CHANNELS field. */
-#define I2S_CONFIG_CHANNELS_CHANNELS_Stereo (0UL) /*!< Stereo. */
-#define I2S_CONFIG_CHANNELS_CHANNELS_Left (1UL) /*!< Left only. */
-#define I2S_CONFIG_CHANNELS_CHANNELS_Right (2UL) /*!< Right only. */
-
-/* Register: I2S_RXD_PTR */
-/* Description: Receive buffer RAM start address. */
-
-/* Bits 31..0 : Receive buffer Data RAM start address. When receiving, words containing samples will be written to this address. This address is a word aligned Data RAM address. */
-#define I2S_RXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
-#define I2S_RXD_PTR_PTR_Msk (0xFFFFFFFFUL << I2S_RXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
-
-/* Register: I2S_TXD_PTR */
-/* Description: Transmit buffer RAM start address. */
-
-/* Bits 31..0 : Transmit buffer Data RAM start address. When transmitting, words containing samples will be fetched from this address. This address is a word aligned Data RAM address. */
-#define I2S_TXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
-#define I2S_TXD_PTR_PTR_Msk (0xFFFFFFFFUL << I2S_TXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
-
-/* Register: I2S_RXTXD_MAXCNT */
-/* Description: Size of RXD and TXD buffers. */
-
-/* Bits 13..0 : Size of RXD and TXD buffers in number of 32 bit words. */
-#define I2S_RXTXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
-#define I2S_RXTXD_MAXCNT_MAXCNT_Msk (0x3FFFUL << I2S_RXTXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
-
-/* Register: I2S_PSEL_MCK */
-/* Description: Pin select for MCK signal. */
-
-/* Bit 31 : Connection */
-#define I2S_PSEL_MCK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define I2S_PSEL_MCK_CONNECT_Msk (0x1UL << I2S_PSEL_MCK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define I2S_PSEL_MCK_CONNECT_Connected (0UL) /*!< Connect */
-#define I2S_PSEL_MCK_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define I2S_PSEL_MCK_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define I2S_PSEL_MCK_PIN_Msk (0x1FUL << I2S_PSEL_MCK_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: I2S_PSEL_SCK */
-/* Description: Pin select for SCK signal. */
-
-/* Bit 31 : Connection */
-#define I2S_PSEL_SCK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define I2S_PSEL_SCK_CONNECT_Msk (0x1UL << I2S_PSEL_SCK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define I2S_PSEL_SCK_CONNECT_Connected (0UL) /*!< Connect */
-#define I2S_PSEL_SCK_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define I2S_PSEL_SCK_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define I2S_PSEL_SCK_PIN_Msk (0x1FUL << I2S_PSEL_SCK_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: I2S_PSEL_LRCK */
-/* Description: Pin select for LRCK signal. */
-
-/* Bit 31 : Connection */
-#define I2S_PSEL_LRCK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define I2S_PSEL_LRCK_CONNECT_Msk (0x1UL << I2S_PSEL_LRCK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define I2S_PSEL_LRCK_CONNECT_Connected (0UL) /*!< Connect */
-#define I2S_PSEL_LRCK_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define I2S_PSEL_LRCK_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define I2S_PSEL_LRCK_PIN_Msk (0x1FUL << I2S_PSEL_LRCK_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: I2S_PSEL_SDIN */
-/* Description: Pin select for SDIN signal. */
-
-/* Bit 31 : Connection */
-#define I2S_PSEL_SDIN_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define I2S_PSEL_SDIN_CONNECT_Msk (0x1UL << I2S_PSEL_SDIN_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define I2S_PSEL_SDIN_CONNECT_Connected (0UL) /*!< Connect */
-#define I2S_PSEL_SDIN_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define I2S_PSEL_SDIN_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define I2S_PSEL_SDIN_PIN_Msk (0x1FUL << I2S_PSEL_SDIN_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: I2S_PSEL_SDOUT */
-/* Description: Pin select for SDOUT signal. */
-
-/* Bit 31 : Connection */
-#define I2S_PSEL_SDOUT_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define I2S_PSEL_SDOUT_CONNECT_Msk (0x1UL << I2S_PSEL_SDOUT_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define I2S_PSEL_SDOUT_CONNECT_Connected (0UL) /*!< Connect */
-#define I2S_PSEL_SDOUT_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define I2S_PSEL_SDOUT_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define I2S_PSEL_SDOUT_PIN_Msk (0x1FUL << I2S_PSEL_SDOUT_PIN_Pos) /*!< Bit mask of PIN field. */
-
-
-/* Peripheral: LPCOMP */
-/* Description: Low Power Comparator */
-
-/* Register: LPCOMP_SHORTS */
-/* Description: Shortcut register */
-
-/* Bit 4 : Shortcut between CROSS event and STOP task */
-#define LPCOMP_SHORTS_CROSS_STOP_Pos (4UL) /*!< Position of CROSS_STOP field. */
-#define LPCOMP_SHORTS_CROSS_STOP_Msk (0x1UL << LPCOMP_SHORTS_CROSS_STOP_Pos) /*!< Bit mask of CROSS_STOP field. */
-#define LPCOMP_SHORTS_CROSS_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define LPCOMP_SHORTS_CROSS_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 3 : Shortcut between UP event and STOP task */
-#define LPCOMP_SHORTS_UP_STOP_Pos (3UL) /*!< Position of UP_STOP field. */
-#define LPCOMP_SHORTS_UP_STOP_Msk (0x1UL << LPCOMP_SHORTS_UP_STOP_Pos) /*!< Bit mask of UP_STOP field. */
-#define LPCOMP_SHORTS_UP_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define LPCOMP_SHORTS_UP_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 2 : Shortcut between DOWN event and STOP task */
-#define LPCOMP_SHORTS_DOWN_STOP_Pos (2UL) /*!< Position of DOWN_STOP field. */
-#define LPCOMP_SHORTS_DOWN_STOP_Msk (0x1UL << LPCOMP_SHORTS_DOWN_STOP_Pos) /*!< Bit mask of DOWN_STOP field. */
-#define LPCOMP_SHORTS_DOWN_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define LPCOMP_SHORTS_DOWN_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 1 : Shortcut between READY event and STOP task */
-#define LPCOMP_SHORTS_READY_STOP_Pos (1UL) /*!< Position of READY_STOP field. */
-#define LPCOMP_SHORTS_READY_STOP_Msk (0x1UL << LPCOMP_SHORTS_READY_STOP_Pos) /*!< Bit mask of READY_STOP field. */
-#define LPCOMP_SHORTS_READY_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define LPCOMP_SHORTS_READY_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 0 : Shortcut between READY event and SAMPLE task */
-#define LPCOMP_SHORTS_READY_SAMPLE_Pos (0UL) /*!< Position of READY_SAMPLE field. */
-#define LPCOMP_SHORTS_READY_SAMPLE_Msk (0x1UL << LPCOMP_SHORTS_READY_SAMPLE_Pos) /*!< Bit mask of READY_SAMPLE field. */
-#define LPCOMP_SHORTS_READY_SAMPLE_Disabled (0UL) /*!< Disable shortcut */
-#define LPCOMP_SHORTS_READY_SAMPLE_Enabled (1UL) /*!< Enable shortcut */
-
-/* Register: LPCOMP_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 3 : Write '1' to Enable interrupt for CROSS event */
-#define LPCOMP_INTENSET_CROSS_Pos (3UL) /*!< Position of CROSS field. */
-#define LPCOMP_INTENSET_CROSS_Msk (0x1UL << LPCOMP_INTENSET_CROSS_Pos) /*!< Bit mask of CROSS field. */
-#define LPCOMP_INTENSET_CROSS_Disabled (0UL) /*!< Read: Disabled */
-#define LPCOMP_INTENSET_CROSS_Enabled (1UL) /*!< Read: Enabled */
-#define LPCOMP_INTENSET_CROSS_Set (1UL) /*!< Enable */
-
-/* Bit 2 : Write '1' to Enable interrupt for UP event */
-#define LPCOMP_INTENSET_UP_Pos (2UL) /*!< Position of UP field. */
-#define LPCOMP_INTENSET_UP_Msk (0x1UL << LPCOMP_INTENSET_UP_Pos) /*!< Bit mask of UP field. */
-#define LPCOMP_INTENSET_UP_Disabled (0UL) /*!< Read: Disabled */
-#define LPCOMP_INTENSET_UP_Enabled (1UL) /*!< Read: Enabled */
-#define LPCOMP_INTENSET_UP_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for DOWN event */
-#define LPCOMP_INTENSET_DOWN_Pos (1UL) /*!< Position of DOWN field. */
-#define LPCOMP_INTENSET_DOWN_Msk (0x1UL << LPCOMP_INTENSET_DOWN_Pos) /*!< Bit mask of DOWN field. */
-#define LPCOMP_INTENSET_DOWN_Disabled (0UL) /*!< Read: Disabled */
-#define LPCOMP_INTENSET_DOWN_Enabled (1UL) /*!< Read: Enabled */
-#define LPCOMP_INTENSET_DOWN_Set (1UL) /*!< Enable */
-
-/* Bit 0 : Write '1' to Enable interrupt for READY event */
-#define LPCOMP_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
-#define LPCOMP_INTENSET_READY_Msk (0x1UL << LPCOMP_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
-#define LPCOMP_INTENSET_READY_Disabled (0UL) /*!< Read: Disabled */
-#define LPCOMP_INTENSET_READY_Enabled (1UL) /*!< Read: Enabled */
-#define LPCOMP_INTENSET_READY_Set (1UL) /*!< Enable */
-
-/* Register: LPCOMP_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 3 : Write '1' to Disable interrupt for CROSS event */
-#define LPCOMP_INTENCLR_CROSS_Pos (3UL) /*!< Position of CROSS field. */
-#define LPCOMP_INTENCLR_CROSS_Msk (0x1UL << LPCOMP_INTENCLR_CROSS_Pos) /*!< Bit mask of CROSS field. */
-#define LPCOMP_INTENCLR_CROSS_Disabled (0UL) /*!< Read: Disabled */
-#define LPCOMP_INTENCLR_CROSS_Enabled (1UL) /*!< Read: Enabled */
-#define LPCOMP_INTENCLR_CROSS_Clear (1UL) /*!< Disable */
-
-/* Bit 2 : Write '1' to Disable interrupt for UP event */
-#define LPCOMP_INTENCLR_UP_Pos (2UL) /*!< Position of UP field. */
-#define LPCOMP_INTENCLR_UP_Msk (0x1UL << LPCOMP_INTENCLR_UP_Pos) /*!< Bit mask of UP field. */
-#define LPCOMP_INTENCLR_UP_Disabled (0UL) /*!< Read: Disabled */
-#define LPCOMP_INTENCLR_UP_Enabled (1UL) /*!< Read: Enabled */
-#define LPCOMP_INTENCLR_UP_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for DOWN event */
-#define LPCOMP_INTENCLR_DOWN_Pos (1UL) /*!< Position of DOWN field. */
-#define LPCOMP_INTENCLR_DOWN_Msk (0x1UL << LPCOMP_INTENCLR_DOWN_Pos) /*!< Bit mask of DOWN field. */
-#define LPCOMP_INTENCLR_DOWN_Disabled (0UL) /*!< Read: Disabled */
-#define LPCOMP_INTENCLR_DOWN_Enabled (1UL) /*!< Read: Enabled */
-#define LPCOMP_INTENCLR_DOWN_Clear (1UL) /*!< Disable */
-
-/* Bit 0 : Write '1' to Disable interrupt for READY event */
-#define LPCOMP_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
-#define LPCOMP_INTENCLR_READY_Msk (0x1UL << LPCOMP_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
-#define LPCOMP_INTENCLR_READY_Disabled (0UL) /*!< Read: Disabled */
-#define LPCOMP_INTENCLR_READY_Enabled (1UL) /*!< Read: Enabled */
-#define LPCOMP_INTENCLR_READY_Clear (1UL) /*!< Disable */
-
-/* Register: LPCOMP_RESULT */
-/* Description: Compare result */
-
-/* Bit 0 : Result of last compare. Decision point SAMPLE task. */
-#define LPCOMP_RESULT_RESULT_Pos (0UL) /*!< Position of RESULT field. */
-#define LPCOMP_RESULT_RESULT_Msk (0x1UL << LPCOMP_RESULT_RESULT_Pos) /*!< Bit mask of RESULT field. */
-#define LPCOMP_RESULT_RESULT_Below (0UL) /*!< Input voltage is below the reference threshold (VIN+ &lt; VIN-). */
-#define LPCOMP_RESULT_RESULT_Above (1UL) /*!< Input voltage is above the reference threshold (VIN+ &gt; VIN-). */
-
-/* Register: LPCOMP_ENABLE */
-/* Description: Enable LPCOMP */
-
-/* Bits 1..0 : Enable or disable LPCOMP */
-#define LPCOMP_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
-#define LPCOMP_ENABLE_ENABLE_Msk (0x3UL << LPCOMP_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
-#define LPCOMP_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
-#define LPCOMP_ENABLE_ENABLE_Enabled (1UL) /*!< Enable */
-
-/* Register: LPCOMP_PSEL */
-/* Description: Input pin select */
-
-/* Bits 2..0 : Analog pin select */
-#define LPCOMP_PSEL_PSEL_Pos (0UL) /*!< Position of PSEL field. */
-#define LPCOMP_PSEL_PSEL_Msk (0x7UL << LPCOMP_PSEL_PSEL_Pos) /*!< Bit mask of PSEL field. */
-#define LPCOMP_PSEL_PSEL_AnalogInput0 (0UL) /*!< AIN0 selected as analog input */
-#define LPCOMP_PSEL_PSEL_AnalogInput1 (1UL) /*!< AIN1 selected as analog input */
-#define LPCOMP_PSEL_PSEL_AnalogInput2 (2UL) /*!< AIN2 selected as analog input */
-#define LPCOMP_PSEL_PSEL_AnalogInput3 (3UL) /*!< AIN3 selected as analog input */
-#define LPCOMP_PSEL_PSEL_AnalogInput4 (4UL) /*!< AIN4 selected as analog input */
-#define LPCOMP_PSEL_PSEL_AnalogInput5 (5UL) /*!< AIN5 selected as analog input */
-#define LPCOMP_PSEL_PSEL_AnalogInput6 (6UL) /*!< AIN6 selected as analog input */
-#define LPCOMP_PSEL_PSEL_AnalogInput7 (7UL) /*!< AIN7 selected as analog input */
-
-/* Register: LPCOMP_REFSEL */
-/* Description: Reference select */
-
-/* Bits 3..0 : Reference select */
-#define LPCOMP_REFSEL_REFSEL_Pos (0UL) /*!< Position of REFSEL field. */
-#define LPCOMP_REFSEL_REFSEL_Msk (0xFUL << LPCOMP_REFSEL_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
-#define LPCOMP_REFSEL_REFSEL_Ref1_8Vdd (0UL) /*!< VDD * 1/8 selected as reference */
-#define LPCOMP_REFSEL_REFSEL_Ref2_8Vdd (1UL) /*!< VDD * 2/8 selected as reference */
-#define LPCOMP_REFSEL_REFSEL_Ref3_8Vdd (2UL) /*!< VDD * 3/8 selected as reference */
-#define LPCOMP_REFSEL_REFSEL_Ref4_8Vdd (3UL) /*!< VDD * 4/8 selected as reference */
-#define LPCOMP_REFSEL_REFSEL_Ref5_8Vdd (4UL) /*!< VDD * 5/8 selected as reference */
-#define LPCOMP_REFSEL_REFSEL_Ref6_8Vdd (5UL) /*!< VDD * 6/8 selected as reference */
-#define LPCOMP_REFSEL_REFSEL_Ref7_8Vdd (6UL) /*!< VDD * 7/8 selected as reference */
-#define LPCOMP_REFSEL_REFSEL_ARef (7UL) /*!< External analog reference selected */
-#define LPCOMP_REFSEL_REFSEL_Ref1_16Vdd (8UL) /*!< VDD * 1/16 selected as reference */
-#define LPCOMP_REFSEL_REFSEL_Ref3_16Vdd (9UL) /*!< VDD * 3/16 selected as reference */
-#define LPCOMP_REFSEL_REFSEL_Ref5_16Vdd (10UL) /*!< VDD * 5/16 selected as reference */
-#define LPCOMP_REFSEL_REFSEL_Ref7_16Vdd (11UL) /*!< VDD * 7/16 selected as reference */
-#define LPCOMP_REFSEL_REFSEL_Ref9_16Vdd (12UL) /*!< VDD * 9/16 selected as reference */
-#define LPCOMP_REFSEL_REFSEL_Ref11_16Vdd (13UL) /*!< VDD * 11/16 selected as reference */
-#define LPCOMP_REFSEL_REFSEL_Ref13_16Vdd (14UL) /*!< VDD * 13/16 selected as reference */
-#define LPCOMP_REFSEL_REFSEL_Ref15_16Vdd (15UL) /*!< VDD * 15/16 selected as reference */
-
-/* Register: LPCOMP_EXTREFSEL */
-/* Description: External reference select */
-
-/* Bit 0 : External analog reference select */
-#define LPCOMP_EXTREFSEL_EXTREFSEL_Pos (0UL) /*!< Position of EXTREFSEL field. */
-#define LPCOMP_EXTREFSEL_EXTREFSEL_Msk (0x1UL << LPCOMP_EXTREFSEL_EXTREFSEL_Pos) /*!< Bit mask of EXTREFSEL field. */
-#define LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference0 (0UL) /*!< Use AIN0 as external analog reference */
-#define LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference1 (1UL) /*!< Use AIN1 as external analog reference */
-
-/* Register: LPCOMP_ANADETECT */
-/* Description: Analog detect configuration */
-
-/* Bits 1..0 : Analog detect configuration */
-#define LPCOMP_ANADETECT_ANADETECT_Pos (0UL) /*!< Position of ANADETECT field. */
-#define LPCOMP_ANADETECT_ANADETECT_Msk (0x3UL << LPCOMP_ANADETECT_ANADETECT_Pos) /*!< Bit mask of ANADETECT field. */
-#define LPCOMP_ANADETECT_ANADETECT_Cross (0UL) /*!< Generate ANADETECT on crossing, both upward crossing and downward crossing */
-#define LPCOMP_ANADETECT_ANADETECT_Up (1UL) /*!< Generate ANADETECT on upward crossing only */
-#define LPCOMP_ANADETECT_ANADETECT_Down (2UL) /*!< Generate ANADETECT on downward crossing only */
-
-/* Register: LPCOMP_HYST */
-/* Description: Comparator hysteresis enable */
-
-/* Bit 0 : Comparator hysteresis enable */
-#define LPCOMP_HYST_HYST_Pos (0UL) /*!< Position of HYST field. */
-#define LPCOMP_HYST_HYST_Msk (0x1UL << LPCOMP_HYST_HYST_Pos) /*!< Bit mask of HYST field. */
-#define LPCOMP_HYST_HYST_NoHyst (0UL) /*!< Comparator hysteresis disabled */
-#define LPCOMP_HYST_HYST_Hyst50mV (1UL) /*!< Comparator hysteresis disabled (typ. 50 mV) */
-
-
-/* Peripheral: MWU */
-/* Description: Memory Watch Unit */
-
-/* Register: MWU_INTEN */
-/* Description: Enable or disable interrupt */
-
-/* Bit 27 : Enable or disable interrupt for PREGION[1].RA event */
-#define MWU_INTEN_PREGION1RA_Pos (27UL) /*!< Position of PREGION1RA field. */
-#define MWU_INTEN_PREGION1RA_Msk (0x1UL << MWU_INTEN_PREGION1RA_Pos) /*!< Bit mask of PREGION1RA field. */
-#define MWU_INTEN_PREGION1RA_Disabled (0UL) /*!< Disable */
-#define MWU_INTEN_PREGION1RA_Enabled (1UL) /*!< Enable */
-
-/* Bit 26 : Enable or disable interrupt for PREGION[1].WA event */
-#define MWU_INTEN_PREGION1WA_Pos (26UL) /*!< Position of PREGION1WA field. */
-#define MWU_INTEN_PREGION1WA_Msk (0x1UL << MWU_INTEN_PREGION1WA_Pos) /*!< Bit mask of PREGION1WA field. */
-#define MWU_INTEN_PREGION1WA_Disabled (0UL) /*!< Disable */
-#define MWU_INTEN_PREGION1WA_Enabled (1UL) /*!< Enable */
-
-/* Bit 25 : Enable or disable interrupt for PREGION[0].RA event */
-#define MWU_INTEN_PREGION0RA_Pos (25UL) /*!< Position of PREGION0RA field. */
-#define MWU_INTEN_PREGION0RA_Msk (0x1UL << MWU_INTEN_PREGION0RA_Pos) /*!< Bit mask of PREGION0RA field. */
-#define MWU_INTEN_PREGION0RA_Disabled (0UL) /*!< Disable */
-#define MWU_INTEN_PREGION0RA_Enabled (1UL) /*!< Enable */
-
-/* Bit 24 : Enable or disable interrupt for PREGION[0].WA event */
-#define MWU_INTEN_PREGION0WA_Pos (24UL) /*!< Position of PREGION0WA field. */
-#define MWU_INTEN_PREGION0WA_Msk (0x1UL << MWU_INTEN_PREGION0WA_Pos) /*!< Bit mask of PREGION0WA field. */
-#define MWU_INTEN_PREGION0WA_Disabled (0UL) /*!< Disable */
-#define MWU_INTEN_PREGION0WA_Enabled (1UL) /*!< Enable */
-
-/* Bit 7 : Enable or disable interrupt for REGION[3].RA event */
-#define MWU_INTEN_REGION3RA_Pos (7UL) /*!< Position of REGION3RA field. */
-#define MWU_INTEN_REGION3RA_Msk (0x1UL << MWU_INTEN_REGION3RA_Pos) /*!< Bit mask of REGION3RA field. */
-#define MWU_INTEN_REGION3RA_Disabled (0UL) /*!< Disable */
-#define MWU_INTEN_REGION3RA_Enabled (1UL) /*!< Enable */
-
-/* Bit 6 : Enable or disable interrupt for REGION[3].WA event */
-#define MWU_INTEN_REGION3WA_Pos (6UL) /*!< Position of REGION3WA field. */
-#define MWU_INTEN_REGION3WA_Msk (0x1UL << MWU_INTEN_REGION3WA_Pos) /*!< Bit mask of REGION3WA field. */
-#define MWU_INTEN_REGION3WA_Disabled (0UL) /*!< Disable */
-#define MWU_INTEN_REGION3WA_Enabled (1UL) /*!< Enable */
-
-/* Bit 5 : Enable or disable interrupt for REGION[2].RA event */
-#define MWU_INTEN_REGION2RA_Pos (5UL) /*!< Position of REGION2RA field. */
-#define MWU_INTEN_REGION2RA_Msk (0x1UL << MWU_INTEN_REGION2RA_Pos) /*!< Bit mask of REGION2RA field. */
-#define MWU_INTEN_REGION2RA_Disabled (0UL) /*!< Disable */
-#define MWU_INTEN_REGION2RA_Enabled (1UL) /*!< Enable */
-
-/* Bit 4 : Enable or disable interrupt for REGION[2].WA event */
-#define MWU_INTEN_REGION2WA_Pos (4UL) /*!< Position of REGION2WA field. */
-#define MWU_INTEN_REGION2WA_Msk (0x1UL << MWU_INTEN_REGION2WA_Pos) /*!< Bit mask of REGION2WA field. */
-#define MWU_INTEN_REGION2WA_Disabled (0UL) /*!< Disable */
-#define MWU_INTEN_REGION2WA_Enabled (1UL) /*!< Enable */
-
-/* Bit 3 : Enable or disable interrupt for REGION[1].RA event */
-#define MWU_INTEN_REGION1RA_Pos (3UL) /*!< Position of REGION1RA field. */
-#define MWU_INTEN_REGION1RA_Msk (0x1UL << MWU_INTEN_REGION1RA_Pos) /*!< Bit mask of REGION1RA field. */
-#define MWU_INTEN_REGION1RA_Disabled (0UL) /*!< Disable */
-#define MWU_INTEN_REGION1RA_Enabled (1UL) /*!< Enable */
-
-/* Bit 2 : Enable or disable interrupt for REGION[1].WA event */
-#define MWU_INTEN_REGION1WA_Pos (2UL) /*!< Position of REGION1WA field. */
-#define MWU_INTEN_REGION1WA_Msk (0x1UL << MWU_INTEN_REGION1WA_Pos) /*!< Bit mask of REGION1WA field. */
-#define MWU_INTEN_REGION1WA_Disabled (0UL) /*!< Disable */
-#define MWU_INTEN_REGION1WA_Enabled (1UL) /*!< Enable */
-
-/* Bit 1 : Enable or disable interrupt for REGION[0].RA event */
-#define MWU_INTEN_REGION0RA_Pos (1UL) /*!< Position of REGION0RA field. */
-#define MWU_INTEN_REGION0RA_Msk (0x1UL << MWU_INTEN_REGION0RA_Pos) /*!< Bit mask of REGION0RA field. */
-#define MWU_INTEN_REGION0RA_Disabled (0UL) /*!< Disable */
-#define MWU_INTEN_REGION0RA_Enabled (1UL) /*!< Enable */
-
-/* Bit 0 : Enable or disable interrupt for REGION[0].WA event */
-#define MWU_INTEN_REGION0WA_Pos (0UL) /*!< Position of REGION0WA field. */
-#define MWU_INTEN_REGION0WA_Msk (0x1UL << MWU_INTEN_REGION0WA_Pos) /*!< Bit mask of REGION0WA field. */
-#define MWU_INTEN_REGION0WA_Disabled (0UL) /*!< Disable */
-#define MWU_INTEN_REGION0WA_Enabled (1UL) /*!< Enable */
-
-/* Register: MWU_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 27 : Write '1' to Enable interrupt for PREGION[1].RA event */
-#define MWU_INTENSET_PREGION1RA_Pos (27UL) /*!< Position of PREGION1RA field. */
-#define MWU_INTENSET_PREGION1RA_Msk (0x1UL << MWU_INTENSET_PREGION1RA_Pos) /*!< Bit mask of PREGION1RA field. */
-#define MWU_INTENSET_PREGION1RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENSET_PREGION1RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENSET_PREGION1RA_Set (1UL) /*!< Enable */
-
-/* Bit 26 : Write '1' to Enable interrupt for PREGION[1].WA event */
-#define MWU_INTENSET_PREGION1WA_Pos (26UL) /*!< Position of PREGION1WA field. */
-#define MWU_INTENSET_PREGION1WA_Msk (0x1UL << MWU_INTENSET_PREGION1WA_Pos) /*!< Bit mask of PREGION1WA field. */
-#define MWU_INTENSET_PREGION1WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENSET_PREGION1WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENSET_PREGION1WA_Set (1UL) /*!< Enable */
-
-/* Bit 25 : Write '1' to Enable interrupt for PREGION[0].RA event */
-#define MWU_INTENSET_PREGION0RA_Pos (25UL) /*!< Position of PREGION0RA field. */
-#define MWU_INTENSET_PREGION0RA_Msk (0x1UL << MWU_INTENSET_PREGION0RA_Pos) /*!< Bit mask of PREGION0RA field. */
-#define MWU_INTENSET_PREGION0RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENSET_PREGION0RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENSET_PREGION0RA_Set (1UL) /*!< Enable */
-
-/* Bit 24 : Write '1' to Enable interrupt for PREGION[0].WA event */
-#define MWU_INTENSET_PREGION0WA_Pos (24UL) /*!< Position of PREGION0WA field. */
-#define MWU_INTENSET_PREGION0WA_Msk (0x1UL << MWU_INTENSET_PREGION0WA_Pos) /*!< Bit mask of PREGION0WA field. */
-#define MWU_INTENSET_PREGION0WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENSET_PREGION0WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENSET_PREGION0WA_Set (1UL) /*!< Enable */
-
-/* Bit 7 : Write '1' to Enable interrupt for REGION[3].RA event */
-#define MWU_INTENSET_REGION3RA_Pos (7UL) /*!< Position of REGION3RA field. */
-#define MWU_INTENSET_REGION3RA_Msk (0x1UL << MWU_INTENSET_REGION3RA_Pos) /*!< Bit mask of REGION3RA field. */
-#define MWU_INTENSET_REGION3RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENSET_REGION3RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENSET_REGION3RA_Set (1UL) /*!< Enable */
-
-/* Bit 6 : Write '1' to Enable interrupt for REGION[3].WA event */
-#define MWU_INTENSET_REGION3WA_Pos (6UL) /*!< Position of REGION3WA field. */
-#define MWU_INTENSET_REGION3WA_Msk (0x1UL << MWU_INTENSET_REGION3WA_Pos) /*!< Bit mask of REGION3WA field. */
-#define MWU_INTENSET_REGION3WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENSET_REGION3WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENSET_REGION3WA_Set (1UL) /*!< Enable */
-
-/* Bit 5 : Write '1' to Enable interrupt for REGION[2].RA event */
-#define MWU_INTENSET_REGION2RA_Pos (5UL) /*!< Position of REGION2RA field. */
-#define MWU_INTENSET_REGION2RA_Msk (0x1UL << MWU_INTENSET_REGION2RA_Pos) /*!< Bit mask of REGION2RA field. */
-#define MWU_INTENSET_REGION2RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENSET_REGION2RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENSET_REGION2RA_Set (1UL) /*!< Enable */
-
-/* Bit 4 : Write '1' to Enable interrupt for REGION[2].WA event */
-#define MWU_INTENSET_REGION2WA_Pos (4UL) /*!< Position of REGION2WA field. */
-#define MWU_INTENSET_REGION2WA_Msk (0x1UL << MWU_INTENSET_REGION2WA_Pos) /*!< Bit mask of REGION2WA field. */
-#define MWU_INTENSET_REGION2WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENSET_REGION2WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENSET_REGION2WA_Set (1UL) /*!< Enable */
-
-/* Bit 3 : Write '1' to Enable interrupt for REGION[1].RA event */
-#define MWU_INTENSET_REGION1RA_Pos (3UL) /*!< Position of REGION1RA field. */
-#define MWU_INTENSET_REGION1RA_Msk (0x1UL << MWU_INTENSET_REGION1RA_Pos) /*!< Bit mask of REGION1RA field. */
-#define MWU_INTENSET_REGION1RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENSET_REGION1RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENSET_REGION1RA_Set (1UL) /*!< Enable */
-
-/* Bit 2 : Write '1' to Enable interrupt for REGION[1].WA event */
-#define MWU_INTENSET_REGION1WA_Pos (2UL) /*!< Position of REGION1WA field. */
-#define MWU_INTENSET_REGION1WA_Msk (0x1UL << MWU_INTENSET_REGION1WA_Pos) /*!< Bit mask of REGION1WA field. */
-#define MWU_INTENSET_REGION1WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENSET_REGION1WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENSET_REGION1WA_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for REGION[0].RA event */
-#define MWU_INTENSET_REGION0RA_Pos (1UL) /*!< Position of REGION0RA field. */
-#define MWU_INTENSET_REGION0RA_Msk (0x1UL << MWU_INTENSET_REGION0RA_Pos) /*!< Bit mask of REGION0RA field. */
-#define MWU_INTENSET_REGION0RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENSET_REGION0RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENSET_REGION0RA_Set (1UL) /*!< Enable */
-
-/* Bit 0 : Write '1' to Enable interrupt for REGION[0].WA event */
-#define MWU_INTENSET_REGION0WA_Pos (0UL) /*!< Position of REGION0WA field. */
-#define MWU_INTENSET_REGION0WA_Msk (0x1UL << MWU_INTENSET_REGION0WA_Pos) /*!< Bit mask of REGION0WA field. */
-#define MWU_INTENSET_REGION0WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENSET_REGION0WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENSET_REGION0WA_Set (1UL) /*!< Enable */
-
-/* Register: MWU_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 27 : Write '1' to Disable interrupt for PREGION[1].RA event */
-#define MWU_INTENCLR_PREGION1RA_Pos (27UL) /*!< Position of PREGION1RA field. */
-#define MWU_INTENCLR_PREGION1RA_Msk (0x1UL << MWU_INTENCLR_PREGION1RA_Pos) /*!< Bit mask of PREGION1RA field. */
-#define MWU_INTENCLR_PREGION1RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENCLR_PREGION1RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENCLR_PREGION1RA_Clear (1UL) /*!< Disable */
-
-/* Bit 26 : Write '1' to Disable interrupt for PREGION[1].WA event */
-#define MWU_INTENCLR_PREGION1WA_Pos (26UL) /*!< Position of PREGION1WA field. */
-#define MWU_INTENCLR_PREGION1WA_Msk (0x1UL << MWU_INTENCLR_PREGION1WA_Pos) /*!< Bit mask of PREGION1WA field. */
-#define MWU_INTENCLR_PREGION1WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENCLR_PREGION1WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENCLR_PREGION1WA_Clear (1UL) /*!< Disable */
-
-/* Bit 25 : Write '1' to Disable interrupt for PREGION[0].RA event */
-#define MWU_INTENCLR_PREGION0RA_Pos (25UL) /*!< Position of PREGION0RA field. */
-#define MWU_INTENCLR_PREGION0RA_Msk (0x1UL << MWU_INTENCLR_PREGION0RA_Pos) /*!< Bit mask of PREGION0RA field. */
-#define MWU_INTENCLR_PREGION0RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENCLR_PREGION0RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENCLR_PREGION0RA_Clear (1UL) /*!< Disable */
-
-/* Bit 24 : Write '1' to Disable interrupt for PREGION[0].WA event */
-#define MWU_INTENCLR_PREGION0WA_Pos (24UL) /*!< Position of PREGION0WA field. */
-#define MWU_INTENCLR_PREGION0WA_Msk (0x1UL << MWU_INTENCLR_PREGION0WA_Pos) /*!< Bit mask of PREGION0WA field. */
-#define MWU_INTENCLR_PREGION0WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENCLR_PREGION0WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENCLR_PREGION0WA_Clear (1UL) /*!< Disable */
-
-/* Bit 7 : Write '1' to Disable interrupt for REGION[3].RA event */
-#define MWU_INTENCLR_REGION3RA_Pos (7UL) /*!< Position of REGION3RA field. */
-#define MWU_INTENCLR_REGION3RA_Msk (0x1UL << MWU_INTENCLR_REGION3RA_Pos) /*!< Bit mask of REGION3RA field. */
-#define MWU_INTENCLR_REGION3RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENCLR_REGION3RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENCLR_REGION3RA_Clear (1UL) /*!< Disable */
-
-/* Bit 6 : Write '1' to Disable interrupt for REGION[3].WA event */
-#define MWU_INTENCLR_REGION3WA_Pos (6UL) /*!< Position of REGION3WA field. */
-#define MWU_INTENCLR_REGION3WA_Msk (0x1UL << MWU_INTENCLR_REGION3WA_Pos) /*!< Bit mask of REGION3WA field. */
-#define MWU_INTENCLR_REGION3WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENCLR_REGION3WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENCLR_REGION3WA_Clear (1UL) /*!< Disable */
-
-/* Bit 5 : Write '1' to Disable interrupt for REGION[2].RA event */
-#define MWU_INTENCLR_REGION2RA_Pos (5UL) /*!< Position of REGION2RA field. */
-#define MWU_INTENCLR_REGION2RA_Msk (0x1UL << MWU_INTENCLR_REGION2RA_Pos) /*!< Bit mask of REGION2RA field. */
-#define MWU_INTENCLR_REGION2RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENCLR_REGION2RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENCLR_REGION2RA_Clear (1UL) /*!< Disable */
-
-/* Bit 4 : Write '1' to Disable interrupt for REGION[2].WA event */
-#define MWU_INTENCLR_REGION2WA_Pos (4UL) /*!< Position of REGION2WA field. */
-#define MWU_INTENCLR_REGION2WA_Msk (0x1UL << MWU_INTENCLR_REGION2WA_Pos) /*!< Bit mask of REGION2WA field. */
-#define MWU_INTENCLR_REGION2WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENCLR_REGION2WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENCLR_REGION2WA_Clear (1UL) /*!< Disable */
-
-/* Bit 3 : Write '1' to Disable interrupt for REGION[1].RA event */
-#define MWU_INTENCLR_REGION1RA_Pos (3UL) /*!< Position of REGION1RA field. */
-#define MWU_INTENCLR_REGION1RA_Msk (0x1UL << MWU_INTENCLR_REGION1RA_Pos) /*!< Bit mask of REGION1RA field. */
-#define MWU_INTENCLR_REGION1RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENCLR_REGION1RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENCLR_REGION1RA_Clear (1UL) /*!< Disable */
-
-/* Bit 2 : Write '1' to Disable interrupt for REGION[1].WA event */
-#define MWU_INTENCLR_REGION1WA_Pos (2UL) /*!< Position of REGION1WA field. */
-#define MWU_INTENCLR_REGION1WA_Msk (0x1UL << MWU_INTENCLR_REGION1WA_Pos) /*!< Bit mask of REGION1WA field. */
-#define MWU_INTENCLR_REGION1WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENCLR_REGION1WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENCLR_REGION1WA_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for REGION[0].RA event */
-#define MWU_INTENCLR_REGION0RA_Pos (1UL) /*!< Position of REGION0RA field. */
-#define MWU_INTENCLR_REGION0RA_Msk (0x1UL << MWU_INTENCLR_REGION0RA_Pos) /*!< Bit mask of REGION0RA field. */
-#define MWU_INTENCLR_REGION0RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENCLR_REGION0RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENCLR_REGION0RA_Clear (1UL) /*!< Disable */
-
-/* Bit 0 : Write '1' to Disable interrupt for REGION[0].WA event */
-#define MWU_INTENCLR_REGION0WA_Pos (0UL) /*!< Position of REGION0WA field. */
-#define MWU_INTENCLR_REGION0WA_Msk (0x1UL << MWU_INTENCLR_REGION0WA_Pos) /*!< Bit mask of REGION0WA field. */
-#define MWU_INTENCLR_REGION0WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_INTENCLR_REGION0WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_INTENCLR_REGION0WA_Clear (1UL) /*!< Disable */
-
-/* Register: MWU_NMIEN */
-/* Description: Enable or disable non-maskable interrupt */
-
-/* Bit 27 : Enable or disable non-maskable interrupt for PREGION[1].RA event */
-#define MWU_NMIEN_PREGION1RA_Pos (27UL) /*!< Position of PREGION1RA field. */
-#define MWU_NMIEN_PREGION1RA_Msk (0x1UL << MWU_NMIEN_PREGION1RA_Pos) /*!< Bit mask of PREGION1RA field. */
-#define MWU_NMIEN_PREGION1RA_Disabled (0UL) /*!< Disable */
-#define MWU_NMIEN_PREGION1RA_Enabled (1UL) /*!< Enable */
-
-/* Bit 26 : Enable or disable non-maskable interrupt for PREGION[1].WA event */
-#define MWU_NMIEN_PREGION1WA_Pos (26UL) /*!< Position of PREGION1WA field. */
-#define MWU_NMIEN_PREGION1WA_Msk (0x1UL << MWU_NMIEN_PREGION1WA_Pos) /*!< Bit mask of PREGION1WA field. */
-#define MWU_NMIEN_PREGION1WA_Disabled (0UL) /*!< Disable */
-#define MWU_NMIEN_PREGION1WA_Enabled (1UL) /*!< Enable */
-
-/* Bit 25 : Enable or disable non-maskable interrupt for PREGION[0].RA event */
-#define MWU_NMIEN_PREGION0RA_Pos (25UL) /*!< Position of PREGION0RA field. */
-#define MWU_NMIEN_PREGION0RA_Msk (0x1UL << MWU_NMIEN_PREGION0RA_Pos) /*!< Bit mask of PREGION0RA field. */
-#define MWU_NMIEN_PREGION0RA_Disabled (0UL) /*!< Disable */
-#define MWU_NMIEN_PREGION0RA_Enabled (1UL) /*!< Enable */
-
-/* Bit 24 : Enable or disable non-maskable interrupt for PREGION[0].WA event */
-#define MWU_NMIEN_PREGION0WA_Pos (24UL) /*!< Position of PREGION0WA field. */
-#define MWU_NMIEN_PREGION0WA_Msk (0x1UL << MWU_NMIEN_PREGION0WA_Pos) /*!< Bit mask of PREGION0WA field. */
-#define MWU_NMIEN_PREGION0WA_Disabled (0UL) /*!< Disable */
-#define MWU_NMIEN_PREGION0WA_Enabled (1UL) /*!< Enable */
-
-/* Bit 7 : Enable or disable non-maskable interrupt for REGION[3].RA event */
-#define MWU_NMIEN_REGION3RA_Pos (7UL) /*!< Position of REGION3RA field. */
-#define MWU_NMIEN_REGION3RA_Msk (0x1UL << MWU_NMIEN_REGION3RA_Pos) /*!< Bit mask of REGION3RA field. */
-#define MWU_NMIEN_REGION3RA_Disabled (0UL) /*!< Disable */
-#define MWU_NMIEN_REGION3RA_Enabled (1UL) /*!< Enable */
-
-/* Bit 6 : Enable or disable non-maskable interrupt for REGION[3].WA event */
-#define MWU_NMIEN_REGION3WA_Pos (6UL) /*!< Position of REGION3WA field. */
-#define MWU_NMIEN_REGION3WA_Msk (0x1UL << MWU_NMIEN_REGION3WA_Pos) /*!< Bit mask of REGION3WA field. */
-#define MWU_NMIEN_REGION3WA_Disabled (0UL) /*!< Disable */
-#define MWU_NMIEN_REGION3WA_Enabled (1UL) /*!< Enable */
-
-/* Bit 5 : Enable or disable non-maskable interrupt for REGION[2].RA event */
-#define MWU_NMIEN_REGION2RA_Pos (5UL) /*!< Position of REGION2RA field. */
-#define MWU_NMIEN_REGION2RA_Msk (0x1UL << MWU_NMIEN_REGION2RA_Pos) /*!< Bit mask of REGION2RA field. */
-#define MWU_NMIEN_REGION2RA_Disabled (0UL) /*!< Disable */
-#define MWU_NMIEN_REGION2RA_Enabled (1UL) /*!< Enable */
-
-/* Bit 4 : Enable or disable non-maskable interrupt for REGION[2].WA event */
-#define MWU_NMIEN_REGION2WA_Pos (4UL) /*!< Position of REGION2WA field. */
-#define MWU_NMIEN_REGION2WA_Msk (0x1UL << MWU_NMIEN_REGION2WA_Pos) /*!< Bit mask of REGION2WA field. */
-#define MWU_NMIEN_REGION2WA_Disabled (0UL) /*!< Disable */
-#define MWU_NMIEN_REGION2WA_Enabled (1UL) /*!< Enable */
-
-/* Bit 3 : Enable or disable non-maskable interrupt for REGION[1].RA event */
-#define MWU_NMIEN_REGION1RA_Pos (3UL) /*!< Position of REGION1RA field. */
-#define MWU_NMIEN_REGION1RA_Msk (0x1UL << MWU_NMIEN_REGION1RA_Pos) /*!< Bit mask of REGION1RA field. */
-#define MWU_NMIEN_REGION1RA_Disabled (0UL) /*!< Disable */
-#define MWU_NMIEN_REGION1RA_Enabled (1UL) /*!< Enable */
-
-/* Bit 2 : Enable or disable non-maskable interrupt for REGION[1].WA event */
-#define MWU_NMIEN_REGION1WA_Pos (2UL) /*!< Position of REGION1WA field. */
-#define MWU_NMIEN_REGION1WA_Msk (0x1UL << MWU_NMIEN_REGION1WA_Pos) /*!< Bit mask of REGION1WA field. */
-#define MWU_NMIEN_REGION1WA_Disabled (0UL) /*!< Disable */
-#define MWU_NMIEN_REGION1WA_Enabled (1UL) /*!< Enable */
-
-/* Bit 1 : Enable or disable non-maskable interrupt for REGION[0].RA event */
-#define MWU_NMIEN_REGION0RA_Pos (1UL) /*!< Position of REGION0RA field. */
-#define MWU_NMIEN_REGION0RA_Msk (0x1UL << MWU_NMIEN_REGION0RA_Pos) /*!< Bit mask of REGION0RA field. */
-#define MWU_NMIEN_REGION0RA_Disabled (0UL) /*!< Disable */
-#define MWU_NMIEN_REGION0RA_Enabled (1UL) /*!< Enable */
-
-/* Bit 0 : Enable or disable non-maskable interrupt for REGION[0].WA event */
-#define MWU_NMIEN_REGION0WA_Pos (0UL) /*!< Position of REGION0WA field. */
-#define MWU_NMIEN_REGION0WA_Msk (0x1UL << MWU_NMIEN_REGION0WA_Pos) /*!< Bit mask of REGION0WA field. */
-#define MWU_NMIEN_REGION0WA_Disabled (0UL) /*!< Disable */
-#define MWU_NMIEN_REGION0WA_Enabled (1UL) /*!< Enable */
-
-/* Register: MWU_NMIENSET */
-/* Description: Enable non-maskable interrupt */
-
-/* Bit 27 : Write '1' to Enable non-maskable interrupt for PREGION[1].RA event */
-#define MWU_NMIENSET_PREGION1RA_Pos (27UL) /*!< Position of PREGION1RA field. */
-#define MWU_NMIENSET_PREGION1RA_Msk (0x1UL << MWU_NMIENSET_PREGION1RA_Pos) /*!< Bit mask of PREGION1RA field. */
-#define MWU_NMIENSET_PREGION1RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENSET_PREGION1RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENSET_PREGION1RA_Set (1UL) /*!< Enable */
-
-/* Bit 26 : Write '1' to Enable non-maskable interrupt for PREGION[1].WA event */
-#define MWU_NMIENSET_PREGION1WA_Pos (26UL) /*!< Position of PREGION1WA field. */
-#define MWU_NMIENSET_PREGION1WA_Msk (0x1UL << MWU_NMIENSET_PREGION1WA_Pos) /*!< Bit mask of PREGION1WA field. */
-#define MWU_NMIENSET_PREGION1WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENSET_PREGION1WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENSET_PREGION1WA_Set (1UL) /*!< Enable */
-
-/* Bit 25 : Write '1' to Enable non-maskable interrupt for PREGION[0].RA event */
-#define MWU_NMIENSET_PREGION0RA_Pos (25UL) /*!< Position of PREGION0RA field. */
-#define MWU_NMIENSET_PREGION0RA_Msk (0x1UL << MWU_NMIENSET_PREGION0RA_Pos) /*!< Bit mask of PREGION0RA field. */
-#define MWU_NMIENSET_PREGION0RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENSET_PREGION0RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENSET_PREGION0RA_Set (1UL) /*!< Enable */
-
-/* Bit 24 : Write '1' to Enable non-maskable interrupt for PREGION[0].WA event */
-#define MWU_NMIENSET_PREGION0WA_Pos (24UL) /*!< Position of PREGION0WA field. */
-#define MWU_NMIENSET_PREGION0WA_Msk (0x1UL << MWU_NMIENSET_PREGION0WA_Pos) /*!< Bit mask of PREGION0WA field. */
-#define MWU_NMIENSET_PREGION0WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENSET_PREGION0WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENSET_PREGION0WA_Set (1UL) /*!< Enable */
-
-/* Bit 7 : Write '1' to Enable non-maskable interrupt for REGION[3].RA event */
-#define MWU_NMIENSET_REGION3RA_Pos (7UL) /*!< Position of REGION3RA field. */
-#define MWU_NMIENSET_REGION3RA_Msk (0x1UL << MWU_NMIENSET_REGION3RA_Pos) /*!< Bit mask of REGION3RA field. */
-#define MWU_NMIENSET_REGION3RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENSET_REGION3RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENSET_REGION3RA_Set (1UL) /*!< Enable */
-
-/* Bit 6 : Write '1' to Enable non-maskable interrupt for REGION[3].WA event */
-#define MWU_NMIENSET_REGION3WA_Pos (6UL) /*!< Position of REGION3WA field. */
-#define MWU_NMIENSET_REGION3WA_Msk (0x1UL << MWU_NMIENSET_REGION3WA_Pos) /*!< Bit mask of REGION3WA field. */
-#define MWU_NMIENSET_REGION3WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENSET_REGION3WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENSET_REGION3WA_Set (1UL) /*!< Enable */
-
-/* Bit 5 : Write '1' to Enable non-maskable interrupt for REGION[2].RA event */
-#define MWU_NMIENSET_REGION2RA_Pos (5UL) /*!< Position of REGION2RA field. */
-#define MWU_NMIENSET_REGION2RA_Msk (0x1UL << MWU_NMIENSET_REGION2RA_Pos) /*!< Bit mask of REGION2RA field. */
-#define MWU_NMIENSET_REGION2RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENSET_REGION2RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENSET_REGION2RA_Set (1UL) /*!< Enable */
-
-/* Bit 4 : Write '1' to Enable non-maskable interrupt for REGION[2].WA event */
-#define MWU_NMIENSET_REGION2WA_Pos (4UL) /*!< Position of REGION2WA field. */
-#define MWU_NMIENSET_REGION2WA_Msk (0x1UL << MWU_NMIENSET_REGION2WA_Pos) /*!< Bit mask of REGION2WA field. */
-#define MWU_NMIENSET_REGION2WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENSET_REGION2WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENSET_REGION2WA_Set (1UL) /*!< Enable */
-
-/* Bit 3 : Write '1' to Enable non-maskable interrupt for REGION[1].RA event */
-#define MWU_NMIENSET_REGION1RA_Pos (3UL) /*!< Position of REGION1RA field. */
-#define MWU_NMIENSET_REGION1RA_Msk (0x1UL << MWU_NMIENSET_REGION1RA_Pos) /*!< Bit mask of REGION1RA field. */
-#define MWU_NMIENSET_REGION1RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENSET_REGION1RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENSET_REGION1RA_Set (1UL) /*!< Enable */
-
-/* Bit 2 : Write '1' to Enable non-maskable interrupt for REGION[1].WA event */
-#define MWU_NMIENSET_REGION1WA_Pos (2UL) /*!< Position of REGION1WA field. */
-#define MWU_NMIENSET_REGION1WA_Msk (0x1UL << MWU_NMIENSET_REGION1WA_Pos) /*!< Bit mask of REGION1WA field. */
-#define MWU_NMIENSET_REGION1WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENSET_REGION1WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENSET_REGION1WA_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable non-maskable interrupt for REGION[0].RA event */
-#define MWU_NMIENSET_REGION0RA_Pos (1UL) /*!< Position of REGION0RA field. */
-#define MWU_NMIENSET_REGION0RA_Msk (0x1UL << MWU_NMIENSET_REGION0RA_Pos) /*!< Bit mask of REGION0RA field. */
-#define MWU_NMIENSET_REGION0RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENSET_REGION0RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENSET_REGION0RA_Set (1UL) /*!< Enable */
-
-/* Bit 0 : Write '1' to Enable non-maskable interrupt for REGION[0].WA event */
-#define MWU_NMIENSET_REGION0WA_Pos (0UL) /*!< Position of REGION0WA field. */
-#define MWU_NMIENSET_REGION0WA_Msk (0x1UL << MWU_NMIENSET_REGION0WA_Pos) /*!< Bit mask of REGION0WA field. */
-#define MWU_NMIENSET_REGION0WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENSET_REGION0WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENSET_REGION0WA_Set (1UL) /*!< Enable */
-
-/* Register: MWU_NMIENCLR */
-/* Description: Disable non-maskable interrupt */
-
-/* Bit 27 : Write '1' to Disable non-maskable interrupt for PREGION[1].RA event */
-#define MWU_NMIENCLR_PREGION1RA_Pos (27UL) /*!< Position of PREGION1RA field. */
-#define MWU_NMIENCLR_PREGION1RA_Msk (0x1UL << MWU_NMIENCLR_PREGION1RA_Pos) /*!< Bit mask of PREGION1RA field. */
-#define MWU_NMIENCLR_PREGION1RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENCLR_PREGION1RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENCLR_PREGION1RA_Clear (1UL) /*!< Disable */
-
-/* Bit 26 : Write '1' to Disable non-maskable interrupt for PREGION[1].WA event */
-#define MWU_NMIENCLR_PREGION1WA_Pos (26UL) /*!< Position of PREGION1WA field. */
-#define MWU_NMIENCLR_PREGION1WA_Msk (0x1UL << MWU_NMIENCLR_PREGION1WA_Pos) /*!< Bit mask of PREGION1WA field. */
-#define MWU_NMIENCLR_PREGION1WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENCLR_PREGION1WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENCLR_PREGION1WA_Clear (1UL) /*!< Disable */
-
-/* Bit 25 : Write '1' to Disable non-maskable interrupt for PREGION[0].RA event */
-#define MWU_NMIENCLR_PREGION0RA_Pos (25UL) /*!< Position of PREGION0RA field. */
-#define MWU_NMIENCLR_PREGION0RA_Msk (0x1UL << MWU_NMIENCLR_PREGION0RA_Pos) /*!< Bit mask of PREGION0RA field. */
-#define MWU_NMIENCLR_PREGION0RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENCLR_PREGION0RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENCLR_PREGION0RA_Clear (1UL) /*!< Disable */
-
-/* Bit 24 : Write '1' to Disable non-maskable interrupt for PREGION[0].WA event */
-#define MWU_NMIENCLR_PREGION0WA_Pos (24UL) /*!< Position of PREGION0WA field. */
-#define MWU_NMIENCLR_PREGION0WA_Msk (0x1UL << MWU_NMIENCLR_PREGION0WA_Pos) /*!< Bit mask of PREGION0WA field. */
-#define MWU_NMIENCLR_PREGION0WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENCLR_PREGION0WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENCLR_PREGION0WA_Clear (1UL) /*!< Disable */
-
-/* Bit 7 : Write '1' to Disable non-maskable interrupt for REGION[3].RA event */
-#define MWU_NMIENCLR_REGION3RA_Pos (7UL) /*!< Position of REGION3RA field. */
-#define MWU_NMIENCLR_REGION3RA_Msk (0x1UL << MWU_NMIENCLR_REGION3RA_Pos) /*!< Bit mask of REGION3RA field. */
-#define MWU_NMIENCLR_REGION3RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENCLR_REGION3RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENCLR_REGION3RA_Clear (1UL) /*!< Disable */
-
-/* Bit 6 : Write '1' to Disable non-maskable interrupt for REGION[3].WA event */
-#define MWU_NMIENCLR_REGION3WA_Pos (6UL) /*!< Position of REGION3WA field. */
-#define MWU_NMIENCLR_REGION3WA_Msk (0x1UL << MWU_NMIENCLR_REGION3WA_Pos) /*!< Bit mask of REGION3WA field. */
-#define MWU_NMIENCLR_REGION3WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENCLR_REGION3WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENCLR_REGION3WA_Clear (1UL) /*!< Disable */
-
-/* Bit 5 : Write '1' to Disable non-maskable interrupt for REGION[2].RA event */
-#define MWU_NMIENCLR_REGION2RA_Pos (5UL) /*!< Position of REGION2RA field. */
-#define MWU_NMIENCLR_REGION2RA_Msk (0x1UL << MWU_NMIENCLR_REGION2RA_Pos) /*!< Bit mask of REGION2RA field. */
-#define MWU_NMIENCLR_REGION2RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENCLR_REGION2RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENCLR_REGION2RA_Clear (1UL) /*!< Disable */
-
-/* Bit 4 : Write '1' to Disable non-maskable interrupt for REGION[2].WA event */
-#define MWU_NMIENCLR_REGION2WA_Pos (4UL) /*!< Position of REGION2WA field. */
-#define MWU_NMIENCLR_REGION2WA_Msk (0x1UL << MWU_NMIENCLR_REGION2WA_Pos) /*!< Bit mask of REGION2WA field. */
-#define MWU_NMIENCLR_REGION2WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENCLR_REGION2WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENCLR_REGION2WA_Clear (1UL) /*!< Disable */
-
-/* Bit 3 : Write '1' to Disable non-maskable interrupt for REGION[1].RA event */
-#define MWU_NMIENCLR_REGION1RA_Pos (3UL) /*!< Position of REGION1RA field. */
-#define MWU_NMIENCLR_REGION1RA_Msk (0x1UL << MWU_NMIENCLR_REGION1RA_Pos) /*!< Bit mask of REGION1RA field. */
-#define MWU_NMIENCLR_REGION1RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENCLR_REGION1RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENCLR_REGION1RA_Clear (1UL) /*!< Disable */
-
-/* Bit 2 : Write '1' to Disable non-maskable interrupt for REGION[1].WA event */
-#define MWU_NMIENCLR_REGION1WA_Pos (2UL) /*!< Position of REGION1WA field. */
-#define MWU_NMIENCLR_REGION1WA_Msk (0x1UL << MWU_NMIENCLR_REGION1WA_Pos) /*!< Bit mask of REGION1WA field. */
-#define MWU_NMIENCLR_REGION1WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENCLR_REGION1WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENCLR_REGION1WA_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable non-maskable interrupt for REGION[0].RA event */
-#define MWU_NMIENCLR_REGION0RA_Pos (1UL) /*!< Position of REGION0RA field. */
-#define MWU_NMIENCLR_REGION0RA_Msk (0x1UL << MWU_NMIENCLR_REGION0RA_Pos) /*!< Bit mask of REGION0RA field. */
-#define MWU_NMIENCLR_REGION0RA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENCLR_REGION0RA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENCLR_REGION0RA_Clear (1UL) /*!< Disable */
-
-/* Bit 0 : Write '1' to Disable non-maskable interrupt for REGION[0].WA event */
-#define MWU_NMIENCLR_REGION0WA_Pos (0UL) /*!< Position of REGION0WA field. */
-#define MWU_NMIENCLR_REGION0WA_Msk (0x1UL << MWU_NMIENCLR_REGION0WA_Pos) /*!< Bit mask of REGION0WA field. */
-#define MWU_NMIENCLR_REGION0WA_Disabled (0UL) /*!< Read: Disabled */
-#define MWU_NMIENCLR_REGION0WA_Enabled (1UL) /*!< Read: Enabled */
-#define MWU_NMIENCLR_REGION0WA_Clear (1UL) /*!< Disable */
-
-/* Register: MWU_PERREGION_SUBSTATWA */
-/* Description: Description cluster[0]:  Source of event/interrupt in region 0, write access detected while corresponding subregion was enabled for watching */
-
-/* Bit 31 : Subregion 31 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR31_Pos (31UL) /*!< Position of SR31 field. */
-#define MWU_PERREGION_SUBSTATWA_SR31_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR31_Pos) /*!< Bit mask of SR31 field. */
-#define MWU_PERREGION_SUBSTATWA_SR31_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR31_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 30 : Subregion 30 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR30_Pos (30UL) /*!< Position of SR30 field. */
-#define MWU_PERREGION_SUBSTATWA_SR30_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR30_Pos) /*!< Bit mask of SR30 field. */
-#define MWU_PERREGION_SUBSTATWA_SR30_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR30_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 29 : Subregion 29 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR29_Pos (29UL) /*!< Position of SR29 field. */
-#define MWU_PERREGION_SUBSTATWA_SR29_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR29_Pos) /*!< Bit mask of SR29 field. */
-#define MWU_PERREGION_SUBSTATWA_SR29_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR29_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 28 : Subregion 28 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR28_Pos (28UL) /*!< Position of SR28 field. */
-#define MWU_PERREGION_SUBSTATWA_SR28_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR28_Pos) /*!< Bit mask of SR28 field. */
-#define MWU_PERREGION_SUBSTATWA_SR28_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR28_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 27 : Subregion 27 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR27_Pos (27UL) /*!< Position of SR27 field. */
-#define MWU_PERREGION_SUBSTATWA_SR27_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR27_Pos) /*!< Bit mask of SR27 field. */
-#define MWU_PERREGION_SUBSTATWA_SR27_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR27_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 26 : Subregion 26 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR26_Pos (26UL) /*!< Position of SR26 field. */
-#define MWU_PERREGION_SUBSTATWA_SR26_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR26_Pos) /*!< Bit mask of SR26 field. */
-#define MWU_PERREGION_SUBSTATWA_SR26_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR26_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 25 : Subregion 25 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR25_Pos (25UL) /*!< Position of SR25 field. */
-#define MWU_PERREGION_SUBSTATWA_SR25_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR25_Pos) /*!< Bit mask of SR25 field. */
-#define MWU_PERREGION_SUBSTATWA_SR25_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR25_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 24 : Subregion 24 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR24_Pos (24UL) /*!< Position of SR24 field. */
-#define MWU_PERREGION_SUBSTATWA_SR24_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR24_Pos) /*!< Bit mask of SR24 field. */
-#define MWU_PERREGION_SUBSTATWA_SR24_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR24_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 23 : Subregion 23 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR23_Pos (23UL) /*!< Position of SR23 field. */
-#define MWU_PERREGION_SUBSTATWA_SR23_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR23_Pos) /*!< Bit mask of SR23 field. */
-#define MWU_PERREGION_SUBSTATWA_SR23_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR23_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 22 : Subregion 22 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR22_Pos (22UL) /*!< Position of SR22 field. */
-#define MWU_PERREGION_SUBSTATWA_SR22_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR22_Pos) /*!< Bit mask of SR22 field. */
-#define MWU_PERREGION_SUBSTATWA_SR22_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR22_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 21 : Subregion 21 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR21_Pos (21UL) /*!< Position of SR21 field. */
-#define MWU_PERREGION_SUBSTATWA_SR21_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR21_Pos) /*!< Bit mask of SR21 field. */
-#define MWU_PERREGION_SUBSTATWA_SR21_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR21_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 20 : Subregion 20 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR20_Pos (20UL) /*!< Position of SR20 field. */
-#define MWU_PERREGION_SUBSTATWA_SR20_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR20_Pos) /*!< Bit mask of SR20 field. */
-#define MWU_PERREGION_SUBSTATWA_SR20_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR20_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 19 : Subregion 19 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR19_Pos (19UL) /*!< Position of SR19 field. */
-#define MWU_PERREGION_SUBSTATWA_SR19_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR19_Pos) /*!< Bit mask of SR19 field. */
-#define MWU_PERREGION_SUBSTATWA_SR19_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR19_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 18 : Subregion 18 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR18_Pos (18UL) /*!< Position of SR18 field. */
-#define MWU_PERREGION_SUBSTATWA_SR18_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR18_Pos) /*!< Bit mask of SR18 field. */
-#define MWU_PERREGION_SUBSTATWA_SR18_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR18_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 17 : Subregion 17 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR17_Pos (17UL) /*!< Position of SR17 field. */
-#define MWU_PERREGION_SUBSTATWA_SR17_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR17_Pos) /*!< Bit mask of SR17 field. */
-#define MWU_PERREGION_SUBSTATWA_SR17_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR17_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 16 : Subregion 16 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR16_Pos (16UL) /*!< Position of SR16 field. */
-#define MWU_PERREGION_SUBSTATWA_SR16_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR16_Pos) /*!< Bit mask of SR16 field. */
-#define MWU_PERREGION_SUBSTATWA_SR16_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR16_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 15 : Subregion 15 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR15_Pos (15UL) /*!< Position of SR15 field. */
-#define MWU_PERREGION_SUBSTATWA_SR15_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR15_Pos) /*!< Bit mask of SR15 field. */
-#define MWU_PERREGION_SUBSTATWA_SR15_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR15_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 14 : Subregion 14 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR14_Pos (14UL) /*!< Position of SR14 field. */
-#define MWU_PERREGION_SUBSTATWA_SR14_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR14_Pos) /*!< Bit mask of SR14 field. */
-#define MWU_PERREGION_SUBSTATWA_SR14_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR14_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 13 : Subregion 13 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR13_Pos (13UL) /*!< Position of SR13 field. */
-#define MWU_PERREGION_SUBSTATWA_SR13_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR13_Pos) /*!< Bit mask of SR13 field. */
-#define MWU_PERREGION_SUBSTATWA_SR13_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR13_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 12 : Subregion 12 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR12_Pos (12UL) /*!< Position of SR12 field. */
-#define MWU_PERREGION_SUBSTATWA_SR12_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR12_Pos) /*!< Bit mask of SR12 field. */
-#define MWU_PERREGION_SUBSTATWA_SR12_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR12_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 11 : Subregion 11 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR11_Pos (11UL) /*!< Position of SR11 field. */
-#define MWU_PERREGION_SUBSTATWA_SR11_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR11_Pos) /*!< Bit mask of SR11 field. */
-#define MWU_PERREGION_SUBSTATWA_SR11_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR11_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 10 : Subregion 10 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR10_Pos (10UL) /*!< Position of SR10 field. */
-#define MWU_PERREGION_SUBSTATWA_SR10_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR10_Pos) /*!< Bit mask of SR10 field. */
-#define MWU_PERREGION_SUBSTATWA_SR10_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR10_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 9 : Subregion 9 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR9_Pos (9UL) /*!< Position of SR9 field. */
-#define MWU_PERREGION_SUBSTATWA_SR9_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR9_Pos) /*!< Bit mask of SR9 field. */
-#define MWU_PERREGION_SUBSTATWA_SR9_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR9_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 8 : Subregion 8 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR8_Pos (8UL) /*!< Position of SR8 field. */
-#define MWU_PERREGION_SUBSTATWA_SR8_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR8_Pos) /*!< Bit mask of SR8 field. */
-#define MWU_PERREGION_SUBSTATWA_SR8_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR8_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 7 : Subregion 7 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR7_Pos (7UL) /*!< Position of SR7 field. */
-#define MWU_PERREGION_SUBSTATWA_SR7_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR7_Pos) /*!< Bit mask of SR7 field. */
-#define MWU_PERREGION_SUBSTATWA_SR7_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR7_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 6 : Subregion 6 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR6_Pos (6UL) /*!< Position of SR6 field. */
-#define MWU_PERREGION_SUBSTATWA_SR6_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR6_Pos) /*!< Bit mask of SR6 field. */
-#define MWU_PERREGION_SUBSTATWA_SR6_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR6_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 5 : Subregion 5 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR5_Pos (5UL) /*!< Position of SR5 field. */
-#define MWU_PERREGION_SUBSTATWA_SR5_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR5_Pos) /*!< Bit mask of SR5 field. */
-#define MWU_PERREGION_SUBSTATWA_SR5_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR5_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 4 : Subregion 4 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR4_Pos (4UL) /*!< Position of SR4 field. */
-#define MWU_PERREGION_SUBSTATWA_SR4_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR4_Pos) /*!< Bit mask of SR4 field. */
-#define MWU_PERREGION_SUBSTATWA_SR4_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR4_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 3 : Subregion 3 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR3_Pos (3UL) /*!< Position of SR3 field. */
-#define MWU_PERREGION_SUBSTATWA_SR3_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR3_Pos) /*!< Bit mask of SR3 field. */
-#define MWU_PERREGION_SUBSTATWA_SR3_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR3_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 2 : Subregion 2 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR2_Pos (2UL) /*!< Position of SR2 field. */
-#define MWU_PERREGION_SUBSTATWA_SR2_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR2_Pos) /*!< Bit mask of SR2 field. */
-#define MWU_PERREGION_SUBSTATWA_SR2_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR2_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 1 : Subregion 1 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR1_Pos (1UL) /*!< Position of SR1 field. */
-#define MWU_PERREGION_SUBSTATWA_SR1_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR1_Pos) /*!< Bit mask of SR1 field. */
-#define MWU_PERREGION_SUBSTATWA_SR1_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR1_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Bit 0 : Subregion 0 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATWA_SR0_Pos (0UL) /*!< Position of SR0 field. */
-#define MWU_PERREGION_SUBSTATWA_SR0_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR0_Pos) /*!< Bit mask of SR0 field. */
-#define MWU_PERREGION_SUBSTATWA_SR0_NoAccess (0UL) /*!< No write access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATWA_SR0_Access (1UL) /*!< Write access(es) occurred in this subregion */
-
-/* Register: MWU_PERREGION_SUBSTATRA */
-/* Description: Description cluster[0]:  Source of event/interrupt in region 0, read access detected while corresponding subregion was enabled for watching */
-
-/* Bit 31 : Subregion 31 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR31_Pos (31UL) /*!< Position of SR31 field. */
-#define MWU_PERREGION_SUBSTATRA_SR31_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR31_Pos) /*!< Bit mask of SR31 field. */
-#define MWU_PERREGION_SUBSTATRA_SR31_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR31_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 30 : Subregion 30 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR30_Pos (30UL) /*!< Position of SR30 field. */
-#define MWU_PERREGION_SUBSTATRA_SR30_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR30_Pos) /*!< Bit mask of SR30 field. */
-#define MWU_PERREGION_SUBSTATRA_SR30_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR30_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 29 : Subregion 29 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR29_Pos (29UL) /*!< Position of SR29 field. */
-#define MWU_PERREGION_SUBSTATRA_SR29_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR29_Pos) /*!< Bit mask of SR29 field. */
-#define MWU_PERREGION_SUBSTATRA_SR29_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR29_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 28 : Subregion 28 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR28_Pos (28UL) /*!< Position of SR28 field. */
-#define MWU_PERREGION_SUBSTATRA_SR28_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR28_Pos) /*!< Bit mask of SR28 field. */
-#define MWU_PERREGION_SUBSTATRA_SR28_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR28_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 27 : Subregion 27 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR27_Pos (27UL) /*!< Position of SR27 field. */
-#define MWU_PERREGION_SUBSTATRA_SR27_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR27_Pos) /*!< Bit mask of SR27 field. */
-#define MWU_PERREGION_SUBSTATRA_SR27_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR27_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 26 : Subregion 26 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR26_Pos (26UL) /*!< Position of SR26 field. */
-#define MWU_PERREGION_SUBSTATRA_SR26_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR26_Pos) /*!< Bit mask of SR26 field. */
-#define MWU_PERREGION_SUBSTATRA_SR26_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR26_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 25 : Subregion 25 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR25_Pos (25UL) /*!< Position of SR25 field. */
-#define MWU_PERREGION_SUBSTATRA_SR25_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR25_Pos) /*!< Bit mask of SR25 field. */
-#define MWU_PERREGION_SUBSTATRA_SR25_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR25_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 24 : Subregion 24 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR24_Pos (24UL) /*!< Position of SR24 field. */
-#define MWU_PERREGION_SUBSTATRA_SR24_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR24_Pos) /*!< Bit mask of SR24 field. */
-#define MWU_PERREGION_SUBSTATRA_SR24_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR24_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 23 : Subregion 23 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR23_Pos (23UL) /*!< Position of SR23 field. */
-#define MWU_PERREGION_SUBSTATRA_SR23_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR23_Pos) /*!< Bit mask of SR23 field. */
-#define MWU_PERREGION_SUBSTATRA_SR23_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR23_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 22 : Subregion 22 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR22_Pos (22UL) /*!< Position of SR22 field. */
-#define MWU_PERREGION_SUBSTATRA_SR22_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR22_Pos) /*!< Bit mask of SR22 field. */
-#define MWU_PERREGION_SUBSTATRA_SR22_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR22_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 21 : Subregion 21 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR21_Pos (21UL) /*!< Position of SR21 field. */
-#define MWU_PERREGION_SUBSTATRA_SR21_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR21_Pos) /*!< Bit mask of SR21 field. */
-#define MWU_PERREGION_SUBSTATRA_SR21_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR21_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 20 : Subregion 20 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR20_Pos (20UL) /*!< Position of SR20 field. */
-#define MWU_PERREGION_SUBSTATRA_SR20_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR20_Pos) /*!< Bit mask of SR20 field. */
-#define MWU_PERREGION_SUBSTATRA_SR20_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR20_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 19 : Subregion 19 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR19_Pos (19UL) /*!< Position of SR19 field. */
-#define MWU_PERREGION_SUBSTATRA_SR19_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR19_Pos) /*!< Bit mask of SR19 field. */
-#define MWU_PERREGION_SUBSTATRA_SR19_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR19_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 18 : Subregion 18 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR18_Pos (18UL) /*!< Position of SR18 field. */
-#define MWU_PERREGION_SUBSTATRA_SR18_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR18_Pos) /*!< Bit mask of SR18 field. */
-#define MWU_PERREGION_SUBSTATRA_SR18_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR18_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 17 : Subregion 17 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR17_Pos (17UL) /*!< Position of SR17 field. */
-#define MWU_PERREGION_SUBSTATRA_SR17_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR17_Pos) /*!< Bit mask of SR17 field. */
-#define MWU_PERREGION_SUBSTATRA_SR17_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR17_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 16 : Subregion 16 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR16_Pos (16UL) /*!< Position of SR16 field. */
-#define MWU_PERREGION_SUBSTATRA_SR16_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR16_Pos) /*!< Bit mask of SR16 field. */
-#define MWU_PERREGION_SUBSTATRA_SR16_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR16_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 15 : Subregion 15 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR15_Pos (15UL) /*!< Position of SR15 field. */
-#define MWU_PERREGION_SUBSTATRA_SR15_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR15_Pos) /*!< Bit mask of SR15 field. */
-#define MWU_PERREGION_SUBSTATRA_SR15_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR15_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 14 : Subregion 14 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR14_Pos (14UL) /*!< Position of SR14 field. */
-#define MWU_PERREGION_SUBSTATRA_SR14_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR14_Pos) /*!< Bit mask of SR14 field. */
-#define MWU_PERREGION_SUBSTATRA_SR14_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR14_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 13 : Subregion 13 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR13_Pos (13UL) /*!< Position of SR13 field. */
-#define MWU_PERREGION_SUBSTATRA_SR13_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR13_Pos) /*!< Bit mask of SR13 field. */
-#define MWU_PERREGION_SUBSTATRA_SR13_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR13_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 12 : Subregion 12 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR12_Pos (12UL) /*!< Position of SR12 field. */
-#define MWU_PERREGION_SUBSTATRA_SR12_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR12_Pos) /*!< Bit mask of SR12 field. */
-#define MWU_PERREGION_SUBSTATRA_SR12_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR12_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 11 : Subregion 11 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR11_Pos (11UL) /*!< Position of SR11 field. */
-#define MWU_PERREGION_SUBSTATRA_SR11_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR11_Pos) /*!< Bit mask of SR11 field. */
-#define MWU_PERREGION_SUBSTATRA_SR11_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR11_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 10 : Subregion 10 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR10_Pos (10UL) /*!< Position of SR10 field. */
-#define MWU_PERREGION_SUBSTATRA_SR10_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR10_Pos) /*!< Bit mask of SR10 field. */
-#define MWU_PERREGION_SUBSTATRA_SR10_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR10_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 9 : Subregion 9 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR9_Pos (9UL) /*!< Position of SR9 field. */
-#define MWU_PERREGION_SUBSTATRA_SR9_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR9_Pos) /*!< Bit mask of SR9 field. */
-#define MWU_PERREGION_SUBSTATRA_SR9_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR9_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 8 : Subregion 8 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR8_Pos (8UL) /*!< Position of SR8 field. */
-#define MWU_PERREGION_SUBSTATRA_SR8_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR8_Pos) /*!< Bit mask of SR8 field. */
-#define MWU_PERREGION_SUBSTATRA_SR8_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR8_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 7 : Subregion 7 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR7_Pos (7UL) /*!< Position of SR7 field. */
-#define MWU_PERREGION_SUBSTATRA_SR7_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR7_Pos) /*!< Bit mask of SR7 field. */
-#define MWU_PERREGION_SUBSTATRA_SR7_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR7_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 6 : Subregion 6 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR6_Pos (6UL) /*!< Position of SR6 field. */
-#define MWU_PERREGION_SUBSTATRA_SR6_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR6_Pos) /*!< Bit mask of SR6 field. */
-#define MWU_PERREGION_SUBSTATRA_SR6_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR6_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 5 : Subregion 5 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR5_Pos (5UL) /*!< Position of SR5 field. */
-#define MWU_PERREGION_SUBSTATRA_SR5_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR5_Pos) /*!< Bit mask of SR5 field. */
-#define MWU_PERREGION_SUBSTATRA_SR5_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR5_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 4 : Subregion 4 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR4_Pos (4UL) /*!< Position of SR4 field. */
-#define MWU_PERREGION_SUBSTATRA_SR4_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR4_Pos) /*!< Bit mask of SR4 field. */
-#define MWU_PERREGION_SUBSTATRA_SR4_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR4_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 3 : Subregion 3 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR3_Pos (3UL) /*!< Position of SR3 field. */
-#define MWU_PERREGION_SUBSTATRA_SR3_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR3_Pos) /*!< Bit mask of SR3 field. */
-#define MWU_PERREGION_SUBSTATRA_SR3_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR3_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 2 : Subregion 2 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR2_Pos (2UL) /*!< Position of SR2 field. */
-#define MWU_PERREGION_SUBSTATRA_SR2_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR2_Pos) /*!< Bit mask of SR2 field. */
-#define MWU_PERREGION_SUBSTATRA_SR2_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR2_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 1 : Subregion 1 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR1_Pos (1UL) /*!< Position of SR1 field. */
-#define MWU_PERREGION_SUBSTATRA_SR1_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR1_Pos) /*!< Bit mask of SR1 field. */
-#define MWU_PERREGION_SUBSTATRA_SR1_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR1_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Bit 0 : Subregion 0 in region 0 (write '1' to clear) */
-#define MWU_PERREGION_SUBSTATRA_SR0_Pos (0UL) /*!< Position of SR0 field. */
-#define MWU_PERREGION_SUBSTATRA_SR0_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR0_Pos) /*!< Bit mask of SR0 field. */
-#define MWU_PERREGION_SUBSTATRA_SR0_NoAccess (0UL) /*!< No read access occurred in this subregion */
-#define MWU_PERREGION_SUBSTATRA_SR0_Access (1UL) /*!< Read access(es) occurred in this subregion */
-
-/* Register: MWU_REGIONEN */
-/* Description: Enable/disable regions watch */
-
-/* Bit 27 : Enable/disable read access watch in PREGION[1] */
-#define MWU_REGIONEN_PRGN1RA_Pos (27UL) /*!< Position of PRGN1RA field. */
-#define MWU_REGIONEN_PRGN1RA_Msk (0x1UL << MWU_REGIONEN_PRGN1RA_Pos) /*!< Bit mask of PRGN1RA field. */
-#define MWU_REGIONEN_PRGN1RA_Disable (0UL) /*!< Disable read access watch in this PREGION */
-#define MWU_REGIONEN_PRGN1RA_Enable (1UL) /*!< Enable read access watch in this PREGION */
-
-/* Bit 26 : Enable/disable write access watch in PREGION[1] */
-#define MWU_REGIONEN_PRGN1WA_Pos (26UL) /*!< Position of PRGN1WA field. */
-#define MWU_REGIONEN_PRGN1WA_Msk (0x1UL << MWU_REGIONEN_PRGN1WA_Pos) /*!< Bit mask of PRGN1WA field. */
-#define MWU_REGIONEN_PRGN1WA_Disable (0UL) /*!< Disable write access watch in this PREGION */
-#define MWU_REGIONEN_PRGN1WA_Enable (1UL) /*!< Enable write access watch in this PREGION */
-
-/* Bit 25 : Enable/disable read access watch in PREGION[0] */
-#define MWU_REGIONEN_PRGN0RA_Pos (25UL) /*!< Position of PRGN0RA field. */
-#define MWU_REGIONEN_PRGN0RA_Msk (0x1UL << MWU_REGIONEN_PRGN0RA_Pos) /*!< Bit mask of PRGN0RA field. */
-#define MWU_REGIONEN_PRGN0RA_Disable (0UL) /*!< Disable read access watch in this PREGION */
-#define MWU_REGIONEN_PRGN0RA_Enable (1UL) /*!< Enable read access watch in this PREGION */
-
-/* Bit 24 : Enable/disable write access watch in PREGION[0] */
-#define MWU_REGIONEN_PRGN0WA_Pos (24UL) /*!< Position of PRGN0WA field. */
-#define MWU_REGIONEN_PRGN0WA_Msk (0x1UL << MWU_REGIONEN_PRGN0WA_Pos) /*!< Bit mask of PRGN0WA field. */
-#define MWU_REGIONEN_PRGN0WA_Disable (0UL) /*!< Disable write access watch in this PREGION */
-#define MWU_REGIONEN_PRGN0WA_Enable (1UL) /*!< Enable write access watch in this PREGION */
-
-/* Bit 7 : Enable/disable read access watch in region[3] */
-#define MWU_REGIONEN_RGN3RA_Pos (7UL) /*!< Position of RGN3RA field. */
-#define MWU_REGIONEN_RGN3RA_Msk (0x1UL << MWU_REGIONEN_RGN3RA_Pos) /*!< Bit mask of RGN3RA field. */
-#define MWU_REGIONEN_RGN3RA_Disable (0UL) /*!< Disable read access watch in this region */
-#define MWU_REGIONEN_RGN3RA_Enable (1UL) /*!< Enable read access watch in this region */
-
-/* Bit 6 : Enable/disable write access watch in region[3] */
-#define MWU_REGIONEN_RGN3WA_Pos (6UL) /*!< Position of RGN3WA field. */
-#define MWU_REGIONEN_RGN3WA_Msk (0x1UL << MWU_REGIONEN_RGN3WA_Pos) /*!< Bit mask of RGN3WA field. */
-#define MWU_REGIONEN_RGN3WA_Disable (0UL) /*!< Disable write access watch in this region */
-#define MWU_REGIONEN_RGN3WA_Enable (1UL) /*!< Enable write access watch in this region */
-
-/* Bit 5 : Enable/disable read access watch in region[2] */
-#define MWU_REGIONEN_RGN2RA_Pos (5UL) /*!< Position of RGN2RA field. */
-#define MWU_REGIONEN_RGN2RA_Msk (0x1UL << MWU_REGIONEN_RGN2RA_Pos) /*!< Bit mask of RGN2RA field. */
-#define MWU_REGIONEN_RGN2RA_Disable (0UL) /*!< Disable read access watch in this region */
-#define MWU_REGIONEN_RGN2RA_Enable (1UL) /*!< Enable read access watch in this region */
-
-/* Bit 4 : Enable/disable write access watch in region[2] */
-#define MWU_REGIONEN_RGN2WA_Pos (4UL) /*!< Position of RGN2WA field. */
-#define MWU_REGIONEN_RGN2WA_Msk (0x1UL << MWU_REGIONEN_RGN2WA_Pos) /*!< Bit mask of RGN2WA field. */
-#define MWU_REGIONEN_RGN2WA_Disable (0UL) /*!< Disable write access watch in this region */
-#define MWU_REGIONEN_RGN2WA_Enable (1UL) /*!< Enable write access watch in this region */
-
-/* Bit 3 : Enable/disable read access watch in region[1] */
-#define MWU_REGIONEN_RGN1RA_Pos (3UL) /*!< Position of RGN1RA field. */
-#define MWU_REGIONEN_RGN1RA_Msk (0x1UL << MWU_REGIONEN_RGN1RA_Pos) /*!< Bit mask of RGN1RA field. */
-#define MWU_REGIONEN_RGN1RA_Disable (0UL) /*!< Disable read access watch in this region */
-#define MWU_REGIONEN_RGN1RA_Enable (1UL) /*!< Enable read access watch in this region */
-
-/* Bit 2 : Enable/disable write access watch in region[1] */
-#define MWU_REGIONEN_RGN1WA_Pos (2UL) /*!< Position of RGN1WA field. */
-#define MWU_REGIONEN_RGN1WA_Msk (0x1UL << MWU_REGIONEN_RGN1WA_Pos) /*!< Bit mask of RGN1WA field. */
-#define MWU_REGIONEN_RGN1WA_Disable (0UL) /*!< Disable write access watch in this region */
-#define MWU_REGIONEN_RGN1WA_Enable (1UL) /*!< Enable write access watch in this region */
-
-/* Bit 1 : Enable/disable read access watch in region[0] */
-#define MWU_REGIONEN_RGN0RA_Pos (1UL) /*!< Position of RGN0RA field. */
-#define MWU_REGIONEN_RGN0RA_Msk (0x1UL << MWU_REGIONEN_RGN0RA_Pos) /*!< Bit mask of RGN0RA field. */
-#define MWU_REGIONEN_RGN0RA_Disable (0UL) /*!< Disable read access watch in this region */
-#define MWU_REGIONEN_RGN0RA_Enable (1UL) /*!< Enable read access watch in this region */
-
-/* Bit 0 : Enable/disable write access watch in region[0] */
-#define MWU_REGIONEN_RGN0WA_Pos (0UL) /*!< Position of RGN0WA field. */
-#define MWU_REGIONEN_RGN0WA_Msk (0x1UL << MWU_REGIONEN_RGN0WA_Pos) /*!< Bit mask of RGN0WA field. */
-#define MWU_REGIONEN_RGN0WA_Disable (0UL) /*!< Disable write access watch in this region */
-#define MWU_REGIONEN_RGN0WA_Enable (1UL) /*!< Enable write access watch in this region */
-
-/* Register: MWU_REGIONENSET */
-/* Description: Enable regions watch */
-
-/* Bit 27 : Enable read access watch in PREGION[1] */
-#define MWU_REGIONENSET_PRGN1RA_Pos (27UL) /*!< Position of PRGN1RA field. */
-#define MWU_REGIONENSET_PRGN1RA_Msk (0x1UL << MWU_REGIONENSET_PRGN1RA_Pos) /*!< Bit mask of PRGN1RA field. */
-#define MWU_REGIONENSET_PRGN1RA_Disabled (0UL) /*!< Read access watch in this PREGION is disabled */
-#define MWU_REGIONENSET_PRGN1RA_Enabled (1UL) /*!< Read access watch in this PREGION is enabled */
-#define MWU_REGIONENSET_PRGN1RA_Set (1UL) /*!< Enable read access watch in this PREGION */
-
-/* Bit 26 : Enable write access watch in PREGION[1] */
-#define MWU_REGIONENSET_PRGN1WA_Pos (26UL) /*!< Position of PRGN1WA field. */
-#define MWU_REGIONENSET_PRGN1WA_Msk (0x1UL << MWU_REGIONENSET_PRGN1WA_Pos) /*!< Bit mask of PRGN1WA field. */
-#define MWU_REGIONENSET_PRGN1WA_Disabled (0UL) /*!< Write access watch in this PREGION is disabled */
-#define MWU_REGIONENSET_PRGN1WA_Enabled (1UL) /*!< Write access watch in this PREGION is enabled */
-#define MWU_REGIONENSET_PRGN1WA_Set (1UL) /*!< Enable write access watch in this PREGION */
-
-/* Bit 25 : Enable read access watch in PREGION[0] */
-#define MWU_REGIONENSET_PRGN0RA_Pos (25UL) /*!< Position of PRGN0RA field. */
-#define MWU_REGIONENSET_PRGN0RA_Msk (0x1UL << MWU_REGIONENSET_PRGN0RA_Pos) /*!< Bit mask of PRGN0RA field. */
-#define MWU_REGIONENSET_PRGN0RA_Disabled (0UL) /*!< Read access watch in this PREGION is disabled */
-#define MWU_REGIONENSET_PRGN0RA_Enabled (1UL) /*!< Read access watch in this PREGION is enabled */
-#define MWU_REGIONENSET_PRGN0RA_Set (1UL) /*!< Enable read access watch in this PREGION */
-
-/* Bit 24 : Enable write access watch in PREGION[0] */
-#define MWU_REGIONENSET_PRGN0WA_Pos (24UL) /*!< Position of PRGN0WA field. */
-#define MWU_REGIONENSET_PRGN0WA_Msk (0x1UL << MWU_REGIONENSET_PRGN0WA_Pos) /*!< Bit mask of PRGN0WA field. */
-#define MWU_REGIONENSET_PRGN0WA_Disabled (0UL) /*!< Write access watch in this PREGION is disabled */
-#define MWU_REGIONENSET_PRGN0WA_Enabled (1UL) /*!< Write access watch in this PREGION is enabled */
-#define MWU_REGIONENSET_PRGN0WA_Set (1UL) /*!< Enable write access watch in this PREGION */
-
-/* Bit 7 : Enable read access watch in region[3] */
-#define MWU_REGIONENSET_RGN3RA_Pos (7UL) /*!< Position of RGN3RA field. */
-#define MWU_REGIONENSET_RGN3RA_Msk (0x1UL << MWU_REGIONENSET_RGN3RA_Pos) /*!< Bit mask of RGN3RA field. */
-#define MWU_REGIONENSET_RGN3RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
-#define MWU_REGIONENSET_RGN3RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
-#define MWU_REGIONENSET_RGN3RA_Set (1UL) /*!< Enable read access watch in this region */
-
-/* Bit 6 : Enable write access watch in region[3] */
-#define MWU_REGIONENSET_RGN3WA_Pos (6UL) /*!< Position of RGN3WA field. */
-#define MWU_REGIONENSET_RGN3WA_Msk (0x1UL << MWU_REGIONENSET_RGN3WA_Pos) /*!< Bit mask of RGN3WA field. */
-#define MWU_REGIONENSET_RGN3WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
-#define MWU_REGIONENSET_RGN3WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
-#define MWU_REGIONENSET_RGN3WA_Set (1UL) /*!< Enable write access watch in this region */
-
-/* Bit 5 : Enable read access watch in region[2] */
-#define MWU_REGIONENSET_RGN2RA_Pos (5UL) /*!< Position of RGN2RA field. */
-#define MWU_REGIONENSET_RGN2RA_Msk (0x1UL << MWU_REGIONENSET_RGN2RA_Pos) /*!< Bit mask of RGN2RA field. */
-#define MWU_REGIONENSET_RGN2RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
-#define MWU_REGIONENSET_RGN2RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
-#define MWU_REGIONENSET_RGN2RA_Set (1UL) /*!< Enable read access watch in this region */
-
-/* Bit 4 : Enable write access watch in region[2] */
-#define MWU_REGIONENSET_RGN2WA_Pos (4UL) /*!< Position of RGN2WA field. */
-#define MWU_REGIONENSET_RGN2WA_Msk (0x1UL << MWU_REGIONENSET_RGN2WA_Pos) /*!< Bit mask of RGN2WA field. */
-#define MWU_REGIONENSET_RGN2WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
-#define MWU_REGIONENSET_RGN2WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
-#define MWU_REGIONENSET_RGN2WA_Set (1UL) /*!< Enable write access watch in this region */
-
-/* Bit 3 : Enable read access watch in region[1] */
-#define MWU_REGIONENSET_RGN1RA_Pos (3UL) /*!< Position of RGN1RA field. */
-#define MWU_REGIONENSET_RGN1RA_Msk (0x1UL << MWU_REGIONENSET_RGN1RA_Pos) /*!< Bit mask of RGN1RA field. */
-#define MWU_REGIONENSET_RGN1RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
-#define MWU_REGIONENSET_RGN1RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
-#define MWU_REGIONENSET_RGN1RA_Set (1UL) /*!< Enable read access watch in this region */
-
-/* Bit 2 : Enable write access watch in region[1] */
-#define MWU_REGIONENSET_RGN1WA_Pos (2UL) /*!< Position of RGN1WA field. */
-#define MWU_REGIONENSET_RGN1WA_Msk (0x1UL << MWU_REGIONENSET_RGN1WA_Pos) /*!< Bit mask of RGN1WA field. */
-#define MWU_REGIONENSET_RGN1WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
-#define MWU_REGIONENSET_RGN1WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
-#define MWU_REGIONENSET_RGN1WA_Set (1UL) /*!< Enable write access watch in this region */
-
-/* Bit 1 : Enable read access watch in region[0] */
-#define MWU_REGIONENSET_RGN0RA_Pos (1UL) /*!< Position of RGN0RA field. */
-#define MWU_REGIONENSET_RGN0RA_Msk (0x1UL << MWU_REGIONENSET_RGN0RA_Pos) /*!< Bit mask of RGN0RA field. */
-#define MWU_REGIONENSET_RGN0RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
-#define MWU_REGIONENSET_RGN0RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
-#define MWU_REGIONENSET_RGN0RA_Set (1UL) /*!< Enable read access watch in this region */
-
-/* Bit 0 : Enable write access watch in region[0] */
-#define MWU_REGIONENSET_RGN0WA_Pos (0UL) /*!< Position of RGN0WA field. */
-#define MWU_REGIONENSET_RGN0WA_Msk (0x1UL << MWU_REGIONENSET_RGN0WA_Pos) /*!< Bit mask of RGN0WA field. */
-#define MWU_REGIONENSET_RGN0WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
-#define MWU_REGIONENSET_RGN0WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
-#define MWU_REGIONENSET_RGN0WA_Set (1UL) /*!< Enable write access watch in this region */
-
-/* Register: MWU_REGIONENCLR */
-/* Description: Disable regions watch */
-
-/* Bit 27 : Disable read access watch in PREGION[1] */
-#define MWU_REGIONENCLR_PRGN1RA_Pos (27UL) /*!< Position of PRGN1RA field. */
-#define MWU_REGIONENCLR_PRGN1RA_Msk (0x1UL << MWU_REGIONENCLR_PRGN1RA_Pos) /*!< Bit mask of PRGN1RA field. */
-#define MWU_REGIONENCLR_PRGN1RA_Disabled (0UL) /*!< Read access watch in this PREGION is disabled */
-#define MWU_REGIONENCLR_PRGN1RA_Enabled (1UL) /*!< Read access watch in this PREGION is enabled */
-#define MWU_REGIONENCLR_PRGN1RA_Clear (1UL) /*!< Disable read access watch in this PREGION */
-
-/* Bit 26 : Disable write access watch in PREGION[1] */
-#define MWU_REGIONENCLR_PRGN1WA_Pos (26UL) /*!< Position of PRGN1WA field. */
-#define MWU_REGIONENCLR_PRGN1WA_Msk (0x1UL << MWU_REGIONENCLR_PRGN1WA_Pos) /*!< Bit mask of PRGN1WA field. */
-#define MWU_REGIONENCLR_PRGN1WA_Disabled (0UL) /*!< Write access watch in this PREGION is disabled */
-#define MWU_REGIONENCLR_PRGN1WA_Enabled (1UL) /*!< Write access watch in this PREGION is enabled */
-#define MWU_REGIONENCLR_PRGN1WA_Clear (1UL) /*!< Disable write access watch in this PREGION */
-
-/* Bit 25 : Disable read access watch in PREGION[0] */
-#define MWU_REGIONENCLR_PRGN0RA_Pos (25UL) /*!< Position of PRGN0RA field. */
-#define MWU_REGIONENCLR_PRGN0RA_Msk (0x1UL << MWU_REGIONENCLR_PRGN0RA_Pos) /*!< Bit mask of PRGN0RA field. */
-#define MWU_REGIONENCLR_PRGN0RA_Disabled (0UL) /*!< Read access watch in this PREGION is disabled */
-#define MWU_REGIONENCLR_PRGN0RA_Enabled (1UL) /*!< Read access watch in this PREGION is enabled */
-#define MWU_REGIONENCLR_PRGN0RA_Clear (1UL) /*!< Disable read access watch in this PREGION */
-
-/* Bit 24 : Disable write access watch in PREGION[0] */
-#define MWU_REGIONENCLR_PRGN0WA_Pos (24UL) /*!< Position of PRGN0WA field. */
-#define MWU_REGIONENCLR_PRGN0WA_Msk (0x1UL << MWU_REGIONENCLR_PRGN0WA_Pos) /*!< Bit mask of PRGN0WA field. */
-#define MWU_REGIONENCLR_PRGN0WA_Disabled (0UL) /*!< Write access watch in this PREGION is disabled */
-#define MWU_REGIONENCLR_PRGN0WA_Enabled (1UL) /*!< Write access watch in this PREGION is enabled */
-#define MWU_REGIONENCLR_PRGN0WA_Clear (1UL) /*!< Disable write access watch in this PREGION */
-
-/* Bit 7 : Disable read access watch in region[3] */
-#define MWU_REGIONENCLR_RGN3RA_Pos (7UL) /*!< Position of RGN3RA field. */
-#define MWU_REGIONENCLR_RGN3RA_Msk (0x1UL << MWU_REGIONENCLR_RGN3RA_Pos) /*!< Bit mask of RGN3RA field. */
-#define MWU_REGIONENCLR_RGN3RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
-#define MWU_REGIONENCLR_RGN3RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
-#define MWU_REGIONENCLR_RGN3RA_Clear (1UL) /*!< Disable read access watch in this region */
-
-/* Bit 6 : Disable write access watch in region[3] */
-#define MWU_REGIONENCLR_RGN3WA_Pos (6UL) /*!< Position of RGN3WA field. */
-#define MWU_REGIONENCLR_RGN3WA_Msk (0x1UL << MWU_REGIONENCLR_RGN3WA_Pos) /*!< Bit mask of RGN3WA field. */
-#define MWU_REGIONENCLR_RGN3WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
-#define MWU_REGIONENCLR_RGN3WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
-#define MWU_REGIONENCLR_RGN3WA_Clear (1UL) /*!< Disable write access watch in this region */
-
-/* Bit 5 : Disable read access watch in region[2] */
-#define MWU_REGIONENCLR_RGN2RA_Pos (5UL) /*!< Position of RGN2RA field. */
-#define MWU_REGIONENCLR_RGN2RA_Msk (0x1UL << MWU_REGIONENCLR_RGN2RA_Pos) /*!< Bit mask of RGN2RA field. */
-#define MWU_REGIONENCLR_RGN2RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
-#define MWU_REGIONENCLR_RGN2RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
-#define MWU_REGIONENCLR_RGN2RA_Clear (1UL) /*!< Disable read access watch in this region */
-
-/* Bit 4 : Disable write access watch in region[2] */
-#define MWU_REGIONENCLR_RGN2WA_Pos (4UL) /*!< Position of RGN2WA field. */
-#define MWU_REGIONENCLR_RGN2WA_Msk (0x1UL << MWU_REGIONENCLR_RGN2WA_Pos) /*!< Bit mask of RGN2WA field. */
-#define MWU_REGIONENCLR_RGN2WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
-#define MWU_REGIONENCLR_RGN2WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
-#define MWU_REGIONENCLR_RGN2WA_Clear (1UL) /*!< Disable write access watch in this region */
-
-/* Bit 3 : Disable read access watch in region[1] */
-#define MWU_REGIONENCLR_RGN1RA_Pos (3UL) /*!< Position of RGN1RA field. */
-#define MWU_REGIONENCLR_RGN1RA_Msk (0x1UL << MWU_REGIONENCLR_RGN1RA_Pos) /*!< Bit mask of RGN1RA field. */
-#define MWU_REGIONENCLR_RGN1RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
-#define MWU_REGIONENCLR_RGN1RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
-#define MWU_REGIONENCLR_RGN1RA_Clear (1UL) /*!< Disable read access watch in this region */
-
-/* Bit 2 : Disable write access watch in region[1] */
-#define MWU_REGIONENCLR_RGN1WA_Pos (2UL) /*!< Position of RGN1WA field. */
-#define MWU_REGIONENCLR_RGN1WA_Msk (0x1UL << MWU_REGIONENCLR_RGN1WA_Pos) /*!< Bit mask of RGN1WA field. */
-#define MWU_REGIONENCLR_RGN1WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
-#define MWU_REGIONENCLR_RGN1WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
-#define MWU_REGIONENCLR_RGN1WA_Clear (1UL) /*!< Disable write access watch in this region */
-
-/* Bit 1 : Disable read access watch in region[0] */
-#define MWU_REGIONENCLR_RGN0RA_Pos (1UL) /*!< Position of RGN0RA field. */
-#define MWU_REGIONENCLR_RGN0RA_Msk (0x1UL << MWU_REGIONENCLR_RGN0RA_Pos) /*!< Bit mask of RGN0RA field. */
-#define MWU_REGIONENCLR_RGN0RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
-#define MWU_REGIONENCLR_RGN0RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
-#define MWU_REGIONENCLR_RGN0RA_Clear (1UL) /*!< Disable read access watch in this region */
-
-/* Bit 0 : Disable write access watch in region[0] */
-#define MWU_REGIONENCLR_RGN0WA_Pos (0UL) /*!< Position of RGN0WA field. */
-#define MWU_REGIONENCLR_RGN0WA_Msk (0x1UL << MWU_REGIONENCLR_RGN0WA_Pos) /*!< Bit mask of RGN0WA field. */
-#define MWU_REGIONENCLR_RGN0WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
-#define MWU_REGIONENCLR_RGN0WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
-#define MWU_REGIONENCLR_RGN0WA_Clear (1UL) /*!< Disable write access watch in this region */
-
-/* Register: MWU_REGION_START */
-/* Description: Description cluster[0]:  Start address for region 0 */
-
-/* Bits 31..0 : Start address for region */
-#define MWU_REGION_START_START_Pos (0UL) /*!< Position of START field. */
-#define MWU_REGION_START_START_Msk (0xFFFFFFFFUL << MWU_REGION_START_START_Pos) /*!< Bit mask of START field. */
-
-/* Register: MWU_REGION_END */
-/* Description: Description cluster[0]:  End address of region 0 */
-
-/* Bits 31..0 : End address of region. */
-#define MWU_REGION_END_END_Pos (0UL) /*!< Position of END field. */
-#define MWU_REGION_END_END_Msk (0xFFFFFFFFUL << MWU_REGION_END_END_Pos) /*!< Bit mask of END field. */
-
-/* Register: MWU_PREGION_START */
-/* Description: Description cluster[0]:  Reserved for future use */
-
-/* Bits 31..0 : Reserved for future use */
-#define MWU_PREGION_START_START_Pos (0UL) /*!< Position of START field. */
-#define MWU_PREGION_START_START_Msk (0xFFFFFFFFUL << MWU_PREGION_START_START_Pos) /*!< Bit mask of START field. */
-
-/* Register: MWU_PREGION_END */
-/* Description: Description cluster[0]:  Reserved for future use */
-
-/* Bits 31..0 : Reserved for future use */
-#define MWU_PREGION_END_END_Pos (0UL) /*!< Position of END field. */
-#define MWU_PREGION_END_END_Msk (0xFFFFFFFFUL << MWU_PREGION_END_END_Pos) /*!< Bit mask of END field. */
-
-/* Register: MWU_PREGION_SUBS */
-/* Description: Description cluster[0]:  Subregions of region 0 */
-
-/* Bit 31 : Include or exclude subregion 31 in region */
-#define MWU_PREGION_SUBS_SR31_Pos (31UL) /*!< Position of SR31 field. */
-#define MWU_PREGION_SUBS_SR31_Msk (0x1UL << MWU_PREGION_SUBS_SR31_Pos) /*!< Bit mask of SR31 field. */
-#define MWU_PREGION_SUBS_SR31_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR31_Include (1UL) /*!< Include */
-
-/* Bit 30 : Include or exclude subregion 30 in region */
-#define MWU_PREGION_SUBS_SR30_Pos (30UL) /*!< Position of SR30 field. */
-#define MWU_PREGION_SUBS_SR30_Msk (0x1UL << MWU_PREGION_SUBS_SR30_Pos) /*!< Bit mask of SR30 field. */
-#define MWU_PREGION_SUBS_SR30_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR30_Include (1UL) /*!< Include */
-
-/* Bit 29 : Include or exclude subregion 29 in region */
-#define MWU_PREGION_SUBS_SR29_Pos (29UL) /*!< Position of SR29 field. */
-#define MWU_PREGION_SUBS_SR29_Msk (0x1UL << MWU_PREGION_SUBS_SR29_Pos) /*!< Bit mask of SR29 field. */
-#define MWU_PREGION_SUBS_SR29_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR29_Include (1UL) /*!< Include */
-
-/* Bit 28 : Include or exclude subregion 28 in region */
-#define MWU_PREGION_SUBS_SR28_Pos (28UL) /*!< Position of SR28 field. */
-#define MWU_PREGION_SUBS_SR28_Msk (0x1UL << MWU_PREGION_SUBS_SR28_Pos) /*!< Bit mask of SR28 field. */
-#define MWU_PREGION_SUBS_SR28_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR28_Include (1UL) /*!< Include */
-
-/* Bit 27 : Include or exclude subregion 27 in region */
-#define MWU_PREGION_SUBS_SR27_Pos (27UL) /*!< Position of SR27 field. */
-#define MWU_PREGION_SUBS_SR27_Msk (0x1UL << MWU_PREGION_SUBS_SR27_Pos) /*!< Bit mask of SR27 field. */
-#define MWU_PREGION_SUBS_SR27_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR27_Include (1UL) /*!< Include */
-
-/* Bit 26 : Include or exclude subregion 26 in region */
-#define MWU_PREGION_SUBS_SR26_Pos (26UL) /*!< Position of SR26 field. */
-#define MWU_PREGION_SUBS_SR26_Msk (0x1UL << MWU_PREGION_SUBS_SR26_Pos) /*!< Bit mask of SR26 field. */
-#define MWU_PREGION_SUBS_SR26_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR26_Include (1UL) /*!< Include */
-
-/* Bit 25 : Include or exclude subregion 25 in region */
-#define MWU_PREGION_SUBS_SR25_Pos (25UL) /*!< Position of SR25 field. */
-#define MWU_PREGION_SUBS_SR25_Msk (0x1UL << MWU_PREGION_SUBS_SR25_Pos) /*!< Bit mask of SR25 field. */
-#define MWU_PREGION_SUBS_SR25_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR25_Include (1UL) /*!< Include */
-
-/* Bit 24 : Include or exclude subregion 24 in region */
-#define MWU_PREGION_SUBS_SR24_Pos (24UL) /*!< Position of SR24 field. */
-#define MWU_PREGION_SUBS_SR24_Msk (0x1UL << MWU_PREGION_SUBS_SR24_Pos) /*!< Bit mask of SR24 field. */
-#define MWU_PREGION_SUBS_SR24_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR24_Include (1UL) /*!< Include */
-
-/* Bit 23 : Include or exclude subregion 23 in region */
-#define MWU_PREGION_SUBS_SR23_Pos (23UL) /*!< Position of SR23 field. */
-#define MWU_PREGION_SUBS_SR23_Msk (0x1UL << MWU_PREGION_SUBS_SR23_Pos) /*!< Bit mask of SR23 field. */
-#define MWU_PREGION_SUBS_SR23_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR23_Include (1UL) /*!< Include */
-
-/* Bit 22 : Include or exclude subregion 22 in region */
-#define MWU_PREGION_SUBS_SR22_Pos (22UL) /*!< Position of SR22 field. */
-#define MWU_PREGION_SUBS_SR22_Msk (0x1UL << MWU_PREGION_SUBS_SR22_Pos) /*!< Bit mask of SR22 field. */
-#define MWU_PREGION_SUBS_SR22_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR22_Include (1UL) /*!< Include */
-
-/* Bit 21 : Include or exclude subregion 21 in region */
-#define MWU_PREGION_SUBS_SR21_Pos (21UL) /*!< Position of SR21 field. */
-#define MWU_PREGION_SUBS_SR21_Msk (0x1UL << MWU_PREGION_SUBS_SR21_Pos) /*!< Bit mask of SR21 field. */
-#define MWU_PREGION_SUBS_SR21_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR21_Include (1UL) /*!< Include */
-
-/* Bit 20 : Include or exclude subregion 20 in region */
-#define MWU_PREGION_SUBS_SR20_Pos (20UL) /*!< Position of SR20 field. */
-#define MWU_PREGION_SUBS_SR20_Msk (0x1UL << MWU_PREGION_SUBS_SR20_Pos) /*!< Bit mask of SR20 field. */
-#define MWU_PREGION_SUBS_SR20_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR20_Include (1UL) /*!< Include */
-
-/* Bit 19 : Include or exclude subregion 19 in region */
-#define MWU_PREGION_SUBS_SR19_Pos (19UL) /*!< Position of SR19 field. */
-#define MWU_PREGION_SUBS_SR19_Msk (0x1UL << MWU_PREGION_SUBS_SR19_Pos) /*!< Bit mask of SR19 field. */
-#define MWU_PREGION_SUBS_SR19_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR19_Include (1UL) /*!< Include */
-
-/* Bit 18 : Include or exclude subregion 18 in region */
-#define MWU_PREGION_SUBS_SR18_Pos (18UL) /*!< Position of SR18 field. */
-#define MWU_PREGION_SUBS_SR18_Msk (0x1UL << MWU_PREGION_SUBS_SR18_Pos) /*!< Bit mask of SR18 field. */
-#define MWU_PREGION_SUBS_SR18_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR18_Include (1UL) /*!< Include */
-
-/* Bit 17 : Include or exclude subregion 17 in region */
-#define MWU_PREGION_SUBS_SR17_Pos (17UL) /*!< Position of SR17 field. */
-#define MWU_PREGION_SUBS_SR17_Msk (0x1UL << MWU_PREGION_SUBS_SR17_Pos) /*!< Bit mask of SR17 field. */
-#define MWU_PREGION_SUBS_SR17_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR17_Include (1UL) /*!< Include */
-
-/* Bit 16 : Include or exclude subregion 16 in region */
-#define MWU_PREGION_SUBS_SR16_Pos (16UL) /*!< Position of SR16 field. */
-#define MWU_PREGION_SUBS_SR16_Msk (0x1UL << MWU_PREGION_SUBS_SR16_Pos) /*!< Bit mask of SR16 field. */
-#define MWU_PREGION_SUBS_SR16_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR16_Include (1UL) /*!< Include */
-
-/* Bit 15 : Include or exclude subregion 15 in region */
-#define MWU_PREGION_SUBS_SR15_Pos (15UL) /*!< Position of SR15 field. */
-#define MWU_PREGION_SUBS_SR15_Msk (0x1UL << MWU_PREGION_SUBS_SR15_Pos) /*!< Bit mask of SR15 field. */
-#define MWU_PREGION_SUBS_SR15_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR15_Include (1UL) /*!< Include */
-
-/* Bit 14 : Include or exclude subregion 14 in region */
-#define MWU_PREGION_SUBS_SR14_Pos (14UL) /*!< Position of SR14 field. */
-#define MWU_PREGION_SUBS_SR14_Msk (0x1UL << MWU_PREGION_SUBS_SR14_Pos) /*!< Bit mask of SR14 field. */
-#define MWU_PREGION_SUBS_SR14_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR14_Include (1UL) /*!< Include */
-
-/* Bit 13 : Include or exclude subregion 13 in region */
-#define MWU_PREGION_SUBS_SR13_Pos (13UL) /*!< Position of SR13 field. */
-#define MWU_PREGION_SUBS_SR13_Msk (0x1UL << MWU_PREGION_SUBS_SR13_Pos) /*!< Bit mask of SR13 field. */
-#define MWU_PREGION_SUBS_SR13_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR13_Include (1UL) /*!< Include */
-
-/* Bit 12 : Include or exclude subregion 12 in region */
-#define MWU_PREGION_SUBS_SR12_Pos (12UL) /*!< Position of SR12 field. */
-#define MWU_PREGION_SUBS_SR12_Msk (0x1UL << MWU_PREGION_SUBS_SR12_Pos) /*!< Bit mask of SR12 field. */
-#define MWU_PREGION_SUBS_SR12_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR12_Include (1UL) /*!< Include */
-
-/* Bit 11 : Include or exclude subregion 11 in region */
-#define MWU_PREGION_SUBS_SR11_Pos (11UL) /*!< Position of SR11 field. */
-#define MWU_PREGION_SUBS_SR11_Msk (0x1UL << MWU_PREGION_SUBS_SR11_Pos) /*!< Bit mask of SR11 field. */
-#define MWU_PREGION_SUBS_SR11_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR11_Include (1UL) /*!< Include */
-
-/* Bit 10 : Include or exclude subregion 10 in region */
-#define MWU_PREGION_SUBS_SR10_Pos (10UL) /*!< Position of SR10 field. */
-#define MWU_PREGION_SUBS_SR10_Msk (0x1UL << MWU_PREGION_SUBS_SR10_Pos) /*!< Bit mask of SR10 field. */
-#define MWU_PREGION_SUBS_SR10_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR10_Include (1UL) /*!< Include */
-
-/* Bit 9 : Include or exclude subregion 9 in region */
-#define MWU_PREGION_SUBS_SR9_Pos (9UL) /*!< Position of SR9 field. */
-#define MWU_PREGION_SUBS_SR9_Msk (0x1UL << MWU_PREGION_SUBS_SR9_Pos) /*!< Bit mask of SR9 field. */
-#define MWU_PREGION_SUBS_SR9_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR9_Include (1UL) /*!< Include */
-
-/* Bit 8 : Include or exclude subregion 8 in region */
-#define MWU_PREGION_SUBS_SR8_Pos (8UL) /*!< Position of SR8 field. */
-#define MWU_PREGION_SUBS_SR8_Msk (0x1UL << MWU_PREGION_SUBS_SR8_Pos) /*!< Bit mask of SR8 field. */
-#define MWU_PREGION_SUBS_SR8_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR8_Include (1UL) /*!< Include */
-
-/* Bit 7 : Include or exclude subregion 7 in region */
-#define MWU_PREGION_SUBS_SR7_Pos (7UL) /*!< Position of SR7 field. */
-#define MWU_PREGION_SUBS_SR7_Msk (0x1UL << MWU_PREGION_SUBS_SR7_Pos) /*!< Bit mask of SR7 field. */
-#define MWU_PREGION_SUBS_SR7_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR7_Include (1UL) /*!< Include */
-
-/* Bit 6 : Include or exclude subregion 6 in region */
-#define MWU_PREGION_SUBS_SR6_Pos (6UL) /*!< Position of SR6 field. */
-#define MWU_PREGION_SUBS_SR6_Msk (0x1UL << MWU_PREGION_SUBS_SR6_Pos) /*!< Bit mask of SR6 field. */
-#define MWU_PREGION_SUBS_SR6_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR6_Include (1UL) /*!< Include */
-
-/* Bit 5 : Include or exclude subregion 5 in region */
-#define MWU_PREGION_SUBS_SR5_Pos (5UL) /*!< Position of SR5 field. */
-#define MWU_PREGION_SUBS_SR5_Msk (0x1UL << MWU_PREGION_SUBS_SR5_Pos) /*!< Bit mask of SR5 field. */
-#define MWU_PREGION_SUBS_SR5_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR5_Include (1UL) /*!< Include */
-
-/* Bit 4 : Include or exclude subregion 4 in region */
-#define MWU_PREGION_SUBS_SR4_Pos (4UL) /*!< Position of SR4 field. */
-#define MWU_PREGION_SUBS_SR4_Msk (0x1UL << MWU_PREGION_SUBS_SR4_Pos) /*!< Bit mask of SR4 field. */
-#define MWU_PREGION_SUBS_SR4_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR4_Include (1UL) /*!< Include */
-
-/* Bit 3 : Include or exclude subregion 3 in region */
-#define MWU_PREGION_SUBS_SR3_Pos (3UL) /*!< Position of SR3 field. */
-#define MWU_PREGION_SUBS_SR3_Msk (0x1UL << MWU_PREGION_SUBS_SR3_Pos) /*!< Bit mask of SR3 field. */
-#define MWU_PREGION_SUBS_SR3_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR3_Include (1UL) /*!< Include */
-
-/* Bit 2 : Include or exclude subregion 2 in region */
-#define MWU_PREGION_SUBS_SR2_Pos (2UL) /*!< Position of SR2 field. */
-#define MWU_PREGION_SUBS_SR2_Msk (0x1UL << MWU_PREGION_SUBS_SR2_Pos) /*!< Bit mask of SR2 field. */
-#define MWU_PREGION_SUBS_SR2_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR2_Include (1UL) /*!< Include */
-
-/* Bit 1 : Include or exclude subregion 1 in region */
-#define MWU_PREGION_SUBS_SR1_Pos (1UL) /*!< Position of SR1 field. */
-#define MWU_PREGION_SUBS_SR1_Msk (0x1UL << MWU_PREGION_SUBS_SR1_Pos) /*!< Bit mask of SR1 field. */
-#define MWU_PREGION_SUBS_SR1_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR1_Include (1UL) /*!< Include */
-
-/* Bit 0 : Include or exclude subregion 0 in region */
-#define MWU_PREGION_SUBS_SR0_Pos (0UL) /*!< Position of SR0 field. */
-#define MWU_PREGION_SUBS_SR0_Msk (0x1UL << MWU_PREGION_SUBS_SR0_Pos) /*!< Bit mask of SR0 field. */
-#define MWU_PREGION_SUBS_SR0_Exclude (0UL) /*!< Exclude */
-#define MWU_PREGION_SUBS_SR0_Include (1UL) /*!< Include */
-
-
-/* Peripheral: NFCT */
-/* Description: NFC-A compatible radio */
-
-/* Register: NFCT_SHORTS */
-/* Description: Shortcut register */
-
-/* Bit 1 : Shortcut between FIELDLOST event and SENSE task */
-#define NFCT_SHORTS_FIELDLOST_SENSE_Pos (1UL) /*!< Position of FIELDLOST_SENSE field. */
-#define NFCT_SHORTS_FIELDLOST_SENSE_Msk (0x1UL << NFCT_SHORTS_FIELDLOST_SENSE_Pos) /*!< Bit mask of FIELDLOST_SENSE field. */
-#define NFCT_SHORTS_FIELDLOST_SENSE_Disabled (0UL) /*!< Disable shortcut */
-#define NFCT_SHORTS_FIELDLOST_SENSE_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 0 : Shortcut between FIELDDETECTED event and ACTIVATE task */
-#define NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Pos (0UL) /*!< Position of FIELDDETECTED_ACTIVATE field. */
-#define NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Msk (0x1UL << NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Pos) /*!< Bit mask of FIELDDETECTED_ACTIVATE field. */
-#define NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Disabled (0UL) /*!< Disable shortcut */
-#define NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Enabled (1UL) /*!< Enable shortcut */
-
-/* Register: NFCT_INTEN */
-/* Description: Enable or disable interrupt */
-
-/* Bit 20 : Enable or disable interrupt for STARTED event */
-#define NFCT_INTEN_STARTED_Pos (20UL) /*!< Position of STARTED field. */
-#define NFCT_INTEN_STARTED_Msk (0x1UL << NFCT_INTEN_STARTED_Pos) /*!< Bit mask of STARTED field. */
-#define NFCT_INTEN_STARTED_Disabled (0UL) /*!< Disable */
-#define NFCT_INTEN_STARTED_Enabled (1UL) /*!< Enable */
-
-/* Bit 19 : Enable or disable interrupt for SELECTED event */
-#define NFCT_INTEN_SELECTED_Pos (19UL) /*!< Position of SELECTED field. */
-#define NFCT_INTEN_SELECTED_Msk (0x1UL << NFCT_INTEN_SELECTED_Pos) /*!< Bit mask of SELECTED field. */
-#define NFCT_INTEN_SELECTED_Disabled (0UL) /*!< Disable */
-#define NFCT_INTEN_SELECTED_Enabled (1UL) /*!< Enable */
-
-/* Bit 18 : Enable or disable interrupt for COLLISION event */
-#define NFCT_INTEN_COLLISION_Pos (18UL) /*!< Position of COLLISION field. */
-#define NFCT_INTEN_COLLISION_Msk (0x1UL << NFCT_INTEN_COLLISION_Pos) /*!< Bit mask of COLLISION field. */
-#define NFCT_INTEN_COLLISION_Disabled (0UL) /*!< Disable */
-#define NFCT_INTEN_COLLISION_Enabled (1UL) /*!< Enable */
-
-/* Bit 14 : Enable or disable interrupt for AUTOCOLRESSTARTED event */
-#define NFCT_INTEN_AUTOCOLRESSTARTED_Pos (14UL) /*!< Position of AUTOCOLRESSTARTED field. */
-#define NFCT_INTEN_AUTOCOLRESSTARTED_Msk (0x1UL << NFCT_INTEN_AUTOCOLRESSTARTED_Pos) /*!< Bit mask of AUTOCOLRESSTARTED field. */
-#define NFCT_INTEN_AUTOCOLRESSTARTED_Disabled (0UL) /*!< Disable */
-#define NFCT_INTEN_AUTOCOLRESSTARTED_Enabled (1UL) /*!< Enable */
-
-/* Bit 12 : Enable or disable interrupt for ENDTX event */
-#define NFCT_INTEN_ENDTX_Pos (12UL) /*!< Position of ENDTX field. */
-#define NFCT_INTEN_ENDTX_Msk (0x1UL << NFCT_INTEN_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
-#define NFCT_INTEN_ENDTX_Disabled (0UL) /*!< Disable */
-#define NFCT_INTEN_ENDTX_Enabled (1UL) /*!< Enable */
-
-/* Bit 11 : Enable or disable interrupt for ENDRX event */
-#define NFCT_INTEN_ENDRX_Pos (11UL) /*!< Position of ENDRX field. */
-#define NFCT_INTEN_ENDRX_Msk (0x1UL << NFCT_INTEN_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
-#define NFCT_INTEN_ENDRX_Disabled (0UL) /*!< Disable */
-#define NFCT_INTEN_ENDRX_Enabled (1UL) /*!< Enable */
-
-/* Bit 10 : Enable or disable interrupt for RXERROR event */
-#define NFCT_INTEN_RXERROR_Pos (10UL) /*!< Position of RXERROR field. */
-#define NFCT_INTEN_RXERROR_Msk (0x1UL << NFCT_INTEN_RXERROR_Pos) /*!< Bit mask of RXERROR field. */
-#define NFCT_INTEN_RXERROR_Disabled (0UL) /*!< Disable */
-#define NFCT_INTEN_RXERROR_Enabled (1UL) /*!< Enable */
-
-/* Bit 7 : Enable or disable interrupt for ERROR event */
-#define NFCT_INTEN_ERROR_Pos (7UL) /*!< Position of ERROR field. */
-#define NFCT_INTEN_ERROR_Msk (0x1UL << NFCT_INTEN_ERROR_Pos) /*!< Bit mask of ERROR field. */
-#define NFCT_INTEN_ERROR_Disabled (0UL) /*!< Disable */
-#define NFCT_INTEN_ERROR_Enabled (1UL) /*!< Enable */
-
-/* Bit 6 : Enable or disable interrupt for RXFRAMEEND event */
-#define NFCT_INTEN_RXFRAMEEND_Pos (6UL) /*!< Position of RXFRAMEEND field. */
-#define NFCT_INTEN_RXFRAMEEND_Msk (0x1UL << NFCT_INTEN_RXFRAMEEND_Pos) /*!< Bit mask of RXFRAMEEND field. */
-#define NFCT_INTEN_RXFRAMEEND_Disabled (0UL) /*!< Disable */
-#define NFCT_INTEN_RXFRAMEEND_Enabled (1UL) /*!< Enable */
-
-/* Bit 5 : Enable or disable interrupt for RXFRAMESTART event */
-#define NFCT_INTEN_RXFRAMESTART_Pos (5UL) /*!< Position of RXFRAMESTART field. */
-#define NFCT_INTEN_RXFRAMESTART_Msk (0x1UL << NFCT_INTEN_RXFRAMESTART_Pos) /*!< Bit mask of RXFRAMESTART field. */
-#define NFCT_INTEN_RXFRAMESTART_Disabled (0UL) /*!< Disable */
-#define NFCT_INTEN_RXFRAMESTART_Enabled (1UL) /*!< Enable */
-
-/* Bit 4 : Enable or disable interrupt for TXFRAMEEND event */
-#define NFCT_INTEN_TXFRAMEEND_Pos (4UL) /*!< Position of TXFRAMEEND field. */
-#define NFCT_INTEN_TXFRAMEEND_Msk (0x1UL << NFCT_INTEN_TXFRAMEEND_Pos) /*!< Bit mask of TXFRAMEEND field. */
-#define NFCT_INTEN_TXFRAMEEND_Disabled (0UL) /*!< Disable */
-#define NFCT_INTEN_TXFRAMEEND_Enabled (1UL) /*!< Enable */
-
-/* Bit 3 : Enable or disable interrupt for TXFRAMESTART event */
-#define NFCT_INTEN_TXFRAMESTART_Pos (3UL) /*!< Position of TXFRAMESTART field. */
-#define NFCT_INTEN_TXFRAMESTART_Msk (0x1UL << NFCT_INTEN_TXFRAMESTART_Pos) /*!< Bit mask of TXFRAMESTART field. */
-#define NFCT_INTEN_TXFRAMESTART_Disabled (0UL) /*!< Disable */
-#define NFCT_INTEN_TXFRAMESTART_Enabled (1UL) /*!< Enable */
-
-/* Bit 2 : Enable or disable interrupt for FIELDLOST event */
-#define NFCT_INTEN_FIELDLOST_Pos (2UL) /*!< Position of FIELDLOST field. */
-#define NFCT_INTEN_FIELDLOST_Msk (0x1UL << NFCT_INTEN_FIELDLOST_Pos) /*!< Bit mask of FIELDLOST field. */
-#define NFCT_INTEN_FIELDLOST_Disabled (0UL) /*!< Disable */
-#define NFCT_INTEN_FIELDLOST_Enabled (1UL) /*!< Enable */
-
-/* Bit 1 : Enable or disable interrupt for FIELDDETECTED event */
-#define NFCT_INTEN_FIELDDETECTED_Pos (1UL) /*!< Position of FIELDDETECTED field. */
-#define NFCT_INTEN_FIELDDETECTED_Msk (0x1UL << NFCT_INTEN_FIELDDETECTED_Pos) /*!< Bit mask of FIELDDETECTED field. */
-#define NFCT_INTEN_FIELDDETECTED_Disabled (0UL) /*!< Disable */
-#define NFCT_INTEN_FIELDDETECTED_Enabled (1UL) /*!< Enable */
-
-/* Bit 0 : Enable or disable interrupt for READY event */
-#define NFCT_INTEN_READY_Pos (0UL) /*!< Position of READY field. */
-#define NFCT_INTEN_READY_Msk (0x1UL << NFCT_INTEN_READY_Pos) /*!< Bit mask of READY field. */
-#define NFCT_INTEN_READY_Disabled (0UL) /*!< Disable */
-#define NFCT_INTEN_READY_Enabled (1UL) /*!< Enable */
-
-/* Register: NFCT_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 20 : Write '1' to Enable interrupt for STARTED event */
-#define NFCT_INTENSET_STARTED_Pos (20UL) /*!< Position of STARTED field. */
-#define NFCT_INTENSET_STARTED_Msk (0x1UL << NFCT_INTENSET_STARTED_Pos) /*!< Bit mask of STARTED field. */
-#define NFCT_INTENSET_STARTED_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENSET_STARTED_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENSET_STARTED_Set (1UL) /*!< Enable */
-
-/* Bit 19 : Write '1' to Enable interrupt for SELECTED event */
-#define NFCT_INTENSET_SELECTED_Pos (19UL) /*!< Position of SELECTED field. */
-#define NFCT_INTENSET_SELECTED_Msk (0x1UL << NFCT_INTENSET_SELECTED_Pos) /*!< Bit mask of SELECTED field. */
-#define NFCT_INTENSET_SELECTED_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENSET_SELECTED_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENSET_SELECTED_Set (1UL) /*!< Enable */
-
-/* Bit 18 : Write '1' to Enable interrupt for COLLISION event */
-#define NFCT_INTENSET_COLLISION_Pos (18UL) /*!< Position of COLLISION field. */
-#define NFCT_INTENSET_COLLISION_Msk (0x1UL << NFCT_INTENSET_COLLISION_Pos) /*!< Bit mask of COLLISION field. */
-#define NFCT_INTENSET_COLLISION_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENSET_COLLISION_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENSET_COLLISION_Set (1UL) /*!< Enable */
-
-/* Bit 14 : Write '1' to Enable interrupt for AUTOCOLRESSTARTED event */
-#define NFCT_INTENSET_AUTOCOLRESSTARTED_Pos (14UL) /*!< Position of AUTOCOLRESSTARTED field. */
-#define NFCT_INTENSET_AUTOCOLRESSTARTED_Msk (0x1UL << NFCT_INTENSET_AUTOCOLRESSTARTED_Pos) /*!< Bit mask of AUTOCOLRESSTARTED field. */
-#define NFCT_INTENSET_AUTOCOLRESSTARTED_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENSET_AUTOCOLRESSTARTED_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENSET_AUTOCOLRESSTARTED_Set (1UL) /*!< Enable */
-
-/* Bit 12 : Write '1' to Enable interrupt for ENDTX event */
-#define NFCT_INTENSET_ENDTX_Pos (12UL) /*!< Position of ENDTX field. */
-#define NFCT_INTENSET_ENDTX_Msk (0x1UL << NFCT_INTENSET_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
-#define NFCT_INTENSET_ENDTX_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENSET_ENDTX_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENSET_ENDTX_Set (1UL) /*!< Enable */
-
-/* Bit 11 : Write '1' to Enable interrupt for ENDRX event */
-#define NFCT_INTENSET_ENDRX_Pos (11UL) /*!< Position of ENDRX field. */
-#define NFCT_INTENSET_ENDRX_Msk (0x1UL << NFCT_INTENSET_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
-#define NFCT_INTENSET_ENDRX_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENSET_ENDRX_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENSET_ENDRX_Set (1UL) /*!< Enable */
-
-/* Bit 10 : Write '1' to Enable interrupt for RXERROR event */
-#define NFCT_INTENSET_RXERROR_Pos (10UL) /*!< Position of RXERROR field. */
-#define NFCT_INTENSET_RXERROR_Msk (0x1UL << NFCT_INTENSET_RXERROR_Pos) /*!< Bit mask of RXERROR field. */
-#define NFCT_INTENSET_RXERROR_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENSET_RXERROR_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENSET_RXERROR_Set (1UL) /*!< Enable */
-
-/* Bit 7 : Write '1' to Enable interrupt for ERROR event */
-#define NFCT_INTENSET_ERROR_Pos (7UL) /*!< Position of ERROR field. */
-#define NFCT_INTENSET_ERROR_Msk (0x1UL << NFCT_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
-#define NFCT_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENSET_ERROR_Set (1UL) /*!< Enable */
-
-/* Bit 6 : Write '1' to Enable interrupt for RXFRAMEEND event */
-#define NFCT_INTENSET_RXFRAMEEND_Pos (6UL) /*!< Position of RXFRAMEEND field. */
-#define NFCT_INTENSET_RXFRAMEEND_Msk (0x1UL << NFCT_INTENSET_RXFRAMEEND_Pos) /*!< Bit mask of RXFRAMEEND field. */
-#define NFCT_INTENSET_RXFRAMEEND_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENSET_RXFRAMEEND_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENSET_RXFRAMEEND_Set (1UL) /*!< Enable */
-
-/* Bit 5 : Write '1' to Enable interrupt for RXFRAMESTART event */
-#define NFCT_INTENSET_RXFRAMESTART_Pos (5UL) /*!< Position of RXFRAMESTART field. */
-#define NFCT_INTENSET_RXFRAMESTART_Msk (0x1UL << NFCT_INTENSET_RXFRAMESTART_Pos) /*!< Bit mask of RXFRAMESTART field. */
-#define NFCT_INTENSET_RXFRAMESTART_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENSET_RXFRAMESTART_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENSET_RXFRAMESTART_Set (1UL) /*!< Enable */
-
-/* Bit 4 : Write '1' to Enable interrupt for TXFRAMEEND event */
-#define NFCT_INTENSET_TXFRAMEEND_Pos (4UL) /*!< Position of TXFRAMEEND field. */
-#define NFCT_INTENSET_TXFRAMEEND_Msk (0x1UL << NFCT_INTENSET_TXFRAMEEND_Pos) /*!< Bit mask of TXFRAMEEND field. */
-#define NFCT_INTENSET_TXFRAMEEND_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENSET_TXFRAMEEND_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENSET_TXFRAMEEND_Set (1UL) /*!< Enable */
-
-/* Bit 3 : Write '1' to Enable interrupt for TXFRAMESTART event */
-#define NFCT_INTENSET_TXFRAMESTART_Pos (3UL) /*!< Position of TXFRAMESTART field. */
-#define NFCT_INTENSET_TXFRAMESTART_Msk (0x1UL << NFCT_INTENSET_TXFRAMESTART_Pos) /*!< Bit mask of TXFRAMESTART field. */
-#define NFCT_INTENSET_TXFRAMESTART_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENSET_TXFRAMESTART_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENSET_TXFRAMESTART_Set (1UL) /*!< Enable */
-
-/* Bit 2 : Write '1' to Enable interrupt for FIELDLOST event */
-#define NFCT_INTENSET_FIELDLOST_Pos (2UL) /*!< Position of FIELDLOST field. */
-#define NFCT_INTENSET_FIELDLOST_Msk (0x1UL << NFCT_INTENSET_FIELDLOST_Pos) /*!< Bit mask of FIELDLOST field. */
-#define NFCT_INTENSET_FIELDLOST_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENSET_FIELDLOST_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENSET_FIELDLOST_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for FIELDDETECTED event */
-#define NFCT_INTENSET_FIELDDETECTED_Pos (1UL) /*!< Position of FIELDDETECTED field. */
-#define NFCT_INTENSET_FIELDDETECTED_Msk (0x1UL << NFCT_INTENSET_FIELDDETECTED_Pos) /*!< Bit mask of FIELDDETECTED field. */
-#define NFCT_INTENSET_FIELDDETECTED_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENSET_FIELDDETECTED_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENSET_FIELDDETECTED_Set (1UL) /*!< Enable */
-
-/* Bit 0 : Write '1' to Enable interrupt for READY event */
-#define NFCT_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
-#define NFCT_INTENSET_READY_Msk (0x1UL << NFCT_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
-#define NFCT_INTENSET_READY_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENSET_READY_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENSET_READY_Set (1UL) /*!< Enable */
-
-/* Register: NFCT_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 20 : Write '1' to Disable interrupt for STARTED event */
-#define NFCT_INTENCLR_STARTED_Pos (20UL) /*!< Position of STARTED field. */
-#define NFCT_INTENCLR_STARTED_Msk (0x1UL << NFCT_INTENCLR_STARTED_Pos) /*!< Bit mask of STARTED field. */
-#define NFCT_INTENCLR_STARTED_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENCLR_STARTED_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENCLR_STARTED_Clear (1UL) /*!< Disable */
-
-/* Bit 19 : Write '1' to Disable interrupt for SELECTED event */
-#define NFCT_INTENCLR_SELECTED_Pos (19UL) /*!< Position of SELECTED field. */
-#define NFCT_INTENCLR_SELECTED_Msk (0x1UL << NFCT_INTENCLR_SELECTED_Pos) /*!< Bit mask of SELECTED field. */
-#define NFCT_INTENCLR_SELECTED_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENCLR_SELECTED_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENCLR_SELECTED_Clear (1UL) /*!< Disable */
-
-/* Bit 18 : Write '1' to Disable interrupt for COLLISION event */
-#define NFCT_INTENCLR_COLLISION_Pos (18UL) /*!< Position of COLLISION field. */
-#define NFCT_INTENCLR_COLLISION_Msk (0x1UL << NFCT_INTENCLR_COLLISION_Pos) /*!< Bit mask of COLLISION field. */
-#define NFCT_INTENCLR_COLLISION_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENCLR_COLLISION_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENCLR_COLLISION_Clear (1UL) /*!< Disable */
-
-/* Bit 14 : Write '1' to Disable interrupt for AUTOCOLRESSTARTED event */
-#define NFCT_INTENCLR_AUTOCOLRESSTARTED_Pos (14UL) /*!< Position of AUTOCOLRESSTARTED field. */
-#define NFCT_INTENCLR_AUTOCOLRESSTARTED_Msk (0x1UL << NFCT_INTENCLR_AUTOCOLRESSTARTED_Pos) /*!< Bit mask of AUTOCOLRESSTARTED field. */
-#define NFCT_INTENCLR_AUTOCOLRESSTARTED_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENCLR_AUTOCOLRESSTARTED_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENCLR_AUTOCOLRESSTARTED_Clear (1UL) /*!< Disable */
-
-/* Bit 12 : Write '1' to Disable interrupt for ENDTX event */
-#define NFCT_INTENCLR_ENDTX_Pos (12UL) /*!< Position of ENDTX field. */
-#define NFCT_INTENCLR_ENDTX_Msk (0x1UL << NFCT_INTENCLR_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
-#define NFCT_INTENCLR_ENDTX_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENCLR_ENDTX_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENCLR_ENDTX_Clear (1UL) /*!< Disable */
-
-/* Bit 11 : Write '1' to Disable interrupt for ENDRX event */
-#define NFCT_INTENCLR_ENDRX_Pos (11UL) /*!< Position of ENDRX field. */
-#define NFCT_INTENCLR_ENDRX_Msk (0x1UL << NFCT_INTENCLR_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
-#define NFCT_INTENCLR_ENDRX_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENCLR_ENDRX_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENCLR_ENDRX_Clear (1UL) /*!< Disable */
-
-/* Bit 10 : Write '1' to Disable interrupt for RXERROR event */
-#define NFCT_INTENCLR_RXERROR_Pos (10UL) /*!< Position of RXERROR field. */
-#define NFCT_INTENCLR_RXERROR_Msk (0x1UL << NFCT_INTENCLR_RXERROR_Pos) /*!< Bit mask of RXERROR field. */
-#define NFCT_INTENCLR_RXERROR_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENCLR_RXERROR_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENCLR_RXERROR_Clear (1UL) /*!< Disable */
-
-/* Bit 7 : Write '1' to Disable interrupt for ERROR event */
-#define NFCT_INTENCLR_ERROR_Pos (7UL) /*!< Position of ERROR field. */
-#define NFCT_INTENCLR_ERROR_Msk (0x1UL << NFCT_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
-#define NFCT_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
-
-/* Bit 6 : Write '1' to Disable interrupt for RXFRAMEEND event */
-#define NFCT_INTENCLR_RXFRAMEEND_Pos (6UL) /*!< Position of RXFRAMEEND field. */
-#define NFCT_INTENCLR_RXFRAMEEND_Msk (0x1UL << NFCT_INTENCLR_RXFRAMEEND_Pos) /*!< Bit mask of RXFRAMEEND field. */
-#define NFCT_INTENCLR_RXFRAMEEND_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENCLR_RXFRAMEEND_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENCLR_RXFRAMEEND_Clear (1UL) /*!< Disable */
-
-/* Bit 5 : Write '1' to Disable interrupt for RXFRAMESTART event */
-#define NFCT_INTENCLR_RXFRAMESTART_Pos (5UL) /*!< Position of RXFRAMESTART field. */
-#define NFCT_INTENCLR_RXFRAMESTART_Msk (0x1UL << NFCT_INTENCLR_RXFRAMESTART_Pos) /*!< Bit mask of RXFRAMESTART field. */
-#define NFCT_INTENCLR_RXFRAMESTART_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENCLR_RXFRAMESTART_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENCLR_RXFRAMESTART_Clear (1UL) /*!< Disable */
-
-/* Bit 4 : Write '1' to Disable interrupt for TXFRAMEEND event */
-#define NFCT_INTENCLR_TXFRAMEEND_Pos (4UL) /*!< Position of TXFRAMEEND field. */
-#define NFCT_INTENCLR_TXFRAMEEND_Msk (0x1UL << NFCT_INTENCLR_TXFRAMEEND_Pos) /*!< Bit mask of TXFRAMEEND field. */
-#define NFCT_INTENCLR_TXFRAMEEND_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENCLR_TXFRAMEEND_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENCLR_TXFRAMEEND_Clear (1UL) /*!< Disable */
-
-/* Bit 3 : Write '1' to Disable interrupt for TXFRAMESTART event */
-#define NFCT_INTENCLR_TXFRAMESTART_Pos (3UL) /*!< Position of TXFRAMESTART field. */
-#define NFCT_INTENCLR_TXFRAMESTART_Msk (0x1UL << NFCT_INTENCLR_TXFRAMESTART_Pos) /*!< Bit mask of TXFRAMESTART field. */
-#define NFCT_INTENCLR_TXFRAMESTART_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENCLR_TXFRAMESTART_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENCLR_TXFRAMESTART_Clear (1UL) /*!< Disable */
-
-/* Bit 2 : Write '1' to Disable interrupt for FIELDLOST event */
-#define NFCT_INTENCLR_FIELDLOST_Pos (2UL) /*!< Position of FIELDLOST field. */
-#define NFCT_INTENCLR_FIELDLOST_Msk (0x1UL << NFCT_INTENCLR_FIELDLOST_Pos) /*!< Bit mask of FIELDLOST field. */
-#define NFCT_INTENCLR_FIELDLOST_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENCLR_FIELDLOST_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENCLR_FIELDLOST_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for FIELDDETECTED event */
-#define NFCT_INTENCLR_FIELDDETECTED_Pos (1UL) /*!< Position of FIELDDETECTED field. */
-#define NFCT_INTENCLR_FIELDDETECTED_Msk (0x1UL << NFCT_INTENCLR_FIELDDETECTED_Pos) /*!< Bit mask of FIELDDETECTED field. */
-#define NFCT_INTENCLR_FIELDDETECTED_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENCLR_FIELDDETECTED_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENCLR_FIELDDETECTED_Clear (1UL) /*!< Disable */
-
-/* Bit 0 : Write '1' to Disable interrupt for READY event */
-#define NFCT_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
-#define NFCT_INTENCLR_READY_Msk (0x1UL << NFCT_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
-#define NFCT_INTENCLR_READY_Disabled (0UL) /*!< Read: Disabled */
-#define NFCT_INTENCLR_READY_Enabled (1UL) /*!< Read: Enabled */
-#define NFCT_INTENCLR_READY_Clear (1UL) /*!< Disable */
-
-/* Register: NFCT_ERRORSTATUS */
-/* Description: NFC Error Status register */
-
-/* Bit 3 : Field level is too low at min load resistance */
-#define NFCT_ERRORSTATUS_NFCFIELDTOOWEAK_Pos (3UL) /*!< Position of NFCFIELDTOOWEAK field. */
-#define NFCT_ERRORSTATUS_NFCFIELDTOOWEAK_Msk (0x1UL << NFCT_ERRORSTATUS_NFCFIELDTOOWEAK_Pos) /*!< Bit mask of NFCFIELDTOOWEAK field. */
-
-/* Bit 2 : Field level is too high at max load resistance */
-#define NFCT_ERRORSTATUS_NFCFIELDTOOSTRONG_Pos (2UL) /*!< Position of NFCFIELDTOOSTRONG field. */
-#define NFCT_ERRORSTATUS_NFCFIELDTOOSTRONG_Msk (0x1UL << NFCT_ERRORSTATUS_NFCFIELDTOOSTRONG_Pos) /*!< Bit mask of NFCFIELDTOOSTRONG field. */
-
-/* Bit 0 : No STARTTX task triggered before expiration of the time set in FRAMEDELAYMAX */
-#define NFCT_ERRORSTATUS_FRAMEDELAYTIMEOUT_Pos (0UL) /*!< Position of FRAMEDELAYTIMEOUT field. */
-#define NFCT_ERRORSTATUS_FRAMEDELAYTIMEOUT_Msk (0x1UL << NFCT_ERRORSTATUS_FRAMEDELAYTIMEOUT_Pos) /*!< Bit mask of FRAMEDELAYTIMEOUT field. */
-
-/* Register: NFCT_FRAMESTATUS_RX */
-/* Description: Result of last incoming frames */
-
-/* Bit 3 : Overrun detected */
-#define NFCT_FRAMESTATUS_RX_OVERRUN_Pos (3UL) /*!< Position of OVERRUN field. */
-#define NFCT_FRAMESTATUS_RX_OVERRUN_Msk (0x1UL << NFCT_FRAMESTATUS_RX_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
-#define NFCT_FRAMESTATUS_RX_OVERRUN_NoOverrun (0UL) /*!< No overrun detected */
-#define NFCT_FRAMESTATUS_RX_OVERRUN_Overrun (1UL) /*!< Overrun error */
-
-/* Bit 2 : Parity status of received frame */
-#define NFCT_FRAMESTATUS_RX_PARITYSTATUS_Pos (2UL) /*!< Position of PARITYSTATUS field. */
-#define NFCT_FRAMESTATUS_RX_PARITYSTATUS_Msk (0x1UL << NFCT_FRAMESTATUS_RX_PARITYSTATUS_Pos) /*!< Bit mask of PARITYSTATUS field. */
-#define NFCT_FRAMESTATUS_RX_PARITYSTATUS_ParityOK (0UL) /*!< Frame received with parity OK */
-#define NFCT_FRAMESTATUS_RX_PARITYSTATUS_ParityError (1UL) /*!< Frame received with parity error */
-
-/* Bit 0 : No valid End of Frame detected */
-#define NFCT_FRAMESTATUS_RX_CRCERROR_Pos (0UL) /*!< Position of CRCERROR field. */
-#define NFCT_FRAMESTATUS_RX_CRCERROR_Msk (0x1UL << NFCT_FRAMESTATUS_RX_CRCERROR_Pos) /*!< Bit mask of CRCERROR field. */
-#define NFCT_FRAMESTATUS_RX_CRCERROR_CRCCorrect (0UL) /*!< Valid CRC detected */
-#define NFCT_FRAMESTATUS_RX_CRCERROR_CRCError (1UL) /*!< CRC received does not match local check */
-
-/* Register: NFCT_CURRENTLOADCTRL */
-/* Description: Current value driven to the NFC Load Control */
-
-/* Bits 5..0 : Current value driven to the NFC Load Control */
-#define NFCT_CURRENTLOADCTRL_CURRENTLOADCTRL_Pos (0UL) /*!< Position of CURRENTLOADCTRL field. */
-#define NFCT_CURRENTLOADCTRL_CURRENTLOADCTRL_Msk (0x3FUL << NFCT_CURRENTLOADCTRL_CURRENTLOADCTRL_Pos) /*!< Bit mask of CURRENTLOADCTRL field. */
-
-/* Register: NFCT_FIELDPRESENT */
-/* Description: Indicates the presence or not of a valid field */
-
-/* Bit 1 : Indicates if the low level has locked to the field */
-#define NFCT_FIELDPRESENT_LOCKDETECT_Pos (1UL) /*!< Position of LOCKDETECT field. */
-#define NFCT_FIELDPRESENT_LOCKDETECT_Msk (0x1UL << NFCT_FIELDPRESENT_LOCKDETECT_Pos) /*!< Bit mask of LOCKDETECT field. */
-#define NFCT_FIELDPRESENT_LOCKDETECT_NotLocked (0UL) /*!< Not locked to field */
-#define NFCT_FIELDPRESENT_LOCKDETECT_Locked (1UL) /*!< Locked to field */
-
-/* Bit 0 : Indicates the presence or not of a valid field. Available only in the activated state. */
-#define NFCT_FIELDPRESENT_FIELDPRESENT_Pos (0UL) /*!< Position of FIELDPRESENT field. */
-#define NFCT_FIELDPRESENT_FIELDPRESENT_Msk (0x1UL << NFCT_FIELDPRESENT_FIELDPRESENT_Pos) /*!< Bit mask of FIELDPRESENT field. */
-#define NFCT_FIELDPRESENT_FIELDPRESENT_NoField (0UL) /*!< No valid field detected */
-#define NFCT_FIELDPRESENT_FIELDPRESENT_FieldPresent (1UL) /*!< Valid field detected */
-
-/* Register: NFCT_FRAMEDELAYMIN */
-/* Description: Minimum frame delay */
-
-/* Bits 15..0 : Minimum frame delay in number of 13.56 MHz clocks */
-#define NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Pos (0UL) /*!< Position of FRAMEDELAYMIN field. */
-#define NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Msk (0xFFFFUL << NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Pos) /*!< Bit mask of FRAMEDELAYMIN field. */
-
-/* Register: NFCT_FRAMEDELAYMAX */
-/* Description: Maximum frame delay */
-
-/* Bits 15..0 : Maximum frame delay in number of 13.56 MHz clocks */
-#define NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Pos (0UL) /*!< Position of FRAMEDELAYMAX field. */
-#define NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Msk (0xFFFFUL << NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Pos) /*!< Bit mask of FRAMEDELAYMAX field. */
-
-/* Register: NFCT_FRAMEDELAYMODE */
-/* Description: Configuration register for the Frame Delay Timer */
-
-/* Bits 1..0 : Configuration register for the Frame Delay Timer */
-#define NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Pos (0UL) /*!< Position of FRAMEDELAYMODE field. */
-#define NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Msk (0x3UL << NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Pos) /*!< Bit mask of FRAMEDELAYMODE field. */
-#define NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_FreeRun (0UL) /*!< Transmission is independent of frame timer and will start when the STARTTX task is triggered. No timeout. */
-#define NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Window (1UL) /*!< Frame is transmitted between FRAMEDELAYMIN and FRAMEDELAYMAX */
-#define NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_ExactVal (2UL) /*!< Frame is transmitted exactly at FRAMEDELAYMAX */
-#define NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_WindowGrid (3UL) /*!< Frame is transmitted on a bit grid between FRAMEDELAYMIN and FRAMEDELAYMAX */
-
-/* Register: NFCT_PACKETPTR */
-/* Description: Packet pointer for TXD and RXD data storage in Data RAM */
-
-/* Bits 31..0 : Packet pointer for TXD and RXD data storage in Data RAM. This address is a byte aligned RAM address. */
-#define NFCT_PACKETPTR_PTR_Pos (0UL) /*!< Position of PTR field. */
-#define NFCT_PACKETPTR_PTR_Msk (0xFFFFFFFFUL << NFCT_PACKETPTR_PTR_Pos) /*!< Bit mask of PTR field. */
-
-/* Register: NFCT_MAXLEN */
-/* Description: Size of allocated for TXD and RXD data storage buffer in Data RAM */
-
-/* Bits 8..0 : Size of allocated for TXD and RXD data storage buffer in Data RAM */
-#define NFCT_MAXLEN_MAXLEN_Pos (0UL) /*!< Position of MAXLEN field. */
-#define NFCT_MAXLEN_MAXLEN_Msk (0x1FFUL << NFCT_MAXLEN_MAXLEN_Pos) /*!< Bit mask of MAXLEN field. */
-
-/* Register: NFCT_TXD_FRAMECONFIG */
-/* Description: Configuration of outgoing frames */
-
-/* Bit 4 : CRC mode for outgoing frames */
-#define NFCT_TXD_FRAMECONFIG_CRCMODETX_Pos (4UL) /*!< Position of CRCMODETX field. */
-#define NFCT_TXD_FRAMECONFIG_CRCMODETX_Msk (0x1UL << NFCT_TXD_FRAMECONFIG_CRCMODETX_Pos) /*!< Bit mask of CRCMODETX field. */
-#define NFCT_TXD_FRAMECONFIG_CRCMODETX_NoCRCTX (0UL) /*!< CRC is not added to the frame */
-#define NFCT_TXD_FRAMECONFIG_CRCMODETX_CRC16TX (1UL) /*!< 16 bit CRC added to the frame based on all the data read from RAM that is used in the frame */
-
-/* Bit 2 : Adding SoF or not in TX frames */
-#define NFCT_TXD_FRAMECONFIG_SOF_Pos (2UL) /*!< Position of SOF field. */
-#define NFCT_TXD_FRAMECONFIG_SOF_Msk (0x1UL << NFCT_TXD_FRAMECONFIG_SOF_Pos) /*!< Bit mask of SOF field. */
-#define NFCT_TXD_FRAMECONFIG_SOF_NoSoF (0UL) /*!< Start of Frame symbol not added */
-#define NFCT_TXD_FRAMECONFIG_SOF_SoF (1UL) /*!< Start of Frame symbol added */
-
-/* Bit 1 : Discarding unused bits in start or at end of a Frame */
-#define NFCT_TXD_FRAMECONFIG_DISCARDMODE_Pos (1UL) /*!< Position of DISCARDMODE field. */
-#define NFCT_TXD_FRAMECONFIG_DISCARDMODE_Msk (0x1UL << NFCT_TXD_FRAMECONFIG_DISCARDMODE_Pos) /*!< Bit mask of DISCARDMODE field. */
-#define NFCT_TXD_FRAMECONFIG_DISCARDMODE_DiscardEnd (0UL) /*!< Unused bits is discarded at end of frame */
-#define NFCT_TXD_FRAMECONFIG_DISCARDMODE_DiscardStart (1UL) /*!< Unused bits is discarded at start of frame */
-
-/* Bit 0 : Adding parity or not in the frame */
-#define NFCT_TXD_FRAMECONFIG_PARITY_Pos (0UL) /*!< Position of PARITY field. */
-#define NFCT_TXD_FRAMECONFIG_PARITY_Msk (0x1UL << NFCT_TXD_FRAMECONFIG_PARITY_Pos) /*!< Bit mask of PARITY field. */
-#define NFCT_TXD_FRAMECONFIG_PARITY_NoParity (0UL) /*!< Parity is not added in TX frames */
-#define NFCT_TXD_FRAMECONFIG_PARITY_Parity (1UL) /*!< Parity is added TX frames */
-
-/* Register: NFCT_TXD_AMOUNT */
-/* Description: Size of outgoing frame */
-
-/* Bits 11..3 : Number of complete bytes that shall be included in the frame, excluding CRC, parity and framing */
-#define NFCT_TXD_AMOUNT_TXDATABYTES_Pos (3UL) /*!< Position of TXDATABYTES field. */
-#define NFCT_TXD_AMOUNT_TXDATABYTES_Msk (0x1FFUL << NFCT_TXD_AMOUNT_TXDATABYTES_Pos) /*!< Bit mask of TXDATABYTES field. */
-
-/* Bits 2..0 : Number of bits in the last or first byte read from RAM that shall be included in the frame (excluding parity bit). */
-#define NFCT_TXD_AMOUNT_TXDATABITS_Pos (0UL) /*!< Position of TXDATABITS field. */
-#define NFCT_TXD_AMOUNT_TXDATABITS_Msk (0x7UL << NFCT_TXD_AMOUNT_TXDATABITS_Pos) /*!< Bit mask of TXDATABITS field. */
-
-/* Register: NFCT_RXD_FRAMECONFIG */
-/* Description: Configuration of incoming frames */
-
-/* Bit 4 : CRC mode for incoming frames */
-#define NFCT_RXD_FRAMECONFIG_CRCMODERX_Pos (4UL) /*!< Position of CRCMODERX field. */
-#define NFCT_RXD_FRAMECONFIG_CRCMODERX_Msk (0x1UL << NFCT_RXD_FRAMECONFIG_CRCMODERX_Pos) /*!< Bit mask of CRCMODERX field. */
-#define NFCT_RXD_FRAMECONFIG_CRCMODERX_NoCRCRX (0UL) /*!< CRC is not expected in RX frames */
-#define NFCT_RXD_FRAMECONFIG_CRCMODERX_CRC16RX (1UL) /*!< Last 16 bits in RX frame is CRC, CRC is checked and CRCSTATUS updated */
-
-/* Bit 2 : SoF expected or not in RX frames */
-#define NFCT_RXD_FRAMECONFIG_SOF_Pos (2UL) /*!< Position of SOF field. */
-#define NFCT_RXD_FRAMECONFIG_SOF_Msk (0x1UL << NFCT_RXD_FRAMECONFIG_SOF_Pos) /*!< Bit mask of SOF field. */
-#define NFCT_RXD_FRAMECONFIG_SOF_NoSoF (0UL) /*!< Start of Frame symbol is not expected in RX frames */
-#define NFCT_RXD_FRAMECONFIG_SOF_SoF (1UL) /*!< Start of Frame symbol is expected in RX frames */
-
-/* Bit 0 : Parity expected or not in RX frame */
-#define NFCT_RXD_FRAMECONFIG_PARITY_Pos (0UL) /*!< Position of PARITY field. */
-#define NFCT_RXD_FRAMECONFIG_PARITY_Msk (0x1UL << NFCT_RXD_FRAMECONFIG_PARITY_Pos) /*!< Bit mask of PARITY field. */
-#define NFCT_RXD_FRAMECONFIG_PARITY_NoParity (0UL) /*!< Parity is not expected in RX frames */
-#define NFCT_RXD_FRAMECONFIG_PARITY_Parity (1UL) /*!< Parity is expected in RX frames */
-
-/* Register: NFCT_RXD_AMOUNT */
-/* Description: Size of last incoming frame */
-
-/* Bits 11..3 : Number of complete bytes received in the frame (including CRC, but excluding parity and SoF/EoF framing) */
-#define NFCT_RXD_AMOUNT_RXDATABYTES_Pos (3UL) /*!< Position of RXDATABYTES field. */
-#define NFCT_RXD_AMOUNT_RXDATABYTES_Msk (0x1FFUL << NFCT_RXD_AMOUNT_RXDATABYTES_Pos) /*!< Bit mask of RXDATABYTES field. */
-
-/* Bits 2..0 : Number of bits in the last byte in the frame, if less than 8 (including CRC, but excluding parity and SoF/EoF framing). */
-#define NFCT_RXD_AMOUNT_RXDATABITS_Pos (0UL) /*!< Position of RXDATABITS field. */
-#define NFCT_RXD_AMOUNT_RXDATABITS_Msk (0x7UL << NFCT_RXD_AMOUNT_RXDATABITS_Pos) /*!< Bit mask of RXDATABITS field. */
-
-/* Register: NFCT_NFCID1_LAST */
-/* Description: Last NFCID1 part (4, 7 or 10 bytes ID) */
-
-/* Bits 31..24 : NFCID1 byte W */
-#define NFCT_NFCID1_LAST_NFCID1_W_Pos (24UL) /*!< Position of NFCID1_W field. */
-#define NFCT_NFCID1_LAST_NFCID1_W_Msk (0xFFUL << NFCT_NFCID1_LAST_NFCID1_W_Pos) /*!< Bit mask of NFCID1_W field. */
-
-/* Bits 23..16 : NFCID1 byte X */
-#define NFCT_NFCID1_LAST_NFCID1_X_Pos (16UL) /*!< Position of NFCID1_X field. */
-#define NFCT_NFCID1_LAST_NFCID1_X_Msk (0xFFUL << NFCT_NFCID1_LAST_NFCID1_X_Pos) /*!< Bit mask of NFCID1_X field. */
-
-/* Bits 15..8 : NFCID1 byte Y */
-#define NFCT_NFCID1_LAST_NFCID1_Y_Pos (8UL) /*!< Position of NFCID1_Y field. */
-#define NFCT_NFCID1_LAST_NFCID1_Y_Msk (0xFFUL << NFCT_NFCID1_LAST_NFCID1_Y_Pos) /*!< Bit mask of NFCID1_Y field. */
-
-/* Bits 7..0 : NFCID1 byte Z (very last byte sent) */
-#define NFCT_NFCID1_LAST_NFCID1_Z_Pos (0UL) /*!< Position of NFCID1_Z field. */
-#define NFCT_NFCID1_LAST_NFCID1_Z_Msk (0xFFUL << NFCT_NFCID1_LAST_NFCID1_Z_Pos) /*!< Bit mask of NFCID1_Z field. */
-
-/* Register: NFCT_NFCID1_2ND_LAST */
-/* Description: Second last NFCID1 part (7 or 10 bytes ID) */
-
-/* Bits 23..16 : NFCID1 byte T */
-#define NFCT_NFCID1_2ND_LAST_NFCID1_T_Pos (16UL) /*!< Position of NFCID1_T field. */
-#define NFCT_NFCID1_2ND_LAST_NFCID1_T_Msk (0xFFUL << NFCT_NFCID1_2ND_LAST_NFCID1_T_Pos) /*!< Bit mask of NFCID1_T field. */
-
-/* Bits 15..8 : NFCID1 byte U */
-#define NFCT_NFCID1_2ND_LAST_NFCID1_U_Pos (8UL) /*!< Position of NFCID1_U field. */
-#define NFCT_NFCID1_2ND_LAST_NFCID1_U_Msk (0xFFUL << NFCT_NFCID1_2ND_LAST_NFCID1_U_Pos) /*!< Bit mask of NFCID1_U field. */
-
-/* Bits 7..0 : NFCID1 byte V */
-#define NFCT_NFCID1_2ND_LAST_NFCID1_V_Pos (0UL) /*!< Position of NFCID1_V field. */
-#define NFCT_NFCID1_2ND_LAST_NFCID1_V_Msk (0xFFUL << NFCT_NFCID1_2ND_LAST_NFCID1_V_Pos) /*!< Bit mask of NFCID1_V field. */
-
-/* Register: NFCT_NFCID1_3RD_LAST */
-/* Description: Third last NFCID1 part (10 bytes ID) */
-
-/* Bits 23..16 : NFCID1 byte Q */
-#define NFCT_NFCID1_3RD_LAST_NFCID1_Q_Pos (16UL) /*!< Position of NFCID1_Q field. */
-#define NFCT_NFCID1_3RD_LAST_NFCID1_Q_Msk (0xFFUL << NFCT_NFCID1_3RD_LAST_NFCID1_Q_Pos) /*!< Bit mask of NFCID1_Q field. */
-
-/* Bits 15..8 : NFCID1 byte R */
-#define NFCT_NFCID1_3RD_LAST_NFCID1_R_Pos (8UL) /*!< Position of NFCID1_R field. */
-#define NFCT_NFCID1_3RD_LAST_NFCID1_R_Msk (0xFFUL << NFCT_NFCID1_3RD_LAST_NFCID1_R_Pos) /*!< Bit mask of NFCID1_R field. */
-
-/* Bits 7..0 : NFCID1 byte S */
-#define NFCT_NFCID1_3RD_LAST_NFCID1_S_Pos (0UL) /*!< Position of NFCID1_S field. */
-#define NFCT_NFCID1_3RD_LAST_NFCID1_S_Msk (0xFFUL << NFCT_NFCID1_3RD_LAST_NFCID1_S_Pos) /*!< Bit mask of NFCID1_S field. */
-
-/* Register: NFCT_SENSRES */
-/* Description: NFC-A SENS_RES auto-response settings */
-
-/* Bits 15..12 : Reserved for future use. Shall be 0. */
-#define NFCT_SENSRES_RFU74_Pos (12UL) /*!< Position of RFU74 field. */
-#define NFCT_SENSRES_RFU74_Msk (0xFUL << NFCT_SENSRES_RFU74_Pos) /*!< Bit mask of RFU74 field. */
-
-/* Bits 11..8 : Tag platform configuration as defined by the b4:b1 of byte 2 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification */
-#define NFCT_SENSRES_PLATFCONFIG_Pos (8UL) /*!< Position of PLATFCONFIG field. */
-#define NFCT_SENSRES_PLATFCONFIG_Msk (0xFUL << NFCT_SENSRES_PLATFCONFIG_Pos) /*!< Bit mask of PLATFCONFIG field. */
-
-/* Bits 7..6 : NFCID1 size. This value is used by the Auto collision resolution engine. */
-#define NFCT_SENSRES_NFCIDSIZE_Pos (6UL) /*!< Position of NFCIDSIZE field. */
-#define NFCT_SENSRES_NFCIDSIZE_Msk (0x3UL << NFCT_SENSRES_NFCIDSIZE_Pos) /*!< Bit mask of NFCIDSIZE field. */
-#define NFCT_SENSRES_NFCIDSIZE_NFCID1Single (0UL) /*!< NFCID1 size: single (4 bytes) */
-#define NFCT_SENSRES_NFCIDSIZE_NFCID1Double (1UL) /*!< NFCID1 size: double (7 bytes) */
-#define NFCT_SENSRES_NFCIDSIZE_NFCID1Triple (2UL) /*!< NFCID1 size: triple (10 bytes) */
-
-/* Bit 5 : Reserved for future use. Shall be 0. */
-#define NFCT_SENSRES_RFU5_Pos (5UL) /*!< Position of RFU5 field. */
-#define NFCT_SENSRES_RFU5_Msk (0x1UL << NFCT_SENSRES_RFU5_Pos) /*!< Bit mask of RFU5 field. */
-
-/* Bits 4..0 : Bit frame SDD as defined by the b5:b1 of byte 1 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification */
-#define NFCT_SENSRES_BITFRAMESDD_Pos (0UL) /*!< Position of BITFRAMESDD field. */
-#define NFCT_SENSRES_BITFRAMESDD_Msk (0x1FUL << NFCT_SENSRES_BITFRAMESDD_Pos) /*!< Bit mask of BITFRAMESDD field. */
-#define NFCT_SENSRES_BITFRAMESDD_SDD00000 (0UL) /*!< SDD pattern 00000 */
-#define NFCT_SENSRES_BITFRAMESDD_SDD00001 (1UL) /*!< SDD pattern 00001 */
-#define NFCT_SENSRES_BITFRAMESDD_SDD00010 (2UL) /*!< SDD pattern 00010 */
-#define NFCT_SENSRES_BITFRAMESDD_SDD00100 (4UL) /*!< SDD pattern 00100 */
-#define NFCT_SENSRES_BITFRAMESDD_SDD01000 (8UL) /*!< SDD pattern 01000 */
-#define NFCT_SENSRES_BITFRAMESDD_SDD10000 (16UL) /*!< SDD pattern 10000 */
-
-/* Register: NFCT_SELRES */
-/* Description: NFC-A SEL_RES auto-response settings */
-
-/* Bit 7 : Reserved for future use. Shall be 0. */
-#define NFCT_SELRES_RFU7_Pos (7UL) /*!< Position of RFU7 field. */
-#define NFCT_SELRES_RFU7_Msk (0x1UL << NFCT_SELRES_RFU7_Pos) /*!< Bit mask of RFU7 field. */
-
-/* Bits 6..5 : Protocol as defined by the b7:b6 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification */
-#define NFCT_SELRES_PROTOCOL_Pos (5UL) /*!< Position of PROTOCOL field. */
-#define NFCT_SELRES_PROTOCOL_Msk (0x3UL << NFCT_SELRES_PROTOCOL_Pos) /*!< Bit mask of PROTOCOL field. */
-
-/* Bits 4..3 : Reserved for future use. Shall be 0. */
-#define NFCT_SELRES_RFU43_Pos (3UL) /*!< Position of RFU43 field. */
-#define NFCT_SELRES_RFU43_Msk (0x3UL << NFCT_SELRES_RFU43_Pos) /*!< Bit mask of RFU43 field. */
-
-/* Bit 2 : Cascade bit (controlled by hardware, write has no effect) */
-#define NFCT_SELRES_CASCADE_Pos (2UL) /*!< Position of CASCADE field. */
-#define NFCT_SELRES_CASCADE_Msk (0x1UL << NFCT_SELRES_CASCADE_Pos) /*!< Bit mask of CASCADE field. */
-#define NFCT_SELRES_CASCADE_Complete (0UL) /*!< NFCID1 complete */
-#define NFCT_SELRES_CASCADE_NotComplete (1UL) /*!< NFCID1 not complete */
-
-/* Bits 1..0 : Reserved for future use. Shall be 0. */
-#define NFCT_SELRES_RFU10_Pos (0UL) /*!< Position of RFU10 field. */
-#define NFCT_SELRES_RFU10_Msk (0x3UL << NFCT_SELRES_RFU10_Pos) /*!< Bit mask of RFU10 field. */
-
-
-/* Peripheral: NVMC */
-/* Description: Non Volatile Memory Controller */
-
-/* Register: NVMC_READY */
-/* Description: Ready flag */
-
-/* Bit 0 : NVMC is ready or busy */
-#define NVMC_READY_READY_Pos (0UL) /*!< Position of READY field. */
-#define NVMC_READY_READY_Msk (0x1UL << NVMC_READY_READY_Pos) /*!< Bit mask of READY field. */
-#define NVMC_READY_READY_Busy (0UL) /*!< NVMC is busy (on-going write or erase operation) */
-#define NVMC_READY_READY_Ready (1UL) /*!< NVMC is ready */
-
-/* Register: NVMC_CONFIG */
-/* Description: Configuration register */
-
-/* Bits 1..0 : Program memory access mode. It is strongly recommended to only activate erase and write modes when they are actively used. Enabling write or erase will invalidate the cache and keep it invalidated. */
-#define NVMC_CONFIG_WEN_Pos (0UL) /*!< Position of WEN field. */
-#define NVMC_CONFIG_WEN_Msk (0x3UL << NVMC_CONFIG_WEN_Pos) /*!< Bit mask of WEN field. */
-#define NVMC_CONFIG_WEN_Ren (0UL) /*!< Read only access */
-#define NVMC_CONFIG_WEN_Wen (1UL) /*!< Write Enabled */
-#define NVMC_CONFIG_WEN_Een (2UL) /*!< Erase enabled */
-
-/* Register: NVMC_ERASEPAGE */
-/* Description: Register for erasing a page in Code area */
-
-/* Bits 31..0 : Register for starting erase of a page in Code area */
-#define NVMC_ERASEPAGE_ERASEPAGE_Pos (0UL) /*!< Position of ERASEPAGE field. */
-#define NVMC_ERASEPAGE_ERASEPAGE_Msk (0xFFFFFFFFUL << NVMC_ERASEPAGE_ERASEPAGE_Pos) /*!< Bit mask of ERASEPAGE field. */
-
-/* Register: NVMC_ERASEPCR1 */
-/* Description: Deprecated register -  Register for erasing a page in Code area. Equivalent to ERASEPAGE. */
-
-/* Bits 31..0 : Register for erasing a page in Code area. Equivalent to ERASEPAGE. */
-#define NVMC_ERASEPCR1_ERASEPCR1_Pos (0UL) /*!< Position of ERASEPCR1 field. */
-#define NVMC_ERASEPCR1_ERASEPCR1_Msk (0xFFFFFFFFUL << NVMC_ERASEPCR1_ERASEPCR1_Pos) /*!< Bit mask of ERASEPCR1 field. */
-
-/* Register: NVMC_ERASEALL */
-/* Description: Register for erasing all non-volatile user memory */
-
-/* Bit 0 : Erase all non-volatile memory including UICR registers. Note that code erase has to be enabled by CONFIG.EEN before the UICR can be erased. */
-#define NVMC_ERASEALL_ERASEALL_Pos (0UL) /*!< Position of ERASEALL field. */
-#define NVMC_ERASEALL_ERASEALL_Msk (0x1UL << NVMC_ERASEALL_ERASEALL_Pos) /*!< Bit mask of ERASEALL field. */
-#define NVMC_ERASEALL_ERASEALL_NoOperation (0UL) /*!< No operation */
-#define NVMC_ERASEALL_ERASEALL_Erase (1UL) /*!< Start chip erase */
-
-/* Register: NVMC_ERASEPCR0 */
-/* Description: Deprecated register -  Register for erasing a page in Code area. Equivalent to ERASEPAGE. */
-
-/* Bits 31..0 : Register for starting erase of a page in Code area. Equivalent to ERASEPAGE. */
-#define NVMC_ERASEPCR0_ERASEPCR0_Pos (0UL) /*!< Position of ERASEPCR0 field. */
-#define NVMC_ERASEPCR0_ERASEPCR0_Msk (0xFFFFFFFFUL << NVMC_ERASEPCR0_ERASEPCR0_Pos) /*!< Bit mask of ERASEPCR0 field. */
-
-/* Register: NVMC_ERASEUICR */
-/* Description: Register for erasing User Information Configuration Registers */
-
-/* Bit 0 : Register starting erase of all User Information Configuration Registers. Note that code erase has to be enabled by CONFIG.EEN before the UICR can be erased. */
-#define NVMC_ERASEUICR_ERASEUICR_Pos (0UL) /*!< Position of ERASEUICR field. */
-#define NVMC_ERASEUICR_ERASEUICR_Msk (0x1UL << NVMC_ERASEUICR_ERASEUICR_Pos) /*!< Bit mask of ERASEUICR field. */
-#define NVMC_ERASEUICR_ERASEUICR_NoOperation (0UL) /*!< No operation */
-#define NVMC_ERASEUICR_ERASEUICR_Erase (1UL) /*!< Start erase of UICR */
-
-/* Register: NVMC_ICACHECNF */
-/* Description: I-Code cache configuration register. */
-
-/* Bit 8 : Cache profiling enable */
-#define NVMC_ICACHECNF_CACHEPROFEN_Pos (8UL) /*!< Position of CACHEPROFEN field. */
-#define NVMC_ICACHECNF_CACHEPROFEN_Msk (0x1UL << NVMC_ICACHECNF_CACHEPROFEN_Pos) /*!< Bit mask of CACHEPROFEN field. */
-#define NVMC_ICACHECNF_CACHEPROFEN_Disabled (0UL) /*!< Disable cache profiling */
-#define NVMC_ICACHECNF_CACHEPROFEN_Enabled (1UL) /*!< Enable cache profiling */
-
-/* Bit 0 : Cache enable */
-#define NVMC_ICACHECNF_CACHEEN_Pos (0UL) /*!< Position of CACHEEN field. */
-#define NVMC_ICACHECNF_CACHEEN_Msk (0x1UL << NVMC_ICACHECNF_CACHEEN_Pos) /*!< Bit mask of CACHEEN field. */
-#define NVMC_ICACHECNF_CACHEEN_Disabled (0UL) /*!< Disable cache. Invalidates all cache entries. */
-#define NVMC_ICACHECNF_CACHEEN_Enabled (1UL) /*!< Enable cache */
-
-/* Register: NVMC_IHIT */
-/* Description: I-Code cache hit counter. */
-
-/* Bits 31..0 : Number of cache hits */
-#define NVMC_IHIT_HITS_Pos (0UL) /*!< Position of HITS field. */
-#define NVMC_IHIT_HITS_Msk (0xFFFFFFFFUL << NVMC_IHIT_HITS_Pos) /*!< Bit mask of HITS field. */
-
-/* Register: NVMC_IMISS */
-/* Description: I-Code cache miss counter. */
-
-/* Bits 31..0 : Number of cache misses */
-#define NVMC_IMISS_MISSES_Pos (0UL) /*!< Position of MISSES field. */
-#define NVMC_IMISS_MISSES_Msk (0xFFFFFFFFUL << NVMC_IMISS_MISSES_Pos) /*!< Bit mask of MISSES field. */
-
-
-/* Peripheral: GPIO */
-/* Description: GPIO Port 1 */
-
-/* Register: GPIO_OUT */
-/* Description: Write GPIO port */
-
-/* Bit 31 : Pin 31 */
-#define GPIO_OUT_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
-#define GPIO_OUT_PIN31_Msk (0x1UL << GPIO_OUT_PIN31_Pos) /*!< Bit mask of PIN31 field. */
-#define GPIO_OUT_PIN31_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN31_High (1UL) /*!< Pin driver is high */
-
-/* Bit 30 : Pin 30 */
-#define GPIO_OUT_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
-#define GPIO_OUT_PIN30_Msk (0x1UL << GPIO_OUT_PIN30_Pos) /*!< Bit mask of PIN30 field. */
-#define GPIO_OUT_PIN30_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN30_High (1UL) /*!< Pin driver is high */
-
-/* Bit 29 : Pin 29 */
-#define GPIO_OUT_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
-#define GPIO_OUT_PIN29_Msk (0x1UL << GPIO_OUT_PIN29_Pos) /*!< Bit mask of PIN29 field. */
-#define GPIO_OUT_PIN29_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN29_High (1UL) /*!< Pin driver is high */
-
-/* Bit 28 : Pin 28 */
-#define GPIO_OUT_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
-#define GPIO_OUT_PIN28_Msk (0x1UL << GPIO_OUT_PIN28_Pos) /*!< Bit mask of PIN28 field. */
-#define GPIO_OUT_PIN28_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN28_High (1UL) /*!< Pin driver is high */
-
-/* Bit 27 : Pin 27 */
-#define GPIO_OUT_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
-#define GPIO_OUT_PIN27_Msk (0x1UL << GPIO_OUT_PIN27_Pos) /*!< Bit mask of PIN27 field. */
-#define GPIO_OUT_PIN27_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN27_High (1UL) /*!< Pin driver is high */
-
-/* Bit 26 : Pin 26 */
-#define GPIO_OUT_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
-#define GPIO_OUT_PIN26_Msk (0x1UL << GPIO_OUT_PIN26_Pos) /*!< Bit mask of PIN26 field. */
-#define GPIO_OUT_PIN26_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN26_High (1UL) /*!< Pin driver is high */
-
-/* Bit 25 : Pin 25 */
-#define GPIO_OUT_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
-#define GPIO_OUT_PIN25_Msk (0x1UL << GPIO_OUT_PIN25_Pos) /*!< Bit mask of PIN25 field. */
-#define GPIO_OUT_PIN25_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN25_High (1UL) /*!< Pin driver is high */
-
-/* Bit 24 : Pin 24 */
-#define GPIO_OUT_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
-#define GPIO_OUT_PIN24_Msk (0x1UL << GPIO_OUT_PIN24_Pos) /*!< Bit mask of PIN24 field. */
-#define GPIO_OUT_PIN24_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN24_High (1UL) /*!< Pin driver is high */
-
-/* Bit 23 : Pin 23 */
-#define GPIO_OUT_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
-#define GPIO_OUT_PIN23_Msk (0x1UL << GPIO_OUT_PIN23_Pos) /*!< Bit mask of PIN23 field. */
-#define GPIO_OUT_PIN23_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN23_High (1UL) /*!< Pin driver is high */
-
-/* Bit 22 : Pin 22 */
-#define GPIO_OUT_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
-#define GPIO_OUT_PIN22_Msk (0x1UL << GPIO_OUT_PIN22_Pos) /*!< Bit mask of PIN22 field. */
-#define GPIO_OUT_PIN22_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN22_High (1UL) /*!< Pin driver is high */
-
-/* Bit 21 : Pin 21 */
-#define GPIO_OUT_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
-#define GPIO_OUT_PIN21_Msk (0x1UL << GPIO_OUT_PIN21_Pos) /*!< Bit mask of PIN21 field. */
-#define GPIO_OUT_PIN21_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN21_High (1UL) /*!< Pin driver is high */
-
-/* Bit 20 : Pin 20 */
-#define GPIO_OUT_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
-#define GPIO_OUT_PIN20_Msk (0x1UL << GPIO_OUT_PIN20_Pos) /*!< Bit mask of PIN20 field. */
-#define GPIO_OUT_PIN20_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN20_High (1UL) /*!< Pin driver is high */
-
-/* Bit 19 : Pin 19 */
-#define GPIO_OUT_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
-#define GPIO_OUT_PIN19_Msk (0x1UL << GPIO_OUT_PIN19_Pos) /*!< Bit mask of PIN19 field. */
-#define GPIO_OUT_PIN19_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN19_High (1UL) /*!< Pin driver is high */
-
-/* Bit 18 : Pin 18 */
-#define GPIO_OUT_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
-#define GPIO_OUT_PIN18_Msk (0x1UL << GPIO_OUT_PIN18_Pos) /*!< Bit mask of PIN18 field. */
-#define GPIO_OUT_PIN18_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN18_High (1UL) /*!< Pin driver is high */
-
-/* Bit 17 : Pin 17 */
-#define GPIO_OUT_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
-#define GPIO_OUT_PIN17_Msk (0x1UL << GPIO_OUT_PIN17_Pos) /*!< Bit mask of PIN17 field. */
-#define GPIO_OUT_PIN17_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN17_High (1UL) /*!< Pin driver is high */
-
-/* Bit 16 : Pin 16 */
-#define GPIO_OUT_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
-#define GPIO_OUT_PIN16_Msk (0x1UL << GPIO_OUT_PIN16_Pos) /*!< Bit mask of PIN16 field. */
-#define GPIO_OUT_PIN16_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN16_High (1UL) /*!< Pin driver is high */
-
-/* Bit 15 : Pin 15 */
-#define GPIO_OUT_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
-#define GPIO_OUT_PIN15_Msk (0x1UL << GPIO_OUT_PIN15_Pos) /*!< Bit mask of PIN15 field. */
-#define GPIO_OUT_PIN15_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN15_High (1UL) /*!< Pin driver is high */
-
-/* Bit 14 : Pin 14 */
-#define GPIO_OUT_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
-#define GPIO_OUT_PIN14_Msk (0x1UL << GPIO_OUT_PIN14_Pos) /*!< Bit mask of PIN14 field. */
-#define GPIO_OUT_PIN14_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN14_High (1UL) /*!< Pin driver is high */
-
-/* Bit 13 : Pin 13 */
-#define GPIO_OUT_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
-#define GPIO_OUT_PIN13_Msk (0x1UL << GPIO_OUT_PIN13_Pos) /*!< Bit mask of PIN13 field. */
-#define GPIO_OUT_PIN13_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN13_High (1UL) /*!< Pin driver is high */
-
-/* Bit 12 : Pin 12 */
-#define GPIO_OUT_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
-#define GPIO_OUT_PIN12_Msk (0x1UL << GPIO_OUT_PIN12_Pos) /*!< Bit mask of PIN12 field. */
-#define GPIO_OUT_PIN12_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN12_High (1UL) /*!< Pin driver is high */
-
-/* Bit 11 : Pin 11 */
-#define GPIO_OUT_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
-#define GPIO_OUT_PIN11_Msk (0x1UL << GPIO_OUT_PIN11_Pos) /*!< Bit mask of PIN11 field. */
-#define GPIO_OUT_PIN11_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN11_High (1UL) /*!< Pin driver is high */
-
-/* Bit 10 : Pin 10 */
-#define GPIO_OUT_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
-#define GPIO_OUT_PIN10_Msk (0x1UL << GPIO_OUT_PIN10_Pos) /*!< Bit mask of PIN10 field. */
-#define GPIO_OUT_PIN10_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN10_High (1UL) /*!< Pin driver is high */
-
-/* Bit 9 : Pin 9 */
-#define GPIO_OUT_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
-#define GPIO_OUT_PIN9_Msk (0x1UL << GPIO_OUT_PIN9_Pos) /*!< Bit mask of PIN9 field. */
-#define GPIO_OUT_PIN9_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN9_High (1UL) /*!< Pin driver is high */
-
-/* Bit 8 : Pin 8 */
-#define GPIO_OUT_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
-#define GPIO_OUT_PIN8_Msk (0x1UL << GPIO_OUT_PIN8_Pos) /*!< Bit mask of PIN8 field. */
-#define GPIO_OUT_PIN8_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN8_High (1UL) /*!< Pin driver is high */
-
-/* Bit 7 : Pin 7 */
-#define GPIO_OUT_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
-#define GPIO_OUT_PIN7_Msk (0x1UL << GPIO_OUT_PIN7_Pos) /*!< Bit mask of PIN7 field. */
-#define GPIO_OUT_PIN7_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN7_High (1UL) /*!< Pin driver is high */
-
-/* Bit 6 : Pin 6 */
-#define GPIO_OUT_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
-#define GPIO_OUT_PIN6_Msk (0x1UL << GPIO_OUT_PIN6_Pos) /*!< Bit mask of PIN6 field. */
-#define GPIO_OUT_PIN6_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN6_High (1UL) /*!< Pin driver is high */
-
-/* Bit 5 : Pin 5 */
-#define GPIO_OUT_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
-#define GPIO_OUT_PIN5_Msk (0x1UL << GPIO_OUT_PIN5_Pos) /*!< Bit mask of PIN5 field. */
-#define GPIO_OUT_PIN5_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN5_High (1UL) /*!< Pin driver is high */
-
-/* Bit 4 : Pin 4 */
-#define GPIO_OUT_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
-#define GPIO_OUT_PIN4_Msk (0x1UL << GPIO_OUT_PIN4_Pos) /*!< Bit mask of PIN4 field. */
-#define GPIO_OUT_PIN4_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN4_High (1UL) /*!< Pin driver is high */
-
-/* Bit 3 : Pin 3 */
-#define GPIO_OUT_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
-#define GPIO_OUT_PIN3_Msk (0x1UL << GPIO_OUT_PIN3_Pos) /*!< Bit mask of PIN3 field. */
-#define GPIO_OUT_PIN3_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN3_High (1UL) /*!< Pin driver is high */
-
-/* Bit 2 : Pin 2 */
-#define GPIO_OUT_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
-#define GPIO_OUT_PIN2_Msk (0x1UL << GPIO_OUT_PIN2_Pos) /*!< Bit mask of PIN2 field. */
-#define GPIO_OUT_PIN2_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN2_High (1UL) /*!< Pin driver is high */
-
-/* Bit 1 : Pin 1 */
-#define GPIO_OUT_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
-#define GPIO_OUT_PIN1_Msk (0x1UL << GPIO_OUT_PIN1_Pos) /*!< Bit mask of PIN1 field. */
-#define GPIO_OUT_PIN1_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN1_High (1UL) /*!< Pin driver is high */
-
-/* Bit 0 : Pin 0 */
-#define GPIO_OUT_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
-#define GPIO_OUT_PIN0_Msk (0x1UL << GPIO_OUT_PIN0_Pos) /*!< Bit mask of PIN0 field. */
-#define GPIO_OUT_PIN0_Low (0UL) /*!< Pin driver is low */
-#define GPIO_OUT_PIN0_High (1UL) /*!< Pin driver is high */
-
-/* Register: GPIO_OUTSET */
-/* Description: Set individual bits in GPIO port */
-
-/* Bit 31 : Pin 31 */
-#define GPIO_OUTSET_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
-#define GPIO_OUTSET_PIN31_Msk (0x1UL << GPIO_OUTSET_PIN31_Pos) /*!< Bit mask of PIN31 field. */
-#define GPIO_OUTSET_PIN31_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN31_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN31_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 30 : Pin 30 */
-#define GPIO_OUTSET_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
-#define GPIO_OUTSET_PIN30_Msk (0x1UL << GPIO_OUTSET_PIN30_Pos) /*!< Bit mask of PIN30 field. */
-#define GPIO_OUTSET_PIN30_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN30_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN30_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 29 : Pin 29 */
-#define GPIO_OUTSET_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
-#define GPIO_OUTSET_PIN29_Msk (0x1UL << GPIO_OUTSET_PIN29_Pos) /*!< Bit mask of PIN29 field. */
-#define GPIO_OUTSET_PIN29_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN29_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN29_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 28 : Pin 28 */
-#define GPIO_OUTSET_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
-#define GPIO_OUTSET_PIN28_Msk (0x1UL << GPIO_OUTSET_PIN28_Pos) /*!< Bit mask of PIN28 field. */
-#define GPIO_OUTSET_PIN28_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN28_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN28_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 27 : Pin 27 */
-#define GPIO_OUTSET_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
-#define GPIO_OUTSET_PIN27_Msk (0x1UL << GPIO_OUTSET_PIN27_Pos) /*!< Bit mask of PIN27 field. */
-#define GPIO_OUTSET_PIN27_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN27_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN27_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 26 : Pin 26 */
-#define GPIO_OUTSET_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
-#define GPIO_OUTSET_PIN26_Msk (0x1UL << GPIO_OUTSET_PIN26_Pos) /*!< Bit mask of PIN26 field. */
-#define GPIO_OUTSET_PIN26_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN26_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN26_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 25 : Pin 25 */
-#define GPIO_OUTSET_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
-#define GPIO_OUTSET_PIN25_Msk (0x1UL << GPIO_OUTSET_PIN25_Pos) /*!< Bit mask of PIN25 field. */
-#define GPIO_OUTSET_PIN25_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN25_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN25_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 24 : Pin 24 */
-#define GPIO_OUTSET_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
-#define GPIO_OUTSET_PIN24_Msk (0x1UL << GPIO_OUTSET_PIN24_Pos) /*!< Bit mask of PIN24 field. */
-#define GPIO_OUTSET_PIN24_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN24_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN24_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 23 : Pin 23 */
-#define GPIO_OUTSET_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
-#define GPIO_OUTSET_PIN23_Msk (0x1UL << GPIO_OUTSET_PIN23_Pos) /*!< Bit mask of PIN23 field. */
-#define GPIO_OUTSET_PIN23_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN23_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN23_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 22 : Pin 22 */
-#define GPIO_OUTSET_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
-#define GPIO_OUTSET_PIN22_Msk (0x1UL << GPIO_OUTSET_PIN22_Pos) /*!< Bit mask of PIN22 field. */
-#define GPIO_OUTSET_PIN22_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN22_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN22_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 21 : Pin 21 */
-#define GPIO_OUTSET_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
-#define GPIO_OUTSET_PIN21_Msk (0x1UL << GPIO_OUTSET_PIN21_Pos) /*!< Bit mask of PIN21 field. */
-#define GPIO_OUTSET_PIN21_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN21_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN21_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 20 : Pin 20 */
-#define GPIO_OUTSET_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
-#define GPIO_OUTSET_PIN20_Msk (0x1UL << GPIO_OUTSET_PIN20_Pos) /*!< Bit mask of PIN20 field. */
-#define GPIO_OUTSET_PIN20_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN20_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN20_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 19 : Pin 19 */
-#define GPIO_OUTSET_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
-#define GPIO_OUTSET_PIN19_Msk (0x1UL << GPIO_OUTSET_PIN19_Pos) /*!< Bit mask of PIN19 field. */
-#define GPIO_OUTSET_PIN19_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN19_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN19_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 18 : Pin 18 */
-#define GPIO_OUTSET_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
-#define GPIO_OUTSET_PIN18_Msk (0x1UL << GPIO_OUTSET_PIN18_Pos) /*!< Bit mask of PIN18 field. */
-#define GPIO_OUTSET_PIN18_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN18_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN18_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 17 : Pin 17 */
-#define GPIO_OUTSET_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
-#define GPIO_OUTSET_PIN17_Msk (0x1UL << GPIO_OUTSET_PIN17_Pos) /*!< Bit mask of PIN17 field. */
-#define GPIO_OUTSET_PIN17_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN17_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN17_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 16 : Pin 16 */
-#define GPIO_OUTSET_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
-#define GPIO_OUTSET_PIN16_Msk (0x1UL << GPIO_OUTSET_PIN16_Pos) /*!< Bit mask of PIN16 field. */
-#define GPIO_OUTSET_PIN16_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN16_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN16_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 15 : Pin 15 */
-#define GPIO_OUTSET_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
-#define GPIO_OUTSET_PIN15_Msk (0x1UL << GPIO_OUTSET_PIN15_Pos) /*!< Bit mask of PIN15 field. */
-#define GPIO_OUTSET_PIN15_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN15_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN15_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 14 : Pin 14 */
-#define GPIO_OUTSET_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
-#define GPIO_OUTSET_PIN14_Msk (0x1UL << GPIO_OUTSET_PIN14_Pos) /*!< Bit mask of PIN14 field. */
-#define GPIO_OUTSET_PIN14_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN14_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN14_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 13 : Pin 13 */
-#define GPIO_OUTSET_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
-#define GPIO_OUTSET_PIN13_Msk (0x1UL << GPIO_OUTSET_PIN13_Pos) /*!< Bit mask of PIN13 field. */
-#define GPIO_OUTSET_PIN13_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN13_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN13_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 12 : Pin 12 */
-#define GPIO_OUTSET_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
-#define GPIO_OUTSET_PIN12_Msk (0x1UL << GPIO_OUTSET_PIN12_Pos) /*!< Bit mask of PIN12 field. */
-#define GPIO_OUTSET_PIN12_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN12_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN12_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 11 : Pin 11 */
-#define GPIO_OUTSET_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
-#define GPIO_OUTSET_PIN11_Msk (0x1UL << GPIO_OUTSET_PIN11_Pos) /*!< Bit mask of PIN11 field. */
-#define GPIO_OUTSET_PIN11_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN11_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN11_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 10 : Pin 10 */
-#define GPIO_OUTSET_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
-#define GPIO_OUTSET_PIN10_Msk (0x1UL << GPIO_OUTSET_PIN10_Pos) /*!< Bit mask of PIN10 field. */
-#define GPIO_OUTSET_PIN10_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN10_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN10_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 9 : Pin 9 */
-#define GPIO_OUTSET_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
-#define GPIO_OUTSET_PIN9_Msk (0x1UL << GPIO_OUTSET_PIN9_Pos) /*!< Bit mask of PIN9 field. */
-#define GPIO_OUTSET_PIN9_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN9_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN9_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 8 : Pin 8 */
-#define GPIO_OUTSET_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
-#define GPIO_OUTSET_PIN8_Msk (0x1UL << GPIO_OUTSET_PIN8_Pos) /*!< Bit mask of PIN8 field. */
-#define GPIO_OUTSET_PIN8_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN8_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN8_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 7 : Pin 7 */
-#define GPIO_OUTSET_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
-#define GPIO_OUTSET_PIN7_Msk (0x1UL << GPIO_OUTSET_PIN7_Pos) /*!< Bit mask of PIN7 field. */
-#define GPIO_OUTSET_PIN7_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN7_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN7_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 6 : Pin 6 */
-#define GPIO_OUTSET_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
-#define GPIO_OUTSET_PIN6_Msk (0x1UL << GPIO_OUTSET_PIN6_Pos) /*!< Bit mask of PIN6 field. */
-#define GPIO_OUTSET_PIN6_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN6_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN6_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 5 : Pin 5 */
-#define GPIO_OUTSET_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
-#define GPIO_OUTSET_PIN5_Msk (0x1UL << GPIO_OUTSET_PIN5_Pos) /*!< Bit mask of PIN5 field. */
-#define GPIO_OUTSET_PIN5_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN5_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN5_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 4 : Pin 4 */
-#define GPIO_OUTSET_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
-#define GPIO_OUTSET_PIN4_Msk (0x1UL << GPIO_OUTSET_PIN4_Pos) /*!< Bit mask of PIN4 field. */
-#define GPIO_OUTSET_PIN4_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN4_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN4_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 3 : Pin 3 */
-#define GPIO_OUTSET_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
-#define GPIO_OUTSET_PIN3_Msk (0x1UL << GPIO_OUTSET_PIN3_Pos) /*!< Bit mask of PIN3 field. */
-#define GPIO_OUTSET_PIN3_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN3_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN3_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 2 : Pin 2 */
-#define GPIO_OUTSET_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
-#define GPIO_OUTSET_PIN2_Msk (0x1UL << GPIO_OUTSET_PIN2_Pos) /*!< Bit mask of PIN2 field. */
-#define GPIO_OUTSET_PIN2_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN2_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN2_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 1 : Pin 1 */
-#define GPIO_OUTSET_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
-#define GPIO_OUTSET_PIN1_Msk (0x1UL << GPIO_OUTSET_PIN1_Pos) /*!< Bit mask of PIN1 field. */
-#define GPIO_OUTSET_PIN1_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN1_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN1_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Bit 0 : Pin 0 */
-#define GPIO_OUTSET_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
-#define GPIO_OUTSET_PIN0_Msk (0x1UL << GPIO_OUTSET_PIN0_Pos) /*!< Bit mask of PIN0 field. */
-#define GPIO_OUTSET_PIN0_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTSET_PIN0_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTSET_PIN0_Set (1UL) /*!< Write: writing a '1' sets the pin high; writing a '0' has no effect */
-
-/* Register: GPIO_OUTCLR */
-/* Description: Clear individual bits in GPIO port */
-
-/* Bit 31 : Pin 31 */
-#define GPIO_OUTCLR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
-#define GPIO_OUTCLR_PIN31_Msk (0x1UL << GPIO_OUTCLR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
-#define GPIO_OUTCLR_PIN31_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN31_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN31_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 30 : Pin 30 */
-#define GPIO_OUTCLR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
-#define GPIO_OUTCLR_PIN30_Msk (0x1UL << GPIO_OUTCLR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
-#define GPIO_OUTCLR_PIN30_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN30_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN30_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 29 : Pin 29 */
-#define GPIO_OUTCLR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
-#define GPIO_OUTCLR_PIN29_Msk (0x1UL << GPIO_OUTCLR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
-#define GPIO_OUTCLR_PIN29_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN29_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN29_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 28 : Pin 28 */
-#define GPIO_OUTCLR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
-#define GPIO_OUTCLR_PIN28_Msk (0x1UL << GPIO_OUTCLR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
-#define GPIO_OUTCLR_PIN28_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN28_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN28_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 27 : Pin 27 */
-#define GPIO_OUTCLR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
-#define GPIO_OUTCLR_PIN27_Msk (0x1UL << GPIO_OUTCLR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
-#define GPIO_OUTCLR_PIN27_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN27_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN27_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 26 : Pin 26 */
-#define GPIO_OUTCLR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
-#define GPIO_OUTCLR_PIN26_Msk (0x1UL << GPIO_OUTCLR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
-#define GPIO_OUTCLR_PIN26_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN26_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN26_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 25 : Pin 25 */
-#define GPIO_OUTCLR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
-#define GPIO_OUTCLR_PIN25_Msk (0x1UL << GPIO_OUTCLR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
-#define GPIO_OUTCLR_PIN25_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN25_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN25_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 24 : Pin 24 */
-#define GPIO_OUTCLR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
-#define GPIO_OUTCLR_PIN24_Msk (0x1UL << GPIO_OUTCLR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
-#define GPIO_OUTCLR_PIN24_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN24_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN24_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 23 : Pin 23 */
-#define GPIO_OUTCLR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
-#define GPIO_OUTCLR_PIN23_Msk (0x1UL << GPIO_OUTCLR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
-#define GPIO_OUTCLR_PIN23_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN23_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN23_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 22 : Pin 22 */
-#define GPIO_OUTCLR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
-#define GPIO_OUTCLR_PIN22_Msk (0x1UL << GPIO_OUTCLR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
-#define GPIO_OUTCLR_PIN22_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN22_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN22_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 21 : Pin 21 */
-#define GPIO_OUTCLR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
-#define GPIO_OUTCLR_PIN21_Msk (0x1UL << GPIO_OUTCLR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
-#define GPIO_OUTCLR_PIN21_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN21_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN21_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 20 : Pin 20 */
-#define GPIO_OUTCLR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
-#define GPIO_OUTCLR_PIN20_Msk (0x1UL << GPIO_OUTCLR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
-#define GPIO_OUTCLR_PIN20_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN20_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN20_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 19 : Pin 19 */
-#define GPIO_OUTCLR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
-#define GPIO_OUTCLR_PIN19_Msk (0x1UL << GPIO_OUTCLR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
-#define GPIO_OUTCLR_PIN19_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN19_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN19_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 18 : Pin 18 */
-#define GPIO_OUTCLR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
-#define GPIO_OUTCLR_PIN18_Msk (0x1UL << GPIO_OUTCLR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
-#define GPIO_OUTCLR_PIN18_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN18_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN18_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 17 : Pin 17 */
-#define GPIO_OUTCLR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
-#define GPIO_OUTCLR_PIN17_Msk (0x1UL << GPIO_OUTCLR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
-#define GPIO_OUTCLR_PIN17_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN17_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN17_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 16 : Pin 16 */
-#define GPIO_OUTCLR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
-#define GPIO_OUTCLR_PIN16_Msk (0x1UL << GPIO_OUTCLR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
-#define GPIO_OUTCLR_PIN16_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN16_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN16_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 15 : Pin 15 */
-#define GPIO_OUTCLR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
-#define GPIO_OUTCLR_PIN15_Msk (0x1UL << GPIO_OUTCLR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
-#define GPIO_OUTCLR_PIN15_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN15_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN15_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 14 : Pin 14 */
-#define GPIO_OUTCLR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
-#define GPIO_OUTCLR_PIN14_Msk (0x1UL << GPIO_OUTCLR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
-#define GPIO_OUTCLR_PIN14_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN14_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN14_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 13 : Pin 13 */
-#define GPIO_OUTCLR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
-#define GPIO_OUTCLR_PIN13_Msk (0x1UL << GPIO_OUTCLR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
-#define GPIO_OUTCLR_PIN13_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN13_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN13_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 12 : Pin 12 */
-#define GPIO_OUTCLR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
-#define GPIO_OUTCLR_PIN12_Msk (0x1UL << GPIO_OUTCLR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
-#define GPIO_OUTCLR_PIN12_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN12_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN12_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 11 : Pin 11 */
-#define GPIO_OUTCLR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
-#define GPIO_OUTCLR_PIN11_Msk (0x1UL << GPIO_OUTCLR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
-#define GPIO_OUTCLR_PIN11_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN11_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN11_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 10 : Pin 10 */
-#define GPIO_OUTCLR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
-#define GPIO_OUTCLR_PIN10_Msk (0x1UL << GPIO_OUTCLR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
-#define GPIO_OUTCLR_PIN10_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN10_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN10_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 9 : Pin 9 */
-#define GPIO_OUTCLR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
-#define GPIO_OUTCLR_PIN9_Msk (0x1UL << GPIO_OUTCLR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
-#define GPIO_OUTCLR_PIN9_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN9_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN9_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 8 : Pin 8 */
-#define GPIO_OUTCLR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
-#define GPIO_OUTCLR_PIN8_Msk (0x1UL << GPIO_OUTCLR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
-#define GPIO_OUTCLR_PIN8_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN8_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN8_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 7 : Pin 7 */
-#define GPIO_OUTCLR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
-#define GPIO_OUTCLR_PIN7_Msk (0x1UL << GPIO_OUTCLR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
-#define GPIO_OUTCLR_PIN7_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN7_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN7_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 6 : Pin 6 */
-#define GPIO_OUTCLR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
-#define GPIO_OUTCLR_PIN6_Msk (0x1UL << GPIO_OUTCLR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
-#define GPIO_OUTCLR_PIN6_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN6_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN6_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 5 : Pin 5 */
-#define GPIO_OUTCLR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
-#define GPIO_OUTCLR_PIN5_Msk (0x1UL << GPIO_OUTCLR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
-#define GPIO_OUTCLR_PIN5_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN5_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN5_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 4 : Pin 4 */
-#define GPIO_OUTCLR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
-#define GPIO_OUTCLR_PIN4_Msk (0x1UL << GPIO_OUTCLR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
-#define GPIO_OUTCLR_PIN4_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN4_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN4_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 3 : Pin 3 */
-#define GPIO_OUTCLR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
-#define GPIO_OUTCLR_PIN3_Msk (0x1UL << GPIO_OUTCLR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
-#define GPIO_OUTCLR_PIN3_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN3_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN3_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 2 : Pin 2 */
-#define GPIO_OUTCLR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
-#define GPIO_OUTCLR_PIN2_Msk (0x1UL << GPIO_OUTCLR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
-#define GPIO_OUTCLR_PIN2_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN2_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN2_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 1 : Pin 1 */
-#define GPIO_OUTCLR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
-#define GPIO_OUTCLR_PIN1_Msk (0x1UL << GPIO_OUTCLR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
-#define GPIO_OUTCLR_PIN1_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN1_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN1_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Bit 0 : Pin 0 */
-#define GPIO_OUTCLR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
-#define GPIO_OUTCLR_PIN0_Msk (0x1UL << GPIO_OUTCLR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
-#define GPIO_OUTCLR_PIN0_Low (0UL) /*!< Read: pin driver is low */
-#define GPIO_OUTCLR_PIN0_High (1UL) /*!< Read: pin driver is high */
-#define GPIO_OUTCLR_PIN0_Clear (1UL) /*!< Write: writing a '1' sets the pin low; writing a '0' has no effect */
-
-/* Register: GPIO_IN */
-/* Description: Read GPIO port */
-
-/* Bit 31 : Pin 31 */
-#define GPIO_IN_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
-#define GPIO_IN_PIN31_Msk (0x1UL << GPIO_IN_PIN31_Pos) /*!< Bit mask of PIN31 field. */
-#define GPIO_IN_PIN31_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN31_High (1UL) /*!< Pin input is high */
-
-/* Bit 30 : Pin 30 */
-#define GPIO_IN_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
-#define GPIO_IN_PIN30_Msk (0x1UL << GPIO_IN_PIN30_Pos) /*!< Bit mask of PIN30 field. */
-#define GPIO_IN_PIN30_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN30_High (1UL) /*!< Pin input is high */
-
-/* Bit 29 : Pin 29 */
-#define GPIO_IN_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
-#define GPIO_IN_PIN29_Msk (0x1UL << GPIO_IN_PIN29_Pos) /*!< Bit mask of PIN29 field. */
-#define GPIO_IN_PIN29_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN29_High (1UL) /*!< Pin input is high */
-
-/* Bit 28 : Pin 28 */
-#define GPIO_IN_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
-#define GPIO_IN_PIN28_Msk (0x1UL << GPIO_IN_PIN28_Pos) /*!< Bit mask of PIN28 field. */
-#define GPIO_IN_PIN28_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN28_High (1UL) /*!< Pin input is high */
-
-/* Bit 27 : Pin 27 */
-#define GPIO_IN_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
-#define GPIO_IN_PIN27_Msk (0x1UL << GPIO_IN_PIN27_Pos) /*!< Bit mask of PIN27 field. */
-#define GPIO_IN_PIN27_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN27_High (1UL) /*!< Pin input is high */
-
-/* Bit 26 : Pin 26 */
-#define GPIO_IN_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
-#define GPIO_IN_PIN26_Msk (0x1UL << GPIO_IN_PIN26_Pos) /*!< Bit mask of PIN26 field. */
-#define GPIO_IN_PIN26_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN26_High (1UL) /*!< Pin input is high */
-
-/* Bit 25 : Pin 25 */
-#define GPIO_IN_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
-#define GPIO_IN_PIN25_Msk (0x1UL << GPIO_IN_PIN25_Pos) /*!< Bit mask of PIN25 field. */
-#define GPIO_IN_PIN25_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN25_High (1UL) /*!< Pin input is high */
-
-/* Bit 24 : Pin 24 */
-#define GPIO_IN_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
-#define GPIO_IN_PIN24_Msk (0x1UL << GPIO_IN_PIN24_Pos) /*!< Bit mask of PIN24 field. */
-#define GPIO_IN_PIN24_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN24_High (1UL) /*!< Pin input is high */
-
-/* Bit 23 : Pin 23 */
-#define GPIO_IN_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
-#define GPIO_IN_PIN23_Msk (0x1UL << GPIO_IN_PIN23_Pos) /*!< Bit mask of PIN23 field. */
-#define GPIO_IN_PIN23_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN23_High (1UL) /*!< Pin input is high */
-
-/* Bit 22 : Pin 22 */
-#define GPIO_IN_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
-#define GPIO_IN_PIN22_Msk (0x1UL << GPIO_IN_PIN22_Pos) /*!< Bit mask of PIN22 field. */
-#define GPIO_IN_PIN22_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN22_High (1UL) /*!< Pin input is high */
-
-/* Bit 21 : Pin 21 */
-#define GPIO_IN_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
-#define GPIO_IN_PIN21_Msk (0x1UL << GPIO_IN_PIN21_Pos) /*!< Bit mask of PIN21 field. */
-#define GPIO_IN_PIN21_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN21_High (1UL) /*!< Pin input is high */
-
-/* Bit 20 : Pin 20 */
-#define GPIO_IN_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
-#define GPIO_IN_PIN20_Msk (0x1UL << GPIO_IN_PIN20_Pos) /*!< Bit mask of PIN20 field. */
-#define GPIO_IN_PIN20_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN20_High (1UL) /*!< Pin input is high */
-
-/* Bit 19 : Pin 19 */
-#define GPIO_IN_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
-#define GPIO_IN_PIN19_Msk (0x1UL << GPIO_IN_PIN19_Pos) /*!< Bit mask of PIN19 field. */
-#define GPIO_IN_PIN19_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN19_High (1UL) /*!< Pin input is high */
-
-/* Bit 18 : Pin 18 */
-#define GPIO_IN_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
-#define GPIO_IN_PIN18_Msk (0x1UL << GPIO_IN_PIN18_Pos) /*!< Bit mask of PIN18 field. */
-#define GPIO_IN_PIN18_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN18_High (1UL) /*!< Pin input is high */
-
-/* Bit 17 : Pin 17 */
-#define GPIO_IN_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
-#define GPIO_IN_PIN17_Msk (0x1UL << GPIO_IN_PIN17_Pos) /*!< Bit mask of PIN17 field. */
-#define GPIO_IN_PIN17_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN17_High (1UL) /*!< Pin input is high */
-
-/* Bit 16 : Pin 16 */
-#define GPIO_IN_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
-#define GPIO_IN_PIN16_Msk (0x1UL << GPIO_IN_PIN16_Pos) /*!< Bit mask of PIN16 field. */
-#define GPIO_IN_PIN16_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN16_High (1UL) /*!< Pin input is high */
-
-/* Bit 15 : Pin 15 */
-#define GPIO_IN_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
-#define GPIO_IN_PIN15_Msk (0x1UL << GPIO_IN_PIN15_Pos) /*!< Bit mask of PIN15 field. */
-#define GPIO_IN_PIN15_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN15_High (1UL) /*!< Pin input is high */
-
-/* Bit 14 : Pin 14 */
-#define GPIO_IN_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
-#define GPIO_IN_PIN14_Msk (0x1UL << GPIO_IN_PIN14_Pos) /*!< Bit mask of PIN14 field. */
-#define GPIO_IN_PIN14_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN14_High (1UL) /*!< Pin input is high */
-
-/* Bit 13 : Pin 13 */
-#define GPIO_IN_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
-#define GPIO_IN_PIN13_Msk (0x1UL << GPIO_IN_PIN13_Pos) /*!< Bit mask of PIN13 field. */
-#define GPIO_IN_PIN13_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN13_High (1UL) /*!< Pin input is high */
-
-/* Bit 12 : Pin 12 */
-#define GPIO_IN_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
-#define GPIO_IN_PIN12_Msk (0x1UL << GPIO_IN_PIN12_Pos) /*!< Bit mask of PIN12 field. */
-#define GPIO_IN_PIN12_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN12_High (1UL) /*!< Pin input is high */
-
-/* Bit 11 : Pin 11 */
-#define GPIO_IN_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
-#define GPIO_IN_PIN11_Msk (0x1UL << GPIO_IN_PIN11_Pos) /*!< Bit mask of PIN11 field. */
-#define GPIO_IN_PIN11_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN11_High (1UL) /*!< Pin input is high */
-
-/* Bit 10 : Pin 10 */
-#define GPIO_IN_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
-#define GPIO_IN_PIN10_Msk (0x1UL << GPIO_IN_PIN10_Pos) /*!< Bit mask of PIN10 field. */
-#define GPIO_IN_PIN10_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN10_High (1UL) /*!< Pin input is high */
-
-/* Bit 9 : Pin 9 */
-#define GPIO_IN_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
-#define GPIO_IN_PIN9_Msk (0x1UL << GPIO_IN_PIN9_Pos) /*!< Bit mask of PIN9 field. */
-#define GPIO_IN_PIN9_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN9_High (1UL) /*!< Pin input is high */
-
-/* Bit 8 : Pin 8 */
-#define GPIO_IN_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
-#define GPIO_IN_PIN8_Msk (0x1UL << GPIO_IN_PIN8_Pos) /*!< Bit mask of PIN8 field. */
-#define GPIO_IN_PIN8_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN8_High (1UL) /*!< Pin input is high */
-
-/* Bit 7 : Pin 7 */
-#define GPIO_IN_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
-#define GPIO_IN_PIN7_Msk (0x1UL << GPIO_IN_PIN7_Pos) /*!< Bit mask of PIN7 field. */
-#define GPIO_IN_PIN7_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN7_High (1UL) /*!< Pin input is high */
-
-/* Bit 6 : Pin 6 */
-#define GPIO_IN_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
-#define GPIO_IN_PIN6_Msk (0x1UL << GPIO_IN_PIN6_Pos) /*!< Bit mask of PIN6 field. */
-#define GPIO_IN_PIN6_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN6_High (1UL) /*!< Pin input is high */
-
-/* Bit 5 : Pin 5 */
-#define GPIO_IN_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
-#define GPIO_IN_PIN5_Msk (0x1UL << GPIO_IN_PIN5_Pos) /*!< Bit mask of PIN5 field. */
-#define GPIO_IN_PIN5_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN5_High (1UL) /*!< Pin input is high */
-
-/* Bit 4 : Pin 4 */
-#define GPIO_IN_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
-#define GPIO_IN_PIN4_Msk (0x1UL << GPIO_IN_PIN4_Pos) /*!< Bit mask of PIN4 field. */
-#define GPIO_IN_PIN4_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN4_High (1UL) /*!< Pin input is high */
-
-/* Bit 3 : Pin 3 */
-#define GPIO_IN_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
-#define GPIO_IN_PIN3_Msk (0x1UL << GPIO_IN_PIN3_Pos) /*!< Bit mask of PIN3 field. */
-#define GPIO_IN_PIN3_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN3_High (1UL) /*!< Pin input is high */
-
-/* Bit 2 : Pin 2 */
-#define GPIO_IN_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
-#define GPIO_IN_PIN2_Msk (0x1UL << GPIO_IN_PIN2_Pos) /*!< Bit mask of PIN2 field. */
-#define GPIO_IN_PIN2_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN2_High (1UL) /*!< Pin input is high */
-
-/* Bit 1 : Pin 1 */
-#define GPIO_IN_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
-#define GPIO_IN_PIN1_Msk (0x1UL << GPIO_IN_PIN1_Pos) /*!< Bit mask of PIN1 field. */
-#define GPIO_IN_PIN1_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN1_High (1UL) /*!< Pin input is high */
-
-/* Bit 0 : Pin 0 */
-#define GPIO_IN_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
-#define GPIO_IN_PIN0_Msk (0x1UL << GPIO_IN_PIN0_Pos) /*!< Bit mask of PIN0 field. */
-#define GPIO_IN_PIN0_Low (0UL) /*!< Pin input is low */
-#define GPIO_IN_PIN0_High (1UL) /*!< Pin input is high */
-
-/* Register: GPIO_DIR */
-/* Description: Direction of GPIO pins */
-
-/* Bit 31 : Pin 31 */
-#define GPIO_DIR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
-#define GPIO_DIR_PIN31_Msk (0x1UL << GPIO_DIR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
-#define GPIO_DIR_PIN31_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN31_Output (1UL) /*!< Pin set as output */
-
-/* Bit 30 : Pin 30 */
-#define GPIO_DIR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
-#define GPIO_DIR_PIN30_Msk (0x1UL << GPIO_DIR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
-#define GPIO_DIR_PIN30_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN30_Output (1UL) /*!< Pin set as output */
-
-/* Bit 29 : Pin 29 */
-#define GPIO_DIR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
-#define GPIO_DIR_PIN29_Msk (0x1UL << GPIO_DIR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
-#define GPIO_DIR_PIN29_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN29_Output (1UL) /*!< Pin set as output */
-
-/* Bit 28 : Pin 28 */
-#define GPIO_DIR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
-#define GPIO_DIR_PIN28_Msk (0x1UL << GPIO_DIR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
-#define GPIO_DIR_PIN28_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN28_Output (1UL) /*!< Pin set as output */
-
-/* Bit 27 : Pin 27 */
-#define GPIO_DIR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
-#define GPIO_DIR_PIN27_Msk (0x1UL << GPIO_DIR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
-#define GPIO_DIR_PIN27_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN27_Output (1UL) /*!< Pin set as output */
-
-/* Bit 26 : Pin 26 */
-#define GPIO_DIR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
-#define GPIO_DIR_PIN26_Msk (0x1UL << GPIO_DIR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
-#define GPIO_DIR_PIN26_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN26_Output (1UL) /*!< Pin set as output */
-
-/* Bit 25 : Pin 25 */
-#define GPIO_DIR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
-#define GPIO_DIR_PIN25_Msk (0x1UL << GPIO_DIR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
-#define GPIO_DIR_PIN25_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN25_Output (1UL) /*!< Pin set as output */
-
-/* Bit 24 : Pin 24 */
-#define GPIO_DIR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
-#define GPIO_DIR_PIN24_Msk (0x1UL << GPIO_DIR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
-#define GPIO_DIR_PIN24_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN24_Output (1UL) /*!< Pin set as output */
-
-/* Bit 23 : Pin 23 */
-#define GPIO_DIR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
-#define GPIO_DIR_PIN23_Msk (0x1UL << GPIO_DIR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
-#define GPIO_DIR_PIN23_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN23_Output (1UL) /*!< Pin set as output */
-
-/* Bit 22 : Pin 22 */
-#define GPIO_DIR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
-#define GPIO_DIR_PIN22_Msk (0x1UL << GPIO_DIR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
-#define GPIO_DIR_PIN22_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN22_Output (1UL) /*!< Pin set as output */
-
-/* Bit 21 : Pin 21 */
-#define GPIO_DIR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
-#define GPIO_DIR_PIN21_Msk (0x1UL << GPIO_DIR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
-#define GPIO_DIR_PIN21_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN21_Output (1UL) /*!< Pin set as output */
-
-/* Bit 20 : Pin 20 */
-#define GPIO_DIR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
-#define GPIO_DIR_PIN20_Msk (0x1UL << GPIO_DIR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
-#define GPIO_DIR_PIN20_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN20_Output (1UL) /*!< Pin set as output */
-
-/* Bit 19 : Pin 19 */
-#define GPIO_DIR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
-#define GPIO_DIR_PIN19_Msk (0x1UL << GPIO_DIR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
-#define GPIO_DIR_PIN19_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN19_Output (1UL) /*!< Pin set as output */
-
-/* Bit 18 : Pin 18 */
-#define GPIO_DIR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
-#define GPIO_DIR_PIN18_Msk (0x1UL << GPIO_DIR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
-#define GPIO_DIR_PIN18_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN18_Output (1UL) /*!< Pin set as output */
-
-/* Bit 17 : Pin 17 */
-#define GPIO_DIR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
-#define GPIO_DIR_PIN17_Msk (0x1UL << GPIO_DIR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
-#define GPIO_DIR_PIN17_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN17_Output (1UL) /*!< Pin set as output */
-
-/* Bit 16 : Pin 16 */
-#define GPIO_DIR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
-#define GPIO_DIR_PIN16_Msk (0x1UL << GPIO_DIR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
-#define GPIO_DIR_PIN16_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN16_Output (1UL) /*!< Pin set as output */
-
-/* Bit 15 : Pin 15 */
-#define GPIO_DIR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
-#define GPIO_DIR_PIN15_Msk (0x1UL << GPIO_DIR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
-#define GPIO_DIR_PIN15_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN15_Output (1UL) /*!< Pin set as output */
-
-/* Bit 14 : Pin 14 */
-#define GPIO_DIR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
-#define GPIO_DIR_PIN14_Msk (0x1UL << GPIO_DIR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
-#define GPIO_DIR_PIN14_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN14_Output (1UL) /*!< Pin set as output */
-
-/* Bit 13 : Pin 13 */
-#define GPIO_DIR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
-#define GPIO_DIR_PIN13_Msk (0x1UL << GPIO_DIR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
-#define GPIO_DIR_PIN13_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN13_Output (1UL) /*!< Pin set as output */
-
-/* Bit 12 : Pin 12 */
-#define GPIO_DIR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
-#define GPIO_DIR_PIN12_Msk (0x1UL << GPIO_DIR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
-#define GPIO_DIR_PIN12_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN12_Output (1UL) /*!< Pin set as output */
-
-/* Bit 11 : Pin 11 */
-#define GPIO_DIR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
-#define GPIO_DIR_PIN11_Msk (0x1UL << GPIO_DIR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
-#define GPIO_DIR_PIN11_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN11_Output (1UL) /*!< Pin set as output */
-
-/* Bit 10 : Pin 10 */
-#define GPIO_DIR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
-#define GPIO_DIR_PIN10_Msk (0x1UL << GPIO_DIR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
-#define GPIO_DIR_PIN10_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN10_Output (1UL) /*!< Pin set as output */
-
-/* Bit 9 : Pin 9 */
-#define GPIO_DIR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
-#define GPIO_DIR_PIN9_Msk (0x1UL << GPIO_DIR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
-#define GPIO_DIR_PIN9_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN9_Output (1UL) /*!< Pin set as output */
-
-/* Bit 8 : Pin 8 */
-#define GPIO_DIR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
-#define GPIO_DIR_PIN8_Msk (0x1UL << GPIO_DIR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
-#define GPIO_DIR_PIN8_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN8_Output (1UL) /*!< Pin set as output */
-
-/* Bit 7 : Pin 7 */
-#define GPIO_DIR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
-#define GPIO_DIR_PIN7_Msk (0x1UL << GPIO_DIR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
-#define GPIO_DIR_PIN7_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN7_Output (1UL) /*!< Pin set as output */
-
-/* Bit 6 : Pin 6 */
-#define GPIO_DIR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
-#define GPIO_DIR_PIN6_Msk (0x1UL << GPIO_DIR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
-#define GPIO_DIR_PIN6_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN6_Output (1UL) /*!< Pin set as output */
-
-/* Bit 5 : Pin 5 */
-#define GPIO_DIR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
-#define GPIO_DIR_PIN5_Msk (0x1UL << GPIO_DIR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
-#define GPIO_DIR_PIN5_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN5_Output (1UL) /*!< Pin set as output */
-
-/* Bit 4 : Pin 4 */
-#define GPIO_DIR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
-#define GPIO_DIR_PIN4_Msk (0x1UL << GPIO_DIR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
-#define GPIO_DIR_PIN4_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN4_Output (1UL) /*!< Pin set as output */
-
-/* Bit 3 : Pin 3 */
-#define GPIO_DIR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
-#define GPIO_DIR_PIN3_Msk (0x1UL << GPIO_DIR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
-#define GPIO_DIR_PIN3_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN3_Output (1UL) /*!< Pin set as output */
-
-/* Bit 2 : Pin 2 */
-#define GPIO_DIR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
-#define GPIO_DIR_PIN2_Msk (0x1UL << GPIO_DIR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
-#define GPIO_DIR_PIN2_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN2_Output (1UL) /*!< Pin set as output */
-
-/* Bit 1 : Pin 1 */
-#define GPIO_DIR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
-#define GPIO_DIR_PIN1_Msk (0x1UL << GPIO_DIR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
-#define GPIO_DIR_PIN1_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN1_Output (1UL) /*!< Pin set as output */
-
-/* Bit 0 : Pin 0 */
-#define GPIO_DIR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
-#define GPIO_DIR_PIN0_Msk (0x1UL << GPIO_DIR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
-#define GPIO_DIR_PIN0_Input (0UL) /*!< Pin set as input */
-#define GPIO_DIR_PIN0_Output (1UL) /*!< Pin set as output */
-
-/* Register: GPIO_DIRSET */
-/* Description: DIR set register */
-
-/* Bit 31 : Set as output pin 31 */
-#define GPIO_DIRSET_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
-#define GPIO_DIRSET_PIN31_Msk (0x1UL << GPIO_DIRSET_PIN31_Pos) /*!< Bit mask of PIN31 field. */
-#define GPIO_DIRSET_PIN31_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN31_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN31_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 30 : Set as output pin 30 */
-#define GPIO_DIRSET_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
-#define GPIO_DIRSET_PIN30_Msk (0x1UL << GPIO_DIRSET_PIN30_Pos) /*!< Bit mask of PIN30 field. */
-#define GPIO_DIRSET_PIN30_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN30_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN30_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 29 : Set as output pin 29 */
-#define GPIO_DIRSET_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
-#define GPIO_DIRSET_PIN29_Msk (0x1UL << GPIO_DIRSET_PIN29_Pos) /*!< Bit mask of PIN29 field. */
-#define GPIO_DIRSET_PIN29_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN29_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN29_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 28 : Set as output pin 28 */
-#define GPIO_DIRSET_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
-#define GPIO_DIRSET_PIN28_Msk (0x1UL << GPIO_DIRSET_PIN28_Pos) /*!< Bit mask of PIN28 field. */
-#define GPIO_DIRSET_PIN28_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN28_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN28_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 27 : Set as output pin 27 */
-#define GPIO_DIRSET_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
-#define GPIO_DIRSET_PIN27_Msk (0x1UL << GPIO_DIRSET_PIN27_Pos) /*!< Bit mask of PIN27 field. */
-#define GPIO_DIRSET_PIN27_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN27_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN27_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 26 : Set as output pin 26 */
-#define GPIO_DIRSET_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
-#define GPIO_DIRSET_PIN26_Msk (0x1UL << GPIO_DIRSET_PIN26_Pos) /*!< Bit mask of PIN26 field. */
-#define GPIO_DIRSET_PIN26_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN26_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN26_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 25 : Set as output pin 25 */
-#define GPIO_DIRSET_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
-#define GPIO_DIRSET_PIN25_Msk (0x1UL << GPIO_DIRSET_PIN25_Pos) /*!< Bit mask of PIN25 field. */
-#define GPIO_DIRSET_PIN25_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN25_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN25_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 24 : Set as output pin 24 */
-#define GPIO_DIRSET_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
-#define GPIO_DIRSET_PIN24_Msk (0x1UL << GPIO_DIRSET_PIN24_Pos) /*!< Bit mask of PIN24 field. */
-#define GPIO_DIRSET_PIN24_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN24_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN24_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 23 : Set as output pin 23 */
-#define GPIO_DIRSET_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
-#define GPIO_DIRSET_PIN23_Msk (0x1UL << GPIO_DIRSET_PIN23_Pos) /*!< Bit mask of PIN23 field. */
-#define GPIO_DIRSET_PIN23_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN23_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN23_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 22 : Set as output pin 22 */
-#define GPIO_DIRSET_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
-#define GPIO_DIRSET_PIN22_Msk (0x1UL << GPIO_DIRSET_PIN22_Pos) /*!< Bit mask of PIN22 field. */
-#define GPIO_DIRSET_PIN22_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN22_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN22_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 21 : Set as output pin 21 */
-#define GPIO_DIRSET_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
-#define GPIO_DIRSET_PIN21_Msk (0x1UL << GPIO_DIRSET_PIN21_Pos) /*!< Bit mask of PIN21 field. */
-#define GPIO_DIRSET_PIN21_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN21_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN21_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 20 : Set as output pin 20 */
-#define GPIO_DIRSET_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
-#define GPIO_DIRSET_PIN20_Msk (0x1UL << GPIO_DIRSET_PIN20_Pos) /*!< Bit mask of PIN20 field. */
-#define GPIO_DIRSET_PIN20_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN20_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN20_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 19 : Set as output pin 19 */
-#define GPIO_DIRSET_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
-#define GPIO_DIRSET_PIN19_Msk (0x1UL << GPIO_DIRSET_PIN19_Pos) /*!< Bit mask of PIN19 field. */
-#define GPIO_DIRSET_PIN19_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN19_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN19_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 18 : Set as output pin 18 */
-#define GPIO_DIRSET_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
-#define GPIO_DIRSET_PIN18_Msk (0x1UL << GPIO_DIRSET_PIN18_Pos) /*!< Bit mask of PIN18 field. */
-#define GPIO_DIRSET_PIN18_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN18_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN18_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 17 : Set as output pin 17 */
-#define GPIO_DIRSET_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
-#define GPIO_DIRSET_PIN17_Msk (0x1UL << GPIO_DIRSET_PIN17_Pos) /*!< Bit mask of PIN17 field. */
-#define GPIO_DIRSET_PIN17_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN17_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN17_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 16 : Set as output pin 16 */
-#define GPIO_DIRSET_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
-#define GPIO_DIRSET_PIN16_Msk (0x1UL << GPIO_DIRSET_PIN16_Pos) /*!< Bit mask of PIN16 field. */
-#define GPIO_DIRSET_PIN16_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN16_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN16_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 15 : Set as output pin 15 */
-#define GPIO_DIRSET_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
-#define GPIO_DIRSET_PIN15_Msk (0x1UL << GPIO_DIRSET_PIN15_Pos) /*!< Bit mask of PIN15 field. */
-#define GPIO_DIRSET_PIN15_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN15_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN15_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 14 : Set as output pin 14 */
-#define GPIO_DIRSET_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
-#define GPIO_DIRSET_PIN14_Msk (0x1UL << GPIO_DIRSET_PIN14_Pos) /*!< Bit mask of PIN14 field. */
-#define GPIO_DIRSET_PIN14_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN14_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN14_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 13 : Set as output pin 13 */
-#define GPIO_DIRSET_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
-#define GPIO_DIRSET_PIN13_Msk (0x1UL << GPIO_DIRSET_PIN13_Pos) /*!< Bit mask of PIN13 field. */
-#define GPIO_DIRSET_PIN13_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN13_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN13_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 12 : Set as output pin 12 */
-#define GPIO_DIRSET_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
-#define GPIO_DIRSET_PIN12_Msk (0x1UL << GPIO_DIRSET_PIN12_Pos) /*!< Bit mask of PIN12 field. */
-#define GPIO_DIRSET_PIN12_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN12_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN12_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 11 : Set as output pin 11 */
-#define GPIO_DIRSET_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
-#define GPIO_DIRSET_PIN11_Msk (0x1UL << GPIO_DIRSET_PIN11_Pos) /*!< Bit mask of PIN11 field. */
-#define GPIO_DIRSET_PIN11_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN11_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN11_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 10 : Set as output pin 10 */
-#define GPIO_DIRSET_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
-#define GPIO_DIRSET_PIN10_Msk (0x1UL << GPIO_DIRSET_PIN10_Pos) /*!< Bit mask of PIN10 field. */
-#define GPIO_DIRSET_PIN10_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN10_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN10_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 9 : Set as output pin 9 */
-#define GPIO_DIRSET_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
-#define GPIO_DIRSET_PIN9_Msk (0x1UL << GPIO_DIRSET_PIN9_Pos) /*!< Bit mask of PIN9 field. */
-#define GPIO_DIRSET_PIN9_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN9_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN9_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 8 : Set as output pin 8 */
-#define GPIO_DIRSET_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
-#define GPIO_DIRSET_PIN8_Msk (0x1UL << GPIO_DIRSET_PIN8_Pos) /*!< Bit mask of PIN8 field. */
-#define GPIO_DIRSET_PIN8_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN8_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN8_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 7 : Set as output pin 7 */
-#define GPIO_DIRSET_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
-#define GPIO_DIRSET_PIN7_Msk (0x1UL << GPIO_DIRSET_PIN7_Pos) /*!< Bit mask of PIN7 field. */
-#define GPIO_DIRSET_PIN7_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN7_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN7_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 6 : Set as output pin 6 */
-#define GPIO_DIRSET_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
-#define GPIO_DIRSET_PIN6_Msk (0x1UL << GPIO_DIRSET_PIN6_Pos) /*!< Bit mask of PIN6 field. */
-#define GPIO_DIRSET_PIN6_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN6_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN6_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 5 : Set as output pin 5 */
-#define GPIO_DIRSET_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
-#define GPIO_DIRSET_PIN5_Msk (0x1UL << GPIO_DIRSET_PIN5_Pos) /*!< Bit mask of PIN5 field. */
-#define GPIO_DIRSET_PIN5_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN5_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN5_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 4 : Set as output pin 4 */
-#define GPIO_DIRSET_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
-#define GPIO_DIRSET_PIN4_Msk (0x1UL << GPIO_DIRSET_PIN4_Pos) /*!< Bit mask of PIN4 field. */
-#define GPIO_DIRSET_PIN4_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN4_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN4_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 3 : Set as output pin 3 */
-#define GPIO_DIRSET_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
-#define GPIO_DIRSET_PIN3_Msk (0x1UL << GPIO_DIRSET_PIN3_Pos) /*!< Bit mask of PIN3 field. */
-#define GPIO_DIRSET_PIN3_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN3_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN3_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 2 : Set as output pin 2 */
-#define GPIO_DIRSET_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
-#define GPIO_DIRSET_PIN2_Msk (0x1UL << GPIO_DIRSET_PIN2_Pos) /*!< Bit mask of PIN2 field. */
-#define GPIO_DIRSET_PIN2_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN2_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN2_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 1 : Set as output pin 1 */
-#define GPIO_DIRSET_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
-#define GPIO_DIRSET_PIN1_Msk (0x1UL << GPIO_DIRSET_PIN1_Pos) /*!< Bit mask of PIN1 field. */
-#define GPIO_DIRSET_PIN1_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN1_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN1_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Bit 0 : Set as output pin 0 */
-#define GPIO_DIRSET_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
-#define GPIO_DIRSET_PIN0_Msk (0x1UL << GPIO_DIRSET_PIN0_Pos) /*!< Bit mask of PIN0 field. */
-#define GPIO_DIRSET_PIN0_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRSET_PIN0_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRSET_PIN0_Set (1UL) /*!< Write: writing a '1' sets pin to output; writing a '0' has no effect */
-
-/* Register: GPIO_DIRCLR */
-/* Description: DIR clear register */
-
-/* Bit 31 : Set as input pin 31 */
-#define GPIO_DIRCLR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
-#define GPIO_DIRCLR_PIN31_Msk (0x1UL << GPIO_DIRCLR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
-#define GPIO_DIRCLR_PIN31_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN31_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN31_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 30 : Set as input pin 30 */
-#define GPIO_DIRCLR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
-#define GPIO_DIRCLR_PIN30_Msk (0x1UL << GPIO_DIRCLR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
-#define GPIO_DIRCLR_PIN30_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN30_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN30_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 29 : Set as input pin 29 */
-#define GPIO_DIRCLR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
-#define GPIO_DIRCLR_PIN29_Msk (0x1UL << GPIO_DIRCLR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
-#define GPIO_DIRCLR_PIN29_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN29_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN29_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 28 : Set as input pin 28 */
-#define GPIO_DIRCLR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
-#define GPIO_DIRCLR_PIN28_Msk (0x1UL << GPIO_DIRCLR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
-#define GPIO_DIRCLR_PIN28_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN28_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN28_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 27 : Set as input pin 27 */
-#define GPIO_DIRCLR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
-#define GPIO_DIRCLR_PIN27_Msk (0x1UL << GPIO_DIRCLR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
-#define GPIO_DIRCLR_PIN27_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN27_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN27_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 26 : Set as input pin 26 */
-#define GPIO_DIRCLR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
-#define GPIO_DIRCLR_PIN26_Msk (0x1UL << GPIO_DIRCLR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
-#define GPIO_DIRCLR_PIN26_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN26_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN26_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 25 : Set as input pin 25 */
-#define GPIO_DIRCLR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
-#define GPIO_DIRCLR_PIN25_Msk (0x1UL << GPIO_DIRCLR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
-#define GPIO_DIRCLR_PIN25_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN25_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN25_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 24 : Set as input pin 24 */
-#define GPIO_DIRCLR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
-#define GPIO_DIRCLR_PIN24_Msk (0x1UL << GPIO_DIRCLR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
-#define GPIO_DIRCLR_PIN24_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN24_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN24_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 23 : Set as input pin 23 */
-#define GPIO_DIRCLR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
-#define GPIO_DIRCLR_PIN23_Msk (0x1UL << GPIO_DIRCLR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
-#define GPIO_DIRCLR_PIN23_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN23_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN23_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 22 : Set as input pin 22 */
-#define GPIO_DIRCLR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
-#define GPIO_DIRCLR_PIN22_Msk (0x1UL << GPIO_DIRCLR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
-#define GPIO_DIRCLR_PIN22_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN22_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN22_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 21 : Set as input pin 21 */
-#define GPIO_DIRCLR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
-#define GPIO_DIRCLR_PIN21_Msk (0x1UL << GPIO_DIRCLR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
-#define GPIO_DIRCLR_PIN21_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN21_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN21_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 20 : Set as input pin 20 */
-#define GPIO_DIRCLR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
-#define GPIO_DIRCLR_PIN20_Msk (0x1UL << GPIO_DIRCLR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
-#define GPIO_DIRCLR_PIN20_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN20_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN20_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 19 : Set as input pin 19 */
-#define GPIO_DIRCLR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
-#define GPIO_DIRCLR_PIN19_Msk (0x1UL << GPIO_DIRCLR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
-#define GPIO_DIRCLR_PIN19_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN19_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN19_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 18 : Set as input pin 18 */
-#define GPIO_DIRCLR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
-#define GPIO_DIRCLR_PIN18_Msk (0x1UL << GPIO_DIRCLR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
-#define GPIO_DIRCLR_PIN18_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN18_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN18_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 17 : Set as input pin 17 */
-#define GPIO_DIRCLR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
-#define GPIO_DIRCLR_PIN17_Msk (0x1UL << GPIO_DIRCLR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
-#define GPIO_DIRCLR_PIN17_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN17_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN17_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 16 : Set as input pin 16 */
-#define GPIO_DIRCLR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
-#define GPIO_DIRCLR_PIN16_Msk (0x1UL << GPIO_DIRCLR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
-#define GPIO_DIRCLR_PIN16_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN16_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN16_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 15 : Set as input pin 15 */
-#define GPIO_DIRCLR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
-#define GPIO_DIRCLR_PIN15_Msk (0x1UL << GPIO_DIRCLR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
-#define GPIO_DIRCLR_PIN15_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN15_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN15_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 14 : Set as input pin 14 */
-#define GPIO_DIRCLR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
-#define GPIO_DIRCLR_PIN14_Msk (0x1UL << GPIO_DIRCLR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
-#define GPIO_DIRCLR_PIN14_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN14_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN14_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 13 : Set as input pin 13 */
-#define GPIO_DIRCLR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
-#define GPIO_DIRCLR_PIN13_Msk (0x1UL << GPIO_DIRCLR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
-#define GPIO_DIRCLR_PIN13_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN13_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN13_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 12 : Set as input pin 12 */
-#define GPIO_DIRCLR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
-#define GPIO_DIRCLR_PIN12_Msk (0x1UL << GPIO_DIRCLR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
-#define GPIO_DIRCLR_PIN12_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN12_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN12_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 11 : Set as input pin 11 */
-#define GPIO_DIRCLR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
-#define GPIO_DIRCLR_PIN11_Msk (0x1UL << GPIO_DIRCLR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
-#define GPIO_DIRCLR_PIN11_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN11_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN11_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 10 : Set as input pin 10 */
-#define GPIO_DIRCLR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
-#define GPIO_DIRCLR_PIN10_Msk (0x1UL << GPIO_DIRCLR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
-#define GPIO_DIRCLR_PIN10_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN10_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN10_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 9 : Set as input pin 9 */
-#define GPIO_DIRCLR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
-#define GPIO_DIRCLR_PIN9_Msk (0x1UL << GPIO_DIRCLR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
-#define GPIO_DIRCLR_PIN9_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN9_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN9_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 8 : Set as input pin 8 */
-#define GPIO_DIRCLR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
-#define GPIO_DIRCLR_PIN8_Msk (0x1UL << GPIO_DIRCLR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
-#define GPIO_DIRCLR_PIN8_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN8_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN8_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 7 : Set as input pin 7 */
-#define GPIO_DIRCLR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
-#define GPIO_DIRCLR_PIN7_Msk (0x1UL << GPIO_DIRCLR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
-#define GPIO_DIRCLR_PIN7_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN7_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN7_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 6 : Set as input pin 6 */
-#define GPIO_DIRCLR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
-#define GPIO_DIRCLR_PIN6_Msk (0x1UL << GPIO_DIRCLR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
-#define GPIO_DIRCLR_PIN6_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN6_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN6_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 5 : Set as input pin 5 */
-#define GPIO_DIRCLR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
-#define GPIO_DIRCLR_PIN5_Msk (0x1UL << GPIO_DIRCLR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
-#define GPIO_DIRCLR_PIN5_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN5_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN5_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 4 : Set as input pin 4 */
-#define GPIO_DIRCLR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
-#define GPIO_DIRCLR_PIN4_Msk (0x1UL << GPIO_DIRCLR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
-#define GPIO_DIRCLR_PIN4_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN4_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN4_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 3 : Set as input pin 3 */
-#define GPIO_DIRCLR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
-#define GPIO_DIRCLR_PIN3_Msk (0x1UL << GPIO_DIRCLR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
-#define GPIO_DIRCLR_PIN3_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN3_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN3_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 2 : Set as input pin 2 */
-#define GPIO_DIRCLR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
-#define GPIO_DIRCLR_PIN2_Msk (0x1UL << GPIO_DIRCLR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
-#define GPIO_DIRCLR_PIN2_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN2_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN2_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 1 : Set as input pin 1 */
-#define GPIO_DIRCLR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
-#define GPIO_DIRCLR_PIN1_Msk (0x1UL << GPIO_DIRCLR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
-#define GPIO_DIRCLR_PIN1_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN1_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN1_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Bit 0 : Set as input pin 0 */
-#define GPIO_DIRCLR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
-#define GPIO_DIRCLR_PIN0_Msk (0x1UL << GPIO_DIRCLR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
-#define GPIO_DIRCLR_PIN0_Input (0UL) /*!< Read: pin set as input */
-#define GPIO_DIRCLR_PIN0_Output (1UL) /*!< Read: pin set as output */
-#define GPIO_DIRCLR_PIN0_Clear (1UL) /*!< Write: writing a '1' sets pin to input; writing a '0' has no effect */
-
-/* Register: GPIO_LATCH */
-/* Description: Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF[n].SENSE registers */
-
-/* Bit 31 : Status on whether PIN31 has met criteria set in PIN_CNF31.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
-#define GPIO_LATCH_PIN31_Msk (0x1UL << GPIO_LATCH_PIN31_Pos) /*!< Bit mask of PIN31 field. */
-#define GPIO_LATCH_PIN31_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN31_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 30 : Status on whether PIN30 has met criteria set in PIN_CNF30.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
-#define GPIO_LATCH_PIN30_Msk (0x1UL << GPIO_LATCH_PIN30_Pos) /*!< Bit mask of PIN30 field. */
-#define GPIO_LATCH_PIN30_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN30_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 29 : Status on whether PIN29 has met criteria set in PIN_CNF29.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
-#define GPIO_LATCH_PIN29_Msk (0x1UL << GPIO_LATCH_PIN29_Pos) /*!< Bit mask of PIN29 field. */
-#define GPIO_LATCH_PIN29_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN29_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 28 : Status on whether PIN28 has met criteria set in PIN_CNF28.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
-#define GPIO_LATCH_PIN28_Msk (0x1UL << GPIO_LATCH_PIN28_Pos) /*!< Bit mask of PIN28 field. */
-#define GPIO_LATCH_PIN28_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN28_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 27 : Status on whether PIN27 has met criteria set in PIN_CNF27.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
-#define GPIO_LATCH_PIN27_Msk (0x1UL << GPIO_LATCH_PIN27_Pos) /*!< Bit mask of PIN27 field. */
-#define GPIO_LATCH_PIN27_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN27_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 26 : Status on whether PIN26 has met criteria set in PIN_CNF26.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
-#define GPIO_LATCH_PIN26_Msk (0x1UL << GPIO_LATCH_PIN26_Pos) /*!< Bit mask of PIN26 field. */
-#define GPIO_LATCH_PIN26_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN26_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 25 : Status on whether PIN25 has met criteria set in PIN_CNF25.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
-#define GPIO_LATCH_PIN25_Msk (0x1UL << GPIO_LATCH_PIN25_Pos) /*!< Bit mask of PIN25 field. */
-#define GPIO_LATCH_PIN25_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN25_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 24 : Status on whether PIN24 has met criteria set in PIN_CNF24.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
-#define GPIO_LATCH_PIN24_Msk (0x1UL << GPIO_LATCH_PIN24_Pos) /*!< Bit mask of PIN24 field. */
-#define GPIO_LATCH_PIN24_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN24_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 23 : Status on whether PIN23 has met criteria set in PIN_CNF23.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
-#define GPIO_LATCH_PIN23_Msk (0x1UL << GPIO_LATCH_PIN23_Pos) /*!< Bit mask of PIN23 field. */
-#define GPIO_LATCH_PIN23_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN23_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 22 : Status on whether PIN22 has met criteria set in PIN_CNF22.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
-#define GPIO_LATCH_PIN22_Msk (0x1UL << GPIO_LATCH_PIN22_Pos) /*!< Bit mask of PIN22 field. */
-#define GPIO_LATCH_PIN22_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN22_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 21 : Status on whether PIN21 has met criteria set in PIN_CNF21.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
-#define GPIO_LATCH_PIN21_Msk (0x1UL << GPIO_LATCH_PIN21_Pos) /*!< Bit mask of PIN21 field. */
-#define GPIO_LATCH_PIN21_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN21_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 20 : Status on whether PIN20 has met criteria set in PIN_CNF20.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
-#define GPIO_LATCH_PIN20_Msk (0x1UL << GPIO_LATCH_PIN20_Pos) /*!< Bit mask of PIN20 field. */
-#define GPIO_LATCH_PIN20_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN20_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 19 : Status on whether PIN19 has met criteria set in PIN_CNF19.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
-#define GPIO_LATCH_PIN19_Msk (0x1UL << GPIO_LATCH_PIN19_Pos) /*!< Bit mask of PIN19 field. */
-#define GPIO_LATCH_PIN19_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN19_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 18 : Status on whether PIN18 has met criteria set in PIN_CNF18.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
-#define GPIO_LATCH_PIN18_Msk (0x1UL << GPIO_LATCH_PIN18_Pos) /*!< Bit mask of PIN18 field. */
-#define GPIO_LATCH_PIN18_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN18_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 17 : Status on whether PIN17 has met criteria set in PIN_CNF17.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
-#define GPIO_LATCH_PIN17_Msk (0x1UL << GPIO_LATCH_PIN17_Pos) /*!< Bit mask of PIN17 field. */
-#define GPIO_LATCH_PIN17_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN17_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 16 : Status on whether PIN16 has met criteria set in PIN_CNF16.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
-#define GPIO_LATCH_PIN16_Msk (0x1UL << GPIO_LATCH_PIN16_Pos) /*!< Bit mask of PIN16 field. */
-#define GPIO_LATCH_PIN16_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN16_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 15 : Status on whether PIN15 has met criteria set in PIN_CNF15.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
-#define GPIO_LATCH_PIN15_Msk (0x1UL << GPIO_LATCH_PIN15_Pos) /*!< Bit mask of PIN15 field. */
-#define GPIO_LATCH_PIN15_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN15_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 14 : Status on whether PIN14 has met criteria set in PIN_CNF14.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
-#define GPIO_LATCH_PIN14_Msk (0x1UL << GPIO_LATCH_PIN14_Pos) /*!< Bit mask of PIN14 field. */
-#define GPIO_LATCH_PIN14_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN14_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 13 : Status on whether PIN13 has met criteria set in PIN_CNF13.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
-#define GPIO_LATCH_PIN13_Msk (0x1UL << GPIO_LATCH_PIN13_Pos) /*!< Bit mask of PIN13 field. */
-#define GPIO_LATCH_PIN13_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN13_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 12 : Status on whether PIN12 has met criteria set in PIN_CNF12.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
-#define GPIO_LATCH_PIN12_Msk (0x1UL << GPIO_LATCH_PIN12_Pos) /*!< Bit mask of PIN12 field. */
-#define GPIO_LATCH_PIN12_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN12_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 11 : Status on whether PIN11 has met criteria set in PIN_CNF11.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
-#define GPIO_LATCH_PIN11_Msk (0x1UL << GPIO_LATCH_PIN11_Pos) /*!< Bit mask of PIN11 field. */
-#define GPIO_LATCH_PIN11_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN11_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 10 : Status on whether PIN10 has met criteria set in PIN_CNF10.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
-#define GPIO_LATCH_PIN10_Msk (0x1UL << GPIO_LATCH_PIN10_Pos) /*!< Bit mask of PIN10 field. */
-#define GPIO_LATCH_PIN10_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN10_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 9 : Status on whether PIN9 has met criteria set in PIN_CNF9.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
-#define GPIO_LATCH_PIN9_Msk (0x1UL << GPIO_LATCH_PIN9_Pos) /*!< Bit mask of PIN9 field. */
-#define GPIO_LATCH_PIN9_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN9_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 8 : Status on whether PIN8 has met criteria set in PIN_CNF8.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
-#define GPIO_LATCH_PIN8_Msk (0x1UL << GPIO_LATCH_PIN8_Pos) /*!< Bit mask of PIN8 field. */
-#define GPIO_LATCH_PIN8_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN8_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 7 : Status on whether PIN7 has met criteria set in PIN_CNF7.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
-#define GPIO_LATCH_PIN7_Msk (0x1UL << GPIO_LATCH_PIN7_Pos) /*!< Bit mask of PIN7 field. */
-#define GPIO_LATCH_PIN7_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN7_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 6 : Status on whether PIN6 has met criteria set in PIN_CNF6.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
-#define GPIO_LATCH_PIN6_Msk (0x1UL << GPIO_LATCH_PIN6_Pos) /*!< Bit mask of PIN6 field. */
-#define GPIO_LATCH_PIN6_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN6_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 5 : Status on whether PIN5 has met criteria set in PIN_CNF5.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
-#define GPIO_LATCH_PIN5_Msk (0x1UL << GPIO_LATCH_PIN5_Pos) /*!< Bit mask of PIN5 field. */
-#define GPIO_LATCH_PIN5_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN5_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 4 : Status on whether PIN4 has met criteria set in PIN_CNF4.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
-#define GPIO_LATCH_PIN4_Msk (0x1UL << GPIO_LATCH_PIN4_Pos) /*!< Bit mask of PIN4 field. */
-#define GPIO_LATCH_PIN4_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN4_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 3 : Status on whether PIN3 has met criteria set in PIN_CNF3.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
-#define GPIO_LATCH_PIN3_Msk (0x1UL << GPIO_LATCH_PIN3_Pos) /*!< Bit mask of PIN3 field. */
-#define GPIO_LATCH_PIN3_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN3_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 2 : Status on whether PIN2 has met criteria set in PIN_CNF2.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
-#define GPIO_LATCH_PIN2_Msk (0x1UL << GPIO_LATCH_PIN2_Pos) /*!< Bit mask of PIN2 field. */
-#define GPIO_LATCH_PIN2_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN2_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 1 : Status on whether PIN1 has met criteria set in PIN_CNF1.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
-#define GPIO_LATCH_PIN1_Msk (0x1UL << GPIO_LATCH_PIN1_Pos) /*!< Bit mask of PIN1 field. */
-#define GPIO_LATCH_PIN1_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN1_Latched (1UL) /*!< Criteria has been met */
-
-/* Bit 0 : Status on whether PIN0 has met criteria set in PIN_CNF0.SENSE register. Write '1' to clear. */
-#define GPIO_LATCH_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
-#define GPIO_LATCH_PIN0_Msk (0x1UL << GPIO_LATCH_PIN0_Pos) /*!< Bit mask of PIN0 field. */
-#define GPIO_LATCH_PIN0_NotLatched (0UL) /*!< Criteria has not been met */
-#define GPIO_LATCH_PIN0_Latched (1UL) /*!< Criteria has been met */
-
-/* Register: GPIO_DETECTMODE */
-/* Description: Select between default DETECT signal behaviour and LDETECT mode */
-
-/* Bit 0 : Select between default DETECT signal behaviour and LDETECT mode */
-#define GPIO_DETECTMODE_DETECTMODE_Pos (0UL) /*!< Position of DETECTMODE field. */
-#define GPIO_DETECTMODE_DETECTMODE_Msk (0x1UL << GPIO_DETECTMODE_DETECTMODE_Pos) /*!< Bit mask of DETECTMODE field. */
-#define GPIO_DETECTMODE_DETECTMODE_Default (0UL) /*!< DETECT directly connected to PIN DETECT signals */
-#define GPIO_DETECTMODE_DETECTMODE_LDETECT (1UL) /*!< Use the latched LDETECT behaviour */
-
-/* Register: GPIO_PIN_CNF */
-/* Description: Description collection[0]:  Configuration of GPIO pins */
-
-/* Bits 17..16 : Pin sensing mechanism */
-#define GPIO_PIN_CNF_SENSE_Pos (16UL) /*!< Position of SENSE field. */
-#define GPIO_PIN_CNF_SENSE_Msk (0x3UL << GPIO_PIN_CNF_SENSE_Pos) /*!< Bit mask of SENSE field. */
-#define GPIO_PIN_CNF_SENSE_Disabled (0UL) /*!< Disabled */
-#define GPIO_PIN_CNF_SENSE_High (2UL) /*!< Sense for high level */
-#define GPIO_PIN_CNF_SENSE_Low (3UL) /*!< Sense for low level */
-
-/* Bits 10..8 : Drive configuration */
-#define GPIO_PIN_CNF_DRIVE_Pos (8UL) /*!< Position of DRIVE field. */
-#define GPIO_PIN_CNF_DRIVE_Msk (0x7UL << GPIO_PIN_CNF_DRIVE_Pos) /*!< Bit mask of DRIVE field. */
-#define GPIO_PIN_CNF_DRIVE_S0S1 (0UL) /*!< Standard '0', standard '1' */
-#define GPIO_PIN_CNF_DRIVE_H0S1 (1UL) /*!< High drive '0', standard '1' */
-#define GPIO_PIN_CNF_DRIVE_S0H1 (2UL) /*!< Standard '0', high drive '1' */
-#define GPIO_PIN_CNF_DRIVE_H0H1 (3UL) /*!< High drive '0', high 'drive '1'' */
-#define GPIO_PIN_CNF_DRIVE_D0S1 (4UL) /*!< Disconnect '0' standard '1' (normally used for wired-or connections) */
-#define GPIO_PIN_CNF_DRIVE_D0H1 (5UL) /*!< Disconnect '0', high drive '1' (normally used for wired-or connections) */
-#define GPIO_PIN_CNF_DRIVE_S0D1 (6UL) /*!< Standard '0'. disconnect '1' (normally used for wired-and connections) */
-#define GPIO_PIN_CNF_DRIVE_H0D1 (7UL) /*!< High drive '0', disconnect '1' (normally used for wired-and connections) */
-
-/* Bits 3..2 : Pull configuration */
-#define GPIO_PIN_CNF_PULL_Pos (2UL) /*!< Position of PULL field. */
-#define GPIO_PIN_CNF_PULL_Msk (0x3UL << GPIO_PIN_CNF_PULL_Pos) /*!< Bit mask of PULL field. */
-#define GPIO_PIN_CNF_PULL_Disabled (0UL) /*!< No pull */
-#define GPIO_PIN_CNF_PULL_Pulldown (1UL) /*!< Pull down on pin */
-#define GPIO_PIN_CNF_PULL_Pullup (3UL) /*!< Pull up on pin */
-
-/* Bit 1 : Connect or disconnect input buffer */
-#define GPIO_PIN_CNF_INPUT_Pos (1UL) /*!< Position of INPUT field. */
-#define GPIO_PIN_CNF_INPUT_Msk (0x1UL << GPIO_PIN_CNF_INPUT_Pos) /*!< Bit mask of INPUT field. */
-#define GPIO_PIN_CNF_INPUT_Connect (0UL) /*!< Connect input buffer */
-#define GPIO_PIN_CNF_INPUT_Disconnect (1UL) /*!< Disconnect input buffer */
-
-/* Bit 0 : Pin direction. Same physical register as DIR register */
-#define GPIO_PIN_CNF_DIR_Pos (0UL) /*!< Position of DIR field. */
-#define GPIO_PIN_CNF_DIR_Msk (0x1UL << GPIO_PIN_CNF_DIR_Pos) /*!< Bit mask of DIR field. */
-#define GPIO_PIN_CNF_DIR_Input (0UL) /*!< Configure pin as an input pin */
-#define GPIO_PIN_CNF_DIR_Output (1UL) /*!< Configure pin as an output pin */
-
-
-/* Peripheral: PDM */
-/* Description: Pulse Density Modulation (Digital Microphone) Interface */
-
-/* Register: PDM_INTEN */
-/* Description: Enable or disable interrupt */
-
-/* Bit 2 : Enable or disable interrupt for END event */
-#define PDM_INTEN_END_Pos (2UL) /*!< Position of END field. */
-#define PDM_INTEN_END_Msk (0x1UL << PDM_INTEN_END_Pos) /*!< Bit mask of END field. */
-#define PDM_INTEN_END_Disabled (0UL) /*!< Disable */
-#define PDM_INTEN_END_Enabled (1UL) /*!< Enable */
-
-/* Bit 1 : Enable or disable interrupt for STOPPED event */
-#define PDM_INTEN_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
-#define PDM_INTEN_STOPPED_Msk (0x1UL << PDM_INTEN_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define PDM_INTEN_STOPPED_Disabled (0UL) /*!< Disable */
-#define PDM_INTEN_STOPPED_Enabled (1UL) /*!< Enable */
-
-/* Bit 0 : Enable or disable interrupt for STARTED event */
-#define PDM_INTEN_STARTED_Pos (0UL) /*!< Position of STARTED field. */
-#define PDM_INTEN_STARTED_Msk (0x1UL << PDM_INTEN_STARTED_Pos) /*!< Bit mask of STARTED field. */
-#define PDM_INTEN_STARTED_Disabled (0UL) /*!< Disable */
-#define PDM_INTEN_STARTED_Enabled (1UL) /*!< Enable */
-
-/* Register: PDM_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 2 : Write '1' to Enable interrupt for END event */
-#define PDM_INTENSET_END_Pos (2UL) /*!< Position of END field. */
-#define PDM_INTENSET_END_Msk (0x1UL << PDM_INTENSET_END_Pos) /*!< Bit mask of END field. */
-#define PDM_INTENSET_END_Disabled (0UL) /*!< Read: Disabled */
-#define PDM_INTENSET_END_Enabled (1UL) /*!< Read: Enabled */
-#define PDM_INTENSET_END_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for STOPPED event */
-#define PDM_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
-#define PDM_INTENSET_STOPPED_Msk (0x1UL << PDM_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define PDM_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define PDM_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define PDM_INTENSET_STOPPED_Set (1UL) /*!< Enable */
-
-/* Bit 0 : Write '1' to Enable interrupt for STARTED event */
-#define PDM_INTENSET_STARTED_Pos (0UL) /*!< Position of STARTED field. */
-#define PDM_INTENSET_STARTED_Msk (0x1UL << PDM_INTENSET_STARTED_Pos) /*!< Bit mask of STARTED field. */
-#define PDM_INTENSET_STARTED_Disabled (0UL) /*!< Read: Disabled */
-#define PDM_INTENSET_STARTED_Enabled (1UL) /*!< Read: Enabled */
-#define PDM_INTENSET_STARTED_Set (1UL) /*!< Enable */
-
-/* Register: PDM_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 2 : Write '1' to Disable interrupt for END event */
-#define PDM_INTENCLR_END_Pos (2UL) /*!< Position of END field. */
-#define PDM_INTENCLR_END_Msk (0x1UL << PDM_INTENCLR_END_Pos) /*!< Bit mask of END field. */
-#define PDM_INTENCLR_END_Disabled (0UL) /*!< Read: Disabled */
-#define PDM_INTENCLR_END_Enabled (1UL) /*!< Read: Enabled */
-#define PDM_INTENCLR_END_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for STOPPED event */
-#define PDM_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
-#define PDM_INTENCLR_STOPPED_Msk (0x1UL << PDM_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define PDM_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define PDM_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define PDM_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
-
-/* Bit 0 : Write '1' to Disable interrupt for STARTED event */
-#define PDM_INTENCLR_STARTED_Pos (0UL) /*!< Position of STARTED field. */
-#define PDM_INTENCLR_STARTED_Msk (0x1UL << PDM_INTENCLR_STARTED_Pos) /*!< Bit mask of STARTED field. */
-#define PDM_INTENCLR_STARTED_Disabled (0UL) /*!< Read: Disabled */
-#define PDM_INTENCLR_STARTED_Enabled (1UL) /*!< Read: Enabled */
-#define PDM_INTENCLR_STARTED_Clear (1UL) /*!< Disable */
-
-/* Register: PDM_ENABLE */
-/* Description: PDM module enable register */
-
-/* Bit 0 : Enable or disable PDM module */
-#define PDM_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
-#define PDM_ENABLE_ENABLE_Msk (0x1UL << PDM_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
-#define PDM_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
-#define PDM_ENABLE_ENABLE_Enabled (1UL) /*!< Enable */
-
-/* Register: PDM_PDMCLKCTRL */
-/* Description: PDM clock generator control */
-
-/* Bits 31..0 : PDM_CLK frequency */
-#define PDM_PDMCLKCTRL_FREQ_Pos (0UL) /*!< Position of FREQ field. */
-#define PDM_PDMCLKCTRL_FREQ_Msk (0xFFFFFFFFUL << PDM_PDMCLKCTRL_FREQ_Pos) /*!< Bit mask of FREQ field. */
-#define PDM_PDMCLKCTRL_FREQ_1000K (0x08000000UL) /*!< PDM_CLK = 32 MHz / 32 = 1.000 MHz */
-#define PDM_PDMCLKCTRL_FREQ_Default (0x08400000UL) /*!< PDM_CLK = 32 MHz / 31 = 1.032 MHz */
-#define PDM_PDMCLKCTRL_FREQ_1067K (0x08800000UL) /*!< PDM_CLK = 32 MHz / 30 = 1.067 MHz */
-
-/* Register: PDM_MODE */
-/* Description: Defines the routing of the connected PDM microphones' signals */
-
-/* Bit 1 : Defines on which PDM_CLK edge Left (or mono) is sampled */
-#define PDM_MODE_EDGE_Pos (1UL) /*!< Position of EDGE field. */
-#define PDM_MODE_EDGE_Msk (0x1UL << PDM_MODE_EDGE_Pos) /*!< Bit mask of EDGE field. */
-#define PDM_MODE_EDGE_LeftFalling (0UL) /*!< Left (or mono) is sampled on falling edge of PDM_CLK */
-#define PDM_MODE_EDGE_LeftRising (1UL) /*!< Left (or mono) is sampled on rising edge of PDM_CLK */
-
-/* Bit 0 : Mono or stereo operation */
-#define PDM_MODE_OPERATION_Pos (0UL) /*!< Position of OPERATION field. */
-#define PDM_MODE_OPERATION_Msk (0x1UL << PDM_MODE_OPERATION_Pos) /*!< Bit mask of OPERATION field. */
-#define PDM_MODE_OPERATION_Stereo (0UL) /*!< Sample and store one pair (Left + Right) of 16bit samples per RAM word R=[31:16]; L=[15:0] */
-#define PDM_MODE_OPERATION_Mono (1UL) /*!< Sample and store two successive Left samples (16 bit each) per RAM word L1=[31:16]; L0=[15:0] */
-
-/* Register: PDM_GAINL */
-/* Description: Left output gain adjustment */
-
-/* Bits 6..0 : Left output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) 0x00    -20 dB gain adjust 0x01  -19.5 dB gain adjust (...) 0x27   -0.5 dB gain adjust 0x28      0 dB gain adjust 0x29   +0.5 dB gain adjust (...) 0x4F  +19.5 dB gain adjust 0x50    +20 dB gain adjust */
-#define PDM_GAINL_GAINL_Pos (0UL) /*!< Position of GAINL field. */
-#define PDM_GAINL_GAINL_Msk (0x7FUL << PDM_GAINL_GAINL_Pos) /*!< Bit mask of GAINL field. */
-#define PDM_GAINL_GAINL_MinGain (0x00UL) /*!< -20dB gain adjustment (minimum) */
-#define PDM_GAINL_GAINL_DefaultGain (0x28UL) /*!< 0dB gain adjustment ('2500 RMS' requirement) */
-#define PDM_GAINL_GAINL_MaxGain (0x50UL) /*!< +20dB gain adjustment (maximum) */
-
-/* Register: PDM_GAINR */
-/* Description: Right output gain adjustment */
-
-/* Bits 7..0 : Right output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) */
-#define PDM_GAINR_GAINR_Pos (0UL) /*!< Position of GAINR field. */
-#define PDM_GAINR_GAINR_Msk (0xFFUL << PDM_GAINR_GAINR_Pos) /*!< Bit mask of GAINR field. */
-#define PDM_GAINR_GAINR_MinGain (0x00UL) /*!< -20dB gain adjustment (minimum) */
-#define PDM_GAINR_GAINR_DefaultGain (0x28UL) /*!< 0dB gain adjustment ('2500 RMS' requirement) */
-#define PDM_GAINR_GAINR_MaxGain (0x50UL) /*!< +20dB gain adjustment (maximum) */
-
-/* Register: PDM_PSEL_CLK */
-/* Description: Pin number configuration for PDM CLK signal */
-
-/* Bit 31 : Connection */
-#define PDM_PSEL_CLK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define PDM_PSEL_CLK_CONNECT_Msk (0x1UL << PDM_PSEL_CLK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define PDM_PSEL_CLK_CONNECT_Connected (0UL) /*!< Connect */
-#define PDM_PSEL_CLK_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define PDM_PSEL_CLK_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define PDM_PSEL_CLK_PIN_Msk (0x1FUL << PDM_PSEL_CLK_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: PDM_PSEL_DIN */
-/* Description: Pin number configuration for PDM DIN signal */
-
-/* Bit 31 : Connection */
-#define PDM_PSEL_DIN_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define PDM_PSEL_DIN_CONNECT_Msk (0x1UL << PDM_PSEL_DIN_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define PDM_PSEL_DIN_CONNECT_Connected (0UL) /*!< Connect */
-#define PDM_PSEL_DIN_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define PDM_PSEL_DIN_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define PDM_PSEL_DIN_PIN_Msk (0x1FUL << PDM_PSEL_DIN_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: PDM_SAMPLE_PTR */
-/* Description: RAM address pointer to write samples to with EasyDMA */
-
-/* Bits 31..0 : Address to write PDM samples to over DMA */
-#define PDM_SAMPLE_PTR_SAMPLEPTR_Pos (0UL) /*!< Position of SAMPLEPTR field. */
-#define PDM_SAMPLE_PTR_SAMPLEPTR_Msk (0xFFFFFFFFUL << PDM_SAMPLE_PTR_SAMPLEPTR_Pos) /*!< Bit mask of SAMPLEPTR field. */
-
-/* Register: PDM_SAMPLE_MAXCNT */
-/* Description: Number of samples to allocate memory for in EasyDMA mode */
-
-/* Bits 14..0 : Length of DMA RAM allocation in number of samples */
-#define PDM_SAMPLE_MAXCNT_BUFFSIZE_Pos (0UL) /*!< Position of BUFFSIZE field. */
-#define PDM_SAMPLE_MAXCNT_BUFFSIZE_Msk (0x7FFFUL << PDM_SAMPLE_MAXCNT_BUFFSIZE_Pos) /*!< Bit mask of BUFFSIZE field. */
-
-
-/* Peripheral: POWER */
-/* Description: Power control */
-
-/* Register: POWER_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 6 : Write '1' to Enable interrupt for SLEEPEXIT event */
-#define POWER_INTENSET_SLEEPEXIT_Pos (6UL) /*!< Position of SLEEPEXIT field. */
-#define POWER_INTENSET_SLEEPEXIT_Msk (0x1UL << POWER_INTENSET_SLEEPEXIT_Pos) /*!< Bit mask of SLEEPEXIT field. */
-#define POWER_INTENSET_SLEEPEXIT_Disabled (0UL) /*!< Read: Disabled */
-#define POWER_INTENSET_SLEEPEXIT_Enabled (1UL) /*!< Read: Enabled */
-#define POWER_INTENSET_SLEEPEXIT_Set (1UL) /*!< Enable */
-
-/* Bit 5 : Write '1' to Enable interrupt for SLEEPENTER event */
-#define POWER_INTENSET_SLEEPENTER_Pos (5UL) /*!< Position of SLEEPENTER field. */
-#define POWER_INTENSET_SLEEPENTER_Msk (0x1UL << POWER_INTENSET_SLEEPENTER_Pos) /*!< Bit mask of SLEEPENTER field. */
-#define POWER_INTENSET_SLEEPENTER_Disabled (0UL) /*!< Read: Disabled */
-#define POWER_INTENSET_SLEEPENTER_Enabled (1UL) /*!< Read: Enabled */
-#define POWER_INTENSET_SLEEPENTER_Set (1UL) /*!< Enable */
-
-/* Bit 2 : Write '1' to Enable interrupt for POFWARN event */
-#define POWER_INTENSET_POFWARN_Pos (2UL) /*!< Position of POFWARN field. */
-#define POWER_INTENSET_POFWARN_Msk (0x1UL << POWER_INTENSET_POFWARN_Pos) /*!< Bit mask of POFWARN field. */
-#define POWER_INTENSET_POFWARN_Disabled (0UL) /*!< Read: Disabled */
-#define POWER_INTENSET_POFWARN_Enabled (1UL) /*!< Read: Enabled */
-#define POWER_INTENSET_POFWARN_Set (1UL) /*!< Enable */
-
-/* Register: POWER_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 6 : Write '1' to Disable interrupt for SLEEPEXIT event */
-#define POWER_INTENCLR_SLEEPEXIT_Pos (6UL) /*!< Position of SLEEPEXIT field. */
-#define POWER_INTENCLR_SLEEPEXIT_Msk (0x1UL << POWER_INTENCLR_SLEEPEXIT_Pos) /*!< Bit mask of SLEEPEXIT field. */
-#define POWER_INTENCLR_SLEEPEXIT_Disabled (0UL) /*!< Read: Disabled */
-#define POWER_INTENCLR_SLEEPEXIT_Enabled (1UL) /*!< Read: Enabled */
-#define POWER_INTENCLR_SLEEPEXIT_Clear (1UL) /*!< Disable */
-
-/* Bit 5 : Write '1' to Disable interrupt for SLEEPENTER event */
-#define POWER_INTENCLR_SLEEPENTER_Pos (5UL) /*!< Position of SLEEPENTER field. */
-#define POWER_INTENCLR_SLEEPENTER_Msk (0x1UL << POWER_INTENCLR_SLEEPENTER_Pos) /*!< Bit mask of SLEEPENTER field. */
-#define POWER_INTENCLR_SLEEPENTER_Disabled (0UL) /*!< Read: Disabled */
-#define POWER_INTENCLR_SLEEPENTER_Enabled (1UL) /*!< Read: Enabled */
-#define POWER_INTENCLR_SLEEPENTER_Clear (1UL) /*!< Disable */
-
-/* Bit 2 : Write '1' to Disable interrupt for POFWARN event */
-#define POWER_INTENCLR_POFWARN_Pos (2UL) /*!< Position of POFWARN field. */
-#define POWER_INTENCLR_POFWARN_Msk (0x1UL << POWER_INTENCLR_POFWARN_Pos) /*!< Bit mask of POFWARN field. */
-#define POWER_INTENCLR_POFWARN_Disabled (0UL) /*!< Read: Disabled */
-#define POWER_INTENCLR_POFWARN_Enabled (1UL) /*!< Read: Enabled */
-#define POWER_INTENCLR_POFWARN_Clear (1UL) /*!< Disable */
-
-/* Register: POWER_RESETREAS */
-/* Description: Reset reason */
-
-/* Bit 19 : Reset due to wake up from System OFF mode by NFC field detect */
-#define POWER_RESETREAS_NFC_Pos (19UL) /*!< Position of NFC field. */
-#define POWER_RESETREAS_NFC_Msk (0x1UL << POWER_RESETREAS_NFC_Pos) /*!< Bit mask of NFC field. */
-#define POWER_RESETREAS_NFC_NotDetected (0UL) /*!< Not detected */
-#define POWER_RESETREAS_NFC_Detected (1UL) /*!< Detected */
-
-/* Bit 18 : Reset due to wake up from System OFF mode when wakeup is triggered from entering into debug interface mode */
-#define POWER_RESETREAS_DIF_Pos (18UL) /*!< Position of DIF field. */
-#define POWER_RESETREAS_DIF_Msk (0x1UL << POWER_RESETREAS_DIF_Pos) /*!< Bit mask of DIF field. */
-#define POWER_RESETREAS_DIF_NotDetected (0UL) /*!< Not detected */
-#define POWER_RESETREAS_DIF_Detected (1UL) /*!< Detected */
-
-/* Bit 17 : Reset due to wake up from System OFF mode when wakeup is triggered from ANADETECT signal from LPCOMP */
-#define POWER_RESETREAS_LPCOMP_Pos (17UL) /*!< Position of LPCOMP field. */
-#define POWER_RESETREAS_LPCOMP_Msk (0x1UL << POWER_RESETREAS_LPCOMP_Pos) /*!< Bit mask of LPCOMP field. */
-#define POWER_RESETREAS_LPCOMP_NotDetected (0UL) /*!< Not detected */
-#define POWER_RESETREAS_LPCOMP_Detected (1UL) /*!< Detected */
-
-/* Bit 16 : Reset due to wake up from System OFF mode when wakeup is triggered from DETECT signal from GPIO */
-#define POWER_RESETREAS_OFF_Pos (16UL) /*!< Position of OFF field. */
-#define POWER_RESETREAS_OFF_Msk (0x1UL << POWER_RESETREAS_OFF_Pos) /*!< Bit mask of OFF field. */
-#define POWER_RESETREAS_OFF_NotDetected (0UL) /*!< Not detected */
-#define POWER_RESETREAS_OFF_Detected (1UL) /*!< Detected */
-
-/* Bit 3 : Reset from CPU lock-up detected */
-#define POWER_RESETREAS_LOCKUP_Pos (3UL) /*!< Position of LOCKUP field. */
-#define POWER_RESETREAS_LOCKUP_Msk (0x1UL << POWER_RESETREAS_LOCKUP_Pos) /*!< Bit mask of LOCKUP field. */
-#define POWER_RESETREAS_LOCKUP_NotDetected (0UL) /*!< Not detected */
-#define POWER_RESETREAS_LOCKUP_Detected (1UL) /*!< Detected */
-
-/* Bit 2 : Reset from soft reset detected */
-#define POWER_RESETREAS_SREQ_Pos (2UL) /*!< Position of SREQ field. */
-#define POWER_RESETREAS_SREQ_Msk (0x1UL << POWER_RESETREAS_SREQ_Pos) /*!< Bit mask of SREQ field. */
-#define POWER_RESETREAS_SREQ_NotDetected (0UL) /*!< Not detected */
-#define POWER_RESETREAS_SREQ_Detected (1UL) /*!< Detected */
-
-/* Bit 1 : Reset from watchdog detected */
-#define POWER_RESETREAS_DOG_Pos (1UL) /*!< Position of DOG field. */
-#define POWER_RESETREAS_DOG_Msk (0x1UL << POWER_RESETREAS_DOG_Pos) /*!< Bit mask of DOG field. */
-#define POWER_RESETREAS_DOG_NotDetected (0UL) /*!< Not detected */
-#define POWER_RESETREAS_DOG_Detected (1UL) /*!< Detected */
-
-/* Bit 0 : Reset from pin-reset detected */
-#define POWER_RESETREAS_RESETPIN_Pos (0UL) /*!< Position of RESETPIN field. */
-#define POWER_RESETREAS_RESETPIN_Msk (0x1UL << POWER_RESETREAS_RESETPIN_Pos) /*!< Bit mask of RESETPIN field. */
-#define POWER_RESETREAS_RESETPIN_NotDetected (0UL) /*!< Not detected */
-#define POWER_RESETREAS_RESETPIN_Detected (1UL) /*!< Detected */
-
-/* Register: POWER_RAMSTATUS */
-/* Description: Deprecated register -  RAM status register */
-
-/* Bit 3 : RAM block 3 is on or off/powering up */
-#define POWER_RAMSTATUS_RAMBLOCK3_Pos (3UL) /*!< Position of RAMBLOCK3 field. */
-#define POWER_RAMSTATUS_RAMBLOCK3_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK3_Pos) /*!< Bit mask of RAMBLOCK3 field. */
-#define POWER_RAMSTATUS_RAMBLOCK3_Off (0UL) /*!< Off */
-#define POWER_RAMSTATUS_RAMBLOCK3_On (1UL) /*!< On */
-
-/* Bit 2 : RAM block 2 is on or off/powering up */
-#define POWER_RAMSTATUS_RAMBLOCK2_Pos (2UL) /*!< Position of RAMBLOCK2 field. */
-#define POWER_RAMSTATUS_RAMBLOCK2_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK2_Pos) /*!< Bit mask of RAMBLOCK2 field. */
-#define POWER_RAMSTATUS_RAMBLOCK2_Off (0UL) /*!< Off */
-#define POWER_RAMSTATUS_RAMBLOCK2_On (1UL) /*!< On */
-
-/* Bit 1 : RAM block 1 is on or off/powering up */
-#define POWER_RAMSTATUS_RAMBLOCK1_Pos (1UL) /*!< Position of RAMBLOCK1 field. */
-#define POWER_RAMSTATUS_RAMBLOCK1_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK1_Pos) /*!< Bit mask of RAMBLOCK1 field. */
-#define POWER_RAMSTATUS_RAMBLOCK1_Off (0UL) /*!< Off */
-#define POWER_RAMSTATUS_RAMBLOCK1_On (1UL) /*!< On */
-
-/* Bit 0 : RAM block 0 is on or off/powering up */
-#define POWER_RAMSTATUS_RAMBLOCK0_Pos (0UL) /*!< Position of RAMBLOCK0 field. */
-#define POWER_RAMSTATUS_RAMBLOCK0_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK0_Pos) /*!< Bit mask of RAMBLOCK0 field. */
-#define POWER_RAMSTATUS_RAMBLOCK0_Off (0UL) /*!< Off */
-#define POWER_RAMSTATUS_RAMBLOCK0_On (1UL) /*!< On */
-
-/* Register: POWER_SYSTEMOFF */
-/* Description: System OFF register */
-
-/* Bit 0 : Enable System OFF mode */
-#define POWER_SYSTEMOFF_SYSTEMOFF_Pos (0UL) /*!< Position of SYSTEMOFF field. */
-#define POWER_SYSTEMOFF_SYSTEMOFF_Msk (0x1UL << POWER_SYSTEMOFF_SYSTEMOFF_Pos) /*!< Bit mask of SYSTEMOFF field. */
-#define POWER_SYSTEMOFF_SYSTEMOFF_Enter (1UL) /*!< Enable System OFF mode */
-
-/* Register: POWER_POFCON */
-/* Description: Power failure comparator configuration */
-
-/* Bits 4..1 : Power failure comparator threshold setting */
-#define POWER_POFCON_THRESHOLD_Pos (1UL) /*!< Position of THRESHOLD field. */
-#define POWER_POFCON_THRESHOLD_Msk (0xFUL << POWER_POFCON_THRESHOLD_Pos) /*!< Bit mask of THRESHOLD field. */
-#define POWER_POFCON_THRESHOLD_V17 (4UL) /*!< Set threshold to 1.7 V */
-#define POWER_POFCON_THRESHOLD_V18 (5UL) /*!< Set threshold to 1.8 V */
-#define POWER_POFCON_THRESHOLD_V19 (6UL) /*!< Set threshold to 1.9 V */
-#define POWER_POFCON_THRESHOLD_V20 (7UL) /*!< Set threshold to 2.0 V */
-#define POWER_POFCON_THRESHOLD_V21 (8UL) /*!< Set threshold to 2.1 V */
-#define POWER_POFCON_THRESHOLD_V22 (9UL) /*!< Set threshold to 2.2 V */
-#define POWER_POFCON_THRESHOLD_V23 (10UL) /*!< Set threshold to 2.3 V */
-#define POWER_POFCON_THRESHOLD_V24 (11UL) /*!< Set threshold to 2.4 V */
-#define POWER_POFCON_THRESHOLD_V25 (12UL) /*!< Set threshold to 2.5 V */
-#define POWER_POFCON_THRESHOLD_V26 (13UL) /*!< Set threshold to 2.6 V */
-#define POWER_POFCON_THRESHOLD_V27 (14UL) /*!< Set threshold to 2.7 V */
-#define POWER_POFCON_THRESHOLD_V28 (15UL) /*!< Set threshold to 2.8 V */
-
-/* Bit 0 : Enable or disable power failure comparator */
-#define POWER_POFCON_POF_Pos (0UL) /*!< Position of POF field. */
-#define POWER_POFCON_POF_Msk (0x1UL << POWER_POFCON_POF_Pos) /*!< Bit mask of POF field. */
-#define POWER_POFCON_POF_Disabled (0UL) /*!< Disable */
-#define POWER_POFCON_POF_Enabled (1UL) /*!< Enable */
-
-/* Register: POWER_GPREGRET */
-/* Description: General purpose retention register */
-
-/* Bits 7..0 : General purpose retention register */
-#define POWER_GPREGRET_GPREGRET_Pos (0UL) /*!< Position of GPREGRET field. */
-#define POWER_GPREGRET_GPREGRET_Msk (0xFFUL << POWER_GPREGRET_GPREGRET_Pos) /*!< Bit mask of GPREGRET field. */
-
-/* Register: POWER_GPREGRET2 */
-/* Description: General purpose retention register */
-
-/* Bits 7..0 : General purpose retention register */
-#define POWER_GPREGRET2_GPREGRET_Pos (0UL) /*!< Position of GPREGRET field. */
-#define POWER_GPREGRET2_GPREGRET_Msk (0xFFUL << POWER_GPREGRET2_GPREGRET_Pos) /*!< Bit mask of GPREGRET field. */
-
-/* Register: POWER_RAMON */
-/* Description: Deprecated register -  RAM on/off register (this register is retained) */
-
-/* Bit 17 : Keep retention on RAM block 1 when RAM block is switched off */
-#define POWER_RAMON_OFFRAM1_Pos (17UL) /*!< Position of OFFRAM1 field. */
-#define POWER_RAMON_OFFRAM1_Msk (0x1UL << POWER_RAMON_OFFRAM1_Pos) /*!< Bit mask of OFFRAM1 field. */
-#define POWER_RAMON_OFFRAM1_RAM1Off (0UL) /*!< Off */
-#define POWER_RAMON_OFFRAM1_RAM1On (1UL) /*!< On */
-
-/* Bit 16 : Keep retention on RAM block 0 when RAM block is switched off */
-#define POWER_RAMON_OFFRAM0_Pos (16UL) /*!< Position of OFFRAM0 field. */
-#define POWER_RAMON_OFFRAM0_Msk (0x1UL << POWER_RAMON_OFFRAM0_Pos) /*!< Bit mask of OFFRAM0 field. */
-#define POWER_RAMON_OFFRAM0_RAM0Off (0UL) /*!< Off */
-#define POWER_RAMON_OFFRAM0_RAM0On (1UL) /*!< On */
-
-/* Bit 1 : Keep RAM block 1 on or off in system ON Mode */
-#define POWER_RAMON_ONRAM1_Pos (1UL) /*!< Position of ONRAM1 field. */
-#define POWER_RAMON_ONRAM1_Msk (0x1UL << POWER_RAMON_ONRAM1_Pos) /*!< Bit mask of ONRAM1 field. */
-#define POWER_RAMON_ONRAM1_RAM1Off (0UL) /*!< Off */
-#define POWER_RAMON_ONRAM1_RAM1On (1UL) /*!< On */
-
-/* Bit 0 : Keep RAM block 0 on or off in system ON Mode */
-#define POWER_RAMON_ONRAM0_Pos (0UL) /*!< Position of ONRAM0 field. */
-#define POWER_RAMON_ONRAM0_Msk (0x1UL << POWER_RAMON_ONRAM0_Pos) /*!< Bit mask of ONRAM0 field. */
-#define POWER_RAMON_ONRAM0_RAM0Off (0UL) /*!< Off */
-#define POWER_RAMON_ONRAM0_RAM0On (1UL) /*!< On */
-
-/* Register: POWER_RAMONB */
-/* Description: Deprecated register -  RAM on/off register (this register is retained) */
-
-/* Bit 17 : Keep retention on RAM block 3 when RAM block is switched off */
-#define POWER_RAMONB_OFFRAM3_Pos (17UL) /*!< Position of OFFRAM3 field. */
-#define POWER_RAMONB_OFFRAM3_Msk (0x1UL << POWER_RAMONB_OFFRAM3_Pos) /*!< Bit mask of OFFRAM3 field. */
-#define POWER_RAMONB_OFFRAM3_RAM3Off (0UL) /*!< Off */
-#define POWER_RAMONB_OFFRAM3_RAM3On (1UL) /*!< On */
-
-/* Bit 16 : Keep retention on RAM block 2 when RAM block is switched off */
-#define POWER_RAMONB_OFFRAM2_Pos (16UL) /*!< Position of OFFRAM2 field. */
-#define POWER_RAMONB_OFFRAM2_Msk (0x1UL << POWER_RAMONB_OFFRAM2_Pos) /*!< Bit mask of OFFRAM2 field. */
-#define POWER_RAMONB_OFFRAM2_RAM2Off (0UL) /*!< Off */
-#define POWER_RAMONB_OFFRAM2_RAM2On (1UL) /*!< On */
-
-/* Bit 1 : Keep RAM block 3 on or off in system ON Mode */
-#define POWER_RAMONB_ONRAM3_Pos (1UL) /*!< Position of ONRAM3 field. */
-#define POWER_RAMONB_ONRAM3_Msk (0x1UL << POWER_RAMONB_ONRAM3_Pos) /*!< Bit mask of ONRAM3 field. */
-#define POWER_RAMONB_ONRAM3_RAM3Off (0UL) /*!< Off */
-#define POWER_RAMONB_ONRAM3_RAM3On (1UL) /*!< On */
-
-/* Bit 0 : Keep RAM block 2 on or off in system ON Mode */
-#define POWER_RAMONB_ONRAM2_Pos (0UL) /*!< Position of ONRAM2 field. */
-#define POWER_RAMONB_ONRAM2_Msk (0x1UL << POWER_RAMONB_ONRAM2_Pos) /*!< Bit mask of ONRAM2 field. */
-#define POWER_RAMONB_ONRAM2_RAM2Off (0UL) /*!< Off */
-#define POWER_RAMONB_ONRAM2_RAM2On (1UL) /*!< On */
-
-/* Register: POWER_DCDCEN */
-/* Description: DC/DC enable register */
-
-/* Bit 0 : Enable or disable DC/DC converter */
-#define POWER_DCDCEN_DCDCEN_Pos (0UL) /*!< Position of DCDCEN field. */
-#define POWER_DCDCEN_DCDCEN_Msk (0x1UL << POWER_DCDCEN_DCDCEN_Pos) /*!< Bit mask of DCDCEN field. */
-#define POWER_DCDCEN_DCDCEN_Disabled (0UL) /*!< Disable */
-#define POWER_DCDCEN_DCDCEN_Enabled (1UL) /*!< Enable */
-
-/* Register: POWER_RAM_POWER */
-/* Description: Description cluster[0]:  RAM0 power control register */
-
-/* Bit 17 : Keep retention on RAM section S1 when RAM section is in OFF */
-#define POWER_RAM_POWER_S1RETENTION_Pos (17UL) /*!< Position of S1RETENTION field. */
-#define POWER_RAM_POWER_S1RETENTION_Msk (0x1UL << POWER_RAM_POWER_S1RETENTION_Pos) /*!< Bit mask of S1RETENTION field. */
-#define POWER_RAM_POWER_S1RETENTION_Off (0UL) /*!< Off */
-#define POWER_RAM_POWER_S1RETENTION_On (1UL) /*!< On */
-
-/* Bit 16 : Keep retention on RAM section S0 when RAM section is in OFF */
-#define POWER_RAM_POWER_S0RETENTION_Pos (16UL) /*!< Position of S0RETENTION field. */
-#define POWER_RAM_POWER_S0RETENTION_Msk (0x1UL << POWER_RAM_POWER_S0RETENTION_Pos) /*!< Bit mask of S0RETENTION field. */
-#define POWER_RAM_POWER_S0RETENTION_Off (0UL) /*!< Off */
-#define POWER_RAM_POWER_S0RETENTION_On (1UL) /*!< On */
-
-/* Bit 1 : Keep RAM section S1 ON or OFF in System ON mode. */
-#define POWER_RAM_POWER_S1POWER_Pos (1UL) /*!< Position of S1POWER field. */
-#define POWER_RAM_POWER_S1POWER_Msk (0x1UL << POWER_RAM_POWER_S1POWER_Pos) /*!< Bit mask of S1POWER field. */
-#define POWER_RAM_POWER_S1POWER_Off (0UL) /*!< Off */
-#define POWER_RAM_POWER_S1POWER_On (1UL) /*!< On */
-
-/* Bit 0 : Keep RAM section S0 ON or OFF in System ON mode. */
-#define POWER_RAM_POWER_S0POWER_Pos (0UL) /*!< Position of S0POWER field. */
-#define POWER_RAM_POWER_S0POWER_Msk (0x1UL << POWER_RAM_POWER_S0POWER_Pos) /*!< Bit mask of S0POWER field. */
-#define POWER_RAM_POWER_S0POWER_Off (0UL) /*!< Off */
-#define POWER_RAM_POWER_S0POWER_On (1UL) /*!< On */
-
-/* Register: POWER_RAM_POWERSET */
-/* Description: Description cluster[0]:  RAM0 power control set register */
-
-/* Bit 17 : Keep retention on RAM section S1 when RAM section is switched off */
-#define POWER_RAM_POWERSET_S1RETENTION_Pos (17UL) /*!< Position of S1RETENTION field. */
-#define POWER_RAM_POWERSET_S1RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S1RETENTION_Pos) /*!< Bit mask of S1RETENTION field. */
-#define POWER_RAM_POWERSET_S1RETENTION_On (1UL) /*!< On */
-
-/* Bit 16 : Keep retention on RAM section S0 when RAM section is switched off */
-#define POWER_RAM_POWERSET_S0RETENTION_Pos (16UL) /*!< Position of S0RETENTION field. */
-#define POWER_RAM_POWERSET_S0RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S0RETENTION_Pos) /*!< Bit mask of S0RETENTION field. */
-#define POWER_RAM_POWERSET_S0RETENTION_On (1UL) /*!< On */
-
-/* Bit 1 : Keep RAM section S1 of RAM0 on or off in System ON mode */
-#define POWER_RAM_POWERSET_S1POWER_Pos (1UL) /*!< Position of S1POWER field. */
-#define POWER_RAM_POWERSET_S1POWER_Msk (0x1UL << POWER_RAM_POWERSET_S1POWER_Pos) /*!< Bit mask of S1POWER field. */
-#define POWER_RAM_POWERSET_S1POWER_On (1UL) /*!< On */
-
-/* Bit 0 : Keep RAM section S0 of RAM0 on or off in System ON mode */
-#define POWER_RAM_POWERSET_S0POWER_Pos (0UL) /*!< Position of S0POWER field. */
-#define POWER_RAM_POWERSET_S0POWER_Msk (0x1UL << POWER_RAM_POWERSET_S0POWER_Pos) /*!< Bit mask of S0POWER field. */
-#define POWER_RAM_POWERSET_S0POWER_On (1UL) /*!< On */
-
-/* Register: POWER_RAM_POWERCLR */
-/* Description: Description cluster[0]:  RAM0 power control clear register */
-
-/* Bit 17 : Keep retention on RAM section S1 when RAM section is switched off */
-#define POWER_RAM_POWERCLR_S1RETENTION_Pos (17UL) /*!< Position of S1RETENTION field. */
-#define POWER_RAM_POWERCLR_S1RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S1RETENTION_Pos) /*!< Bit mask of S1RETENTION field. */
-#define POWER_RAM_POWERCLR_S1RETENTION_Off (1UL) /*!< Off */
-
-/* Bit 16 : Keep retention on RAM section S0 when RAM section is switched off */
-#define POWER_RAM_POWERCLR_S0RETENTION_Pos (16UL) /*!< Position of S0RETENTION field. */
-#define POWER_RAM_POWERCLR_S0RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S0RETENTION_Pos) /*!< Bit mask of S0RETENTION field. */
-#define POWER_RAM_POWERCLR_S0RETENTION_Off (1UL) /*!< Off */
-
-/* Bit 1 : Keep RAM section S1 of RAM0 on or off in System ON mode */
-#define POWER_RAM_POWERCLR_S1POWER_Pos (1UL) /*!< Position of S1POWER field. */
-#define POWER_RAM_POWERCLR_S1POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S1POWER_Pos) /*!< Bit mask of S1POWER field. */
-#define POWER_RAM_POWERCLR_S1POWER_Off (1UL) /*!< Off */
-
-/* Bit 0 : Keep RAM section S0 of RAM0 on or off in System ON mode */
-#define POWER_RAM_POWERCLR_S0POWER_Pos (0UL) /*!< Position of S0POWER field. */
-#define POWER_RAM_POWERCLR_S0POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S0POWER_Pos) /*!< Bit mask of S0POWER field. */
-#define POWER_RAM_POWERCLR_S0POWER_Off (1UL) /*!< Off */
-
-
-/* Peripheral: PPI */
-/* Description: Programmable Peripheral Interconnect */
-
-/* Register: PPI_CHEN */
-/* Description: Channel enable register */
-
-/* Bit 31 : Enable or disable channel 31 */
-#define PPI_CHEN_CH31_Pos (31UL) /*!< Position of CH31 field. */
-#define PPI_CHEN_CH31_Msk (0x1UL << PPI_CHEN_CH31_Pos) /*!< Bit mask of CH31 field. */
-#define PPI_CHEN_CH31_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH31_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 30 : Enable or disable channel 30 */
-#define PPI_CHEN_CH30_Pos (30UL) /*!< Position of CH30 field. */
-#define PPI_CHEN_CH30_Msk (0x1UL << PPI_CHEN_CH30_Pos) /*!< Bit mask of CH30 field. */
-#define PPI_CHEN_CH30_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH30_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 29 : Enable or disable channel 29 */
-#define PPI_CHEN_CH29_Pos (29UL) /*!< Position of CH29 field. */
-#define PPI_CHEN_CH29_Msk (0x1UL << PPI_CHEN_CH29_Pos) /*!< Bit mask of CH29 field. */
-#define PPI_CHEN_CH29_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH29_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 28 : Enable or disable channel 28 */
-#define PPI_CHEN_CH28_Pos (28UL) /*!< Position of CH28 field. */
-#define PPI_CHEN_CH28_Msk (0x1UL << PPI_CHEN_CH28_Pos) /*!< Bit mask of CH28 field. */
-#define PPI_CHEN_CH28_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH28_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 27 : Enable or disable channel 27 */
-#define PPI_CHEN_CH27_Pos (27UL) /*!< Position of CH27 field. */
-#define PPI_CHEN_CH27_Msk (0x1UL << PPI_CHEN_CH27_Pos) /*!< Bit mask of CH27 field. */
-#define PPI_CHEN_CH27_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH27_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 26 : Enable or disable channel 26 */
-#define PPI_CHEN_CH26_Pos (26UL) /*!< Position of CH26 field. */
-#define PPI_CHEN_CH26_Msk (0x1UL << PPI_CHEN_CH26_Pos) /*!< Bit mask of CH26 field. */
-#define PPI_CHEN_CH26_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH26_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 25 : Enable or disable channel 25 */
-#define PPI_CHEN_CH25_Pos (25UL) /*!< Position of CH25 field. */
-#define PPI_CHEN_CH25_Msk (0x1UL << PPI_CHEN_CH25_Pos) /*!< Bit mask of CH25 field. */
-#define PPI_CHEN_CH25_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH25_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 24 : Enable or disable channel 24 */
-#define PPI_CHEN_CH24_Pos (24UL) /*!< Position of CH24 field. */
-#define PPI_CHEN_CH24_Msk (0x1UL << PPI_CHEN_CH24_Pos) /*!< Bit mask of CH24 field. */
-#define PPI_CHEN_CH24_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH24_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 23 : Enable or disable channel 23 */
-#define PPI_CHEN_CH23_Pos (23UL) /*!< Position of CH23 field. */
-#define PPI_CHEN_CH23_Msk (0x1UL << PPI_CHEN_CH23_Pos) /*!< Bit mask of CH23 field. */
-#define PPI_CHEN_CH23_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH23_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 22 : Enable or disable channel 22 */
-#define PPI_CHEN_CH22_Pos (22UL) /*!< Position of CH22 field. */
-#define PPI_CHEN_CH22_Msk (0x1UL << PPI_CHEN_CH22_Pos) /*!< Bit mask of CH22 field. */
-#define PPI_CHEN_CH22_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH22_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 21 : Enable or disable channel 21 */
-#define PPI_CHEN_CH21_Pos (21UL) /*!< Position of CH21 field. */
-#define PPI_CHEN_CH21_Msk (0x1UL << PPI_CHEN_CH21_Pos) /*!< Bit mask of CH21 field. */
-#define PPI_CHEN_CH21_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH21_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 20 : Enable or disable channel 20 */
-#define PPI_CHEN_CH20_Pos (20UL) /*!< Position of CH20 field. */
-#define PPI_CHEN_CH20_Msk (0x1UL << PPI_CHEN_CH20_Pos) /*!< Bit mask of CH20 field. */
-#define PPI_CHEN_CH20_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH20_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 19 : Enable or disable channel 19 */
-#define PPI_CHEN_CH19_Pos (19UL) /*!< Position of CH19 field. */
-#define PPI_CHEN_CH19_Msk (0x1UL << PPI_CHEN_CH19_Pos) /*!< Bit mask of CH19 field. */
-#define PPI_CHEN_CH19_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH19_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 18 : Enable or disable channel 18 */
-#define PPI_CHEN_CH18_Pos (18UL) /*!< Position of CH18 field. */
-#define PPI_CHEN_CH18_Msk (0x1UL << PPI_CHEN_CH18_Pos) /*!< Bit mask of CH18 field. */
-#define PPI_CHEN_CH18_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH18_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 17 : Enable or disable channel 17 */
-#define PPI_CHEN_CH17_Pos (17UL) /*!< Position of CH17 field. */
-#define PPI_CHEN_CH17_Msk (0x1UL << PPI_CHEN_CH17_Pos) /*!< Bit mask of CH17 field. */
-#define PPI_CHEN_CH17_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH17_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 16 : Enable or disable channel 16 */
-#define PPI_CHEN_CH16_Pos (16UL) /*!< Position of CH16 field. */
-#define PPI_CHEN_CH16_Msk (0x1UL << PPI_CHEN_CH16_Pos) /*!< Bit mask of CH16 field. */
-#define PPI_CHEN_CH16_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH16_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 15 : Enable or disable channel 15 */
-#define PPI_CHEN_CH15_Pos (15UL) /*!< Position of CH15 field. */
-#define PPI_CHEN_CH15_Msk (0x1UL << PPI_CHEN_CH15_Pos) /*!< Bit mask of CH15 field. */
-#define PPI_CHEN_CH15_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH15_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 14 : Enable or disable channel 14 */
-#define PPI_CHEN_CH14_Pos (14UL) /*!< Position of CH14 field. */
-#define PPI_CHEN_CH14_Msk (0x1UL << PPI_CHEN_CH14_Pos) /*!< Bit mask of CH14 field. */
-#define PPI_CHEN_CH14_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH14_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 13 : Enable or disable channel 13 */
-#define PPI_CHEN_CH13_Pos (13UL) /*!< Position of CH13 field. */
-#define PPI_CHEN_CH13_Msk (0x1UL << PPI_CHEN_CH13_Pos) /*!< Bit mask of CH13 field. */
-#define PPI_CHEN_CH13_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH13_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 12 : Enable or disable channel 12 */
-#define PPI_CHEN_CH12_Pos (12UL) /*!< Position of CH12 field. */
-#define PPI_CHEN_CH12_Msk (0x1UL << PPI_CHEN_CH12_Pos) /*!< Bit mask of CH12 field. */
-#define PPI_CHEN_CH12_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH12_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 11 : Enable or disable channel 11 */
-#define PPI_CHEN_CH11_Pos (11UL) /*!< Position of CH11 field. */
-#define PPI_CHEN_CH11_Msk (0x1UL << PPI_CHEN_CH11_Pos) /*!< Bit mask of CH11 field. */
-#define PPI_CHEN_CH11_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH11_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 10 : Enable or disable channel 10 */
-#define PPI_CHEN_CH10_Pos (10UL) /*!< Position of CH10 field. */
-#define PPI_CHEN_CH10_Msk (0x1UL << PPI_CHEN_CH10_Pos) /*!< Bit mask of CH10 field. */
-#define PPI_CHEN_CH10_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH10_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 9 : Enable or disable channel 9 */
-#define PPI_CHEN_CH9_Pos (9UL) /*!< Position of CH9 field. */
-#define PPI_CHEN_CH9_Msk (0x1UL << PPI_CHEN_CH9_Pos) /*!< Bit mask of CH9 field. */
-#define PPI_CHEN_CH9_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH9_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 8 : Enable or disable channel 8 */
-#define PPI_CHEN_CH8_Pos (8UL) /*!< Position of CH8 field. */
-#define PPI_CHEN_CH8_Msk (0x1UL << PPI_CHEN_CH8_Pos) /*!< Bit mask of CH8 field. */
-#define PPI_CHEN_CH8_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH8_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 7 : Enable or disable channel 7 */
-#define PPI_CHEN_CH7_Pos (7UL) /*!< Position of CH7 field. */
-#define PPI_CHEN_CH7_Msk (0x1UL << PPI_CHEN_CH7_Pos) /*!< Bit mask of CH7 field. */
-#define PPI_CHEN_CH7_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH7_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 6 : Enable or disable channel 6 */
-#define PPI_CHEN_CH6_Pos (6UL) /*!< Position of CH6 field. */
-#define PPI_CHEN_CH6_Msk (0x1UL << PPI_CHEN_CH6_Pos) /*!< Bit mask of CH6 field. */
-#define PPI_CHEN_CH6_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH6_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 5 : Enable or disable channel 5 */
-#define PPI_CHEN_CH5_Pos (5UL) /*!< Position of CH5 field. */
-#define PPI_CHEN_CH5_Msk (0x1UL << PPI_CHEN_CH5_Pos) /*!< Bit mask of CH5 field. */
-#define PPI_CHEN_CH5_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH5_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 4 : Enable or disable channel 4 */
-#define PPI_CHEN_CH4_Pos (4UL) /*!< Position of CH4 field. */
-#define PPI_CHEN_CH4_Msk (0x1UL << PPI_CHEN_CH4_Pos) /*!< Bit mask of CH4 field. */
-#define PPI_CHEN_CH4_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH4_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 3 : Enable or disable channel 3 */
-#define PPI_CHEN_CH3_Pos (3UL) /*!< Position of CH3 field. */
-#define PPI_CHEN_CH3_Msk (0x1UL << PPI_CHEN_CH3_Pos) /*!< Bit mask of CH3 field. */
-#define PPI_CHEN_CH3_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH3_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 2 : Enable or disable channel 2 */
-#define PPI_CHEN_CH2_Pos (2UL) /*!< Position of CH2 field. */
-#define PPI_CHEN_CH2_Msk (0x1UL << PPI_CHEN_CH2_Pos) /*!< Bit mask of CH2 field. */
-#define PPI_CHEN_CH2_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH2_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 1 : Enable or disable channel 1 */
-#define PPI_CHEN_CH1_Pos (1UL) /*!< Position of CH1 field. */
-#define PPI_CHEN_CH1_Msk (0x1UL << PPI_CHEN_CH1_Pos) /*!< Bit mask of CH1 field. */
-#define PPI_CHEN_CH1_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH1_Enabled (1UL) /*!< Enable channel */
-
-/* Bit 0 : Enable or disable channel 0 */
-#define PPI_CHEN_CH0_Pos (0UL) /*!< Position of CH0 field. */
-#define PPI_CHEN_CH0_Msk (0x1UL << PPI_CHEN_CH0_Pos) /*!< Bit mask of CH0 field. */
-#define PPI_CHEN_CH0_Disabled (0UL) /*!< Disable channel */
-#define PPI_CHEN_CH0_Enabled (1UL) /*!< Enable channel */
-
-/* Register: PPI_CHENSET */
-/* Description: Channel enable set register */
-
-/* Bit 31 : Channel 31 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH31_Pos (31UL) /*!< Position of CH31 field. */
-#define PPI_CHENSET_CH31_Msk (0x1UL << PPI_CHENSET_CH31_Pos) /*!< Bit mask of CH31 field. */
-#define PPI_CHENSET_CH31_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH31_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH31_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 30 : Channel 30 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH30_Pos (30UL) /*!< Position of CH30 field. */
-#define PPI_CHENSET_CH30_Msk (0x1UL << PPI_CHENSET_CH30_Pos) /*!< Bit mask of CH30 field. */
-#define PPI_CHENSET_CH30_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH30_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH30_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 29 : Channel 29 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH29_Pos (29UL) /*!< Position of CH29 field. */
-#define PPI_CHENSET_CH29_Msk (0x1UL << PPI_CHENSET_CH29_Pos) /*!< Bit mask of CH29 field. */
-#define PPI_CHENSET_CH29_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH29_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH29_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 28 : Channel 28 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH28_Pos (28UL) /*!< Position of CH28 field. */
-#define PPI_CHENSET_CH28_Msk (0x1UL << PPI_CHENSET_CH28_Pos) /*!< Bit mask of CH28 field. */
-#define PPI_CHENSET_CH28_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH28_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH28_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 27 : Channel 27 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH27_Pos (27UL) /*!< Position of CH27 field. */
-#define PPI_CHENSET_CH27_Msk (0x1UL << PPI_CHENSET_CH27_Pos) /*!< Bit mask of CH27 field. */
-#define PPI_CHENSET_CH27_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH27_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH27_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 26 : Channel 26 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH26_Pos (26UL) /*!< Position of CH26 field. */
-#define PPI_CHENSET_CH26_Msk (0x1UL << PPI_CHENSET_CH26_Pos) /*!< Bit mask of CH26 field. */
-#define PPI_CHENSET_CH26_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH26_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH26_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 25 : Channel 25 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH25_Pos (25UL) /*!< Position of CH25 field. */
-#define PPI_CHENSET_CH25_Msk (0x1UL << PPI_CHENSET_CH25_Pos) /*!< Bit mask of CH25 field. */
-#define PPI_CHENSET_CH25_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH25_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH25_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 24 : Channel 24 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH24_Pos (24UL) /*!< Position of CH24 field. */
-#define PPI_CHENSET_CH24_Msk (0x1UL << PPI_CHENSET_CH24_Pos) /*!< Bit mask of CH24 field. */
-#define PPI_CHENSET_CH24_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH24_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH24_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 23 : Channel 23 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH23_Pos (23UL) /*!< Position of CH23 field. */
-#define PPI_CHENSET_CH23_Msk (0x1UL << PPI_CHENSET_CH23_Pos) /*!< Bit mask of CH23 field. */
-#define PPI_CHENSET_CH23_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH23_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH23_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 22 : Channel 22 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH22_Pos (22UL) /*!< Position of CH22 field. */
-#define PPI_CHENSET_CH22_Msk (0x1UL << PPI_CHENSET_CH22_Pos) /*!< Bit mask of CH22 field. */
-#define PPI_CHENSET_CH22_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH22_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH22_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 21 : Channel 21 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH21_Pos (21UL) /*!< Position of CH21 field. */
-#define PPI_CHENSET_CH21_Msk (0x1UL << PPI_CHENSET_CH21_Pos) /*!< Bit mask of CH21 field. */
-#define PPI_CHENSET_CH21_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH21_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH21_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 20 : Channel 20 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH20_Pos (20UL) /*!< Position of CH20 field. */
-#define PPI_CHENSET_CH20_Msk (0x1UL << PPI_CHENSET_CH20_Pos) /*!< Bit mask of CH20 field. */
-#define PPI_CHENSET_CH20_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH20_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH20_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 19 : Channel 19 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH19_Pos (19UL) /*!< Position of CH19 field. */
-#define PPI_CHENSET_CH19_Msk (0x1UL << PPI_CHENSET_CH19_Pos) /*!< Bit mask of CH19 field. */
-#define PPI_CHENSET_CH19_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH19_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH19_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 18 : Channel 18 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH18_Pos (18UL) /*!< Position of CH18 field. */
-#define PPI_CHENSET_CH18_Msk (0x1UL << PPI_CHENSET_CH18_Pos) /*!< Bit mask of CH18 field. */
-#define PPI_CHENSET_CH18_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH18_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH18_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 17 : Channel 17 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH17_Pos (17UL) /*!< Position of CH17 field. */
-#define PPI_CHENSET_CH17_Msk (0x1UL << PPI_CHENSET_CH17_Pos) /*!< Bit mask of CH17 field. */
-#define PPI_CHENSET_CH17_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH17_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH17_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 16 : Channel 16 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH16_Pos (16UL) /*!< Position of CH16 field. */
-#define PPI_CHENSET_CH16_Msk (0x1UL << PPI_CHENSET_CH16_Pos) /*!< Bit mask of CH16 field. */
-#define PPI_CHENSET_CH16_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH16_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH16_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 15 : Channel 15 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH15_Pos (15UL) /*!< Position of CH15 field. */
-#define PPI_CHENSET_CH15_Msk (0x1UL << PPI_CHENSET_CH15_Pos) /*!< Bit mask of CH15 field. */
-#define PPI_CHENSET_CH15_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH15_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH15_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 14 : Channel 14 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH14_Pos (14UL) /*!< Position of CH14 field. */
-#define PPI_CHENSET_CH14_Msk (0x1UL << PPI_CHENSET_CH14_Pos) /*!< Bit mask of CH14 field. */
-#define PPI_CHENSET_CH14_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH14_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH14_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 13 : Channel 13 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH13_Pos (13UL) /*!< Position of CH13 field. */
-#define PPI_CHENSET_CH13_Msk (0x1UL << PPI_CHENSET_CH13_Pos) /*!< Bit mask of CH13 field. */
-#define PPI_CHENSET_CH13_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH13_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH13_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 12 : Channel 12 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH12_Pos (12UL) /*!< Position of CH12 field. */
-#define PPI_CHENSET_CH12_Msk (0x1UL << PPI_CHENSET_CH12_Pos) /*!< Bit mask of CH12 field. */
-#define PPI_CHENSET_CH12_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH12_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH12_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 11 : Channel 11 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH11_Pos (11UL) /*!< Position of CH11 field. */
-#define PPI_CHENSET_CH11_Msk (0x1UL << PPI_CHENSET_CH11_Pos) /*!< Bit mask of CH11 field. */
-#define PPI_CHENSET_CH11_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH11_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH11_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 10 : Channel 10 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH10_Pos (10UL) /*!< Position of CH10 field. */
-#define PPI_CHENSET_CH10_Msk (0x1UL << PPI_CHENSET_CH10_Pos) /*!< Bit mask of CH10 field. */
-#define PPI_CHENSET_CH10_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH10_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH10_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 9 : Channel 9 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH9_Pos (9UL) /*!< Position of CH9 field. */
-#define PPI_CHENSET_CH9_Msk (0x1UL << PPI_CHENSET_CH9_Pos) /*!< Bit mask of CH9 field. */
-#define PPI_CHENSET_CH9_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH9_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH9_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 8 : Channel 8 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH8_Pos (8UL) /*!< Position of CH8 field. */
-#define PPI_CHENSET_CH8_Msk (0x1UL << PPI_CHENSET_CH8_Pos) /*!< Bit mask of CH8 field. */
-#define PPI_CHENSET_CH8_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH8_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH8_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 7 : Channel 7 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH7_Pos (7UL) /*!< Position of CH7 field. */
-#define PPI_CHENSET_CH7_Msk (0x1UL << PPI_CHENSET_CH7_Pos) /*!< Bit mask of CH7 field. */
-#define PPI_CHENSET_CH7_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH7_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH7_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 6 : Channel 6 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH6_Pos (6UL) /*!< Position of CH6 field. */
-#define PPI_CHENSET_CH6_Msk (0x1UL << PPI_CHENSET_CH6_Pos) /*!< Bit mask of CH6 field. */
-#define PPI_CHENSET_CH6_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH6_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH6_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 5 : Channel 5 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH5_Pos (5UL) /*!< Position of CH5 field. */
-#define PPI_CHENSET_CH5_Msk (0x1UL << PPI_CHENSET_CH5_Pos) /*!< Bit mask of CH5 field. */
-#define PPI_CHENSET_CH5_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH5_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH5_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 4 : Channel 4 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH4_Pos (4UL) /*!< Position of CH4 field. */
-#define PPI_CHENSET_CH4_Msk (0x1UL << PPI_CHENSET_CH4_Pos) /*!< Bit mask of CH4 field. */
-#define PPI_CHENSET_CH4_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH4_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH4_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 3 : Channel 3 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH3_Pos (3UL) /*!< Position of CH3 field. */
-#define PPI_CHENSET_CH3_Msk (0x1UL << PPI_CHENSET_CH3_Pos) /*!< Bit mask of CH3 field. */
-#define PPI_CHENSET_CH3_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH3_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH3_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 2 : Channel 2 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH2_Pos (2UL) /*!< Position of CH2 field. */
-#define PPI_CHENSET_CH2_Msk (0x1UL << PPI_CHENSET_CH2_Pos) /*!< Bit mask of CH2 field. */
-#define PPI_CHENSET_CH2_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH2_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH2_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 1 : Channel 1 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH1_Pos (1UL) /*!< Position of CH1 field. */
-#define PPI_CHENSET_CH1_Msk (0x1UL << PPI_CHENSET_CH1_Pos) /*!< Bit mask of CH1 field. */
-#define PPI_CHENSET_CH1_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH1_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH1_Set (1UL) /*!< Write: Enable channel */
-
-/* Bit 0 : Channel 0 enable set register.  Writing '0' has no effect */
-#define PPI_CHENSET_CH0_Pos (0UL) /*!< Position of CH0 field. */
-#define PPI_CHENSET_CH0_Msk (0x1UL << PPI_CHENSET_CH0_Pos) /*!< Bit mask of CH0 field. */
-#define PPI_CHENSET_CH0_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENSET_CH0_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENSET_CH0_Set (1UL) /*!< Write: Enable channel */
-
-/* Register: PPI_CHENCLR */
-/* Description: Channel enable clear register */
-
-/* Bit 31 : Channel 31 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH31_Pos (31UL) /*!< Position of CH31 field. */
-#define PPI_CHENCLR_CH31_Msk (0x1UL << PPI_CHENCLR_CH31_Pos) /*!< Bit mask of CH31 field. */
-#define PPI_CHENCLR_CH31_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH31_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH31_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 30 : Channel 30 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH30_Pos (30UL) /*!< Position of CH30 field. */
-#define PPI_CHENCLR_CH30_Msk (0x1UL << PPI_CHENCLR_CH30_Pos) /*!< Bit mask of CH30 field. */
-#define PPI_CHENCLR_CH30_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH30_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH30_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 29 : Channel 29 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH29_Pos (29UL) /*!< Position of CH29 field. */
-#define PPI_CHENCLR_CH29_Msk (0x1UL << PPI_CHENCLR_CH29_Pos) /*!< Bit mask of CH29 field. */
-#define PPI_CHENCLR_CH29_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH29_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH29_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 28 : Channel 28 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH28_Pos (28UL) /*!< Position of CH28 field. */
-#define PPI_CHENCLR_CH28_Msk (0x1UL << PPI_CHENCLR_CH28_Pos) /*!< Bit mask of CH28 field. */
-#define PPI_CHENCLR_CH28_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH28_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH28_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 27 : Channel 27 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH27_Pos (27UL) /*!< Position of CH27 field. */
-#define PPI_CHENCLR_CH27_Msk (0x1UL << PPI_CHENCLR_CH27_Pos) /*!< Bit mask of CH27 field. */
-#define PPI_CHENCLR_CH27_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH27_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH27_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 26 : Channel 26 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH26_Pos (26UL) /*!< Position of CH26 field. */
-#define PPI_CHENCLR_CH26_Msk (0x1UL << PPI_CHENCLR_CH26_Pos) /*!< Bit mask of CH26 field. */
-#define PPI_CHENCLR_CH26_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH26_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH26_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 25 : Channel 25 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH25_Pos (25UL) /*!< Position of CH25 field. */
-#define PPI_CHENCLR_CH25_Msk (0x1UL << PPI_CHENCLR_CH25_Pos) /*!< Bit mask of CH25 field. */
-#define PPI_CHENCLR_CH25_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH25_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH25_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 24 : Channel 24 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH24_Pos (24UL) /*!< Position of CH24 field. */
-#define PPI_CHENCLR_CH24_Msk (0x1UL << PPI_CHENCLR_CH24_Pos) /*!< Bit mask of CH24 field. */
-#define PPI_CHENCLR_CH24_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH24_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH24_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 23 : Channel 23 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH23_Pos (23UL) /*!< Position of CH23 field. */
-#define PPI_CHENCLR_CH23_Msk (0x1UL << PPI_CHENCLR_CH23_Pos) /*!< Bit mask of CH23 field. */
-#define PPI_CHENCLR_CH23_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH23_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH23_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 22 : Channel 22 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH22_Pos (22UL) /*!< Position of CH22 field. */
-#define PPI_CHENCLR_CH22_Msk (0x1UL << PPI_CHENCLR_CH22_Pos) /*!< Bit mask of CH22 field. */
-#define PPI_CHENCLR_CH22_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH22_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH22_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 21 : Channel 21 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH21_Pos (21UL) /*!< Position of CH21 field. */
-#define PPI_CHENCLR_CH21_Msk (0x1UL << PPI_CHENCLR_CH21_Pos) /*!< Bit mask of CH21 field. */
-#define PPI_CHENCLR_CH21_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH21_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH21_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 20 : Channel 20 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH20_Pos (20UL) /*!< Position of CH20 field. */
-#define PPI_CHENCLR_CH20_Msk (0x1UL << PPI_CHENCLR_CH20_Pos) /*!< Bit mask of CH20 field. */
-#define PPI_CHENCLR_CH20_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH20_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH20_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 19 : Channel 19 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH19_Pos (19UL) /*!< Position of CH19 field. */
-#define PPI_CHENCLR_CH19_Msk (0x1UL << PPI_CHENCLR_CH19_Pos) /*!< Bit mask of CH19 field. */
-#define PPI_CHENCLR_CH19_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH19_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH19_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 18 : Channel 18 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH18_Pos (18UL) /*!< Position of CH18 field. */
-#define PPI_CHENCLR_CH18_Msk (0x1UL << PPI_CHENCLR_CH18_Pos) /*!< Bit mask of CH18 field. */
-#define PPI_CHENCLR_CH18_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH18_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH18_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 17 : Channel 17 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH17_Pos (17UL) /*!< Position of CH17 field. */
-#define PPI_CHENCLR_CH17_Msk (0x1UL << PPI_CHENCLR_CH17_Pos) /*!< Bit mask of CH17 field. */
-#define PPI_CHENCLR_CH17_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH17_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH17_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 16 : Channel 16 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH16_Pos (16UL) /*!< Position of CH16 field. */
-#define PPI_CHENCLR_CH16_Msk (0x1UL << PPI_CHENCLR_CH16_Pos) /*!< Bit mask of CH16 field. */
-#define PPI_CHENCLR_CH16_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH16_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH16_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 15 : Channel 15 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH15_Pos (15UL) /*!< Position of CH15 field. */
-#define PPI_CHENCLR_CH15_Msk (0x1UL << PPI_CHENCLR_CH15_Pos) /*!< Bit mask of CH15 field. */
-#define PPI_CHENCLR_CH15_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH15_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH15_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 14 : Channel 14 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH14_Pos (14UL) /*!< Position of CH14 field. */
-#define PPI_CHENCLR_CH14_Msk (0x1UL << PPI_CHENCLR_CH14_Pos) /*!< Bit mask of CH14 field. */
-#define PPI_CHENCLR_CH14_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH14_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH14_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 13 : Channel 13 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH13_Pos (13UL) /*!< Position of CH13 field. */
-#define PPI_CHENCLR_CH13_Msk (0x1UL << PPI_CHENCLR_CH13_Pos) /*!< Bit mask of CH13 field. */
-#define PPI_CHENCLR_CH13_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH13_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH13_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 12 : Channel 12 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH12_Pos (12UL) /*!< Position of CH12 field. */
-#define PPI_CHENCLR_CH12_Msk (0x1UL << PPI_CHENCLR_CH12_Pos) /*!< Bit mask of CH12 field. */
-#define PPI_CHENCLR_CH12_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH12_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH12_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 11 : Channel 11 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH11_Pos (11UL) /*!< Position of CH11 field. */
-#define PPI_CHENCLR_CH11_Msk (0x1UL << PPI_CHENCLR_CH11_Pos) /*!< Bit mask of CH11 field. */
-#define PPI_CHENCLR_CH11_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH11_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH11_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 10 : Channel 10 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH10_Pos (10UL) /*!< Position of CH10 field. */
-#define PPI_CHENCLR_CH10_Msk (0x1UL << PPI_CHENCLR_CH10_Pos) /*!< Bit mask of CH10 field. */
-#define PPI_CHENCLR_CH10_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH10_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH10_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 9 : Channel 9 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH9_Pos (9UL) /*!< Position of CH9 field. */
-#define PPI_CHENCLR_CH9_Msk (0x1UL << PPI_CHENCLR_CH9_Pos) /*!< Bit mask of CH9 field. */
-#define PPI_CHENCLR_CH9_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH9_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH9_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 8 : Channel 8 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH8_Pos (8UL) /*!< Position of CH8 field. */
-#define PPI_CHENCLR_CH8_Msk (0x1UL << PPI_CHENCLR_CH8_Pos) /*!< Bit mask of CH8 field. */
-#define PPI_CHENCLR_CH8_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH8_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH8_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 7 : Channel 7 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH7_Pos (7UL) /*!< Position of CH7 field. */
-#define PPI_CHENCLR_CH7_Msk (0x1UL << PPI_CHENCLR_CH7_Pos) /*!< Bit mask of CH7 field. */
-#define PPI_CHENCLR_CH7_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH7_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH7_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 6 : Channel 6 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH6_Pos (6UL) /*!< Position of CH6 field. */
-#define PPI_CHENCLR_CH6_Msk (0x1UL << PPI_CHENCLR_CH6_Pos) /*!< Bit mask of CH6 field. */
-#define PPI_CHENCLR_CH6_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH6_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH6_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 5 : Channel 5 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH5_Pos (5UL) /*!< Position of CH5 field. */
-#define PPI_CHENCLR_CH5_Msk (0x1UL << PPI_CHENCLR_CH5_Pos) /*!< Bit mask of CH5 field. */
-#define PPI_CHENCLR_CH5_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH5_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH5_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 4 : Channel 4 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH4_Pos (4UL) /*!< Position of CH4 field. */
-#define PPI_CHENCLR_CH4_Msk (0x1UL << PPI_CHENCLR_CH4_Pos) /*!< Bit mask of CH4 field. */
-#define PPI_CHENCLR_CH4_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH4_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH4_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 3 : Channel 3 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH3_Pos (3UL) /*!< Position of CH3 field. */
-#define PPI_CHENCLR_CH3_Msk (0x1UL << PPI_CHENCLR_CH3_Pos) /*!< Bit mask of CH3 field. */
-#define PPI_CHENCLR_CH3_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH3_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH3_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 2 : Channel 2 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH2_Pos (2UL) /*!< Position of CH2 field. */
-#define PPI_CHENCLR_CH2_Msk (0x1UL << PPI_CHENCLR_CH2_Pos) /*!< Bit mask of CH2 field. */
-#define PPI_CHENCLR_CH2_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH2_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH2_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 1 : Channel 1 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH1_Pos (1UL) /*!< Position of CH1 field. */
-#define PPI_CHENCLR_CH1_Msk (0x1UL << PPI_CHENCLR_CH1_Pos) /*!< Bit mask of CH1 field. */
-#define PPI_CHENCLR_CH1_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH1_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH1_Clear (1UL) /*!< Write: disable channel */
-
-/* Bit 0 : Channel 0 enable clear register.  Writing '0' has no effect */
-#define PPI_CHENCLR_CH0_Pos (0UL) /*!< Position of CH0 field. */
-#define PPI_CHENCLR_CH0_Msk (0x1UL << PPI_CHENCLR_CH0_Pos) /*!< Bit mask of CH0 field. */
-#define PPI_CHENCLR_CH0_Disabled (0UL) /*!< Read: channel disabled */
-#define PPI_CHENCLR_CH0_Enabled (1UL) /*!< Read: channel enabled */
-#define PPI_CHENCLR_CH0_Clear (1UL) /*!< Write: disable channel */
-
-/* Register: PPI_CH_EEP */
-/* Description: Description cluster[0]:  Channel 0 event end-point */
-
-/* Bits 31..0 : Pointer to event register. Accepts only addresses to registers from the Event group. */
-#define PPI_CH_EEP_EEP_Pos (0UL) /*!< Position of EEP field. */
-#define PPI_CH_EEP_EEP_Msk (0xFFFFFFFFUL << PPI_CH_EEP_EEP_Pos) /*!< Bit mask of EEP field. */
-
-/* Register: PPI_CH_TEP */
-/* Description: Description cluster[0]:  Channel 0 task end-point */
-
-/* Bits 31..0 : Pointer to task register. Accepts only addresses to registers from the Task group. */
-#define PPI_CH_TEP_TEP_Pos (0UL) /*!< Position of TEP field. */
-#define PPI_CH_TEP_TEP_Msk (0xFFFFFFFFUL << PPI_CH_TEP_TEP_Pos) /*!< Bit mask of TEP field. */
-
-/* Register: PPI_CHG */
-/* Description: Description collection[0]:  Channel group 0 */
-
-/* Bit 31 : Include or exclude channel 31 */
-#define PPI_CHG_CH31_Pos (31UL) /*!< Position of CH31 field. */
-#define PPI_CHG_CH31_Msk (0x1UL << PPI_CHG_CH31_Pos) /*!< Bit mask of CH31 field. */
-#define PPI_CHG_CH31_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH31_Included (1UL) /*!< Include */
-
-/* Bit 30 : Include or exclude channel 30 */
-#define PPI_CHG_CH30_Pos (30UL) /*!< Position of CH30 field. */
-#define PPI_CHG_CH30_Msk (0x1UL << PPI_CHG_CH30_Pos) /*!< Bit mask of CH30 field. */
-#define PPI_CHG_CH30_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH30_Included (1UL) /*!< Include */
-
-/* Bit 29 : Include or exclude channel 29 */
-#define PPI_CHG_CH29_Pos (29UL) /*!< Position of CH29 field. */
-#define PPI_CHG_CH29_Msk (0x1UL << PPI_CHG_CH29_Pos) /*!< Bit mask of CH29 field. */
-#define PPI_CHG_CH29_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH29_Included (1UL) /*!< Include */
-
-/* Bit 28 : Include or exclude channel 28 */
-#define PPI_CHG_CH28_Pos (28UL) /*!< Position of CH28 field. */
-#define PPI_CHG_CH28_Msk (0x1UL << PPI_CHG_CH28_Pos) /*!< Bit mask of CH28 field. */
-#define PPI_CHG_CH28_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH28_Included (1UL) /*!< Include */
-
-/* Bit 27 : Include or exclude channel 27 */
-#define PPI_CHG_CH27_Pos (27UL) /*!< Position of CH27 field. */
-#define PPI_CHG_CH27_Msk (0x1UL << PPI_CHG_CH27_Pos) /*!< Bit mask of CH27 field. */
-#define PPI_CHG_CH27_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH27_Included (1UL) /*!< Include */
-
-/* Bit 26 : Include or exclude channel 26 */
-#define PPI_CHG_CH26_Pos (26UL) /*!< Position of CH26 field. */
-#define PPI_CHG_CH26_Msk (0x1UL << PPI_CHG_CH26_Pos) /*!< Bit mask of CH26 field. */
-#define PPI_CHG_CH26_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH26_Included (1UL) /*!< Include */
-
-/* Bit 25 : Include or exclude channel 25 */
-#define PPI_CHG_CH25_Pos (25UL) /*!< Position of CH25 field. */
-#define PPI_CHG_CH25_Msk (0x1UL << PPI_CHG_CH25_Pos) /*!< Bit mask of CH25 field. */
-#define PPI_CHG_CH25_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH25_Included (1UL) /*!< Include */
-
-/* Bit 24 : Include or exclude channel 24 */
-#define PPI_CHG_CH24_Pos (24UL) /*!< Position of CH24 field. */
-#define PPI_CHG_CH24_Msk (0x1UL << PPI_CHG_CH24_Pos) /*!< Bit mask of CH24 field. */
-#define PPI_CHG_CH24_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH24_Included (1UL) /*!< Include */
-
-/* Bit 23 : Include or exclude channel 23 */
-#define PPI_CHG_CH23_Pos (23UL) /*!< Position of CH23 field. */
-#define PPI_CHG_CH23_Msk (0x1UL << PPI_CHG_CH23_Pos) /*!< Bit mask of CH23 field. */
-#define PPI_CHG_CH23_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH23_Included (1UL) /*!< Include */
-
-/* Bit 22 : Include or exclude channel 22 */
-#define PPI_CHG_CH22_Pos (22UL) /*!< Position of CH22 field. */
-#define PPI_CHG_CH22_Msk (0x1UL << PPI_CHG_CH22_Pos) /*!< Bit mask of CH22 field. */
-#define PPI_CHG_CH22_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH22_Included (1UL) /*!< Include */
-
-/* Bit 21 : Include or exclude channel 21 */
-#define PPI_CHG_CH21_Pos (21UL) /*!< Position of CH21 field. */
-#define PPI_CHG_CH21_Msk (0x1UL << PPI_CHG_CH21_Pos) /*!< Bit mask of CH21 field. */
-#define PPI_CHG_CH21_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH21_Included (1UL) /*!< Include */
-
-/* Bit 20 : Include or exclude channel 20 */
-#define PPI_CHG_CH20_Pos (20UL) /*!< Position of CH20 field. */
-#define PPI_CHG_CH20_Msk (0x1UL << PPI_CHG_CH20_Pos) /*!< Bit mask of CH20 field. */
-#define PPI_CHG_CH20_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH20_Included (1UL) /*!< Include */
-
-/* Bit 19 : Include or exclude channel 19 */
-#define PPI_CHG_CH19_Pos (19UL) /*!< Position of CH19 field. */
-#define PPI_CHG_CH19_Msk (0x1UL << PPI_CHG_CH19_Pos) /*!< Bit mask of CH19 field. */
-#define PPI_CHG_CH19_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH19_Included (1UL) /*!< Include */
-
-/* Bit 18 : Include or exclude channel 18 */
-#define PPI_CHG_CH18_Pos (18UL) /*!< Position of CH18 field. */
-#define PPI_CHG_CH18_Msk (0x1UL << PPI_CHG_CH18_Pos) /*!< Bit mask of CH18 field. */
-#define PPI_CHG_CH18_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH18_Included (1UL) /*!< Include */
-
-/* Bit 17 : Include or exclude channel 17 */
-#define PPI_CHG_CH17_Pos (17UL) /*!< Position of CH17 field. */
-#define PPI_CHG_CH17_Msk (0x1UL << PPI_CHG_CH17_Pos) /*!< Bit mask of CH17 field. */
-#define PPI_CHG_CH17_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH17_Included (1UL) /*!< Include */
-
-/* Bit 16 : Include or exclude channel 16 */
-#define PPI_CHG_CH16_Pos (16UL) /*!< Position of CH16 field. */
-#define PPI_CHG_CH16_Msk (0x1UL << PPI_CHG_CH16_Pos) /*!< Bit mask of CH16 field. */
-#define PPI_CHG_CH16_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH16_Included (1UL) /*!< Include */
-
-/* Bit 15 : Include or exclude channel 15 */
-#define PPI_CHG_CH15_Pos (15UL) /*!< Position of CH15 field. */
-#define PPI_CHG_CH15_Msk (0x1UL << PPI_CHG_CH15_Pos) /*!< Bit mask of CH15 field. */
-#define PPI_CHG_CH15_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH15_Included (1UL) /*!< Include */
-
-/* Bit 14 : Include or exclude channel 14 */
-#define PPI_CHG_CH14_Pos (14UL) /*!< Position of CH14 field. */
-#define PPI_CHG_CH14_Msk (0x1UL << PPI_CHG_CH14_Pos) /*!< Bit mask of CH14 field. */
-#define PPI_CHG_CH14_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH14_Included (1UL) /*!< Include */
-
-/* Bit 13 : Include or exclude channel 13 */
-#define PPI_CHG_CH13_Pos (13UL) /*!< Position of CH13 field. */
-#define PPI_CHG_CH13_Msk (0x1UL << PPI_CHG_CH13_Pos) /*!< Bit mask of CH13 field. */
-#define PPI_CHG_CH13_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH13_Included (1UL) /*!< Include */
-
-/* Bit 12 : Include or exclude channel 12 */
-#define PPI_CHG_CH12_Pos (12UL) /*!< Position of CH12 field. */
-#define PPI_CHG_CH12_Msk (0x1UL << PPI_CHG_CH12_Pos) /*!< Bit mask of CH12 field. */
-#define PPI_CHG_CH12_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH12_Included (1UL) /*!< Include */
-
-/* Bit 11 : Include or exclude channel 11 */
-#define PPI_CHG_CH11_Pos (11UL) /*!< Position of CH11 field. */
-#define PPI_CHG_CH11_Msk (0x1UL << PPI_CHG_CH11_Pos) /*!< Bit mask of CH11 field. */
-#define PPI_CHG_CH11_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH11_Included (1UL) /*!< Include */
-
-/* Bit 10 : Include or exclude channel 10 */
-#define PPI_CHG_CH10_Pos (10UL) /*!< Position of CH10 field. */
-#define PPI_CHG_CH10_Msk (0x1UL << PPI_CHG_CH10_Pos) /*!< Bit mask of CH10 field. */
-#define PPI_CHG_CH10_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH10_Included (1UL) /*!< Include */
-
-/* Bit 9 : Include or exclude channel 9 */
-#define PPI_CHG_CH9_Pos (9UL) /*!< Position of CH9 field. */
-#define PPI_CHG_CH9_Msk (0x1UL << PPI_CHG_CH9_Pos) /*!< Bit mask of CH9 field. */
-#define PPI_CHG_CH9_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH9_Included (1UL) /*!< Include */
-
-/* Bit 8 : Include or exclude channel 8 */
-#define PPI_CHG_CH8_Pos (8UL) /*!< Position of CH8 field. */
-#define PPI_CHG_CH8_Msk (0x1UL << PPI_CHG_CH8_Pos) /*!< Bit mask of CH8 field. */
-#define PPI_CHG_CH8_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH8_Included (1UL) /*!< Include */
-
-/* Bit 7 : Include or exclude channel 7 */
-#define PPI_CHG_CH7_Pos (7UL) /*!< Position of CH7 field. */
-#define PPI_CHG_CH7_Msk (0x1UL << PPI_CHG_CH7_Pos) /*!< Bit mask of CH7 field. */
-#define PPI_CHG_CH7_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH7_Included (1UL) /*!< Include */
-
-/* Bit 6 : Include or exclude channel 6 */
-#define PPI_CHG_CH6_Pos (6UL) /*!< Position of CH6 field. */
-#define PPI_CHG_CH6_Msk (0x1UL << PPI_CHG_CH6_Pos) /*!< Bit mask of CH6 field. */
-#define PPI_CHG_CH6_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH6_Included (1UL) /*!< Include */
-
-/* Bit 5 : Include or exclude channel 5 */
-#define PPI_CHG_CH5_Pos (5UL) /*!< Position of CH5 field. */
-#define PPI_CHG_CH5_Msk (0x1UL << PPI_CHG_CH5_Pos) /*!< Bit mask of CH5 field. */
-#define PPI_CHG_CH5_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH5_Included (1UL) /*!< Include */
-
-/* Bit 4 : Include or exclude channel 4 */
-#define PPI_CHG_CH4_Pos (4UL) /*!< Position of CH4 field. */
-#define PPI_CHG_CH4_Msk (0x1UL << PPI_CHG_CH4_Pos) /*!< Bit mask of CH4 field. */
-#define PPI_CHG_CH4_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH4_Included (1UL) /*!< Include */
-
-/* Bit 3 : Include or exclude channel 3 */
-#define PPI_CHG_CH3_Pos (3UL) /*!< Position of CH3 field. */
-#define PPI_CHG_CH3_Msk (0x1UL << PPI_CHG_CH3_Pos) /*!< Bit mask of CH3 field. */
-#define PPI_CHG_CH3_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH3_Included (1UL) /*!< Include */
-
-/* Bit 2 : Include or exclude channel 2 */
-#define PPI_CHG_CH2_Pos (2UL) /*!< Position of CH2 field. */
-#define PPI_CHG_CH2_Msk (0x1UL << PPI_CHG_CH2_Pos) /*!< Bit mask of CH2 field. */
-#define PPI_CHG_CH2_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH2_Included (1UL) /*!< Include */
-
-/* Bit 1 : Include or exclude channel 1 */
-#define PPI_CHG_CH1_Pos (1UL) /*!< Position of CH1 field. */
-#define PPI_CHG_CH1_Msk (0x1UL << PPI_CHG_CH1_Pos) /*!< Bit mask of CH1 field. */
-#define PPI_CHG_CH1_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH1_Included (1UL) /*!< Include */
-
-/* Bit 0 : Include or exclude channel 0 */
-#define PPI_CHG_CH0_Pos (0UL) /*!< Position of CH0 field. */
-#define PPI_CHG_CH0_Msk (0x1UL << PPI_CHG_CH0_Pos) /*!< Bit mask of CH0 field. */
-#define PPI_CHG_CH0_Excluded (0UL) /*!< Exclude */
-#define PPI_CHG_CH0_Included (1UL) /*!< Include */
-
-/* Register: PPI_FORK_TEP */
-/* Description: Description cluster[0]:  Channel 0 task end-point */
-
-/* Bits 31..0 : Pointer to task register */
-#define PPI_FORK_TEP_TEP_Pos (0UL) /*!< Position of TEP field. */
-#define PPI_FORK_TEP_TEP_Msk (0xFFFFFFFFUL << PPI_FORK_TEP_TEP_Pos) /*!< Bit mask of TEP field. */
-
-
-/* Peripheral: PWM */
-/* Description: Pulse Width Modulation Unit 0 */
-
-/* Register: PWM_SHORTS */
-/* Description: Shortcut register */
-
-/* Bit 4 : Shortcut between LOOPSDONE event and STOP task */
-#define PWM_SHORTS_LOOPSDONE_STOP_Pos (4UL) /*!< Position of LOOPSDONE_STOP field. */
-#define PWM_SHORTS_LOOPSDONE_STOP_Msk (0x1UL << PWM_SHORTS_LOOPSDONE_STOP_Pos) /*!< Bit mask of LOOPSDONE_STOP field. */
-#define PWM_SHORTS_LOOPSDONE_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define PWM_SHORTS_LOOPSDONE_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 3 : Shortcut between LOOPSDONE event and SEQSTART[1] task */
-#define PWM_SHORTS_LOOPSDONE_SEQSTART1_Pos (3UL) /*!< Position of LOOPSDONE_SEQSTART1 field. */
-#define PWM_SHORTS_LOOPSDONE_SEQSTART1_Msk (0x1UL << PWM_SHORTS_LOOPSDONE_SEQSTART1_Pos) /*!< Bit mask of LOOPSDONE_SEQSTART1 field. */
-#define PWM_SHORTS_LOOPSDONE_SEQSTART1_Disabled (0UL) /*!< Disable shortcut */
-#define PWM_SHORTS_LOOPSDONE_SEQSTART1_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 2 : Shortcut between LOOPSDONE event and SEQSTART[0] task */
-#define PWM_SHORTS_LOOPSDONE_SEQSTART0_Pos (2UL) /*!< Position of LOOPSDONE_SEQSTART0 field. */
-#define PWM_SHORTS_LOOPSDONE_SEQSTART0_Msk (0x1UL << PWM_SHORTS_LOOPSDONE_SEQSTART0_Pos) /*!< Bit mask of LOOPSDONE_SEQSTART0 field. */
-#define PWM_SHORTS_LOOPSDONE_SEQSTART0_Disabled (0UL) /*!< Disable shortcut */
-#define PWM_SHORTS_LOOPSDONE_SEQSTART0_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 1 : Shortcut between SEQEND[1] event and STOP task */
-#define PWM_SHORTS_SEQEND1_STOP_Pos (1UL) /*!< Position of SEQEND1_STOP field. */
-#define PWM_SHORTS_SEQEND1_STOP_Msk (0x1UL << PWM_SHORTS_SEQEND1_STOP_Pos) /*!< Bit mask of SEQEND1_STOP field. */
-#define PWM_SHORTS_SEQEND1_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define PWM_SHORTS_SEQEND1_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 0 : Shortcut between SEQEND[0] event and STOP task */
-#define PWM_SHORTS_SEQEND0_STOP_Pos (0UL) /*!< Position of SEQEND0_STOP field. */
-#define PWM_SHORTS_SEQEND0_STOP_Msk (0x1UL << PWM_SHORTS_SEQEND0_STOP_Pos) /*!< Bit mask of SEQEND0_STOP field. */
-#define PWM_SHORTS_SEQEND0_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define PWM_SHORTS_SEQEND0_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Register: PWM_INTEN */
-/* Description: Enable or disable interrupt */
-
-/* Bit 7 : Enable or disable interrupt for LOOPSDONE event */
-#define PWM_INTEN_LOOPSDONE_Pos (7UL) /*!< Position of LOOPSDONE field. */
-#define PWM_INTEN_LOOPSDONE_Msk (0x1UL << PWM_INTEN_LOOPSDONE_Pos) /*!< Bit mask of LOOPSDONE field. */
-#define PWM_INTEN_LOOPSDONE_Disabled (0UL) /*!< Disable */
-#define PWM_INTEN_LOOPSDONE_Enabled (1UL) /*!< Enable */
-
-/* Bit 6 : Enable or disable interrupt for PWMPERIODEND event */
-#define PWM_INTEN_PWMPERIODEND_Pos (6UL) /*!< Position of PWMPERIODEND field. */
-#define PWM_INTEN_PWMPERIODEND_Msk (0x1UL << PWM_INTEN_PWMPERIODEND_Pos) /*!< Bit mask of PWMPERIODEND field. */
-#define PWM_INTEN_PWMPERIODEND_Disabled (0UL) /*!< Disable */
-#define PWM_INTEN_PWMPERIODEND_Enabled (1UL) /*!< Enable */
-
-/* Bit 5 : Enable or disable interrupt for SEQEND[1] event */
-#define PWM_INTEN_SEQEND1_Pos (5UL) /*!< Position of SEQEND1 field. */
-#define PWM_INTEN_SEQEND1_Msk (0x1UL << PWM_INTEN_SEQEND1_Pos) /*!< Bit mask of SEQEND1 field. */
-#define PWM_INTEN_SEQEND1_Disabled (0UL) /*!< Disable */
-#define PWM_INTEN_SEQEND1_Enabled (1UL) /*!< Enable */
-
-/* Bit 4 : Enable or disable interrupt for SEQEND[0] event */
-#define PWM_INTEN_SEQEND0_Pos (4UL) /*!< Position of SEQEND0 field. */
-#define PWM_INTEN_SEQEND0_Msk (0x1UL << PWM_INTEN_SEQEND0_Pos) /*!< Bit mask of SEQEND0 field. */
-#define PWM_INTEN_SEQEND0_Disabled (0UL) /*!< Disable */
-#define PWM_INTEN_SEQEND0_Enabled (1UL) /*!< Enable */
-
-/* Bit 3 : Enable or disable interrupt for SEQSTARTED[1] event */
-#define PWM_INTEN_SEQSTARTED1_Pos (3UL) /*!< Position of SEQSTARTED1 field. */
-#define PWM_INTEN_SEQSTARTED1_Msk (0x1UL << PWM_INTEN_SEQSTARTED1_Pos) /*!< Bit mask of SEQSTARTED1 field. */
-#define PWM_INTEN_SEQSTARTED1_Disabled (0UL) /*!< Disable */
-#define PWM_INTEN_SEQSTARTED1_Enabled (1UL) /*!< Enable */
-
-/* Bit 2 : Enable or disable interrupt for SEQSTARTED[0] event */
-#define PWM_INTEN_SEQSTARTED0_Pos (2UL) /*!< Position of SEQSTARTED0 field. */
-#define PWM_INTEN_SEQSTARTED0_Msk (0x1UL << PWM_INTEN_SEQSTARTED0_Pos) /*!< Bit mask of SEQSTARTED0 field. */
-#define PWM_INTEN_SEQSTARTED0_Disabled (0UL) /*!< Disable */
-#define PWM_INTEN_SEQSTARTED0_Enabled (1UL) /*!< Enable */
-
-/* Bit 1 : Enable or disable interrupt for STOPPED event */
-#define PWM_INTEN_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
-#define PWM_INTEN_STOPPED_Msk (0x1UL << PWM_INTEN_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define PWM_INTEN_STOPPED_Disabled (0UL) /*!< Disable */
-#define PWM_INTEN_STOPPED_Enabled (1UL) /*!< Enable */
-
-/* Register: PWM_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 7 : Write '1' to Enable interrupt for LOOPSDONE event */
-#define PWM_INTENSET_LOOPSDONE_Pos (7UL) /*!< Position of LOOPSDONE field. */
-#define PWM_INTENSET_LOOPSDONE_Msk (0x1UL << PWM_INTENSET_LOOPSDONE_Pos) /*!< Bit mask of LOOPSDONE field. */
-#define PWM_INTENSET_LOOPSDONE_Disabled (0UL) /*!< Read: Disabled */
-#define PWM_INTENSET_LOOPSDONE_Enabled (1UL) /*!< Read: Enabled */
-#define PWM_INTENSET_LOOPSDONE_Set (1UL) /*!< Enable */
-
-/* Bit 6 : Write '1' to Enable interrupt for PWMPERIODEND event */
-#define PWM_INTENSET_PWMPERIODEND_Pos (6UL) /*!< Position of PWMPERIODEND field. */
-#define PWM_INTENSET_PWMPERIODEND_Msk (0x1UL << PWM_INTENSET_PWMPERIODEND_Pos) /*!< Bit mask of PWMPERIODEND field. */
-#define PWM_INTENSET_PWMPERIODEND_Disabled (0UL) /*!< Read: Disabled */
-#define PWM_INTENSET_PWMPERIODEND_Enabled (1UL) /*!< Read: Enabled */
-#define PWM_INTENSET_PWMPERIODEND_Set (1UL) /*!< Enable */
-
-/* Bit 5 : Write '1' to Enable interrupt for SEQEND[1] event */
-#define PWM_INTENSET_SEQEND1_Pos (5UL) /*!< Position of SEQEND1 field. */
-#define PWM_INTENSET_SEQEND1_Msk (0x1UL << PWM_INTENSET_SEQEND1_Pos) /*!< Bit mask of SEQEND1 field. */
-#define PWM_INTENSET_SEQEND1_Disabled (0UL) /*!< Read: Disabled */
-#define PWM_INTENSET_SEQEND1_Enabled (1UL) /*!< Read: Enabled */
-#define PWM_INTENSET_SEQEND1_Set (1UL) /*!< Enable */
-
-/* Bit 4 : Write '1' to Enable interrupt for SEQEND[0] event */
-#define PWM_INTENSET_SEQEND0_Pos (4UL) /*!< Position of SEQEND0 field. */
-#define PWM_INTENSET_SEQEND0_Msk (0x1UL << PWM_INTENSET_SEQEND0_Pos) /*!< Bit mask of SEQEND0 field. */
-#define PWM_INTENSET_SEQEND0_Disabled (0UL) /*!< Read: Disabled */
-#define PWM_INTENSET_SEQEND0_Enabled (1UL) /*!< Read: Enabled */
-#define PWM_INTENSET_SEQEND0_Set (1UL) /*!< Enable */
-
-/* Bit 3 : Write '1' to Enable interrupt for SEQSTARTED[1] event */
-#define PWM_INTENSET_SEQSTARTED1_Pos (3UL) /*!< Position of SEQSTARTED1 field. */
-#define PWM_INTENSET_SEQSTARTED1_Msk (0x1UL << PWM_INTENSET_SEQSTARTED1_Pos) /*!< Bit mask of SEQSTARTED1 field. */
-#define PWM_INTENSET_SEQSTARTED1_Disabled (0UL) /*!< Read: Disabled */
-#define PWM_INTENSET_SEQSTARTED1_Enabled (1UL) /*!< Read: Enabled */
-#define PWM_INTENSET_SEQSTARTED1_Set (1UL) /*!< Enable */
-
-/* Bit 2 : Write '1' to Enable interrupt for SEQSTARTED[0] event */
-#define PWM_INTENSET_SEQSTARTED0_Pos (2UL) /*!< Position of SEQSTARTED0 field. */
-#define PWM_INTENSET_SEQSTARTED0_Msk (0x1UL << PWM_INTENSET_SEQSTARTED0_Pos) /*!< Bit mask of SEQSTARTED0 field. */
-#define PWM_INTENSET_SEQSTARTED0_Disabled (0UL) /*!< Read: Disabled */
-#define PWM_INTENSET_SEQSTARTED0_Enabled (1UL) /*!< Read: Enabled */
-#define PWM_INTENSET_SEQSTARTED0_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for STOPPED event */
-#define PWM_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
-#define PWM_INTENSET_STOPPED_Msk (0x1UL << PWM_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define PWM_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define PWM_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define PWM_INTENSET_STOPPED_Set (1UL) /*!< Enable */
-
-/* Register: PWM_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 7 : Write '1' to Disable interrupt for LOOPSDONE event */
-#define PWM_INTENCLR_LOOPSDONE_Pos (7UL) /*!< Position of LOOPSDONE field. */
-#define PWM_INTENCLR_LOOPSDONE_Msk (0x1UL << PWM_INTENCLR_LOOPSDONE_Pos) /*!< Bit mask of LOOPSDONE field. */
-#define PWM_INTENCLR_LOOPSDONE_Disabled (0UL) /*!< Read: Disabled */
-#define PWM_INTENCLR_LOOPSDONE_Enabled (1UL) /*!< Read: Enabled */
-#define PWM_INTENCLR_LOOPSDONE_Clear (1UL) /*!< Disable */
-
-/* Bit 6 : Write '1' to Disable interrupt for PWMPERIODEND event */
-#define PWM_INTENCLR_PWMPERIODEND_Pos (6UL) /*!< Position of PWMPERIODEND field. */
-#define PWM_INTENCLR_PWMPERIODEND_Msk (0x1UL << PWM_INTENCLR_PWMPERIODEND_Pos) /*!< Bit mask of PWMPERIODEND field. */
-#define PWM_INTENCLR_PWMPERIODEND_Disabled (0UL) /*!< Read: Disabled */
-#define PWM_INTENCLR_PWMPERIODEND_Enabled (1UL) /*!< Read: Enabled */
-#define PWM_INTENCLR_PWMPERIODEND_Clear (1UL) /*!< Disable */
-
-/* Bit 5 : Write '1' to Disable interrupt for SEQEND[1] event */
-#define PWM_INTENCLR_SEQEND1_Pos (5UL) /*!< Position of SEQEND1 field. */
-#define PWM_INTENCLR_SEQEND1_Msk (0x1UL << PWM_INTENCLR_SEQEND1_Pos) /*!< Bit mask of SEQEND1 field. */
-#define PWM_INTENCLR_SEQEND1_Disabled (0UL) /*!< Read: Disabled */
-#define PWM_INTENCLR_SEQEND1_Enabled (1UL) /*!< Read: Enabled */
-#define PWM_INTENCLR_SEQEND1_Clear (1UL) /*!< Disable */
-
-/* Bit 4 : Write '1' to Disable interrupt for SEQEND[0] event */
-#define PWM_INTENCLR_SEQEND0_Pos (4UL) /*!< Position of SEQEND0 field. */
-#define PWM_INTENCLR_SEQEND0_Msk (0x1UL << PWM_INTENCLR_SEQEND0_Pos) /*!< Bit mask of SEQEND0 field. */
-#define PWM_INTENCLR_SEQEND0_Disabled (0UL) /*!< Read: Disabled */
-#define PWM_INTENCLR_SEQEND0_Enabled (1UL) /*!< Read: Enabled */
-#define PWM_INTENCLR_SEQEND0_Clear (1UL) /*!< Disable */
-
-/* Bit 3 : Write '1' to Disable interrupt for SEQSTARTED[1] event */
-#define PWM_INTENCLR_SEQSTARTED1_Pos (3UL) /*!< Position of SEQSTARTED1 field. */
-#define PWM_INTENCLR_SEQSTARTED1_Msk (0x1UL << PWM_INTENCLR_SEQSTARTED1_Pos) /*!< Bit mask of SEQSTARTED1 field. */
-#define PWM_INTENCLR_SEQSTARTED1_Disabled (0UL) /*!< Read: Disabled */
-#define PWM_INTENCLR_SEQSTARTED1_Enabled (1UL) /*!< Read: Enabled */
-#define PWM_INTENCLR_SEQSTARTED1_Clear (1UL) /*!< Disable */
-
-/* Bit 2 : Write '1' to Disable interrupt for SEQSTARTED[0] event */
-#define PWM_INTENCLR_SEQSTARTED0_Pos (2UL) /*!< Position of SEQSTARTED0 field. */
-#define PWM_INTENCLR_SEQSTARTED0_Msk (0x1UL << PWM_INTENCLR_SEQSTARTED0_Pos) /*!< Bit mask of SEQSTARTED0 field. */
-#define PWM_INTENCLR_SEQSTARTED0_Disabled (0UL) /*!< Read: Disabled */
-#define PWM_INTENCLR_SEQSTARTED0_Enabled (1UL) /*!< Read: Enabled */
-#define PWM_INTENCLR_SEQSTARTED0_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for STOPPED event */
-#define PWM_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
-#define PWM_INTENCLR_STOPPED_Msk (0x1UL << PWM_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define PWM_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define PWM_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define PWM_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
-
-/* Register: PWM_ENABLE */
-/* Description: PWM module enable register */
-
-/* Bit 0 : Enable or disable PWM module */
-#define PWM_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
-#define PWM_ENABLE_ENABLE_Msk (0x1UL << PWM_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
-#define PWM_ENABLE_ENABLE_Disabled (0UL) /*!< Disabled */
-#define PWM_ENABLE_ENABLE_Enabled (1UL) /*!< Enable */
-
-/* Register: PWM_MODE */
-/* Description: Selects operating mode of the wave counter */
-
-/* Bit 0 : Selects up or up and down as wave counter mode */
-#define PWM_MODE_UPDOWN_Pos (0UL) /*!< Position of UPDOWN field. */
-#define PWM_MODE_UPDOWN_Msk (0x1UL << PWM_MODE_UPDOWN_Pos) /*!< Bit mask of UPDOWN field. */
-#define PWM_MODE_UPDOWN_Up (0UL) /*!< Up counter - edge aligned PWM duty-cycle */
-#define PWM_MODE_UPDOWN_UpAndDown (1UL) /*!< Up and down counter - center aligned PWM duty cycle */
-
-/* Register: PWM_COUNTERTOP */
-/* Description: Value up to which the pulse generator counter counts */
-
-/* Bits 14..0 : Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM will be used. */
-#define PWM_COUNTERTOP_COUNTERTOP_Pos (0UL) /*!< Position of COUNTERTOP field. */
-#define PWM_COUNTERTOP_COUNTERTOP_Msk (0x7FFFUL << PWM_COUNTERTOP_COUNTERTOP_Pos) /*!< Bit mask of COUNTERTOP field. */
-
-/* Register: PWM_PRESCALER */
-/* Description: Configuration for PWM_CLK */
-
-/* Bits 2..0 : Pre-scaler of PWM_CLK */
-#define PWM_PRESCALER_PRESCALER_Pos (0UL) /*!< Position of PRESCALER field. */
-#define PWM_PRESCALER_PRESCALER_Msk (0x7UL << PWM_PRESCALER_PRESCALER_Pos) /*!< Bit mask of PRESCALER field. */
-#define PWM_PRESCALER_PRESCALER_DIV_1 (0UL) /*!< Divide by   1 (16MHz) */
-#define PWM_PRESCALER_PRESCALER_DIV_2 (1UL) /*!< Divide by   2 ( 8MHz) */
-#define PWM_PRESCALER_PRESCALER_DIV_4 (2UL) /*!< Divide by   4 ( 4MHz) */
-#define PWM_PRESCALER_PRESCALER_DIV_8 (3UL) /*!< Divide by   8 ( 2MHz) */
-#define PWM_PRESCALER_PRESCALER_DIV_16 (4UL) /*!< Divide by  16 ( 1MHz) */
-#define PWM_PRESCALER_PRESCALER_DIV_32 (5UL) /*!< Divide by  32 ( 500kHz) */
-#define PWM_PRESCALER_PRESCALER_DIV_64 (6UL) /*!< Divide by  64 ( 250kHz) */
-#define PWM_PRESCALER_PRESCALER_DIV_128 (7UL) /*!< Divide by 128 ( 125kHz) */
-
-/* Register: PWM_DECODER */
-/* Description: Configuration of the decoder */
-
-/* Bit 8 : Selects source for advancing the active sequence */
-#define PWM_DECODER_MODE_Pos (8UL) /*!< Position of MODE field. */
-#define PWM_DECODER_MODE_Msk (0x1UL << PWM_DECODER_MODE_Pos) /*!< Bit mask of MODE field. */
-#define PWM_DECODER_MODE_RefreshCount (0UL) /*!< SEQ[n].REFRESH is used to determine loading internal compare registers */
-#define PWM_DECODER_MODE_NextStep (1UL) /*!< NEXTSTEP task causes a new value to be loaded to internal compare registers */
-
-/* Bits 2..0 : How a sequence is read from RAM and spread to the compare register */
-#define PWM_DECODER_LOAD_Pos (0UL) /*!< Position of LOAD field. */
-#define PWM_DECODER_LOAD_Msk (0x7UL << PWM_DECODER_LOAD_Pos) /*!< Bit mask of LOAD field. */
-#define PWM_DECODER_LOAD_Common (0UL) /*!< 1st half word (16-bit) used in all PWM channels 0..3 */
-#define PWM_DECODER_LOAD_Grouped (1UL) /*!< 1st half word (16-bit) used in channel 0..1; 2nd word in channel 2..3 */
-#define PWM_DECODER_LOAD_Individual (2UL) /*!< 1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in ch.3 */
-#define PWM_DECODER_LOAD_WaveForm (3UL) /*!< 1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in COUNTERTOP */
-
-/* Register: PWM_LOOP */
-/* Description: Amount of playback of a loop */
-
-/* Bits 15..0 : Amount of playback of pattern cycles */
-#define PWM_LOOP_CNT_Pos (0UL) /*!< Position of CNT field. */
-#define PWM_LOOP_CNT_Msk (0xFFFFUL << PWM_LOOP_CNT_Pos) /*!< Bit mask of CNT field. */
-#define PWM_LOOP_CNT_Disabled (0UL) /*!< Looping disabled (stop at the end of the sequence) */
-
-/* Register: PWM_SEQ_PTR */
-/* Description: Description cluster[0]:  Beginning address in Data RAM of this sequence */
-
-/* Bits 31..0 : Beginning address in Data RAM of this sequence */
-#define PWM_SEQ_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
-#define PWM_SEQ_PTR_PTR_Msk (0xFFFFFFFFUL << PWM_SEQ_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
-
-/* Register: PWM_SEQ_CNT */
-/* Description: Description cluster[0]:  Amount of values (duty cycles) in this sequence */
-
-/* Bits 14..0 : Amount of values (duty cycles) in this sequence */
-#define PWM_SEQ_CNT_CNT_Pos (0UL) /*!< Position of CNT field. */
-#define PWM_SEQ_CNT_CNT_Msk (0x7FFFUL << PWM_SEQ_CNT_CNT_Pos) /*!< Bit mask of CNT field. */
-#define PWM_SEQ_CNT_CNT_Disabled (0UL) /*!< Sequence is disabled, and shall not be started as it is empty */
-
-/* Register: PWM_SEQ_REFRESH */
-/* Description: Description cluster[0]:  Amount of additional PWM periods between samples loaded into compare register */
-
-/* Bits 23..0 : Amount of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods) */
-#define PWM_SEQ_REFRESH_CNT_Pos (0UL) /*!< Position of CNT field. */
-#define PWM_SEQ_REFRESH_CNT_Msk (0xFFFFFFUL << PWM_SEQ_REFRESH_CNT_Pos) /*!< Bit mask of CNT field. */
-#define PWM_SEQ_REFRESH_CNT_Continuous (0UL) /*!< Update every PWM period */
-
-/* Register: PWM_SEQ_ENDDELAY */
-/* Description: Description cluster[0]:  Time added after the sequence */
-
-/* Bits 23..0 : Time added after the sequence in PWM periods */
-#define PWM_SEQ_ENDDELAY_CNT_Pos (0UL) /*!< Position of CNT field. */
-#define PWM_SEQ_ENDDELAY_CNT_Msk (0xFFFFFFUL << PWM_SEQ_ENDDELAY_CNT_Pos) /*!< Bit mask of CNT field. */
-
-/* Register: PWM_PSEL_OUT */
-/* Description: Description collection[0]:  Output pin select for PWM channel 0 */
-
-/* Bit 31 : Connection */
-#define PWM_PSEL_OUT_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define PWM_PSEL_OUT_CONNECT_Msk (0x1UL << PWM_PSEL_OUT_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define PWM_PSEL_OUT_CONNECT_Connected (0UL) /*!< Connect */
-#define PWM_PSEL_OUT_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define PWM_PSEL_OUT_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define PWM_PSEL_OUT_PIN_Msk (0x1FUL << PWM_PSEL_OUT_PIN_Pos) /*!< Bit mask of PIN field. */
-
-
-/* Peripheral: QDEC */
-/* Description: Quadrature Decoder */
-
-/* Register: QDEC_SHORTS */
-/* Description: Shortcut register */
-
-/* Bit 6 : Shortcut between SAMPLERDY event and READCLRACC task */
-#define QDEC_SHORTS_SAMPLERDY_READCLRACC_Pos (6UL) /*!< Position of SAMPLERDY_READCLRACC field. */
-#define QDEC_SHORTS_SAMPLERDY_READCLRACC_Msk (0x1UL << QDEC_SHORTS_SAMPLERDY_READCLRACC_Pos) /*!< Bit mask of SAMPLERDY_READCLRACC field. */
-#define QDEC_SHORTS_SAMPLERDY_READCLRACC_Disabled (0UL) /*!< Disable shortcut */
-#define QDEC_SHORTS_SAMPLERDY_READCLRACC_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 5 : Shortcut between DBLRDY event and STOP task */
-#define QDEC_SHORTS_DBLRDY_STOP_Pos (5UL) /*!< Position of DBLRDY_STOP field. */
-#define QDEC_SHORTS_DBLRDY_STOP_Msk (0x1UL << QDEC_SHORTS_DBLRDY_STOP_Pos) /*!< Bit mask of DBLRDY_STOP field. */
-#define QDEC_SHORTS_DBLRDY_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define QDEC_SHORTS_DBLRDY_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 4 : Shortcut between DBLRDY event and RDCLRDBL task */
-#define QDEC_SHORTS_DBLRDY_RDCLRDBL_Pos (4UL) /*!< Position of DBLRDY_RDCLRDBL field. */
-#define QDEC_SHORTS_DBLRDY_RDCLRDBL_Msk (0x1UL << QDEC_SHORTS_DBLRDY_RDCLRDBL_Pos) /*!< Bit mask of DBLRDY_RDCLRDBL field. */
-#define QDEC_SHORTS_DBLRDY_RDCLRDBL_Disabled (0UL) /*!< Disable shortcut */
-#define QDEC_SHORTS_DBLRDY_RDCLRDBL_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 3 : Shortcut between REPORTRDY event and STOP task */
-#define QDEC_SHORTS_REPORTRDY_STOP_Pos (3UL) /*!< Position of REPORTRDY_STOP field. */
-#define QDEC_SHORTS_REPORTRDY_STOP_Msk (0x1UL << QDEC_SHORTS_REPORTRDY_STOP_Pos) /*!< Bit mask of REPORTRDY_STOP field. */
-#define QDEC_SHORTS_REPORTRDY_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define QDEC_SHORTS_REPORTRDY_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 2 : Shortcut between REPORTRDY event and RDCLRACC task */
-#define QDEC_SHORTS_REPORTRDY_RDCLRACC_Pos (2UL) /*!< Position of REPORTRDY_RDCLRACC field. */
-#define QDEC_SHORTS_REPORTRDY_RDCLRACC_Msk (0x1UL << QDEC_SHORTS_REPORTRDY_RDCLRACC_Pos) /*!< Bit mask of REPORTRDY_RDCLRACC field. */
-#define QDEC_SHORTS_REPORTRDY_RDCLRACC_Disabled (0UL) /*!< Disable shortcut */
-#define QDEC_SHORTS_REPORTRDY_RDCLRACC_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 1 : Shortcut between SAMPLERDY event and STOP task */
-#define QDEC_SHORTS_SAMPLERDY_STOP_Pos (1UL) /*!< Position of SAMPLERDY_STOP field. */
-#define QDEC_SHORTS_SAMPLERDY_STOP_Msk (0x1UL << QDEC_SHORTS_SAMPLERDY_STOP_Pos) /*!< Bit mask of SAMPLERDY_STOP field. */
-#define QDEC_SHORTS_SAMPLERDY_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define QDEC_SHORTS_SAMPLERDY_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 0 : Shortcut between REPORTRDY event and READCLRACC task */
-#define QDEC_SHORTS_REPORTRDY_READCLRACC_Pos (0UL) /*!< Position of REPORTRDY_READCLRACC field. */
-#define QDEC_SHORTS_REPORTRDY_READCLRACC_Msk (0x1UL << QDEC_SHORTS_REPORTRDY_READCLRACC_Pos) /*!< Bit mask of REPORTRDY_READCLRACC field. */
-#define QDEC_SHORTS_REPORTRDY_READCLRACC_Disabled (0UL) /*!< Disable shortcut */
-#define QDEC_SHORTS_REPORTRDY_READCLRACC_Enabled (1UL) /*!< Enable shortcut */
-
-/* Register: QDEC_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 4 : Write '1' to Enable interrupt for STOPPED event */
-#define QDEC_INTENSET_STOPPED_Pos (4UL) /*!< Position of STOPPED field. */
-#define QDEC_INTENSET_STOPPED_Msk (0x1UL << QDEC_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define QDEC_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define QDEC_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define QDEC_INTENSET_STOPPED_Set (1UL) /*!< Enable */
-
-/* Bit 3 : Write '1' to Enable interrupt for DBLRDY event */
-#define QDEC_INTENSET_DBLRDY_Pos (3UL) /*!< Position of DBLRDY field. */
-#define QDEC_INTENSET_DBLRDY_Msk (0x1UL << QDEC_INTENSET_DBLRDY_Pos) /*!< Bit mask of DBLRDY field. */
-#define QDEC_INTENSET_DBLRDY_Disabled (0UL) /*!< Read: Disabled */
-#define QDEC_INTENSET_DBLRDY_Enabled (1UL) /*!< Read: Enabled */
-#define QDEC_INTENSET_DBLRDY_Set (1UL) /*!< Enable */
-
-/* Bit 2 : Write '1' to Enable interrupt for ACCOF event */
-#define QDEC_INTENSET_ACCOF_Pos (2UL) /*!< Position of ACCOF field. */
-#define QDEC_INTENSET_ACCOF_Msk (0x1UL << QDEC_INTENSET_ACCOF_Pos) /*!< Bit mask of ACCOF field. */
-#define QDEC_INTENSET_ACCOF_Disabled (0UL) /*!< Read: Disabled */
-#define QDEC_INTENSET_ACCOF_Enabled (1UL) /*!< Read: Enabled */
-#define QDEC_INTENSET_ACCOF_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for REPORTRDY event */
-#define QDEC_INTENSET_REPORTRDY_Pos (1UL) /*!< Position of REPORTRDY field. */
-#define QDEC_INTENSET_REPORTRDY_Msk (0x1UL << QDEC_INTENSET_REPORTRDY_Pos) /*!< Bit mask of REPORTRDY field. */
-#define QDEC_INTENSET_REPORTRDY_Disabled (0UL) /*!< Read: Disabled */
-#define QDEC_INTENSET_REPORTRDY_Enabled (1UL) /*!< Read: Enabled */
-#define QDEC_INTENSET_REPORTRDY_Set (1UL) /*!< Enable */
-
-/* Bit 0 : Write '1' to Enable interrupt for SAMPLERDY event */
-#define QDEC_INTENSET_SAMPLERDY_Pos (0UL) /*!< Position of SAMPLERDY field. */
-#define QDEC_INTENSET_SAMPLERDY_Msk (0x1UL << QDEC_INTENSET_SAMPLERDY_Pos) /*!< Bit mask of SAMPLERDY field. */
-#define QDEC_INTENSET_SAMPLERDY_Disabled (0UL) /*!< Read: Disabled */
-#define QDEC_INTENSET_SAMPLERDY_Enabled (1UL) /*!< Read: Enabled */
-#define QDEC_INTENSET_SAMPLERDY_Set (1UL) /*!< Enable */
-
-/* Register: QDEC_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 4 : Write '1' to Disable interrupt for STOPPED event */
-#define QDEC_INTENCLR_STOPPED_Pos (4UL) /*!< Position of STOPPED field. */
-#define QDEC_INTENCLR_STOPPED_Msk (0x1UL << QDEC_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define QDEC_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define QDEC_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define QDEC_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
-
-/* Bit 3 : Write '1' to Disable interrupt for DBLRDY event */
-#define QDEC_INTENCLR_DBLRDY_Pos (3UL) /*!< Position of DBLRDY field. */
-#define QDEC_INTENCLR_DBLRDY_Msk (0x1UL << QDEC_INTENCLR_DBLRDY_Pos) /*!< Bit mask of DBLRDY field. */
-#define QDEC_INTENCLR_DBLRDY_Disabled (0UL) /*!< Read: Disabled */
-#define QDEC_INTENCLR_DBLRDY_Enabled (1UL) /*!< Read: Enabled */
-#define QDEC_INTENCLR_DBLRDY_Clear (1UL) /*!< Disable */
-
-/* Bit 2 : Write '1' to Disable interrupt for ACCOF event */
-#define QDEC_INTENCLR_ACCOF_Pos (2UL) /*!< Position of ACCOF field. */
-#define QDEC_INTENCLR_ACCOF_Msk (0x1UL << QDEC_INTENCLR_ACCOF_Pos) /*!< Bit mask of ACCOF field. */
-#define QDEC_INTENCLR_ACCOF_Disabled (0UL) /*!< Read: Disabled */
-#define QDEC_INTENCLR_ACCOF_Enabled (1UL) /*!< Read: Enabled */
-#define QDEC_INTENCLR_ACCOF_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for REPORTRDY event */
-#define QDEC_INTENCLR_REPORTRDY_Pos (1UL) /*!< Position of REPORTRDY field. */
-#define QDEC_INTENCLR_REPORTRDY_Msk (0x1UL << QDEC_INTENCLR_REPORTRDY_Pos) /*!< Bit mask of REPORTRDY field. */
-#define QDEC_INTENCLR_REPORTRDY_Disabled (0UL) /*!< Read: Disabled */
-#define QDEC_INTENCLR_REPORTRDY_Enabled (1UL) /*!< Read: Enabled */
-#define QDEC_INTENCLR_REPORTRDY_Clear (1UL) /*!< Disable */
-
-/* Bit 0 : Write '1' to Disable interrupt for SAMPLERDY event */
-#define QDEC_INTENCLR_SAMPLERDY_Pos (0UL) /*!< Position of SAMPLERDY field. */
-#define QDEC_INTENCLR_SAMPLERDY_Msk (0x1UL << QDEC_INTENCLR_SAMPLERDY_Pos) /*!< Bit mask of SAMPLERDY field. */
-#define QDEC_INTENCLR_SAMPLERDY_Disabled (0UL) /*!< Read: Disabled */
-#define QDEC_INTENCLR_SAMPLERDY_Enabled (1UL) /*!< Read: Enabled */
-#define QDEC_INTENCLR_SAMPLERDY_Clear (1UL) /*!< Disable */
-
-/* Register: QDEC_ENABLE */
-/* Description: Enable the quadrature decoder */
-
-/* Bit 0 : Enable or disable the quadrature decoder */
-#define QDEC_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
-#define QDEC_ENABLE_ENABLE_Msk (0x1UL << QDEC_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
-#define QDEC_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
-#define QDEC_ENABLE_ENABLE_Enabled (1UL) /*!< Enable */
-
-/* Register: QDEC_LEDPOL */
-/* Description: LED output pin polarity */
-
-/* Bit 0 : LED output pin polarity */
-#define QDEC_LEDPOL_LEDPOL_Pos (0UL) /*!< Position of LEDPOL field. */
-#define QDEC_LEDPOL_LEDPOL_Msk (0x1UL << QDEC_LEDPOL_LEDPOL_Pos) /*!< Bit mask of LEDPOL field. */
-#define QDEC_LEDPOL_LEDPOL_ActiveLow (0UL) /*!< Led active on output pin low */
-#define QDEC_LEDPOL_LEDPOL_ActiveHigh (1UL) /*!< Led active on output pin high */
-
-/* Register: QDEC_SAMPLEPER */
-/* Description: Sample period */
-
-/* Bits 3..0 : Sample period. The SAMPLE register will be updated for every new sample */
-#define QDEC_SAMPLEPER_SAMPLEPER_Pos (0UL) /*!< Position of SAMPLEPER field. */
-#define QDEC_SAMPLEPER_SAMPLEPER_Msk (0xFUL << QDEC_SAMPLEPER_SAMPLEPER_Pos) /*!< Bit mask of SAMPLEPER field. */
-#define QDEC_SAMPLEPER_SAMPLEPER_128us (0UL) /*!< 128 us */
-#define QDEC_SAMPLEPER_SAMPLEPER_256us (1UL) /*!< 256 us */
-#define QDEC_SAMPLEPER_SAMPLEPER_512us (2UL) /*!< 512 us */
-#define QDEC_SAMPLEPER_SAMPLEPER_1024us (3UL) /*!< 1024 us */
-#define QDEC_SAMPLEPER_SAMPLEPER_2048us (4UL) /*!< 2048 us */
-#define QDEC_SAMPLEPER_SAMPLEPER_4096us (5UL) /*!< 4096 us */
-#define QDEC_SAMPLEPER_SAMPLEPER_8192us (6UL) /*!< 8192 us */
-#define QDEC_SAMPLEPER_SAMPLEPER_16384us (7UL) /*!< 16384 us */
-#define QDEC_SAMPLEPER_SAMPLEPER_32ms (8UL) /*!< 32768 us */
-#define QDEC_SAMPLEPER_SAMPLEPER_65ms (9UL) /*!< 65536 us */
-#define QDEC_SAMPLEPER_SAMPLEPER_131ms (10UL) /*!< 131072 us */
-
-/* Register: QDEC_SAMPLE */
-/* Description: Motion sample value */
-
-/* Bits 31..0 : Last motion sample */
-#define QDEC_SAMPLE_SAMPLE_Pos (0UL) /*!< Position of SAMPLE field. */
-#define QDEC_SAMPLE_SAMPLE_Msk (0xFFFFFFFFUL << QDEC_SAMPLE_SAMPLE_Pos) /*!< Bit mask of SAMPLE field. */
-
-/* Register: QDEC_REPORTPER */
-/* Description: Number of samples to be taken before REPORTRDY and DBLRDY events can be generated */
-
-/* Bits 3..0 : Specifies the number of samples to be accumulated in the ACC register before the REPORTRDY and DBLRDY events can be generated */
-#define QDEC_REPORTPER_REPORTPER_Pos (0UL) /*!< Position of REPORTPER field. */
-#define QDEC_REPORTPER_REPORTPER_Msk (0xFUL << QDEC_REPORTPER_REPORTPER_Pos) /*!< Bit mask of REPORTPER field. */
-#define QDEC_REPORTPER_REPORTPER_10Smpl (0UL) /*!< 10 samples / report */
-#define QDEC_REPORTPER_REPORTPER_40Smpl (1UL) /*!< 40 samples / report */
-#define QDEC_REPORTPER_REPORTPER_80Smpl (2UL) /*!< 80 samples / report */
-#define QDEC_REPORTPER_REPORTPER_120Smpl (3UL) /*!< 120 samples / report */
-#define QDEC_REPORTPER_REPORTPER_160Smpl (4UL) /*!< 160 samples / report */
-#define QDEC_REPORTPER_REPORTPER_200Smpl (5UL) /*!< 200 samples / report */
-#define QDEC_REPORTPER_REPORTPER_240Smpl (6UL) /*!< 240 samples / report */
-#define QDEC_REPORTPER_REPORTPER_280Smpl (7UL) /*!< 280 samples / report */
-#define QDEC_REPORTPER_REPORTPER_1Smpl (8UL) /*!< 1 sample / report */
-
-/* Register: QDEC_ACC */
-/* Description: Register accumulating the valid transitions */
-
-/* Bits 31..0 : Register accumulating all valid samples (not double transition) read from the SAMPLE register */
-#define QDEC_ACC_ACC_Pos (0UL) /*!< Position of ACC field. */
-#define QDEC_ACC_ACC_Msk (0xFFFFFFFFUL << QDEC_ACC_ACC_Pos) /*!< Bit mask of ACC field. */
-
-/* Register: QDEC_ACCREAD */
-/* Description: Snapshot of the ACC register, updated by the READCLRACC or RDCLRACC task */
-
-/* Bits 31..0 : Snapshot of the ACC register. */
-#define QDEC_ACCREAD_ACCREAD_Pos (0UL) /*!< Position of ACCREAD field. */
-#define QDEC_ACCREAD_ACCREAD_Msk (0xFFFFFFFFUL << QDEC_ACCREAD_ACCREAD_Pos) /*!< Bit mask of ACCREAD field. */
-
-/* Register: QDEC_PSEL_LED */
-/* Description: Pin select for LED signal */
-
-/* Bit 31 : Connection */
-#define QDEC_PSEL_LED_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define QDEC_PSEL_LED_CONNECT_Msk (0x1UL << QDEC_PSEL_LED_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define QDEC_PSEL_LED_CONNECT_Connected (0UL) /*!< Connect */
-#define QDEC_PSEL_LED_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define QDEC_PSEL_LED_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define QDEC_PSEL_LED_PIN_Msk (0x1FUL << QDEC_PSEL_LED_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: QDEC_PSEL_A */
-/* Description: Pin select for A signal */
-
-/* Bit 31 : Connection */
-#define QDEC_PSEL_A_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define QDEC_PSEL_A_CONNECT_Msk (0x1UL << QDEC_PSEL_A_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define QDEC_PSEL_A_CONNECT_Connected (0UL) /*!< Connect */
-#define QDEC_PSEL_A_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define QDEC_PSEL_A_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define QDEC_PSEL_A_PIN_Msk (0x1FUL << QDEC_PSEL_A_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: QDEC_PSEL_B */
-/* Description: Pin select for B signal */
-
-/* Bit 31 : Connection */
-#define QDEC_PSEL_B_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define QDEC_PSEL_B_CONNECT_Msk (0x1UL << QDEC_PSEL_B_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define QDEC_PSEL_B_CONNECT_Connected (0UL) /*!< Connect */
-#define QDEC_PSEL_B_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define QDEC_PSEL_B_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define QDEC_PSEL_B_PIN_Msk (0x1FUL << QDEC_PSEL_B_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: QDEC_DBFEN */
-/* Description: Enable input debounce filters */
-
-/* Bit 0 : Enable input debounce filters */
-#define QDEC_DBFEN_DBFEN_Pos (0UL) /*!< Position of DBFEN field. */
-#define QDEC_DBFEN_DBFEN_Msk (0x1UL << QDEC_DBFEN_DBFEN_Pos) /*!< Bit mask of DBFEN field. */
-#define QDEC_DBFEN_DBFEN_Disabled (0UL) /*!< Debounce input filters disabled */
-#define QDEC_DBFEN_DBFEN_Enabled (1UL) /*!< Debounce input filters enabled */
-
-/* Register: QDEC_LEDPRE */
-/* Description: Time period the LED is switched ON prior to sampling */
-
-/* Bits 8..0 : Period in us the LED is switched on prior to sampling */
-#define QDEC_LEDPRE_LEDPRE_Pos (0UL) /*!< Position of LEDPRE field. */
-#define QDEC_LEDPRE_LEDPRE_Msk (0x1FFUL << QDEC_LEDPRE_LEDPRE_Pos) /*!< Bit mask of LEDPRE field. */
-
-/* Register: QDEC_ACCDBL */
-/* Description: Register accumulating the number of detected double transitions */
-
-/* Bits 3..0 : Register accumulating the number of detected double or illegal transitions. ( SAMPLE = 2 ). */
-#define QDEC_ACCDBL_ACCDBL_Pos (0UL) /*!< Position of ACCDBL field. */
-#define QDEC_ACCDBL_ACCDBL_Msk (0xFUL << QDEC_ACCDBL_ACCDBL_Pos) /*!< Bit mask of ACCDBL field. */
-
-/* Register: QDEC_ACCDBLREAD */
-/* Description: Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL task */
-
-/* Bits 3..0 : Snapshot of the ACCDBL register. This field is updated when the READCLRACC or RDCLRDBL task is triggered. */
-#define QDEC_ACCDBLREAD_ACCDBLREAD_Pos (0UL) /*!< Position of ACCDBLREAD field. */
-#define QDEC_ACCDBLREAD_ACCDBLREAD_Msk (0xFUL << QDEC_ACCDBLREAD_ACCDBLREAD_Pos) /*!< Bit mask of ACCDBLREAD field. */
-
-
-/* Peripheral: RADIO */
-/* Description: 2.4 GHz Radio */
-
-/* Register: RADIO_SHORTS */
-/* Description: Shortcut register */
-
-/* Bit 8 : Shortcut between DISABLED event and RSSISTOP task */
-#define RADIO_SHORTS_DISABLED_RSSISTOP_Pos (8UL) /*!< Position of DISABLED_RSSISTOP field. */
-#define RADIO_SHORTS_DISABLED_RSSISTOP_Msk (0x1UL << RADIO_SHORTS_DISABLED_RSSISTOP_Pos) /*!< Bit mask of DISABLED_RSSISTOP field. */
-#define RADIO_SHORTS_DISABLED_RSSISTOP_Disabled (0UL) /*!< Disable shortcut */
-#define RADIO_SHORTS_DISABLED_RSSISTOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 6 : Shortcut between ADDRESS event and BCSTART task */
-#define RADIO_SHORTS_ADDRESS_BCSTART_Pos (6UL) /*!< Position of ADDRESS_BCSTART field. */
-#define RADIO_SHORTS_ADDRESS_BCSTART_Msk (0x1UL << RADIO_SHORTS_ADDRESS_BCSTART_Pos) /*!< Bit mask of ADDRESS_BCSTART field. */
-#define RADIO_SHORTS_ADDRESS_BCSTART_Disabled (0UL) /*!< Disable shortcut */
-#define RADIO_SHORTS_ADDRESS_BCSTART_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 5 : Shortcut between END event and START task */
-#define RADIO_SHORTS_END_START_Pos (5UL) /*!< Position of END_START field. */
-#define RADIO_SHORTS_END_START_Msk (0x1UL << RADIO_SHORTS_END_START_Pos) /*!< Bit mask of END_START field. */
-#define RADIO_SHORTS_END_START_Disabled (0UL) /*!< Disable shortcut */
-#define RADIO_SHORTS_END_START_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 4 : Shortcut between ADDRESS event and RSSISTART task */
-#define RADIO_SHORTS_ADDRESS_RSSISTART_Pos (4UL) /*!< Position of ADDRESS_RSSISTART field. */
-#define RADIO_SHORTS_ADDRESS_RSSISTART_Msk (0x1UL << RADIO_SHORTS_ADDRESS_RSSISTART_Pos) /*!< Bit mask of ADDRESS_RSSISTART field. */
-#define RADIO_SHORTS_ADDRESS_RSSISTART_Disabled (0UL) /*!< Disable shortcut */
-#define RADIO_SHORTS_ADDRESS_RSSISTART_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 3 : Shortcut between DISABLED event and RXEN task */
-#define RADIO_SHORTS_DISABLED_RXEN_Pos (3UL) /*!< Position of DISABLED_RXEN field. */
-#define RADIO_SHORTS_DISABLED_RXEN_Msk (0x1UL << RADIO_SHORTS_DISABLED_RXEN_Pos) /*!< Bit mask of DISABLED_RXEN field. */
-#define RADIO_SHORTS_DISABLED_RXEN_Disabled (0UL) /*!< Disable shortcut */
-#define RADIO_SHORTS_DISABLED_RXEN_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 2 : Shortcut between DISABLED event and TXEN task */
-#define RADIO_SHORTS_DISABLED_TXEN_Pos (2UL) /*!< Position of DISABLED_TXEN field. */
-#define RADIO_SHORTS_DISABLED_TXEN_Msk (0x1UL << RADIO_SHORTS_DISABLED_TXEN_Pos) /*!< Bit mask of DISABLED_TXEN field. */
-#define RADIO_SHORTS_DISABLED_TXEN_Disabled (0UL) /*!< Disable shortcut */
-#define RADIO_SHORTS_DISABLED_TXEN_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 1 : Shortcut between END event and DISABLE task */
-#define RADIO_SHORTS_END_DISABLE_Pos (1UL) /*!< Position of END_DISABLE field. */
-#define RADIO_SHORTS_END_DISABLE_Msk (0x1UL << RADIO_SHORTS_END_DISABLE_Pos) /*!< Bit mask of END_DISABLE field. */
-#define RADIO_SHORTS_END_DISABLE_Disabled (0UL) /*!< Disable shortcut */
-#define RADIO_SHORTS_END_DISABLE_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 0 : Shortcut between READY event and START task */
-#define RADIO_SHORTS_READY_START_Pos (0UL) /*!< Position of READY_START field. */
-#define RADIO_SHORTS_READY_START_Msk (0x1UL << RADIO_SHORTS_READY_START_Pos) /*!< Bit mask of READY_START field. */
-#define RADIO_SHORTS_READY_START_Disabled (0UL) /*!< Disable shortcut */
-#define RADIO_SHORTS_READY_START_Enabled (1UL) /*!< Enable shortcut */
-
-/* Register: RADIO_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 13 : Write '1' to Enable interrupt for CRCERROR event */
-#define RADIO_INTENSET_CRCERROR_Pos (13UL) /*!< Position of CRCERROR field. */
-#define RADIO_INTENSET_CRCERROR_Msk (0x1UL << RADIO_INTENSET_CRCERROR_Pos) /*!< Bit mask of CRCERROR field. */
-#define RADIO_INTENSET_CRCERROR_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENSET_CRCERROR_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENSET_CRCERROR_Set (1UL) /*!< Enable */
-
-/* Bit 12 : Write '1' to Enable interrupt for CRCOK event */
-#define RADIO_INTENSET_CRCOK_Pos (12UL) /*!< Position of CRCOK field. */
-#define RADIO_INTENSET_CRCOK_Msk (0x1UL << RADIO_INTENSET_CRCOK_Pos) /*!< Bit mask of CRCOK field. */
-#define RADIO_INTENSET_CRCOK_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENSET_CRCOK_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENSET_CRCOK_Set (1UL) /*!< Enable */
-
-/* Bit 10 : Write '1' to Enable interrupt for BCMATCH event */
-#define RADIO_INTENSET_BCMATCH_Pos (10UL) /*!< Position of BCMATCH field. */
-#define RADIO_INTENSET_BCMATCH_Msk (0x1UL << RADIO_INTENSET_BCMATCH_Pos) /*!< Bit mask of BCMATCH field. */
-#define RADIO_INTENSET_BCMATCH_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENSET_BCMATCH_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENSET_BCMATCH_Set (1UL) /*!< Enable */
-
-/* Bit 7 : Write '1' to Enable interrupt for RSSIEND event */
-#define RADIO_INTENSET_RSSIEND_Pos (7UL) /*!< Position of RSSIEND field. */
-#define RADIO_INTENSET_RSSIEND_Msk (0x1UL << RADIO_INTENSET_RSSIEND_Pos) /*!< Bit mask of RSSIEND field. */
-#define RADIO_INTENSET_RSSIEND_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENSET_RSSIEND_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENSET_RSSIEND_Set (1UL) /*!< Enable */
-
-/* Bit 6 : Write '1' to Enable interrupt for DEVMISS event */
-#define RADIO_INTENSET_DEVMISS_Pos (6UL) /*!< Position of DEVMISS field. */
-#define RADIO_INTENSET_DEVMISS_Msk (0x1UL << RADIO_INTENSET_DEVMISS_Pos) /*!< Bit mask of DEVMISS field. */
-#define RADIO_INTENSET_DEVMISS_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENSET_DEVMISS_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENSET_DEVMISS_Set (1UL) /*!< Enable */
-
-/* Bit 5 : Write '1' to Enable interrupt for DEVMATCH event */
-#define RADIO_INTENSET_DEVMATCH_Pos (5UL) /*!< Position of DEVMATCH field. */
-#define RADIO_INTENSET_DEVMATCH_Msk (0x1UL << RADIO_INTENSET_DEVMATCH_Pos) /*!< Bit mask of DEVMATCH field. */
-#define RADIO_INTENSET_DEVMATCH_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENSET_DEVMATCH_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENSET_DEVMATCH_Set (1UL) /*!< Enable */
-
-/* Bit 4 : Write '1' to Enable interrupt for DISABLED event */
-#define RADIO_INTENSET_DISABLED_Pos (4UL) /*!< Position of DISABLED field. */
-#define RADIO_INTENSET_DISABLED_Msk (0x1UL << RADIO_INTENSET_DISABLED_Pos) /*!< Bit mask of DISABLED field. */
-#define RADIO_INTENSET_DISABLED_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENSET_DISABLED_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENSET_DISABLED_Set (1UL) /*!< Enable */
-
-/* Bit 3 : Write '1' to Enable interrupt for END event */
-#define RADIO_INTENSET_END_Pos (3UL) /*!< Position of END field. */
-#define RADIO_INTENSET_END_Msk (0x1UL << RADIO_INTENSET_END_Pos) /*!< Bit mask of END field. */
-#define RADIO_INTENSET_END_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENSET_END_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENSET_END_Set (1UL) /*!< Enable */
-
-/* Bit 2 : Write '1' to Enable interrupt for PAYLOAD event */
-#define RADIO_INTENSET_PAYLOAD_Pos (2UL) /*!< Position of PAYLOAD field. */
-#define RADIO_INTENSET_PAYLOAD_Msk (0x1UL << RADIO_INTENSET_PAYLOAD_Pos) /*!< Bit mask of PAYLOAD field. */
-#define RADIO_INTENSET_PAYLOAD_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENSET_PAYLOAD_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENSET_PAYLOAD_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for ADDRESS event */
-#define RADIO_INTENSET_ADDRESS_Pos (1UL) /*!< Position of ADDRESS field. */
-#define RADIO_INTENSET_ADDRESS_Msk (0x1UL << RADIO_INTENSET_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
-#define RADIO_INTENSET_ADDRESS_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENSET_ADDRESS_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENSET_ADDRESS_Set (1UL) /*!< Enable */
-
-/* Bit 0 : Write '1' to Enable interrupt for READY event */
-#define RADIO_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
-#define RADIO_INTENSET_READY_Msk (0x1UL << RADIO_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
-#define RADIO_INTENSET_READY_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENSET_READY_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENSET_READY_Set (1UL) /*!< Enable */
-
-/* Register: RADIO_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 13 : Write '1' to Disable interrupt for CRCERROR event */
-#define RADIO_INTENCLR_CRCERROR_Pos (13UL) /*!< Position of CRCERROR field. */
-#define RADIO_INTENCLR_CRCERROR_Msk (0x1UL << RADIO_INTENCLR_CRCERROR_Pos) /*!< Bit mask of CRCERROR field. */
-#define RADIO_INTENCLR_CRCERROR_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENCLR_CRCERROR_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENCLR_CRCERROR_Clear (1UL) /*!< Disable */
-
-/* Bit 12 : Write '1' to Disable interrupt for CRCOK event */
-#define RADIO_INTENCLR_CRCOK_Pos (12UL) /*!< Position of CRCOK field. */
-#define RADIO_INTENCLR_CRCOK_Msk (0x1UL << RADIO_INTENCLR_CRCOK_Pos) /*!< Bit mask of CRCOK field. */
-#define RADIO_INTENCLR_CRCOK_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENCLR_CRCOK_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENCLR_CRCOK_Clear (1UL) /*!< Disable */
-
-/* Bit 10 : Write '1' to Disable interrupt for BCMATCH event */
-#define RADIO_INTENCLR_BCMATCH_Pos (10UL) /*!< Position of BCMATCH field. */
-#define RADIO_INTENCLR_BCMATCH_Msk (0x1UL << RADIO_INTENCLR_BCMATCH_Pos) /*!< Bit mask of BCMATCH field. */
-#define RADIO_INTENCLR_BCMATCH_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENCLR_BCMATCH_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENCLR_BCMATCH_Clear (1UL) /*!< Disable */
-
-/* Bit 7 : Write '1' to Disable interrupt for RSSIEND event */
-#define RADIO_INTENCLR_RSSIEND_Pos (7UL) /*!< Position of RSSIEND field. */
-#define RADIO_INTENCLR_RSSIEND_Msk (0x1UL << RADIO_INTENCLR_RSSIEND_Pos) /*!< Bit mask of RSSIEND field. */
-#define RADIO_INTENCLR_RSSIEND_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENCLR_RSSIEND_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENCLR_RSSIEND_Clear (1UL) /*!< Disable */
-
-/* Bit 6 : Write '1' to Disable interrupt for DEVMISS event */
-#define RADIO_INTENCLR_DEVMISS_Pos (6UL) /*!< Position of DEVMISS field. */
-#define RADIO_INTENCLR_DEVMISS_Msk (0x1UL << RADIO_INTENCLR_DEVMISS_Pos) /*!< Bit mask of DEVMISS field. */
-#define RADIO_INTENCLR_DEVMISS_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENCLR_DEVMISS_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENCLR_DEVMISS_Clear (1UL) /*!< Disable */
-
-/* Bit 5 : Write '1' to Disable interrupt for DEVMATCH event */
-#define RADIO_INTENCLR_DEVMATCH_Pos (5UL) /*!< Position of DEVMATCH field. */
-#define RADIO_INTENCLR_DEVMATCH_Msk (0x1UL << RADIO_INTENCLR_DEVMATCH_Pos) /*!< Bit mask of DEVMATCH field. */
-#define RADIO_INTENCLR_DEVMATCH_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENCLR_DEVMATCH_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENCLR_DEVMATCH_Clear (1UL) /*!< Disable */
-
-/* Bit 4 : Write '1' to Disable interrupt for DISABLED event */
-#define RADIO_INTENCLR_DISABLED_Pos (4UL) /*!< Position of DISABLED field. */
-#define RADIO_INTENCLR_DISABLED_Msk (0x1UL << RADIO_INTENCLR_DISABLED_Pos) /*!< Bit mask of DISABLED field. */
-#define RADIO_INTENCLR_DISABLED_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENCLR_DISABLED_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENCLR_DISABLED_Clear (1UL) /*!< Disable */
-
-/* Bit 3 : Write '1' to Disable interrupt for END event */
-#define RADIO_INTENCLR_END_Pos (3UL) /*!< Position of END field. */
-#define RADIO_INTENCLR_END_Msk (0x1UL << RADIO_INTENCLR_END_Pos) /*!< Bit mask of END field. */
-#define RADIO_INTENCLR_END_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENCLR_END_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENCLR_END_Clear (1UL) /*!< Disable */
-
-/* Bit 2 : Write '1' to Disable interrupt for PAYLOAD event */
-#define RADIO_INTENCLR_PAYLOAD_Pos (2UL) /*!< Position of PAYLOAD field. */
-#define RADIO_INTENCLR_PAYLOAD_Msk (0x1UL << RADIO_INTENCLR_PAYLOAD_Pos) /*!< Bit mask of PAYLOAD field. */
-#define RADIO_INTENCLR_PAYLOAD_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENCLR_PAYLOAD_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENCLR_PAYLOAD_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for ADDRESS event */
-#define RADIO_INTENCLR_ADDRESS_Pos (1UL) /*!< Position of ADDRESS field. */
-#define RADIO_INTENCLR_ADDRESS_Msk (0x1UL << RADIO_INTENCLR_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
-#define RADIO_INTENCLR_ADDRESS_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENCLR_ADDRESS_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENCLR_ADDRESS_Clear (1UL) /*!< Disable */
-
-/* Bit 0 : Write '1' to Disable interrupt for READY event */
-#define RADIO_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
-#define RADIO_INTENCLR_READY_Msk (0x1UL << RADIO_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
-#define RADIO_INTENCLR_READY_Disabled (0UL) /*!< Read: Disabled */
-#define RADIO_INTENCLR_READY_Enabled (1UL) /*!< Read: Enabled */
-#define RADIO_INTENCLR_READY_Clear (1UL) /*!< Disable */
-
-/* Register: RADIO_CRCSTATUS */
-/* Description: CRC status */
-
-/* Bit 0 : CRC status of packet received */
-#define RADIO_CRCSTATUS_CRCSTATUS_Pos (0UL) /*!< Position of CRCSTATUS field. */
-#define RADIO_CRCSTATUS_CRCSTATUS_Msk (0x1UL << RADIO_CRCSTATUS_CRCSTATUS_Pos) /*!< Bit mask of CRCSTATUS field. */
-#define RADIO_CRCSTATUS_CRCSTATUS_CRCError (0UL) /*!< Packet received with CRC error */
-#define RADIO_CRCSTATUS_CRCSTATUS_CRCOk (1UL) /*!< Packet received with CRC ok */
-
-/* Register: RADIO_RXMATCH */
-/* Description: Received address */
-
-/* Bits 2..0 : Received address */
-#define RADIO_RXMATCH_RXMATCH_Pos (0UL) /*!< Position of RXMATCH field. */
-#define RADIO_RXMATCH_RXMATCH_Msk (0x7UL << RADIO_RXMATCH_RXMATCH_Pos) /*!< Bit mask of RXMATCH field. */
-
-/* Register: RADIO_RXCRC */
-/* Description: CRC field of previously received packet */
-
-/* Bits 23..0 : CRC field of previously received packet */
-#define RADIO_RXCRC_RXCRC_Pos (0UL) /*!< Position of RXCRC field. */
-#define RADIO_RXCRC_RXCRC_Msk (0xFFFFFFUL << RADIO_RXCRC_RXCRC_Pos) /*!< Bit mask of RXCRC field. */
-
-/* Register: RADIO_DAI */
-/* Description: Device address match index */
-
-/* Bits 2..0 : Device address match index */
-#define RADIO_DAI_DAI_Pos (0UL) /*!< Position of DAI field. */
-#define RADIO_DAI_DAI_Msk (0x7UL << RADIO_DAI_DAI_Pos) /*!< Bit mask of DAI field. */
-
-/* Register: RADIO_PACKETPTR */
-/* Description: Packet pointer */
-
-/* Bits 31..0 : Packet pointer */
-#define RADIO_PACKETPTR_PACKETPTR_Pos (0UL) /*!< Position of PACKETPTR field. */
-#define RADIO_PACKETPTR_PACKETPTR_Msk (0xFFFFFFFFUL << RADIO_PACKETPTR_PACKETPTR_Pos) /*!< Bit mask of PACKETPTR field. */
-
-/* Register: RADIO_FREQUENCY */
-/* Description: Frequency */
-
-/* Bit 8 : Channel map selection. */
-#define RADIO_FREQUENCY_MAP_Pos (8UL) /*!< Position of MAP field. */
-#define RADIO_FREQUENCY_MAP_Msk (0x1UL << RADIO_FREQUENCY_MAP_Pos) /*!< Bit mask of MAP field. */
-#define RADIO_FREQUENCY_MAP_Default (0UL) /*!< Channel map between 2400 MHZ .. 2500 MHz */
-#define RADIO_FREQUENCY_MAP_Low (1UL) /*!< Channel map between 2360 MHZ .. 2460 MHz */
-
-/* Bits 6..0 : Radio channel frequency */
-#define RADIO_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
-#define RADIO_FREQUENCY_FREQUENCY_Msk (0x7FUL << RADIO_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
-
-/* Register: RADIO_TXPOWER */
-/* Description: Output power */
-
-/* Bits 7..0 : RADIO output power. */
-#define RADIO_TXPOWER_TXPOWER_Pos (0UL) /*!< Position of TXPOWER field. */
-#define RADIO_TXPOWER_TXPOWER_Msk (0xFFUL << RADIO_TXPOWER_TXPOWER_Pos) /*!< Bit mask of TXPOWER field. */
-#define RADIO_TXPOWER_TXPOWER_0dBm (0x00UL) /*!< 0 dBm */
-#define RADIO_TXPOWER_TXPOWER_Pos3dBm (0x03UL) /*!< +3 dBm */
-#define RADIO_TXPOWER_TXPOWER_Pos4dBm (0x04UL) /*!< +4 dBm */
-#define RADIO_TXPOWER_TXPOWER_Neg30dBm (0xD8UL) /*!< Deprecated enumerator -  -40 dBm */
-#define RADIO_TXPOWER_TXPOWER_Neg40dBm (0xD8UL) /*!< -40 dBm */
-#define RADIO_TXPOWER_TXPOWER_Neg20dBm (0xECUL) /*!< -20 dBm */
-#define RADIO_TXPOWER_TXPOWER_Neg16dBm (0xF0UL) /*!< -16 dBm */
-#define RADIO_TXPOWER_TXPOWER_Neg12dBm (0xF4UL) /*!< -12 dBm */
-#define RADIO_TXPOWER_TXPOWER_Neg8dBm (0xF8UL) /*!< -8 dBm */
-#define RADIO_TXPOWER_TXPOWER_Neg4dBm (0xFCUL) /*!< -4 dBm */
-
-/* Register: RADIO_MODE */
-/* Description: Data rate and modulation */
-
-/* Bits 3..0 : Radio data rate and modulation setting. The radio supports Frequency-shift Keying (FSK) modulation. */
-#define RADIO_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
-#define RADIO_MODE_MODE_Msk (0xFUL << RADIO_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
-#define RADIO_MODE_MODE_Nrf_1Mbit (0UL) /*!< 1 Mbit/s Nordic proprietary radio mode */
-#define RADIO_MODE_MODE_Nrf_2Mbit (1UL) /*!< 2 Mbit/s Nordic proprietary radio mode */
-#define RADIO_MODE_MODE_Nrf_250Kbit (2UL) /*!< Deprecated enumerator -  250 kbit/s Nordic proprietary radio mode */
-#define RADIO_MODE_MODE_Ble_1Mbit (3UL) /*!< 1 Mbit/s Bluetooth Low Energy */
-
-/* Register: RADIO_PCNF0 */
-/* Description: Packet configuration register 0 */
-
-/* Bit 24 : Length of preamble on air. Decision point: TASKS_START task */
-#define RADIO_PCNF0_PLEN_Pos (24UL) /*!< Position of PLEN field. */
-#define RADIO_PCNF0_PLEN_Msk (0x1UL << RADIO_PCNF0_PLEN_Pos) /*!< Bit mask of PLEN field. */
-#define RADIO_PCNF0_PLEN_8bit (0UL) /*!< 8-bit preamble */
-#define RADIO_PCNF0_PLEN_16bit (1UL) /*!< 16-bit preamble */
-
-/* Bit 20 : Include or exclude S1 field in RAM */
-#define RADIO_PCNF0_S1INCL_Pos (20UL) /*!< Position of S1INCL field. */
-#define RADIO_PCNF0_S1INCL_Msk (0x1UL << RADIO_PCNF0_S1INCL_Pos) /*!< Bit mask of S1INCL field. */
-#define RADIO_PCNF0_S1INCL_Automatic (0UL) /*!< Include S1 field in RAM only if S1LEN &gt; 0 */
-#define RADIO_PCNF0_S1INCL_Include (1UL) /*!< Always include S1 field in RAM independent of S1LEN */
-
-/* Bits 19..16 : Length on air of S1 field in number of bits. */
-#define RADIO_PCNF0_S1LEN_Pos (16UL) /*!< Position of S1LEN field. */
-#define RADIO_PCNF0_S1LEN_Msk (0xFUL << RADIO_PCNF0_S1LEN_Pos) /*!< Bit mask of S1LEN field. */
-
-/* Bit 8 : Length on air of S0 field in number of bytes. */
-#define RADIO_PCNF0_S0LEN_Pos (8UL) /*!< Position of S0LEN field. */
-#define RADIO_PCNF0_S0LEN_Msk (0x1UL << RADIO_PCNF0_S0LEN_Pos) /*!< Bit mask of S0LEN field. */
-
-/* Bits 3..0 : Length on air of LENGTH field in number of bits. */
-#define RADIO_PCNF0_LFLEN_Pos (0UL) /*!< Position of LFLEN field. */
-#define RADIO_PCNF0_LFLEN_Msk (0xFUL << RADIO_PCNF0_LFLEN_Pos) /*!< Bit mask of LFLEN field. */
-
-/* Register: RADIO_PCNF1 */
-/* Description: Packet configuration register 1 */
-
-/* Bit 25 : Enable or disable packet whitening */
-#define RADIO_PCNF1_WHITEEN_Pos (25UL) /*!< Position of WHITEEN field. */
-#define RADIO_PCNF1_WHITEEN_Msk (0x1UL << RADIO_PCNF1_WHITEEN_Pos) /*!< Bit mask of WHITEEN field. */
-#define RADIO_PCNF1_WHITEEN_Disabled (0UL) /*!< Disable */
-#define RADIO_PCNF1_WHITEEN_Enabled (1UL) /*!< Enable */
-
-/* Bit 24 : On air endianness of packet, this applies to the S0, LENGTH, S1 and the PAYLOAD fields. */
-#define RADIO_PCNF1_ENDIAN_Pos (24UL) /*!< Position of ENDIAN field. */
-#define RADIO_PCNF1_ENDIAN_Msk (0x1UL << RADIO_PCNF1_ENDIAN_Pos) /*!< Bit mask of ENDIAN field. */
-#define RADIO_PCNF1_ENDIAN_Little (0UL) /*!< Least Significant bit on air first */
-#define RADIO_PCNF1_ENDIAN_Big (1UL) /*!< Most significant bit on air first */
-
-/* Bits 18..16 : Base address length in number of bytes */
-#define RADIO_PCNF1_BALEN_Pos (16UL) /*!< Position of BALEN field. */
-#define RADIO_PCNF1_BALEN_Msk (0x7UL << RADIO_PCNF1_BALEN_Pos) /*!< Bit mask of BALEN field. */
-
-/* Bits 15..8 : Static length in number of bytes */
-#define RADIO_PCNF1_STATLEN_Pos (8UL) /*!< Position of STATLEN field. */
-#define RADIO_PCNF1_STATLEN_Msk (0xFFUL << RADIO_PCNF1_STATLEN_Pos) /*!< Bit mask of STATLEN field. */
-
-/* Bits 7..0 : Maximum length of packet payload. If the packet payload is larger than MAXLEN, the radio will truncate the payload to MAXLEN. */
-#define RADIO_PCNF1_MAXLEN_Pos (0UL) /*!< Position of MAXLEN field. */
-#define RADIO_PCNF1_MAXLEN_Msk (0xFFUL << RADIO_PCNF1_MAXLEN_Pos) /*!< Bit mask of MAXLEN field. */
-
-/* Register: RADIO_BASE0 */
-/* Description: Base address 0 */
-
-/* Bits 31..0 : Base address 0 */
-#define RADIO_BASE0_BASE0_Pos (0UL) /*!< Position of BASE0 field. */
-#define RADIO_BASE0_BASE0_Msk (0xFFFFFFFFUL << RADIO_BASE0_BASE0_Pos) /*!< Bit mask of BASE0 field. */
-
-/* Register: RADIO_BASE1 */
-/* Description: Base address 1 */
-
-/* Bits 31..0 : Base address 1 */
-#define RADIO_BASE1_BASE1_Pos (0UL) /*!< Position of BASE1 field. */
-#define RADIO_BASE1_BASE1_Msk (0xFFFFFFFFUL << RADIO_BASE1_BASE1_Pos) /*!< Bit mask of BASE1 field. */
-
-/* Register: RADIO_PREFIX0 */
-/* Description: Prefixes bytes for logical addresses 0-3 */
-
-/* Bits 31..24 : Address prefix 3. */
-#define RADIO_PREFIX0_AP3_Pos (24UL) /*!< Position of AP3 field. */
-#define RADIO_PREFIX0_AP3_Msk (0xFFUL << RADIO_PREFIX0_AP3_Pos) /*!< Bit mask of AP3 field. */
-
-/* Bits 23..16 : Address prefix 2. */
-#define RADIO_PREFIX0_AP2_Pos (16UL) /*!< Position of AP2 field. */
-#define RADIO_PREFIX0_AP2_Msk (0xFFUL << RADIO_PREFIX0_AP2_Pos) /*!< Bit mask of AP2 field. */
-
-/* Bits 15..8 : Address prefix 1. */
-#define RADIO_PREFIX0_AP1_Pos (8UL) /*!< Position of AP1 field. */
-#define RADIO_PREFIX0_AP1_Msk (0xFFUL << RADIO_PREFIX0_AP1_Pos) /*!< Bit mask of AP1 field. */
-
-/* Bits 7..0 : Address prefix 0. */
-#define RADIO_PREFIX0_AP0_Pos (0UL) /*!< Position of AP0 field. */
-#define RADIO_PREFIX0_AP0_Msk (0xFFUL << RADIO_PREFIX0_AP0_Pos) /*!< Bit mask of AP0 field. */
-
-/* Register: RADIO_PREFIX1 */
-/* Description: Prefixes bytes for logical addresses 4-7 */
-
-/* Bits 31..24 : Address prefix 7. */
-#define RADIO_PREFIX1_AP7_Pos (24UL) /*!< Position of AP7 field. */
-#define RADIO_PREFIX1_AP7_Msk (0xFFUL << RADIO_PREFIX1_AP7_Pos) /*!< Bit mask of AP7 field. */
-
-/* Bits 23..16 : Address prefix 6. */
-#define RADIO_PREFIX1_AP6_Pos (16UL) /*!< Position of AP6 field. */
-#define RADIO_PREFIX1_AP6_Msk (0xFFUL << RADIO_PREFIX1_AP6_Pos) /*!< Bit mask of AP6 field. */
-
-/* Bits 15..8 : Address prefix 5. */
-#define RADIO_PREFIX1_AP5_Pos (8UL) /*!< Position of AP5 field. */
-#define RADIO_PREFIX1_AP5_Msk (0xFFUL << RADIO_PREFIX1_AP5_Pos) /*!< Bit mask of AP5 field. */
-
-/* Bits 7..0 : Address prefix 4. */
-#define RADIO_PREFIX1_AP4_Pos (0UL) /*!< Position of AP4 field. */
-#define RADIO_PREFIX1_AP4_Msk (0xFFUL << RADIO_PREFIX1_AP4_Pos) /*!< Bit mask of AP4 field. */
-
-/* Register: RADIO_TXADDRESS */
-/* Description: Transmit address select */
-
-/* Bits 2..0 : Transmit address select */
-#define RADIO_TXADDRESS_TXADDRESS_Pos (0UL) /*!< Position of TXADDRESS field. */
-#define RADIO_TXADDRESS_TXADDRESS_Msk (0x7UL << RADIO_TXADDRESS_TXADDRESS_Pos) /*!< Bit mask of TXADDRESS field. */
-
-/* Register: RADIO_RXADDRESSES */
-/* Description: Receive address select */
-
-/* Bit 7 : Enable or disable reception on logical address 7. */
-#define RADIO_RXADDRESSES_ADDR7_Pos (7UL) /*!< Position of ADDR7 field. */
-#define RADIO_RXADDRESSES_ADDR7_Msk (0x1UL << RADIO_RXADDRESSES_ADDR7_Pos) /*!< Bit mask of ADDR7 field. */
-#define RADIO_RXADDRESSES_ADDR7_Disabled (0UL) /*!< Disable */
-#define RADIO_RXADDRESSES_ADDR7_Enabled (1UL) /*!< Enable */
-
-/* Bit 6 : Enable or disable reception on logical address 6. */
-#define RADIO_RXADDRESSES_ADDR6_Pos (6UL) /*!< Position of ADDR6 field. */
-#define RADIO_RXADDRESSES_ADDR6_Msk (0x1UL << RADIO_RXADDRESSES_ADDR6_Pos) /*!< Bit mask of ADDR6 field. */
-#define RADIO_RXADDRESSES_ADDR6_Disabled (0UL) /*!< Disable */
-#define RADIO_RXADDRESSES_ADDR6_Enabled (1UL) /*!< Enable */
-
-/* Bit 5 : Enable or disable reception on logical address 5. */
-#define RADIO_RXADDRESSES_ADDR5_Pos (5UL) /*!< Position of ADDR5 field. */
-#define RADIO_RXADDRESSES_ADDR5_Msk (0x1UL << RADIO_RXADDRESSES_ADDR5_Pos) /*!< Bit mask of ADDR5 field. */
-#define RADIO_RXADDRESSES_ADDR5_Disabled (0UL) /*!< Disable */
-#define RADIO_RXADDRESSES_ADDR5_Enabled (1UL) /*!< Enable */
-
-/* Bit 4 : Enable or disable reception on logical address 4. */
-#define RADIO_RXADDRESSES_ADDR4_Pos (4UL) /*!< Position of ADDR4 field. */
-#define RADIO_RXADDRESSES_ADDR4_Msk (0x1UL << RADIO_RXADDRESSES_ADDR4_Pos) /*!< Bit mask of ADDR4 field. */
-#define RADIO_RXADDRESSES_ADDR4_Disabled (0UL) /*!< Disable */
-#define RADIO_RXADDRESSES_ADDR4_Enabled (1UL) /*!< Enable */
-
-/* Bit 3 : Enable or disable reception on logical address 3. */
-#define RADIO_RXADDRESSES_ADDR3_Pos (3UL) /*!< Position of ADDR3 field. */
-#define RADIO_RXADDRESSES_ADDR3_Msk (0x1UL << RADIO_RXADDRESSES_ADDR3_Pos) /*!< Bit mask of ADDR3 field. */
-#define RADIO_RXADDRESSES_ADDR3_Disabled (0UL) /*!< Disable */
-#define RADIO_RXADDRESSES_ADDR3_Enabled (1UL) /*!< Enable */
-
-/* Bit 2 : Enable or disable reception on logical address 2. */
-#define RADIO_RXADDRESSES_ADDR2_Pos (2UL) /*!< Position of ADDR2 field. */
-#define RADIO_RXADDRESSES_ADDR2_Msk (0x1UL << RADIO_RXADDRESSES_ADDR2_Pos) /*!< Bit mask of ADDR2 field. */
-#define RADIO_RXADDRESSES_ADDR2_Disabled (0UL) /*!< Disable */
-#define RADIO_RXADDRESSES_ADDR2_Enabled (1UL) /*!< Enable */
-
-/* Bit 1 : Enable or disable reception on logical address 1. */
-#define RADIO_RXADDRESSES_ADDR1_Pos (1UL) /*!< Position of ADDR1 field. */
-#define RADIO_RXADDRESSES_ADDR1_Msk (0x1UL << RADIO_RXADDRESSES_ADDR1_Pos) /*!< Bit mask of ADDR1 field. */
-#define RADIO_RXADDRESSES_ADDR1_Disabled (0UL) /*!< Disable */
-#define RADIO_RXADDRESSES_ADDR1_Enabled (1UL) /*!< Enable */
-
-/* Bit 0 : Enable or disable reception on logical address 0. */
-#define RADIO_RXADDRESSES_ADDR0_Pos (0UL) /*!< Position of ADDR0 field. */
-#define RADIO_RXADDRESSES_ADDR0_Msk (0x1UL << RADIO_RXADDRESSES_ADDR0_Pos) /*!< Bit mask of ADDR0 field. */
-#define RADIO_RXADDRESSES_ADDR0_Disabled (0UL) /*!< Disable */
-#define RADIO_RXADDRESSES_ADDR0_Enabled (1UL) /*!< Enable */
-
-/* Register: RADIO_CRCCNF */
-/* Description: CRC configuration */
-
-/* Bit 8 : Include or exclude packet address field out of CRC calculation. */
-#define RADIO_CRCCNF_SKIPADDR_Pos (8UL) /*!< Position of SKIPADDR field. */
-#define RADIO_CRCCNF_SKIPADDR_Msk (0x1UL << RADIO_CRCCNF_SKIPADDR_Pos) /*!< Bit mask of SKIPADDR field. */
-#define RADIO_CRCCNF_SKIPADDR_Include (0UL) /*!< CRC calculation includes address field */
-#define RADIO_CRCCNF_SKIPADDR_Skip (1UL) /*!< CRC calculation does not include address field. The CRC calculation will start at the first byte after the address. */
-
-/* Bits 1..0 : CRC length in number of bytes. */
-#define RADIO_CRCCNF_LEN_Pos (0UL) /*!< Position of LEN field. */
-#define RADIO_CRCCNF_LEN_Msk (0x3UL << RADIO_CRCCNF_LEN_Pos) /*!< Bit mask of LEN field. */
-#define RADIO_CRCCNF_LEN_Disabled (0UL) /*!< CRC length is zero and CRC calculation is disabled */
-#define RADIO_CRCCNF_LEN_One (1UL) /*!< CRC length is one byte and CRC calculation is enabled */
-#define RADIO_CRCCNF_LEN_Two (2UL) /*!< CRC length is two bytes and CRC calculation is enabled */
-#define RADIO_CRCCNF_LEN_Three (3UL) /*!< CRC length is three bytes and CRC calculation is enabled */
-
-/* Register: RADIO_CRCPOLY */
-/* Description: CRC polynomial */
-
-/* Bits 23..0 : CRC polynomial */
-#define RADIO_CRCPOLY_CRCPOLY_Pos (0UL) /*!< Position of CRCPOLY field. */
-#define RADIO_CRCPOLY_CRCPOLY_Msk (0xFFFFFFUL << RADIO_CRCPOLY_CRCPOLY_Pos) /*!< Bit mask of CRCPOLY field. */
-
-/* Register: RADIO_CRCINIT */
-/* Description: CRC initial value */
-
-/* Bits 23..0 : CRC initial value */
-#define RADIO_CRCINIT_CRCINIT_Pos (0UL) /*!< Position of CRCINIT field. */
-#define RADIO_CRCINIT_CRCINIT_Msk (0xFFFFFFUL << RADIO_CRCINIT_CRCINIT_Pos) /*!< Bit mask of CRCINIT field. */
-
-/* Register: RADIO_TIFS */
-/* Description: Inter Frame Spacing in us */
-
-/* Bits 7..0 : Inter Frame Spacing in us */
-#define RADIO_TIFS_TIFS_Pos (0UL) /*!< Position of TIFS field. */
-#define RADIO_TIFS_TIFS_Msk (0xFFUL << RADIO_TIFS_TIFS_Pos) /*!< Bit mask of TIFS field. */
-
-/* Register: RADIO_RSSISAMPLE */
-/* Description: RSSI sample */
-
-/* Bits 6..0 : RSSI sample */
-#define RADIO_RSSISAMPLE_RSSISAMPLE_Pos (0UL) /*!< Position of RSSISAMPLE field. */
-#define RADIO_RSSISAMPLE_RSSISAMPLE_Msk (0x7FUL << RADIO_RSSISAMPLE_RSSISAMPLE_Pos) /*!< Bit mask of RSSISAMPLE field. */
-
-/* Register: RADIO_STATE */
-/* Description: Current radio state */
-
-/* Bits 3..0 : Current radio state */
-#define RADIO_STATE_STATE_Pos (0UL) /*!< Position of STATE field. */
-#define RADIO_STATE_STATE_Msk (0xFUL << RADIO_STATE_STATE_Pos) /*!< Bit mask of STATE field. */
-#define RADIO_STATE_STATE_Disabled (0UL) /*!< RADIO is in the Disabled state */
-#define RADIO_STATE_STATE_RxRu (1UL) /*!< RADIO is in the RXRU state */
-#define RADIO_STATE_STATE_RxIdle (2UL) /*!< RADIO is in the RXIDLE state */
-#define RADIO_STATE_STATE_Rx (3UL) /*!< RADIO is in the RX state */
-#define RADIO_STATE_STATE_RxDisable (4UL) /*!< RADIO is in the RXDISABLED state */
-#define RADIO_STATE_STATE_TxRu (9UL) /*!< RADIO is in the TXRU state */
-#define RADIO_STATE_STATE_TxIdle (10UL) /*!< RADIO is in the TXIDLE state */
-#define RADIO_STATE_STATE_Tx (11UL) /*!< RADIO is in the TX state */
-#define RADIO_STATE_STATE_TxDisable (12UL) /*!< RADIO is in the TXDISABLED state */
-
-/* Register: RADIO_DATAWHITEIV */
-/* Description: Data whitening initial value */
-
-/* Bits 6..0 : Data whitening initial value. Bit 6 is hard-wired to '1', writing '0' to it has no effect, and it will always be read back and used by the device as '1'. */
-#define RADIO_DATAWHITEIV_DATAWHITEIV_Pos (0UL) /*!< Position of DATAWHITEIV field. */
-#define RADIO_DATAWHITEIV_DATAWHITEIV_Msk (0x7FUL << RADIO_DATAWHITEIV_DATAWHITEIV_Pos) /*!< Bit mask of DATAWHITEIV field. */
-
-/* Register: RADIO_BCC */
-/* Description: Bit counter compare */
-
-/* Bits 31..0 : Bit counter compare */
-#define RADIO_BCC_BCC_Pos (0UL) /*!< Position of BCC field. */
-#define RADIO_BCC_BCC_Msk (0xFFFFFFFFUL << RADIO_BCC_BCC_Pos) /*!< Bit mask of BCC field. */
-
-/* Register: RADIO_DAB */
-/* Description: Description collection[0]:  Device address base segment 0 */
-
-/* Bits 31..0 : Device address base segment 0 */
-#define RADIO_DAB_DAB_Pos (0UL) /*!< Position of DAB field. */
-#define RADIO_DAB_DAB_Msk (0xFFFFFFFFUL << RADIO_DAB_DAB_Pos) /*!< Bit mask of DAB field. */
-
-/* Register: RADIO_DAP */
-/* Description: Description collection[0]:  Device address prefix 0 */
-
-/* Bits 15..0 : Device address prefix 0 */
-#define RADIO_DAP_DAP_Pos (0UL) /*!< Position of DAP field. */
-#define RADIO_DAP_DAP_Msk (0xFFFFUL << RADIO_DAP_DAP_Pos) /*!< Bit mask of DAP field. */
-
-/* Register: RADIO_DACNF */
-/* Description: Device address match configuration */
-
-/* Bit 15 : TxAdd for device address 7 */
-#define RADIO_DACNF_TXADD7_Pos (15UL) /*!< Position of TXADD7 field. */
-#define RADIO_DACNF_TXADD7_Msk (0x1UL << RADIO_DACNF_TXADD7_Pos) /*!< Bit mask of TXADD7 field. */
-
-/* Bit 14 : TxAdd for device address 6 */
-#define RADIO_DACNF_TXADD6_Pos (14UL) /*!< Position of TXADD6 field. */
-#define RADIO_DACNF_TXADD6_Msk (0x1UL << RADIO_DACNF_TXADD6_Pos) /*!< Bit mask of TXADD6 field. */
-
-/* Bit 13 : TxAdd for device address 5 */
-#define RADIO_DACNF_TXADD5_Pos (13UL) /*!< Position of TXADD5 field. */
-#define RADIO_DACNF_TXADD5_Msk (0x1UL << RADIO_DACNF_TXADD5_Pos) /*!< Bit mask of TXADD5 field. */
-
-/* Bit 12 : TxAdd for device address 4 */
-#define RADIO_DACNF_TXADD4_Pos (12UL) /*!< Position of TXADD4 field. */
-#define RADIO_DACNF_TXADD4_Msk (0x1UL << RADIO_DACNF_TXADD4_Pos) /*!< Bit mask of TXADD4 field. */
-
-/* Bit 11 : TxAdd for device address 3 */
-#define RADIO_DACNF_TXADD3_Pos (11UL) /*!< Position of TXADD3 field. */
-#define RADIO_DACNF_TXADD3_Msk (0x1UL << RADIO_DACNF_TXADD3_Pos) /*!< Bit mask of TXADD3 field. */
-
-/* Bit 10 : TxAdd for device address 2 */
-#define RADIO_DACNF_TXADD2_Pos (10UL) /*!< Position of TXADD2 field. */
-#define RADIO_DACNF_TXADD2_Msk (0x1UL << RADIO_DACNF_TXADD2_Pos) /*!< Bit mask of TXADD2 field. */
-
-/* Bit 9 : TxAdd for device address 1 */
-#define RADIO_DACNF_TXADD1_Pos (9UL) /*!< Position of TXADD1 field. */
-#define RADIO_DACNF_TXADD1_Msk (0x1UL << RADIO_DACNF_TXADD1_Pos) /*!< Bit mask of TXADD1 field. */
-
-/* Bit 8 : TxAdd for device address 0 */
-#define RADIO_DACNF_TXADD0_Pos (8UL) /*!< Position of TXADD0 field. */
-#define RADIO_DACNF_TXADD0_Msk (0x1UL << RADIO_DACNF_TXADD0_Pos) /*!< Bit mask of TXADD0 field. */
-
-/* Bit 7 : Enable or disable device address matching using device address 7 */
-#define RADIO_DACNF_ENA7_Pos (7UL) /*!< Position of ENA7 field. */
-#define RADIO_DACNF_ENA7_Msk (0x1UL << RADIO_DACNF_ENA7_Pos) /*!< Bit mask of ENA7 field. */
-#define RADIO_DACNF_ENA7_Disabled (0UL) /*!< Disabled */
-#define RADIO_DACNF_ENA7_Enabled (1UL) /*!< Enabled */
-
-/* Bit 6 : Enable or disable device address matching using device address 6 */
-#define RADIO_DACNF_ENA6_Pos (6UL) /*!< Position of ENA6 field. */
-#define RADIO_DACNF_ENA6_Msk (0x1UL << RADIO_DACNF_ENA6_Pos) /*!< Bit mask of ENA6 field. */
-#define RADIO_DACNF_ENA6_Disabled (0UL) /*!< Disabled */
-#define RADIO_DACNF_ENA6_Enabled (1UL) /*!< Enabled */
-
-/* Bit 5 : Enable or disable device address matching using device address 5 */
-#define RADIO_DACNF_ENA5_Pos (5UL) /*!< Position of ENA5 field. */
-#define RADIO_DACNF_ENA5_Msk (0x1UL << RADIO_DACNF_ENA5_Pos) /*!< Bit mask of ENA5 field. */
-#define RADIO_DACNF_ENA5_Disabled (0UL) /*!< Disabled */
-#define RADIO_DACNF_ENA5_Enabled (1UL) /*!< Enabled */
-
-/* Bit 4 : Enable or disable device address matching using device address 4 */
-#define RADIO_DACNF_ENA4_Pos (4UL) /*!< Position of ENA4 field. */
-#define RADIO_DACNF_ENA4_Msk (0x1UL << RADIO_DACNF_ENA4_Pos) /*!< Bit mask of ENA4 field. */
-#define RADIO_DACNF_ENA4_Disabled (0UL) /*!< Disabled */
-#define RADIO_DACNF_ENA4_Enabled (1UL) /*!< Enabled */
-
-/* Bit 3 : Enable or disable device address matching using device address 3 */
-#define RADIO_DACNF_ENA3_Pos (3UL) /*!< Position of ENA3 field. */
-#define RADIO_DACNF_ENA3_Msk (0x1UL << RADIO_DACNF_ENA3_Pos) /*!< Bit mask of ENA3 field. */
-#define RADIO_DACNF_ENA3_Disabled (0UL) /*!< Disabled */
-#define RADIO_DACNF_ENA3_Enabled (1UL) /*!< Enabled */
-
-/* Bit 2 : Enable or disable device address matching using device address 2 */
-#define RADIO_DACNF_ENA2_Pos (2UL) /*!< Position of ENA2 field. */
-#define RADIO_DACNF_ENA2_Msk (0x1UL << RADIO_DACNF_ENA2_Pos) /*!< Bit mask of ENA2 field. */
-#define RADIO_DACNF_ENA2_Disabled (0UL) /*!< Disabled */
-#define RADIO_DACNF_ENA2_Enabled (1UL) /*!< Enabled */
-
-/* Bit 1 : Enable or disable device address matching using device address 1 */
-#define RADIO_DACNF_ENA1_Pos (1UL) /*!< Position of ENA1 field. */
-#define RADIO_DACNF_ENA1_Msk (0x1UL << RADIO_DACNF_ENA1_Pos) /*!< Bit mask of ENA1 field. */
-#define RADIO_DACNF_ENA1_Disabled (0UL) /*!< Disabled */
-#define RADIO_DACNF_ENA1_Enabled (1UL) /*!< Enabled */
-
-/* Bit 0 : Enable or disable device address matching using device address 0 */
-#define RADIO_DACNF_ENA0_Pos (0UL) /*!< Position of ENA0 field. */
-#define RADIO_DACNF_ENA0_Msk (0x1UL << RADIO_DACNF_ENA0_Pos) /*!< Bit mask of ENA0 field. */
-#define RADIO_DACNF_ENA0_Disabled (0UL) /*!< Disabled */
-#define RADIO_DACNF_ENA0_Enabled (1UL) /*!< Enabled */
-
-/* Register: RADIO_MODECNF0 */
-/* Description: Radio mode configuration register 0 */
-
-/* Bits 9..8 : Default TX value */
-#define RADIO_MODECNF0_DTX_Pos (8UL) /*!< Position of DTX field. */
-#define RADIO_MODECNF0_DTX_Msk (0x3UL << RADIO_MODECNF0_DTX_Pos) /*!< Bit mask of DTX field. */
-#define RADIO_MODECNF0_DTX_B1 (0UL) /*!< Transmit '1' */
-#define RADIO_MODECNF0_DTX_B0 (1UL) /*!< Transmit '0' */
-#define RADIO_MODECNF0_DTX_Center (2UL) /*!< Transmit center frequency */
-
-/* Bit 0 : Radio ramp-up time */
-#define RADIO_MODECNF0_RU_Pos (0UL) /*!< Position of RU field. */
-#define RADIO_MODECNF0_RU_Msk (0x1UL << RADIO_MODECNF0_RU_Pos) /*!< Bit mask of RU field. */
-#define RADIO_MODECNF0_RU_Default (0UL) /*!< Default ramp-up time (tRXEN), compatible with firmware written for nRF51 */
-#define RADIO_MODECNF0_RU_Fast (1UL) /*!< Fast ramp-up (tRXEN,FAST), see electrical specification for more information */
-
-/* Register: RADIO_POWER */
-/* Description: Peripheral power control */
-
-/* Bit 0 : Peripheral power control. The peripheral and its registers will be reset to its initial state by switching the peripheral off and then back on again. */
-#define RADIO_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
-#define RADIO_POWER_POWER_Msk (0x1UL << RADIO_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
-#define RADIO_POWER_POWER_Disabled (0UL) /*!< Peripheral is powered off */
-#define RADIO_POWER_POWER_Enabled (1UL) /*!< Peripheral is powered on */
-
-
-/* Peripheral: RNG */
-/* Description: Random Number Generator */
-
-/* Register: RNG_SHORTS */
-/* Description: Shortcut register */
-
-/* Bit 0 : Shortcut between VALRDY event and STOP task */
-#define RNG_SHORTS_VALRDY_STOP_Pos (0UL) /*!< Position of VALRDY_STOP field. */
-#define RNG_SHORTS_VALRDY_STOP_Msk (0x1UL << RNG_SHORTS_VALRDY_STOP_Pos) /*!< Bit mask of VALRDY_STOP field. */
-#define RNG_SHORTS_VALRDY_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define RNG_SHORTS_VALRDY_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Register: RNG_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 0 : Write '1' to Enable interrupt for VALRDY event */
-#define RNG_INTENSET_VALRDY_Pos (0UL) /*!< Position of VALRDY field. */
-#define RNG_INTENSET_VALRDY_Msk (0x1UL << RNG_INTENSET_VALRDY_Pos) /*!< Bit mask of VALRDY field. */
-#define RNG_INTENSET_VALRDY_Disabled (0UL) /*!< Read: Disabled */
-#define RNG_INTENSET_VALRDY_Enabled (1UL) /*!< Read: Enabled */
-#define RNG_INTENSET_VALRDY_Set (1UL) /*!< Enable */
-
-/* Register: RNG_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 0 : Write '1' to Disable interrupt for VALRDY event */
-#define RNG_INTENCLR_VALRDY_Pos (0UL) /*!< Position of VALRDY field. */
-#define RNG_INTENCLR_VALRDY_Msk (0x1UL << RNG_INTENCLR_VALRDY_Pos) /*!< Bit mask of VALRDY field. */
-#define RNG_INTENCLR_VALRDY_Disabled (0UL) /*!< Read: Disabled */
-#define RNG_INTENCLR_VALRDY_Enabled (1UL) /*!< Read: Enabled */
-#define RNG_INTENCLR_VALRDY_Clear (1UL) /*!< Disable */
-
-/* Register: RNG_CONFIG */
-/* Description: Configuration register */
-
-/* Bit 0 : Bias correction */
-#define RNG_CONFIG_DERCEN_Pos (0UL) /*!< Position of DERCEN field. */
-#define RNG_CONFIG_DERCEN_Msk (0x1UL << RNG_CONFIG_DERCEN_Pos) /*!< Bit mask of DERCEN field. */
-#define RNG_CONFIG_DERCEN_Disabled (0UL) /*!< Disabled */
-#define RNG_CONFIG_DERCEN_Enabled (1UL) /*!< Enabled */
-
-/* Register: RNG_VALUE */
-/* Description: Output random number */
-
-/* Bits 7..0 : Generated random number */
-#define RNG_VALUE_VALUE_Pos (0UL) /*!< Position of VALUE field. */
-#define RNG_VALUE_VALUE_Msk (0xFFUL << RNG_VALUE_VALUE_Pos) /*!< Bit mask of VALUE field. */
-
-
-/* Peripheral: RTC */
-/* Description: Real time counter 0 */
-
-/* Register: RTC_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 19 : Write '1' to Enable interrupt for COMPARE[3] event */
-#define RTC_INTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
-#define RTC_INTENSET_COMPARE3_Msk (0x1UL << RTC_INTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
-#define RTC_INTENSET_COMPARE3_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_INTENSET_COMPARE3_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_INTENSET_COMPARE3_Set (1UL) /*!< Enable */
-
-/* Bit 18 : Write '1' to Enable interrupt for COMPARE[2] event */
-#define RTC_INTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
-#define RTC_INTENSET_COMPARE2_Msk (0x1UL << RTC_INTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
-#define RTC_INTENSET_COMPARE2_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_INTENSET_COMPARE2_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_INTENSET_COMPARE2_Set (1UL) /*!< Enable */
-
-/* Bit 17 : Write '1' to Enable interrupt for COMPARE[1] event */
-#define RTC_INTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
-#define RTC_INTENSET_COMPARE1_Msk (0x1UL << RTC_INTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
-#define RTC_INTENSET_COMPARE1_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_INTENSET_COMPARE1_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_INTENSET_COMPARE1_Set (1UL) /*!< Enable */
-
-/* Bit 16 : Write '1' to Enable interrupt for COMPARE[0] event */
-#define RTC_INTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
-#define RTC_INTENSET_COMPARE0_Msk (0x1UL << RTC_INTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
-#define RTC_INTENSET_COMPARE0_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_INTENSET_COMPARE0_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_INTENSET_COMPARE0_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for OVRFLW event */
-#define RTC_INTENSET_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
-#define RTC_INTENSET_OVRFLW_Msk (0x1UL << RTC_INTENSET_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
-#define RTC_INTENSET_OVRFLW_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_INTENSET_OVRFLW_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_INTENSET_OVRFLW_Set (1UL) /*!< Enable */
-
-/* Bit 0 : Write '1' to Enable interrupt for TICK event */
-#define RTC_INTENSET_TICK_Pos (0UL) /*!< Position of TICK field. */
-#define RTC_INTENSET_TICK_Msk (0x1UL << RTC_INTENSET_TICK_Pos) /*!< Bit mask of TICK field. */
-#define RTC_INTENSET_TICK_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_INTENSET_TICK_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_INTENSET_TICK_Set (1UL) /*!< Enable */
-
-/* Register: RTC_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 19 : Write '1' to Disable interrupt for COMPARE[3] event */
-#define RTC_INTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
-#define RTC_INTENCLR_COMPARE3_Msk (0x1UL << RTC_INTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
-#define RTC_INTENCLR_COMPARE3_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_INTENCLR_COMPARE3_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_INTENCLR_COMPARE3_Clear (1UL) /*!< Disable */
-
-/* Bit 18 : Write '1' to Disable interrupt for COMPARE[2] event */
-#define RTC_INTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
-#define RTC_INTENCLR_COMPARE2_Msk (0x1UL << RTC_INTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
-#define RTC_INTENCLR_COMPARE2_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_INTENCLR_COMPARE2_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_INTENCLR_COMPARE2_Clear (1UL) /*!< Disable */
-
-/* Bit 17 : Write '1' to Disable interrupt for COMPARE[1] event */
-#define RTC_INTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
-#define RTC_INTENCLR_COMPARE1_Msk (0x1UL << RTC_INTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
-#define RTC_INTENCLR_COMPARE1_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_INTENCLR_COMPARE1_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_INTENCLR_COMPARE1_Clear (1UL) /*!< Disable */
-
-/* Bit 16 : Write '1' to Disable interrupt for COMPARE[0] event */
-#define RTC_INTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
-#define RTC_INTENCLR_COMPARE0_Msk (0x1UL << RTC_INTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
-#define RTC_INTENCLR_COMPARE0_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_INTENCLR_COMPARE0_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_INTENCLR_COMPARE0_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for OVRFLW event */
-#define RTC_INTENCLR_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
-#define RTC_INTENCLR_OVRFLW_Msk (0x1UL << RTC_INTENCLR_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
-#define RTC_INTENCLR_OVRFLW_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_INTENCLR_OVRFLW_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_INTENCLR_OVRFLW_Clear (1UL) /*!< Disable */
-
-/* Bit 0 : Write '1' to Disable interrupt for TICK event */
-#define RTC_INTENCLR_TICK_Pos (0UL) /*!< Position of TICK field. */
-#define RTC_INTENCLR_TICK_Msk (0x1UL << RTC_INTENCLR_TICK_Pos) /*!< Bit mask of TICK field. */
-#define RTC_INTENCLR_TICK_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_INTENCLR_TICK_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_INTENCLR_TICK_Clear (1UL) /*!< Disable */
-
-/* Register: RTC_EVTEN */
-/* Description: Enable or disable event routing */
-
-/* Bit 19 : Enable or disable event routing for COMPARE[3] event */
-#define RTC_EVTEN_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
-#define RTC_EVTEN_COMPARE3_Msk (0x1UL << RTC_EVTEN_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
-#define RTC_EVTEN_COMPARE3_Disabled (0UL) /*!< Disable */
-#define RTC_EVTEN_COMPARE3_Enabled (1UL) /*!< Enable */
-
-/* Bit 18 : Enable or disable event routing for COMPARE[2] event */
-#define RTC_EVTEN_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
-#define RTC_EVTEN_COMPARE2_Msk (0x1UL << RTC_EVTEN_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
-#define RTC_EVTEN_COMPARE2_Disabled (0UL) /*!< Disable */
-#define RTC_EVTEN_COMPARE2_Enabled (1UL) /*!< Enable */
-
-/* Bit 17 : Enable or disable event routing for COMPARE[1] event */
-#define RTC_EVTEN_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
-#define RTC_EVTEN_COMPARE1_Msk (0x1UL << RTC_EVTEN_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
-#define RTC_EVTEN_COMPARE1_Disabled (0UL) /*!< Disable */
-#define RTC_EVTEN_COMPARE1_Enabled (1UL) /*!< Enable */
-
-/* Bit 16 : Enable or disable event routing for COMPARE[0] event */
-#define RTC_EVTEN_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
-#define RTC_EVTEN_COMPARE0_Msk (0x1UL << RTC_EVTEN_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
-#define RTC_EVTEN_COMPARE0_Disabled (0UL) /*!< Disable */
-#define RTC_EVTEN_COMPARE0_Enabled (1UL) /*!< Enable */
-
-/* Bit 1 : Enable or disable event routing for OVRFLW event */
-#define RTC_EVTEN_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
-#define RTC_EVTEN_OVRFLW_Msk (0x1UL << RTC_EVTEN_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
-#define RTC_EVTEN_OVRFLW_Disabled (0UL) /*!< Disable */
-#define RTC_EVTEN_OVRFLW_Enabled (1UL) /*!< Enable */
-
-/* Bit 0 : Enable or disable event routing for TICK event */
-#define RTC_EVTEN_TICK_Pos (0UL) /*!< Position of TICK field. */
-#define RTC_EVTEN_TICK_Msk (0x1UL << RTC_EVTEN_TICK_Pos) /*!< Bit mask of TICK field. */
-#define RTC_EVTEN_TICK_Disabled (0UL) /*!< Disable */
-#define RTC_EVTEN_TICK_Enabled (1UL) /*!< Enable */
-
-/* Register: RTC_EVTENSET */
-/* Description: Enable event routing */
-
-/* Bit 19 : Write '1' to Enable event routing for COMPARE[3] event */
-#define RTC_EVTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
-#define RTC_EVTENSET_COMPARE3_Msk (0x1UL << RTC_EVTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
-#define RTC_EVTENSET_COMPARE3_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_EVTENSET_COMPARE3_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_EVTENSET_COMPARE3_Set (1UL) /*!< Enable */
-
-/* Bit 18 : Write '1' to Enable event routing for COMPARE[2] event */
-#define RTC_EVTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
-#define RTC_EVTENSET_COMPARE2_Msk (0x1UL << RTC_EVTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
-#define RTC_EVTENSET_COMPARE2_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_EVTENSET_COMPARE2_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_EVTENSET_COMPARE2_Set (1UL) /*!< Enable */
-
-/* Bit 17 : Write '1' to Enable event routing for COMPARE[1] event */
-#define RTC_EVTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
-#define RTC_EVTENSET_COMPARE1_Msk (0x1UL << RTC_EVTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
-#define RTC_EVTENSET_COMPARE1_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_EVTENSET_COMPARE1_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_EVTENSET_COMPARE1_Set (1UL) /*!< Enable */
-
-/* Bit 16 : Write '1' to Enable event routing for COMPARE[0] event */
-#define RTC_EVTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
-#define RTC_EVTENSET_COMPARE0_Msk (0x1UL << RTC_EVTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
-#define RTC_EVTENSET_COMPARE0_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_EVTENSET_COMPARE0_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_EVTENSET_COMPARE0_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable event routing for OVRFLW event */
-#define RTC_EVTENSET_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
-#define RTC_EVTENSET_OVRFLW_Msk (0x1UL << RTC_EVTENSET_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
-#define RTC_EVTENSET_OVRFLW_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_EVTENSET_OVRFLW_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_EVTENSET_OVRFLW_Set (1UL) /*!< Enable */
-
-/* Bit 0 : Write '1' to Enable event routing for TICK event */
-#define RTC_EVTENSET_TICK_Pos (0UL) /*!< Position of TICK field. */
-#define RTC_EVTENSET_TICK_Msk (0x1UL << RTC_EVTENSET_TICK_Pos) /*!< Bit mask of TICK field. */
-#define RTC_EVTENSET_TICK_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_EVTENSET_TICK_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_EVTENSET_TICK_Set (1UL) /*!< Enable */
-
-/* Register: RTC_EVTENCLR */
-/* Description: Disable event routing */
-
-/* Bit 19 : Write '1' to Disable event routing for COMPARE[3] event */
-#define RTC_EVTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
-#define RTC_EVTENCLR_COMPARE3_Msk (0x1UL << RTC_EVTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
-#define RTC_EVTENCLR_COMPARE3_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_EVTENCLR_COMPARE3_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_EVTENCLR_COMPARE3_Clear (1UL) /*!< Disable */
-
-/* Bit 18 : Write '1' to Disable event routing for COMPARE[2] event */
-#define RTC_EVTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
-#define RTC_EVTENCLR_COMPARE2_Msk (0x1UL << RTC_EVTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
-#define RTC_EVTENCLR_COMPARE2_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_EVTENCLR_COMPARE2_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_EVTENCLR_COMPARE2_Clear (1UL) /*!< Disable */
-
-/* Bit 17 : Write '1' to Disable event routing for COMPARE[1] event */
-#define RTC_EVTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
-#define RTC_EVTENCLR_COMPARE1_Msk (0x1UL << RTC_EVTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
-#define RTC_EVTENCLR_COMPARE1_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_EVTENCLR_COMPARE1_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_EVTENCLR_COMPARE1_Clear (1UL) /*!< Disable */
-
-/* Bit 16 : Write '1' to Disable event routing for COMPARE[0] event */
-#define RTC_EVTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
-#define RTC_EVTENCLR_COMPARE0_Msk (0x1UL << RTC_EVTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
-#define RTC_EVTENCLR_COMPARE0_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_EVTENCLR_COMPARE0_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_EVTENCLR_COMPARE0_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable event routing for OVRFLW event */
-#define RTC_EVTENCLR_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
-#define RTC_EVTENCLR_OVRFLW_Msk (0x1UL << RTC_EVTENCLR_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
-#define RTC_EVTENCLR_OVRFLW_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_EVTENCLR_OVRFLW_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_EVTENCLR_OVRFLW_Clear (1UL) /*!< Disable */
-
-/* Bit 0 : Write '1' to Disable event routing for TICK event */
-#define RTC_EVTENCLR_TICK_Pos (0UL) /*!< Position of TICK field. */
-#define RTC_EVTENCLR_TICK_Msk (0x1UL << RTC_EVTENCLR_TICK_Pos) /*!< Bit mask of TICK field. */
-#define RTC_EVTENCLR_TICK_Disabled (0UL) /*!< Read: Disabled */
-#define RTC_EVTENCLR_TICK_Enabled (1UL) /*!< Read: Enabled */
-#define RTC_EVTENCLR_TICK_Clear (1UL) /*!< Disable */
-
-/* Register: RTC_COUNTER */
-/* Description: Current COUNTER value */
-
-/* Bits 23..0 : Counter value */
-#define RTC_COUNTER_COUNTER_Pos (0UL) /*!< Position of COUNTER field. */
-#define RTC_COUNTER_COUNTER_Msk (0xFFFFFFUL << RTC_COUNTER_COUNTER_Pos) /*!< Bit mask of COUNTER field. */
-
-/* Register: RTC_PRESCALER */
-/* Description: 12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Must be written when RTC is stopped */
-
-/* Bits 11..0 : Prescaler value */
-#define RTC_PRESCALER_PRESCALER_Pos (0UL) /*!< Position of PRESCALER field. */
-#define RTC_PRESCALER_PRESCALER_Msk (0xFFFUL << RTC_PRESCALER_PRESCALER_Pos) /*!< Bit mask of PRESCALER field. */
-
-/* Register: RTC_CC */
-/* Description: Description collection[0]:  Compare register 0 */
-
-/* Bits 23..0 : Compare value */
-#define RTC_CC_COMPARE_Pos (0UL) /*!< Position of COMPARE field. */
-#define RTC_CC_COMPARE_Msk (0xFFFFFFUL << RTC_CC_COMPARE_Pos) /*!< Bit mask of COMPARE field. */
-
-
-/* Peripheral: SAADC */
-/* Description: Analog to Digital Converter */
-
-/* Register: SAADC_INTEN */
-/* Description: Enable or disable interrupt */
-
-/* Bit 21 : Enable or disable interrupt for CH[7].LIMITL event */
-#define SAADC_INTEN_CH7LIMITL_Pos (21UL) /*!< Position of CH7LIMITL field. */
-#define SAADC_INTEN_CH7LIMITL_Msk (0x1UL << SAADC_INTEN_CH7LIMITL_Pos) /*!< Bit mask of CH7LIMITL field. */
-#define SAADC_INTEN_CH7LIMITL_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_CH7LIMITL_Enabled (1UL) /*!< Enable */
-
-/* Bit 20 : Enable or disable interrupt for CH[7].LIMITH event */
-#define SAADC_INTEN_CH7LIMITH_Pos (20UL) /*!< Position of CH7LIMITH field. */
-#define SAADC_INTEN_CH7LIMITH_Msk (0x1UL << SAADC_INTEN_CH7LIMITH_Pos) /*!< Bit mask of CH7LIMITH field. */
-#define SAADC_INTEN_CH7LIMITH_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_CH7LIMITH_Enabled (1UL) /*!< Enable */
-
-/* Bit 19 : Enable or disable interrupt for CH[6].LIMITL event */
-#define SAADC_INTEN_CH6LIMITL_Pos (19UL) /*!< Position of CH6LIMITL field. */
-#define SAADC_INTEN_CH6LIMITL_Msk (0x1UL << SAADC_INTEN_CH6LIMITL_Pos) /*!< Bit mask of CH6LIMITL field. */
-#define SAADC_INTEN_CH6LIMITL_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_CH6LIMITL_Enabled (1UL) /*!< Enable */
-
-/* Bit 18 : Enable or disable interrupt for CH[6].LIMITH event */
-#define SAADC_INTEN_CH6LIMITH_Pos (18UL) /*!< Position of CH6LIMITH field. */
-#define SAADC_INTEN_CH6LIMITH_Msk (0x1UL << SAADC_INTEN_CH6LIMITH_Pos) /*!< Bit mask of CH6LIMITH field. */
-#define SAADC_INTEN_CH6LIMITH_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_CH6LIMITH_Enabled (1UL) /*!< Enable */
-
-/* Bit 17 : Enable or disable interrupt for CH[5].LIMITL event */
-#define SAADC_INTEN_CH5LIMITL_Pos (17UL) /*!< Position of CH5LIMITL field. */
-#define SAADC_INTEN_CH5LIMITL_Msk (0x1UL << SAADC_INTEN_CH5LIMITL_Pos) /*!< Bit mask of CH5LIMITL field. */
-#define SAADC_INTEN_CH5LIMITL_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_CH5LIMITL_Enabled (1UL) /*!< Enable */
-
-/* Bit 16 : Enable or disable interrupt for CH[5].LIMITH event */
-#define SAADC_INTEN_CH5LIMITH_Pos (16UL) /*!< Position of CH5LIMITH field. */
-#define SAADC_INTEN_CH5LIMITH_Msk (0x1UL << SAADC_INTEN_CH5LIMITH_Pos) /*!< Bit mask of CH5LIMITH field. */
-#define SAADC_INTEN_CH5LIMITH_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_CH5LIMITH_Enabled (1UL) /*!< Enable */
-
-/* Bit 15 : Enable or disable interrupt for CH[4].LIMITL event */
-#define SAADC_INTEN_CH4LIMITL_Pos (15UL) /*!< Position of CH4LIMITL field. */
-#define SAADC_INTEN_CH4LIMITL_Msk (0x1UL << SAADC_INTEN_CH4LIMITL_Pos) /*!< Bit mask of CH4LIMITL field. */
-#define SAADC_INTEN_CH4LIMITL_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_CH4LIMITL_Enabled (1UL) /*!< Enable */
-
-/* Bit 14 : Enable or disable interrupt for CH[4].LIMITH event */
-#define SAADC_INTEN_CH4LIMITH_Pos (14UL) /*!< Position of CH4LIMITH field. */
-#define SAADC_INTEN_CH4LIMITH_Msk (0x1UL << SAADC_INTEN_CH4LIMITH_Pos) /*!< Bit mask of CH4LIMITH field. */
-#define SAADC_INTEN_CH4LIMITH_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_CH4LIMITH_Enabled (1UL) /*!< Enable */
-
-/* Bit 13 : Enable or disable interrupt for CH[3].LIMITL event */
-#define SAADC_INTEN_CH3LIMITL_Pos (13UL) /*!< Position of CH3LIMITL field. */
-#define SAADC_INTEN_CH3LIMITL_Msk (0x1UL << SAADC_INTEN_CH3LIMITL_Pos) /*!< Bit mask of CH3LIMITL field. */
-#define SAADC_INTEN_CH3LIMITL_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_CH3LIMITL_Enabled (1UL) /*!< Enable */
-
-/* Bit 12 : Enable or disable interrupt for CH[3].LIMITH event */
-#define SAADC_INTEN_CH3LIMITH_Pos (12UL) /*!< Position of CH3LIMITH field. */
-#define SAADC_INTEN_CH3LIMITH_Msk (0x1UL << SAADC_INTEN_CH3LIMITH_Pos) /*!< Bit mask of CH3LIMITH field. */
-#define SAADC_INTEN_CH3LIMITH_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_CH3LIMITH_Enabled (1UL) /*!< Enable */
-
-/* Bit 11 : Enable or disable interrupt for CH[2].LIMITL event */
-#define SAADC_INTEN_CH2LIMITL_Pos (11UL) /*!< Position of CH2LIMITL field. */
-#define SAADC_INTEN_CH2LIMITL_Msk (0x1UL << SAADC_INTEN_CH2LIMITL_Pos) /*!< Bit mask of CH2LIMITL field. */
-#define SAADC_INTEN_CH2LIMITL_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_CH2LIMITL_Enabled (1UL) /*!< Enable */
-
-/* Bit 10 : Enable or disable interrupt for CH[2].LIMITH event */
-#define SAADC_INTEN_CH2LIMITH_Pos (10UL) /*!< Position of CH2LIMITH field. */
-#define SAADC_INTEN_CH2LIMITH_Msk (0x1UL << SAADC_INTEN_CH2LIMITH_Pos) /*!< Bit mask of CH2LIMITH field. */
-#define SAADC_INTEN_CH2LIMITH_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_CH2LIMITH_Enabled (1UL) /*!< Enable */
-
-/* Bit 9 : Enable or disable interrupt for CH[1].LIMITL event */
-#define SAADC_INTEN_CH1LIMITL_Pos (9UL) /*!< Position of CH1LIMITL field. */
-#define SAADC_INTEN_CH1LIMITL_Msk (0x1UL << SAADC_INTEN_CH1LIMITL_Pos) /*!< Bit mask of CH1LIMITL field. */
-#define SAADC_INTEN_CH1LIMITL_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_CH1LIMITL_Enabled (1UL) /*!< Enable */
-
-/* Bit 8 : Enable or disable interrupt for CH[1].LIMITH event */
-#define SAADC_INTEN_CH1LIMITH_Pos (8UL) /*!< Position of CH1LIMITH field. */
-#define SAADC_INTEN_CH1LIMITH_Msk (0x1UL << SAADC_INTEN_CH1LIMITH_Pos) /*!< Bit mask of CH1LIMITH field. */
-#define SAADC_INTEN_CH1LIMITH_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_CH1LIMITH_Enabled (1UL) /*!< Enable */
-
-/* Bit 7 : Enable or disable interrupt for CH[0].LIMITL event */
-#define SAADC_INTEN_CH0LIMITL_Pos (7UL) /*!< Position of CH0LIMITL field. */
-#define SAADC_INTEN_CH0LIMITL_Msk (0x1UL << SAADC_INTEN_CH0LIMITL_Pos) /*!< Bit mask of CH0LIMITL field. */
-#define SAADC_INTEN_CH0LIMITL_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_CH0LIMITL_Enabled (1UL) /*!< Enable */
-
-/* Bit 6 : Enable or disable interrupt for CH[0].LIMITH event */
-#define SAADC_INTEN_CH0LIMITH_Pos (6UL) /*!< Position of CH0LIMITH field. */
-#define SAADC_INTEN_CH0LIMITH_Msk (0x1UL << SAADC_INTEN_CH0LIMITH_Pos) /*!< Bit mask of CH0LIMITH field. */
-#define SAADC_INTEN_CH0LIMITH_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_CH0LIMITH_Enabled (1UL) /*!< Enable */
-
-/* Bit 5 : Enable or disable interrupt for STOPPED event */
-#define SAADC_INTEN_STOPPED_Pos (5UL) /*!< Position of STOPPED field. */
-#define SAADC_INTEN_STOPPED_Msk (0x1UL << SAADC_INTEN_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define SAADC_INTEN_STOPPED_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_STOPPED_Enabled (1UL) /*!< Enable */
-
-/* Bit 4 : Enable or disable interrupt for CALIBRATEDONE event */
-#define SAADC_INTEN_CALIBRATEDONE_Pos (4UL) /*!< Position of CALIBRATEDONE field. */
-#define SAADC_INTEN_CALIBRATEDONE_Msk (0x1UL << SAADC_INTEN_CALIBRATEDONE_Pos) /*!< Bit mask of CALIBRATEDONE field. */
-#define SAADC_INTEN_CALIBRATEDONE_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_CALIBRATEDONE_Enabled (1UL) /*!< Enable */
-
-/* Bit 3 : Enable or disable interrupt for RESULTDONE event */
-#define SAADC_INTEN_RESULTDONE_Pos (3UL) /*!< Position of RESULTDONE field. */
-#define SAADC_INTEN_RESULTDONE_Msk (0x1UL << SAADC_INTEN_RESULTDONE_Pos) /*!< Bit mask of RESULTDONE field. */
-#define SAADC_INTEN_RESULTDONE_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_RESULTDONE_Enabled (1UL) /*!< Enable */
-
-/* Bit 2 : Enable or disable interrupt for DONE event */
-#define SAADC_INTEN_DONE_Pos (2UL) /*!< Position of DONE field. */
-#define SAADC_INTEN_DONE_Msk (0x1UL << SAADC_INTEN_DONE_Pos) /*!< Bit mask of DONE field. */
-#define SAADC_INTEN_DONE_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_DONE_Enabled (1UL) /*!< Enable */
-
-/* Bit 1 : Enable or disable interrupt for END event */
-#define SAADC_INTEN_END_Pos (1UL) /*!< Position of END field. */
-#define SAADC_INTEN_END_Msk (0x1UL << SAADC_INTEN_END_Pos) /*!< Bit mask of END field. */
-#define SAADC_INTEN_END_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_END_Enabled (1UL) /*!< Enable */
-
-/* Bit 0 : Enable or disable interrupt for STARTED event */
-#define SAADC_INTEN_STARTED_Pos (0UL) /*!< Position of STARTED field. */
-#define SAADC_INTEN_STARTED_Msk (0x1UL << SAADC_INTEN_STARTED_Pos) /*!< Bit mask of STARTED field. */
-#define SAADC_INTEN_STARTED_Disabled (0UL) /*!< Disable */
-#define SAADC_INTEN_STARTED_Enabled (1UL) /*!< Enable */
-
-/* Register: SAADC_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 21 : Write '1' to Enable interrupt for CH[7].LIMITL event */
-#define SAADC_INTENSET_CH7LIMITL_Pos (21UL) /*!< Position of CH7LIMITL field. */
-#define SAADC_INTENSET_CH7LIMITL_Msk (0x1UL << SAADC_INTENSET_CH7LIMITL_Pos) /*!< Bit mask of CH7LIMITL field. */
-#define SAADC_INTENSET_CH7LIMITL_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_CH7LIMITL_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_CH7LIMITL_Set (1UL) /*!< Enable */
-
-/* Bit 20 : Write '1' to Enable interrupt for CH[7].LIMITH event */
-#define SAADC_INTENSET_CH7LIMITH_Pos (20UL) /*!< Position of CH7LIMITH field. */
-#define SAADC_INTENSET_CH7LIMITH_Msk (0x1UL << SAADC_INTENSET_CH7LIMITH_Pos) /*!< Bit mask of CH7LIMITH field. */
-#define SAADC_INTENSET_CH7LIMITH_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_CH7LIMITH_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_CH7LIMITH_Set (1UL) /*!< Enable */
-
-/* Bit 19 : Write '1' to Enable interrupt for CH[6].LIMITL event */
-#define SAADC_INTENSET_CH6LIMITL_Pos (19UL) /*!< Position of CH6LIMITL field. */
-#define SAADC_INTENSET_CH6LIMITL_Msk (0x1UL << SAADC_INTENSET_CH6LIMITL_Pos) /*!< Bit mask of CH6LIMITL field. */
-#define SAADC_INTENSET_CH6LIMITL_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_CH6LIMITL_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_CH6LIMITL_Set (1UL) /*!< Enable */
-
-/* Bit 18 : Write '1' to Enable interrupt for CH[6].LIMITH event */
-#define SAADC_INTENSET_CH6LIMITH_Pos (18UL) /*!< Position of CH6LIMITH field. */
-#define SAADC_INTENSET_CH6LIMITH_Msk (0x1UL << SAADC_INTENSET_CH6LIMITH_Pos) /*!< Bit mask of CH6LIMITH field. */
-#define SAADC_INTENSET_CH6LIMITH_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_CH6LIMITH_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_CH6LIMITH_Set (1UL) /*!< Enable */
-
-/* Bit 17 : Write '1' to Enable interrupt for CH[5].LIMITL event */
-#define SAADC_INTENSET_CH5LIMITL_Pos (17UL) /*!< Position of CH5LIMITL field. */
-#define SAADC_INTENSET_CH5LIMITL_Msk (0x1UL << SAADC_INTENSET_CH5LIMITL_Pos) /*!< Bit mask of CH5LIMITL field. */
-#define SAADC_INTENSET_CH5LIMITL_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_CH5LIMITL_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_CH5LIMITL_Set (1UL) /*!< Enable */
-
-/* Bit 16 : Write '1' to Enable interrupt for CH[5].LIMITH event */
-#define SAADC_INTENSET_CH5LIMITH_Pos (16UL) /*!< Position of CH5LIMITH field. */
-#define SAADC_INTENSET_CH5LIMITH_Msk (0x1UL << SAADC_INTENSET_CH5LIMITH_Pos) /*!< Bit mask of CH5LIMITH field. */
-#define SAADC_INTENSET_CH5LIMITH_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_CH5LIMITH_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_CH5LIMITH_Set (1UL) /*!< Enable */
-
-/* Bit 15 : Write '1' to Enable interrupt for CH[4].LIMITL event */
-#define SAADC_INTENSET_CH4LIMITL_Pos (15UL) /*!< Position of CH4LIMITL field. */
-#define SAADC_INTENSET_CH4LIMITL_Msk (0x1UL << SAADC_INTENSET_CH4LIMITL_Pos) /*!< Bit mask of CH4LIMITL field. */
-#define SAADC_INTENSET_CH4LIMITL_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_CH4LIMITL_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_CH4LIMITL_Set (1UL) /*!< Enable */
-
-/* Bit 14 : Write '1' to Enable interrupt for CH[4].LIMITH event */
-#define SAADC_INTENSET_CH4LIMITH_Pos (14UL) /*!< Position of CH4LIMITH field. */
-#define SAADC_INTENSET_CH4LIMITH_Msk (0x1UL << SAADC_INTENSET_CH4LIMITH_Pos) /*!< Bit mask of CH4LIMITH field. */
-#define SAADC_INTENSET_CH4LIMITH_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_CH4LIMITH_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_CH4LIMITH_Set (1UL) /*!< Enable */
-
-/* Bit 13 : Write '1' to Enable interrupt for CH[3].LIMITL event */
-#define SAADC_INTENSET_CH3LIMITL_Pos (13UL) /*!< Position of CH3LIMITL field. */
-#define SAADC_INTENSET_CH3LIMITL_Msk (0x1UL << SAADC_INTENSET_CH3LIMITL_Pos) /*!< Bit mask of CH3LIMITL field. */
-#define SAADC_INTENSET_CH3LIMITL_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_CH3LIMITL_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_CH3LIMITL_Set (1UL) /*!< Enable */
-
-/* Bit 12 : Write '1' to Enable interrupt for CH[3].LIMITH event */
-#define SAADC_INTENSET_CH3LIMITH_Pos (12UL) /*!< Position of CH3LIMITH field. */
-#define SAADC_INTENSET_CH3LIMITH_Msk (0x1UL << SAADC_INTENSET_CH3LIMITH_Pos) /*!< Bit mask of CH3LIMITH field. */
-#define SAADC_INTENSET_CH3LIMITH_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_CH3LIMITH_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_CH3LIMITH_Set (1UL) /*!< Enable */
-
-/* Bit 11 : Write '1' to Enable interrupt for CH[2].LIMITL event */
-#define SAADC_INTENSET_CH2LIMITL_Pos (11UL) /*!< Position of CH2LIMITL field. */
-#define SAADC_INTENSET_CH2LIMITL_Msk (0x1UL << SAADC_INTENSET_CH2LIMITL_Pos) /*!< Bit mask of CH2LIMITL field. */
-#define SAADC_INTENSET_CH2LIMITL_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_CH2LIMITL_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_CH2LIMITL_Set (1UL) /*!< Enable */
-
-/* Bit 10 : Write '1' to Enable interrupt for CH[2].LIMITH event */
-#define SAADC_INTENSET_CH2LIMITH_Pos (10UL) /*!< Position of CH2LIMITH field. */
-#define SAADC_INTENSET_CH2LIMITH_Msk (0x1UL << SAADC_INTENSET_CH2LIMITH_Pos) /*!< Bit mask of CH2LIMITH field. */
-#define SAADC_INTENSET_CH2LIMITH_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_CH2LIMITH_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_CH2LIMITH_Set (1UL) /*!< Enable */
-
-/* Bit 9 : Write '1' to Enable interrupt for CH[1].LIMITL event */
-#define SAADC_INTENSET_CH1LIMITL_Pos (9UL) /*!< Position of CH1LIMITL field. */
-#define SAADC_INTENSET_CH1LIMITL_Msk (0x1UL << SAADC_INTENSET_CH1LIMITL_Pos) /*!< Bit mask of CH1LIMITL field. */
-#define SAADC_INTENSET_CH1LIMITL_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_CH1LIMITL_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_CH1LIMITL_Set (1UL) /*!< Enable */
-
-/* Bit 8 : Write '1' to Enable interrupt for CH[1].LIMITH event */
-#define SAADC_INTENSET_CH1LIMITH_Pos (8UL) /*!< Position of CH1LIMITH field. */
-#define SAADC_INTENSET_CH1LIMITH_Msk (0x1UL << SAADC_INTENSET_CH1LIMITH_Pos) /*!< Bit mask of CH1LIMITH field. */
-#define SAADC_INTENSET_CH1LIMITH_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_CH1LIMITH_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_CH1LIMITH_Set (1UL) /*!< Enable */
-
-/* Bit 7 : Write '1' to Enable interrupt for CH[0].LIMITL event */
-#define SAADC_INTENSET_CH0LIMITL_Pos (7UL) /*!< Position of CH0LIMITL field. */
-#define SAADC_INTENSET_CH0LIMITL_Msk (0x1UL << SAADC_INTENSET_CH0LIMITL_Pos) /*!< Bit mask of CH0LIMITL field. */
-#define SAADC_INTENSET_CH0LIMITL_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_CH0LIMITL_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_CH0LIMITL_Set (1UL) /*!< Enable */
-
-/* Bit 6 : Write '1' to Enable interrupt for CH[0].LIMITH event */
-#define SAADC_INTENSET_CH0LIMITH_Pos (6UL) /*!< Position of CH0LIMITH field. */
-#define SAADC_INTENSET_CH0LIMITH_Msk (0x1UL << SAADC_INTENSET_CH0LIMITH_Pos) /*!< Bit mask of CH0LIMITH field. */
-#define SAADC_INTENSET_CH0LIMITH_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_CH0LIMITH_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_CH0LIMITH_Set (1UL) /*!< Enable */
-
-/* Bit 5 : Write '1' to Enable interrupt for STOPPED event */
-#define SAADC_INTENSET_STOPPED_Pos (5UL) /*!< Position of STOPPED field. */
-#define SAADC_INTENSET_STOPPED_Msk (0x1UL << SAADC_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define SAADC_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_STOPPED_Set (1UL) /*!< Enable */
-
-/* Bit 4 : Write '1' to Enable interrupt for CALIBRATEDONE event */
-#define SAADC_INTENSET_CALIBRATEDONE_Pos (4UL) /*!< Position of CALIBRATEDONE field. */
-#define SAADC_INTENSET_CALIBRATEDONE_Msk (0x1UL << SAADC_INTENSET_CALIBRATEDONE_Pos) /*!< Bit mask of CALIBRATEDONE field. */
-#define SAADC_INTENSET_CALIBRATEDONE_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_CALIBRATEDONE_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_CALIBRATEDONE_Set (1UL) /*!< Enable */
-
-/* Bit 3 : Write '1' to Enable interrupt for RESULTDONE event */
-#define SAADC_INTENSET_RESULTDONE_Pos (3UL) /*!< Position of RESULTDONE field. */
-#define SAADC_INTENSET_RESULTDONE_Msk (0x1UL << SAADC_INTENSET_RESULTDONE_Pos) /*!< Bit mask of RESULTDONE field. */
-#define SAADC_INTENSET_RESULTDONE_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_RESULTDONE_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_RESULTDONE_Set (1UL) /*!< Enable */
-
-/* Bit 2 : Write '1' to Enable interrupt for DONE event */
-#define SAADC_INTENSET_DONE_Pos (2UL) /*!< Position of DONE field. */
-#define SAADC_INTENSET_DONE_Msk (0x1UL << SAADC_INTENSET_DONE_Pos) /*!< Bit mask of DONE field. */
-#define SAADC_INTENSET_DONE_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_DONE_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_DONE_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for END event */
-#define SAADC_INTENSET_END_Pos (1UL) /*!< Position of END field. */
-#define SAADC_INTENSET_END_Msk (0x1UL << SAADC_INTENSET_END_Pos) /*!< Bit mask of END field. */
-#define SAADC_INTENSET_END_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_END_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_END_Set (1UL) /*!< Enable */
-
-/* Bit 0 : Write '1' to Enable interrupt for STARTED event */
-#define SAADC_INTENSET_STARTED_Pos (0UL) /*!< Position of STARTED field. */
-#define SAADC_INTENSET_STARTED_Msk (0x1UL << SAADC_INTENSET_STARTED_Pos) /*!< Bit mask of STARTED field. */
-#define SAADC_INTENSET_STARTED_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENSET_STARTED_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENSET_STARTED_Set (1UL) /*!< Enable */
-
-/* Register: SAADC_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 21 : Write '1' to Disable interrupt for CH[7].LIMITL event */
-#define SAADC_INTENCLR_CH7LIMITL_Pos (21UL) /*!< Position of CH7LIMITL field. */
-#define SAADC_INTENCLR_CH7LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH7LIMITL_Pos) /*!< Bit mask of CH7LIMITL field. */
-#define SAADC_INTENCLR_CH7LIMITL_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_CH7LIMITL_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_CH7LIMITL_Clear (1UL) /*!< Disable */
-
-/* Bit 20 : Write '1' to Disable interrupt for CH[7].LIMITH event */
-#define SAADC_INTENCLR_CH7LIMITH_Pos (20UL) /*!< Position of CH7LIMITH field. */
-#define SAADC_INTENCLR_CH7LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH7LIMITH_Pos) /*!< Bit mask of CH7LIMITH field. */
-#define SAADC_INTENCLR_CH7LIMITH_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_CH7LIMITH_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_CH7LIMITH_Clear (1UL) /*!< Disable */
-
-/* Bit 19 : Write '1' to Disable interrupt for CH[6].LIMITL event */
-#define SAADC_INTENCLR_CH6LIMITL_Pos (19UL) /*!< Position of CH6LIMITL field. */
-#define SAADC_INTENCLR_CH6LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH6LIMITL_Pos) /*!< Bit mask of CH6LIMITL field. */
-#define SAADC_INTENCLR_CH6LIMITL_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_CH6LIMITL_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_CH6LIMITL_Clear (1UL) /*!< Disable */
-
-/* Bit 18 : Write '1' to Disable interrupt for CH[6].LIMITH event */
-#define SAADC_INTENCLR_CH6LIMITH_Pos (18UL) /*!< Position of CH6LIMITH field. */
-#define SAADC_INTENCLR_CH6LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH6LIMITH_Pos) /*!< Bit mask of CH6LIMITH field. */
-#define SAADC_INTENCLR_CH6LIMITH_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_CH6LIMITH_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_CH6LIMITH_Clear (1UL) /*!< Disable */
-
-/* Bit 17 : Write '1' to Disable interrupt for CH[5].LIMITL event */
-#define SAADC_INTENCLR_CH5LIMITL_Pos (17UL) /*!< Position of CH5LIMITL field. */
-#define SAADC_INTENCLR_CH5LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH5LIMITL_Pos) /*!< Bit mask of CH5LIMITL field. */
-#define SAADC_INTENCLR_CH5LIMITL_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_CH5LIMITL_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_CH5LIMITL_Clear (1UL) /*!< Disable */
-
-/* Bit 16 : Write '1' to Disable interrupt for CH[5].LIMITH event */
-#define SAADC_INTENCLR_CH5LIMITH_Pos (16UL) /*!< Position of CH5LIMITH field. */
-#define SAADC_INTENCLR_CH5LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH5LIMITH_Pos) /*!< Bit mask of CH5LIMITH field. */
-#define SAADC_INTENCLR_CH5LIMITH_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_CH5LIMITH_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_CH5LIMITH_Clear (1UL) /*!< Disable */
-
-/* Bit 15 : Write '1' to Disable interrupt for CH[4].LIMITL event */
-#define SAADC_INTENCLR_CH4LIMITL_Pos (15UL) /*!< Position of CH4LIMITL field. */
-#define SAADC_INTENCLR_CH4LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH4LIMITL_Pos) /*!< Bit mask of CH4LIMITL field. */
-#define SAADC_INTENCLR_CH4LIMITL_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_CH4LIMITL_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_CH4LIMITL_Clear (1UL) /*!< Disable */
-
-/* Bit 14 : Write '1' to Disable interrupt for CH[4].LIMITH event */
-#define SAADC_INTENCLR_CH4LIMITH_Pos (14UL) /*!< Position of CH4LIMITH field. */
-#define SAADC_INTENCLR_CH4LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH4LIMITH_Pos) /*!< Bit mask of CH4LIMITH field. */
-#define SAADC_INTENCLR_CH4LIMITH_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_CH4LIMITH_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_CH4LIMITH_Clear (1UL) /*!< Disable */
-
-/* Bit 13 : Write '1' to Disable interrupt for CH[3].LIMITL event */
-#define SAADC_INTENCLR_CH3LIMITL_Pos (13UL) /*!< Position of CH3LIMITL field. */
-#define SAADC_INTENCLR_CH3LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH3LIMITL_Pos) /*!< Bit mask of CH3LIMITL field. */
-#define SAADC_INTENCLR_CH3LIMITL_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_CH3LIMITL_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_CH3LIMITL_Clear (1UL) /*!< Disable */
-
-/* Bit 12 : Write '1' to Disable interrupt for CH[3].LIMITH event */
-#define SAADC_INTENCLR_CH3LIMITH_Pos (12UL) /*!< Position of CH3LIMITH field. */
-#define SAADC_INTENCLR_CH3LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH3LIMITH_Pos) /*!< Bit mask of CH3LIMITH field. */
-#define SAADC_INTENCLR_CH3LIMITH_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_CH3LIMITH_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_CH3LIMITH_Clear (1UL) /*!< Disable */
-
-/* Bit 11 : Write '1' to Disable interrupt for CH[2].LIMITL event */
-#define SAADC_INTENCLR_CH2LIMITL_Pos (11UL) /*!< Position of CH2LIMITL field. */
-#define SAADC_INTENCLR_CH2LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH2LIMITL_Pos) /*!< Bit mask of CH2LIMITL field. */
-#define SAADC_INTENCLR_CH2LIMITL_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_CH2LIMITL_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_CH2LIMITL_Clear (1UL) /*!< Disable */
-
-/* Bit 10 : Write '1' to Disable interrupt for CH[2].LIMITH event */
-#define SAADC_INTENCLR_CH2LIMITH_Pos (10UL) /*!< Position of CH2LIMITH field. */
-#define SAADC_INTENCLR_CH2LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH2LIMITH_Pos) /*!< Bit mask of CH2LIMITH field. */
-#define SAADC_INTENCLR_CH2LIMITH_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_CH2LIMITH_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_CH2LIMITH_Clear (1UL) /*!< Disable */
-
-/* Bit 9 : Write '1' to Disable interrupt for CH[1].LIMITL event */
-#define SAADC_INTENCLR_CH1LIMITL_Pos (9UL) /*!< Position of CH1LIMITL field. */
-#define SAADC_INTENCLR_CH1LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH1LIMITL_Pos) /*!< Bit mask of CH1LIMITL field. */
-#define SAADC_INTENCLR_CH1LIMITL_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_CH1LIMITL_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_CH1LIMITL_Clear (1UL) /*!< Disable */
-
-/* Bit 8 : Write '1' to Disable interrupt for CH[1].LIMITH event */
-#define SAADC_INTENCLR_CH1LIMITH_Pos (8UL) /*!< Position of CH1LIMITH field. */
-#define SAADC_INTENCLR_CH1LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH1LIMITH_Pos) /*!< Bit mask of CH1LIMITH field. */
-#define SAADC_INTENCLR_CH1LIMITH_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_CH1LIMITH_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_CH1LIMITH_Clear (1UL) /*!< Disable */
-
-/* Bit 7 : Write '1' to Disable interrupt for CH[0].LIMITL event */
-#define SAADC_INTENCLR_CH0LIMITL_Pos (7UL) /*!< Position of CH0LIMITL field. */
-#define SAADC_INTENCLR_CH0LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH0LIMITL_Pos) /*!< Bit mask of CH0LIMITL field. */
-#define SAADC_INTENCLR_CH0LIMITL_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_CH0LIMITL_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_CH0LIMITL_Clear (1UL) /*!< Disable */
-
-/* Bit 6 : Write '1' to Disable interrupt for CH[0].LIMITH event */
-#define SAADC_INTENCLR_CH0LIMITH_Pos (6UL) /*!< Position of CH0LIMITH field. */
-#define SAADC_INTENCLR_CH0LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH0LIMITH_Pos) /*!< Bit mask of CH0LIMITH field. */
-#define SAADC_INTENCLR_CH0LIMITH_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_CH0LIMITH_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_CH0LIMITH_Clear (1UL) /*!< Disable */
-
-/* Bit 5 : Write '1' to Disable interrupt for STOPPED event */
-#define SAADC_INTENCLR_STOPPED_Pos (5UL) /*!< Position of STOPPED field. */
-#define SAADC_INTENCLR_STOPPED_Msk (0x1UL << SAADC_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define SAADC_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
-
-/* Bit 4 : Write '1' to Disable interrupt for CALIBRATEDONE event */
-#define SAADC_INTENCLR_CALIBRATEDONE_Pos (4UL) /*!< Position of CALIBRATEDONE field. */
-#define SAADC_INTENCLR_CALIBRATEDONE_Msk (0x1UL << SAADC_INTENCLR_CALIBRATEDONE_Pos) /*!< Bit mask of CALIBRATEDONE field. */
-#define SAADC_INTENCLR_CALIBRATEDONE_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_CALIBRATEDONE_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_CALIBRATEDONE_Clear (1UL) /*!< Disable */
-
-/* Bit 3 : Write '1' to Disable interrupt for RESULTDONE event */
-#define SAADC_INTENCLR_RESULTDONE_Pos (3UL) /*!< Position of RESULTDONE field. */
-#define SAADC_INTENCLR_RESULTDONE_Msk (0x1UL << SAADC_INTENCLR_RESULTDONE_Pos) /*!< Bit mask of RESULTDONE field. */
-#define SAADC_INTENCLR_RESULTDONE_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_RESULTDONE_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_RESULTDONE_Clear (1UL) /*!< Disable */
-
-/* Bit 2 : Write '1' to Disable interrupt for DONE event */
-#define SAADC_INTENCLR_DONE_Pos (2UL) /*!< Position of DONE field. */
-#define SAADC_INTENCLR_DONE_Msk (0x1UL << SAADC_INTENCLR_DONE_Pos) /*!< Bit mask of DONE field. */
-#define SAADC_INTENCLR_DONE_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_DONE_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_DONE_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for END event */
-#define SAADC_INTENCLR_END_Pos (1UL) /*!< Position of END field. */
-#define SAADC_INTENCLR_END_Msk (0x1UL << SAADC_INTENCLR_END_Pos) /*!< Bit mask of END field. */
-#define SAADC_INTENCLR_END_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_END_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_END_Clear (1UL) /*!< Disable */
-
-/* Bit 0 : Write '1' to Disable interrupt for STARTED event */
-#define SAADC_INTENCLR_STARTED_Pos (0UL) /*!< Position of STARTED field. */
-#define SAADC_INTENCLR_STARTED_Msk (0x1UL << SAADC_INTENCLR_STARTED_Pos) /*!< Bit mask of STARTED field. */
-#define SAADC_INTENCLR_STARTED_Disabled (0UL) /*!< Read: Disabled */
-#define SAADC_INTENCLR_STARTED_Enabled (1UL) /*!< Read: Enabled */
-#define SAADC_INTENCLR_STARTED_Clear (1UL) /*!< Disable */
-
-/* Register: SAADC_STATUS */
-/* Description: Status */
-
-/* Bit 0 : Status */
-#define SAADC_STATUS_STATUS_Pos (0UL) /*!< Position of STATUS field. */
-#define SAADC_STATUS_STATUS_Msk (0x1UL << SAADC_STATUS_STATUS_Pos) /*!< Bit mask of STATUS field. */
-#define SAADC_STATUS_STATUS_Ready (0UL) /*!< ADC is ready. No on-going conversion. */
-#define SAADC_STATUS_STATUS_Busy (1UL) /*!< ADC is busy. Conversion in progress. */
-
-/* Register: SAADC_ENABLE */
-/* Description: Enable or disable ADC */
-
-/* Bit 0 : Enable or disable ADC */
-#define SAADC_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
-#define SAADC_ENABLE_ENABLE_Msk (0x1UL << SAADC_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
-#define SAADC_ENABLE_ENABLE_Disabled (0UL) /*!< Disable ADC */
-#define SAADC_ENABLE_ENABLE_Enabled (1UL) /*!< Enable ADC */
-
-/* Register: SAADC_CH_PSELP */
-/* Description: Description cluster[0]:  Input positive pin selection for CH[0] */
-
-/* Bits 4..0 : Analog positive input channel */
-#define SAADC_CH_PSELP_PSELP_Pos (0UL) /*!< Position of PSELP field. */
-#define SAADC_CH_PSELP_PSELP_Msk (0x1FUL << SAADC_CH_PSELP_PSELP_Pos) /*!< Bit mask of PSELP field. */
-#define SAADC_CH_PSELP_PSELP_NC (0UL) /*!< Not connected */
-#define SAADC_CH_PSELP_PSELP_AnalogInput0 (1UL) /*!< AIN0 */
-#define SAADC_CH_PSELP_PSELP_AnalogInput1 (2UL) /*!< AIN1 */
-#define SAADC_CH_PSELP_PSELP_AnalogInput2 (3UL) /*!< AIN2 */
-#define SAADC_CH_PSELP_PSELP_AnalogInput3 (4UL) /*!< AIN3 */
-#define SAADC_CH_PSELP_PSELP_AnalogInput4 (5UL) /*!< AIN4 */
-#define SAADC_CH_PSELP_PSELP_AnalogInput5 (6UL) /*!< AIN5 */
-#define SAADC_CH_PSELP_PSELP_AnalogInput6 (7UL) /*!< AIN6 */
-#define SAADC_CH_PSELP_PSELP_AnalogInput7 (8UL) /*!< AIN7 */
-#define SAADC_CH_PSELP_PSELP_VDD (9UL) /*!< VDD */
-
-/* Register: SAADC_CH_PSELN */
-/* Description: Description cluster[0]:  Input negative pin selection for CH[0] */
-
-/* Bits 4..0 : Analog negative input, enables differential channel */
-#define SAADC_CH_PSELN_PSELN_Pos (0UL) /*!< Position of PSELN field. */
-#define SAADC_CH_PSELN_PSELN_Msk (0x1FUL << SAADC_CH_PSELN_PSELN_Pos) /*!< Bit mask of PSELN field. */
-#define SAADC_CH_PSELN_PSELN_NC (0UL) /*!< Not connected */
-#define SAADC_CH_PSELN_PSELN_AnalogInput0 (1UL) /*!< AIN0 */
-#define SAADC_CH_PSELN_PSELN_AnalogInput1 (2UL) /*!< AIN1 */
-#define SAADC_CH_PSELN_PSELN_AnalogInput2 (3UL) /*!< AIN2 */
-#define SAADC_CH_PSELN_PSELN_AnalogInput3 (4UL) /*!< AIN3 */
-#define SAADC_CH_PSELN_PSELN_AnalogInput4 (5UL) /*!< AIN4 */
-#define SAADC_CH_PSELN_PSELN_AnalogInput5 (6UL) /*!< AIN5 */
-#define SAADC_CH_PSELN_PSELN_AnalogInput6 (7UL) /*!< AIN6 */
-#define SAADC_CH_PSELN_PSELN_AnalogInput7 (8UL) /*!< AIN7 */
-#define SAADC_CH_PSELN_PSELN_VDD (9UL) /*!< VDD */
-
-/* Register: SAADC_CH_CONFIG */
-/* Description: Description cluster[0]:  Input configuration for CH[0] */
-
-/* Bit 24 : Enable burst mode */
-#define SAADC_CH_CONFIG_BURST_Pos (24UL) /*!< Position of BURST field. */
-#define SAADC_CH_CONFIG_BURST_Msk (0x1UL << SAADC_CH_CONFIG_BURST_Pos) /*!< Bit mask of BURST field. */
-#define SAADC_CH_CONFIG_BURST_Disabled (0UL) /*!< Burst mode is disabled (normal operation) */
-#define SAADC_CH_CONFIG_BURST_Enabled (1UL) /*!< Burst mode is enabled. SAADC takes 2^OVERSAMPLE number of samples as fast as it can, and sends the average to Data RAM. */
-
-/* Bit 20 : Enable differential mode */
-#define SAADC_CH_CONFIG_MODE_Pos (20UL) /*!< Position of MODE field. */
-#define SAADC_CH_CONFIG_MODE_Msk (0x1UL << SAADC_CH_CONFIG_MODE_Pos) /*!< Bit mask of MODE field. */
-#define SAADC_CH_CONFIG_MODE_SE (0UL) /*!< Single ended, PSELN will be ignored, negative input to ADC shorted to GND */
-#define SAADC_CH_CONFIG_MODE_Diff (1UL) /*!< Differential */
-
-/* Bits 18..16 : Acquisition time, the time the ADC uses to sample the input voltage */
-#define SAADC_CH_CONFIG_TACQ_Pos (16UL) /*!< Position of TACQ field. */
-#define SAADC_CH_CONFIG_TACQ_Msk (0x7UL << SAADC_CH_CONFIG_TACQ_Pos) /*!< Bit mask of TACQ field. */
-#define SAADC_CH_CONFIG_TACQ_3us (0UL) /*!< 3 us */
-#define SAADC_CH_CONFIG_TACQ_5us (1UL) /*!< 5 us */
-#define SAADC_CH_CONFIG_TACQ_10us (2UL) /*!< 10 us */
-#define SAADC_CH_CONFIG_TACQ_15us (3UL) /*!< 15 us */
-#define SAADC_CH_CONFIG_TACQ_20us (4UL) /*!< 20 us */
-#define SAADC_CH_CONFIG_TACQ_40us (5UL) /*!< 40 us */
-
-/* Bit 12 : Reference control */
-#define SAADC_CH_CONFIG_REFSEL_Pos (12UL) /*!< Position of REFSEL field. */
-#define SAADC_CH_CONFIG_REFSEL_Msk (0x1UL << SAADC_CH_CONFIG_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
-#define SAADC_CH_CONFIG_REFSEL_Internal (0UL) /*!< Internal reference (0.6 V) */
-#define SAADC_CH_CONFIG_REFSEL_VDD1_4 (1UL) /*!< VDD/4 as reference */
-
-/* Bits 10..8 : Gain control */
-#define SAADC_CH_CONFIG_GAIN_Pos (8UL) /*!< Position of GAIN field. */
-#define SAADC_CH_CONFIG_GAIN_Msk (0x7UL << SAADC_CH_CONFIG_GAIN_Pos) /*!< Bit mask of GAIN field. */
-#define SAADC_CH_CONFIG_GAIN_Gain1_6 (0UL) /*!< 1/6 */
-#define SAADC_CH_CONFIG_GAIN_Gain1_5 (1UL) /*!< 1/5 */
-#define SAADC_CH_CONFIG_GAIN_Gain1_4 (2UL) /*!< 1/4 */
-#define SAADC_CH_CONFIG_GAIN_Gain1_3 (3UL) /*!< 1/3 */
-#define SAADC_CH_CONFIG_GAIN_Gain1_2 (4UL) /*!< 1/2 */
-#define SAADC_CH_CONFIG_GAIN_Gain1 (5UL) /*!< 1 */
-#define SAADC_CH_CONFIG_GAIN_Gain2 (6UL) /*!< 2 */
-#define SAADC_CH_CONFIG_GAIN_Gain4 (7UL) /*!< 4 */
-
-/* Bits 5..4 : Negative channel resistor control */
-#define SAADC_CH_CONFIG_RESN_Pos (4UL) /*!< Position of RESN field. */
-#define SAADC_CH_CONFIG_RESN_Msk (0x3UL << SAADC_CH_CONFIG_RESN_Pos) /*!< Bit mask of RESN field. */
-#define SAADC_CH_CONFIG_RESN_Bypass (0UL) /*!< Bypass resistor ladder */
-#define SAADC_CH_CONFIG_RESN_Pulldown (1UL) /*!< Pull-down to GND */
-#define SAADC_CH_CONFIG_RESN_Pullup (2UL) /*!< Pull-up to VDD */
-#define SAADC_CH_CONFIG_RESN_VDD1_2 (3UL) /*!< Set input at VDD/2 */
-
-/* Bits 1..0 : Positive channel resistor control */
-#define SAADC_CH_CONFIG_RESP_Pos (0UL) /*!< Position of RESP field. */
-#define SAADC_CH_CONFIG_RESP_Msk (0x3UL << SAADC_CH_CONFIG_RESP_Pos) /*!< Bit mask of RESP field. */
-#define SAADC_CH_CONFIG_RESP_Bypass (0UL) /*!< Bypass resistor ladder */
-#define SAADC_CH_CONFIG_RESP_Pulldown (1UL) /*!< Pull-down to GND */
-#define SAADC_CH_CONFIG_RESP_Pullup (2UL) /*!< Pull-up to VDD */
-#define SAADC_CH_CONFIG_RESP_VDD1_2 (3UL) /*!< Set input at VDD/2 */
-
-/* Register: SAADC_CH_LIMIT */
-/* Description: Description cluster[0]:  High/low limits for event monitoring a channel */
-
-/* Bits 31..16 : High level limit */
-#define SAADC_CH_LIMIT_HIGH_Pos (16UL) /*!< Position of HIGH field. */
-#define SAADC_CH_LIMIT_HIGH_Msk (0xFFFFUL << SAADC_CH_LIMIT_HIGH_Pos) /*!< Bit mask of HIGH field. */
-
-/* Bits 15..0 : Low level limit */
-#define SAADC_CH_LIMIT_LOW_Pos (0UL) /*!< Position of LOW field. */
-#define SAADC_CH_LIMIT_LOW_Msk (0xFFFFUL << SAADC_CH_LIMIT_LOW_Pos) /*!< Bit mask of LOW field. */
-
-/* Register: SAADC_RESOLUTION */
-/* Description: Resolution configuration */
-
-/* Bits 2..0 : Set the resolution */
-#define SAADC_RESOLUTION_VAL_Pos (0UL) /*!< Position of VAL field. */
-#define SAADC_RESOLUTION_VAL_Msk (0x7UL << SAADC_RESOLUTION_VAL_Pos) /*!< Bit mask of VAL field. */
-#define SAADC_RESOLUTION_VAL_8bit (0UL) /*!< 8 bit */
-#define SAADC_RESOLUTION_VAL_10bit (1UL) /*!< 10 bit */
-#define SAADC_RESOLUTION_VAL_12bit (2UL) /*!< 12 bit */
-#define SAADC_RESOLUTION_VAL_14bit (3UL) /*!< 14 bit */
-
-/* Register: SAADC_OVERSAMPLE */
-/* Description: Oversampling configuration. OVERSAMPLE should not be combined with SCAN. The RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher RESOLUTION should be used. */
-
-/* Bits 3..0 : Oversample control */
-#define SAADC_OVERSAMPLE_OVERSAMPLE_Pos (0UL) /*!< Position of OVERSAMPLE field. */
-#define SAADC_OVERSAMPLE_OVERSAMPLE_Msk (0xFUL << SAADC_OVERSAMPLE_OVERSAMPLE_Pos) /*!< Bit mask of OVERSAMPLE field. */
-#define SAADC_OVERSAMPLE_OVERSAMPLE_Bypass (0UL) /*!< Bypass oversampling */
-#define SAADC_OVERSAMPLE_OVERSAMPLE_Over2x (1UL) /*!< Oversample 2x */
-#define SAADC_OVERSAMPLE_OVERSAMPLE_Over4x (2UL) /*!< Oversample 4x */
-#define SAADC_OVERSAMPLE_OVERSAMPLE_Over8x (3UL) /*!< Oversample 8x */
-#define SAADC_OVERSAMPLE_OVERSAMPLE_Over16x (4UL) /*!< Oversample 16x */
-#define SAADC_OVERSAMPLE_OVERSAMPLE_Over32x (5UL) /*!< Oversample 32x */
-#define SAADC_OVERSAMPLE_OVERSAMPLE_Over64x (6UL) /*!< Oversample 64x */
-#define SAADC_OVERSAMPLE_OVERSAMPLE_Over128x (7UL) /*!< Oversample 128x */
-#define SAADC_OVERSAMPLE_OVERSAMPLE_Over256x (8UL) /*!< Oversample 256x */
-
-/* Register: SAADC_SAMPLERATE */
-/* Description: Controls normal or continuous sample rate */
-
-/* Bit 12 : Select mode for sample rate control */
-#define SAADC_SAMPLERATE_MODE_Pos (12UL) /*!< Position of MODE field. */
-#define SAADC_SAMPLERATE_MODE_Msk (0x1UL << SAADC_SAMPLERATE_MODE_Pos) /*!< Bit mask of MODE field. */
-#define SAADC_SAMPLERATE_MODE_Task (0UL) /*!< Rate is controlled from SAMPLE task */
-#define SAADC_SAMPLERATE_MODE_Timers (1UL) /*!< Rate is controlled from local timer (use CC to control the rate) */
-
-/* Bits 10..0 : Capture and compare value. Sample rate is 16 MHz/CC */
-#define SAADC_SAMPLERATE_CC_Pos (0UL) /*!< Position of CC field. */
-#define SAADC_SAMPLERATE_CC_Msk (0x7FFUL << SAADC_SAMPLERATE_CC_Pos) /*!< Bit mask of CC field. */
-
-/* Register: SAADC_RESULT_PTR */
-/* Description: Data pointer */
-
-/* Bits 31..0 : Data pointer */
-#define SAADC_RESULT_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
-#define SAADC_RESULT_PTR_PTR_Msk (0xFFFFFFFFUL << SAADC_RESULT_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
-
-/* Register: SAADC_RESULT_MAXCNT */
-/* Description: Maximum number of buffer words to transfer */
-
-/* Bits 14..0 : Maximum number of buffer words to transfer */
-#define SAADC_RESULT_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
-#define SAADC_RESULT_MAXCNT_MAXCNT_Msk (0x7FFFUL << SAADC_RESULT_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
-
-/* Register: SAADC_RESULT_AMOUNT */
-/* Description: Number of buffer words transferred since last START */
-
-/* Bits 14..0 : Number of buffer words transferred since last START. This register can be read after an END or STOPPED event. */
-#define SAADC_RESULT_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
-#define SAADC_RESULT_AMOUNT_AMOUNT_Msk (0x7FFFUL << SAADC_RESULT_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
-
-
-/* Peripheral: SPI */
-/* Description: Serial Peripheral Interface 0 */
-
-/* Register: SPI_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 2 : Write '1' to Enable interrupt for READY event */
-#define SPI_INTENSET_READY_Pos (2UL) /*!< Position of READY field. */
-#define SPI_INTENSET_READY_Msk (0x1UL << SPI_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
-#define SPI_INTENSET_READY_Disabled (0UL) /*!< Read: Disabled */
-#define SPI_INTENSET_READY_Enabled (1UL) /*!< Read: Enabled */
-#define SPI_INTENSET_READY_Set (1UL) /*!< Enable */
-
-/* Register: SPI_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 2 : Write '1' to Disable interrupt for READY event */
-#define SPI_INTENCLR_READY_Pos (2UL) /*!< Position of READY field. */
-#define SPI_INTENCLR_READY_Msk (0x1UL << SPI_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
-#define SPI_INTENCLR_READY_Disabled (0UL) /*!< Read: Disabled */
-#define SPI_INTENCLR_READY_Enabled (1UL) /*!< Read: Enabled */
-#define SPI_INTENCLR_READY_Clear (1UL) /*!< Disable */
-
-/* Register: SPI_ENABLE */
-/* Description: Enable SPI */
-
-/* Bits 3..0 : Enable or disable SPI */
-#define SPI_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
-#define SPI_ENABLE_ENABLE_Msk (0xFUL << SPI_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
-#define SPI_ENABLE_ENABLE_Disabled (0UL) /*!< Disable SPI */
-#define SPI_ENABLE_ENABLE_Enabled (1UL) /*!< Enable SPI */
-
-/* Register: SPI_PSEL_SCK */
-/* Description: Pin select for SCK */
-
-/* Bits 31..0 : Pin number configuration for SPI SCK signal */
-#define SPI_PSEL_SCK_PSELSCK_Pos (0UL) /*!< Position of PSELSCK field. */
-#define SPI_PSEL_SCK_PSELSCK_Msk (0xFFFFFFFFUL << SPI_PSEL_SCK_PSELSCK_Pos) /*!< Bit mask of PSELSCK field. */
-#define SPI_PSEL_SCK_PSELSCK_Disconnected (0xFFFFFFFFUL) /*!< Disconnect */
-
-/* Register: SPI_PSEL_MOSI */
-/* Description: Pin select for MOSI */
-
-/* Bits 31..0 : Pin number configuration for SPI MOSI signal */
-#define SPI_PSEL_MOSI_PSELMOSI_Pos (0UL) /*!< Position of PSELMOSI field. */
-#define SPI_PSEL_MOSI_PSELMOSI_Msk (0xFFFFFFFFUL << SPI_PSEL_MOSI_PSELMOSI_Pos) /*!< Bit mask of PSELMOSI field. */
-#define SPI_PSEL_MOSI_PSELMOSI_Disconnected (0xFFFFFFFFUL) /*!< Disconnect */
-
-/* Register: SPI_PSEL_MISO */
-/* Description: Pin select for MISO */
-
-/* Bits 31..0 : Pin number configuration for SPI MISO signal */
-#define SPI_PSEL_MISO_PSELMISO_Pos (0UL) /*!< Position of PSELMISO field. */
-#define SPI_PSEL_MISO_PSELMISO_Msk (0xFFFFFFFFUL << SPI_PSEL_MISO_PSELMISO_Pos) /*!< Bit mask of PSELMISO field. */
-#define SPI_PSEL_MISO_PSELMISO_Disconnected (0xFFFFFFFFUL) /*!< Disconnect */
-
-/* Register: SPI_RXD */
-/* Description: RXD register */
-
-/* Bits 7..0 : RX data received. Double buffered */
-#define SPI_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
-#define SPI_RXD_RXD_Msk (0xFFUL << SPI_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
-
-/* Register: SPI_TXD */
-/* Description: TXD register */
-
-/* Bits 7..0 : TX data to send. Double buffered */
-#define SPI_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
-#define SPI_TXD_TXD_Msk (0xFFUL << SPI_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
-
-/* Register: SPI_FREQUENCY */
-/* Description: SPI frequency */
-
-/* Bits 31..0 : SPI master data rate */
-#define SPI_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
-#define SPI_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << SPI_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
-#define SPI_FREQUENCY_FREQUENCY_K125 (0x02000000UL) /*!< 125 kbps */
-#define SPI_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250 kbps */
-#define SPI_FREQUENCY_FREQUENCY_K500 (0x08000000UL) /*!< 500 kbps */
-#define SPI_FREQUENCY_FREQUENCY_M1 (0x10000000UL) /*!< 1 Mbps */
-#define SPI_FREQUENCY_FREQUENCY_M2 (0x20000000UL) /*!< 2 Mbps */
-#define SPI_FREQUENCY_FREQUENCY_M4 (0x40000000UL) /*!< 4 Mbps */
-#define SPI_FREQUENCY_FREQUENCY_M8 (0x80000000UL) /*!< 8 Mbps */
-
-/* Register: SPI_CONFIG */
-/* Description: Configuration register */
-
-/* Bit 2 : Serial clock (SCK) polarity */
-#define SPI_CONFIG_CPOL_Pos (2UL) /*!< Position of CPOL field. */
-#define SPI_CONFIG_CPOL_Msk (0x1UL << SPI_CONFIG_CPOL_Pos) /*!< Bit mask of CPOL field. */
-#define SPI_CONFIG_CPOL_ActiveHigh (0UL) /*!< Active high */
-#define SPI_CONFIG_CPOL_ActiveLow (1UL) /*!< Active low */
-
-/* Bit 1 : Serial clock (SCK) phase */
-#define SPI_CONFIG_CPHA_Pos (1UL) /*!< Position of CPHA field. */
-#define SPI_CONFIG_CPHA_Msk (0x1UL << SPI_CONFIG_CPHA_Pos) /*!< Bit mask of CPHA field. */
-#define SPI_CONFIG_CPHA_Leading (0UL) /*!< Sample on leading edge of clock, shift serial data on trailing edge */
-#define SPI_CONFIG_CPHA_Trailing (1UL) /*!< Sample on trailing edge of clock, shift serial data on leading edge */
-
-/* Bit 0 : Bit order */
-#define SPI_CONFIG_ORDER_Pos (0UL) /*!< Position of ORDER field. */
-#define SPI_CONFIG_ORDER_Msk (0x1UL << SPI_CONFIG_ORDER_Pos) /*!< Bit mask of ORDER field. */
-#define SPI_CONFIG_ORDER_MsbFirst (0UL) /*!< Most significant bit shifted out first */
-#define SPI_CONFIG_ORDER_LsbFirst (1UL) /*!< Least significant bit shifted out first */
-
-
-/* Peripheral: SPIM */
-/* Description: Serial Peripheral Interface Master with EasyDMA 0 */
-
-/* Register: SPIM_SHORTS */
-/* Description: Shortcut register */
-
-/* Bit 17 : Shortcut between END event and START task */
-#define SPIM_SHORTS_END_START_Pos (17UL) /*!< Position of END_START field. */
-#define SPIM_SHORTS_END_START_Msk (0x1UL << SPIM_SHORTS_END_START_Pos) /*!< Bit mask of END_START field. */
-#define SPIM_SHORTS_END_START_Disabled (0UL) /*!< Disable shortcut */
-#define SPIM_SHORTS_END_START_Enabled (1UL) /*!< Enable shortcut */
-
-/* Register: SPIM_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 19 : Write '1' to Enable interrupt for STARTED event */
-#define SPIM_INTENSET_STARTED_Pos (19UL) /*!< Position of STARTED field. */
-#define SPIM_INTENSET_STARTED_Msk (0x1UL << SPIM_INTENSET_STARTED_Pos) /*!< Bit mask of STARTED field. */
-#define SPIM_INTENSET_STARTED_Disabled (0UL) /*!< Read: Disabled */
-#define SPIM_INTENSET_STARTED_Enabled (1UL) /*!< Read: Enabled */
-#define SPIM_INTENSET_STARTED_Set (1UL) /*!< Enable */
-
-/* Bit 8 : Write '1' to Enable interrupt for ENDTX event */
-#define SPIM_INTENSET_ENDTX_Pos (8UL) /*!< Position of ENDTX field. */
-#define SPIM_INTENSET_ENDTX_Msk (0x1UL << SPIM_INTENSET_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
-#define SPIM_INTENSET_ENDTX_Disabled (0UL) /*!< Read: Disabled */
-#define SPIM_INTENSET_ENDTX_Enabled (1UL) /*!< Read: Enabled */
-#define SPIM_INTENSET_ENDTX_Set (1UL) /*!< Enable */
-
-/* Bit 6 : Write '1' to Enable interrupt for END event */
-#define SPIM_INTENSET_END_Pos (6UL) /*!< Position of END field. */
-#define SPIM_INTENSET_END_Msk (0x1UL << SPIM_INTENSET_END_Pos) /*!< Bit mask of END field. */
-#define SPIM_INTENSET_END_Disabled (0UL) /*!< Read: Disabled */
-#define SPIM_INTENSET_END_Enabled (1UL) /*!< Read: Enabled */
-#define SPIM_INTENSET_END_Set (1UL) /*!< Enable */
-
-/* Bit 4 : Write '1' to Enable interrupt for ENDRX event */
-#define SPIM_INTENSET_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
-#define SPIM_INTENSET_ENDRX_Msk (0x1UL << SPIM_INTENSET_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
-#define SPIM_INTENSET_ENDRX_Disabled (0UL) /*!< Read: Disabled */
-#define SPIM_INTENSET_ENDRX_Enabled (1UL) /*!< Read: Enabled */
-#define SPIM_INTENSET_ENDRX_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for STOPPED event */
-#define SPIM_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
-#define SPIM_INTENSET_STOPPED_Msk (0x1UL << SPIM_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define SPIM_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define SPIM_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define SPIM_INTENSET_STOPPED_Set (1UL) /*!< Enable */
-
-/* Register: SPIM_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 19 : Write '1' to Disable interrupt for STARTED event */
-#define SPIM_INTENCLR_STARTED_Pos (19UL) /*!< Position of STARTED field. */
-#define SPIM_INTENCLR_STARTED_Msk (0x1UL << SPIM_INTENCLR_STARTED_Pos) /*!< Bit mask of STARTED field. */
-#define SPIM_INTENCLR_STARTED_Disabled (0UL) /*!< Read: Disabled */
-#define SPIM_INTENCLR_STARTED_Enabled (1UL) /*!< Read: Enabled */
-#define SPIM_INTENCLR_STARTED_Clear (1UL) /*!< Disable */
-
-/* Bit 8 : Write '1' to Disable interrupt for ENDTX event */
-#define SPIM_INTENCLR_ENDTX_Pos (8UL) /*!< Position of ENDTX field. */
-#define SPIM_INTENCLR_ENDTX_Msk (0x1UL << SPIM_INTENCLR_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
-#define SPIM_INTENCLR_ENDTX_Disabled (0UL) /*!< Read: Disabled */
-#define SPIM_INTENCLR_ENDTX_Enabled (1UL) /*!< Read: Enabled */
-#define SPIM_INTENCLR_ENDTX_Clear (1UL) /*!< Disable */
-
-/* Bit 6 : Write '1' to Disable interrupt for END event */
-#define SPIM_INTENCLR_END_Pos (6UL) /*!< Position of END field. */
-#define SPIM_INTENCLR_END_Msk (0x1UL << SPIM_INTENCLR_END_Pos) /*!< Bit mask of END field. */
-#define SPIM_INTENCLR_END_Disabled (0UL) /*!< Read: Disabled */
-#define SPIM_INTENCLR_END_Enabled (1UL) /*!< Read: Enabled */
-#define SPIM_INTENCLR_END_Clear (1UL) /*!< Disable */
-
-/* Bit 4 : Write '1' to Disable interrupt for ENDRX event */
-#define SPIM_INTENCLR_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
-#define SPIM_INTENCLR_ENDRX_Msk (0x1UL << SPIM_INTENCLR_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
-#define SPIM_INTENCLR_ENDRX_Disabled (0UL) /*!< Read: Disabled */
-#define SPIM_INTENCLR_ENDRX_Enabled (1UL) /*!< Read: Enabled */
-#define SPIM_INTENCLR_ENDRX_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for STOPPED event */
-#define SPIM_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
-#define SPIM_INTENCLR_STOPPED_Msk (0x1UL << SPIM_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define SPIM_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define SPIM_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define SPIM_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
-
-/* Register: SPIM_ENABLE */
-/* Description: Enable SPIM */
-
-/* Bits 3..0 : Enable or disable SPIM */
-#define SPIM_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
-#define SPIM_ENABLE_ENABLE_Msk (0xFUL << SPIM_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
-#define SPIM_ENABLE_ENABLE_Disabled (0UL) /*!< Disable SPIM */
-#define SPIM_ENABLE_ENABLE_Enabled (7UL) /*!< Enable SPIM */
-
-/* Register: SPIM_PSEL_SCK */
-/* Description: Pin select for SCK */
-
-/* Bit 31 : Connection */
-#define SPIM_PSEL_SCK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define SPIM_PSEL_SCK_CONNECT_Msk (0x1UL << SPIM_PSEL_SCK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define SPIM_PSEL_SCK_CONNECT_Connected (0UL) /*!< Connect */
-#define SPIM_PSEL_SCK_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define SPIM_PSEL_SCK_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define SPIM_PSEL_SCK_PIN_Msk (0x1FUL << SPIM_PSEL_SCK_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: SPIM_PSEL_MOSI */
-/* Description: Pin select for MOSI signal */
-
-/* Bit 31 : Connection */
-#define SPIM_PSEL_MOSI_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define SPIM_PSEL_MOSI_CONNECT_Msk (0x1UL << SPIM_PSEL_MOSI_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define SPIM_PSEL_MOSI_CONNECT_Connected (0UL) /*!< Connect */
-#define SPIM_PSEL_MOSI_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define SPIM_PSEL_MOSI_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define SPIM_PSEL_MOSI_PIN_Msk (0x1FUL << SPIM_PSEL_MOSI_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: SPIM_PSEL_MISO */
-/* Description: Pin select for MISO signal */
-
-/* Bit 31 : Connection */
-#define SPIM_PSEL_MISO_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define SPIM_PSEL_MISO_CONNECT_Msk (0x1UL << SPIM_PSEL_MISO_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define SPIM_PSEL_MISO_CONNECT_Connected (0UL) /*!< Connect */
-#define SPIM_PSEL_MISO_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define SPIM_PSEL_MISO_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define SPIM_PSEL_MISO_PIN_Msk (0x1FUL << SPIM_PSEL_MISO_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: SPIM_FREQUENCY */
-/* Description: SPI frequency */
-
-/* Bits 31..0 : SPI master data rate */
-#define SPIM_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
-#define SPIM_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << SPIM_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
-#define SPIM_FREQUENCY_FREQUENCY_K125 (0x02000000UL) /*!< 125 kbps */
-#define SPIM_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250 kbps */
-#define SPIM_FREQUENCY_FREQUENCY_K500 (0x08000000UL) /*!< 500 kbps */
-#define SPIM_FREQUENCY_FREQUENCY_M1 (0x10000000UL) /*!< 1 Mbps */
-#define SPIM_FREQUENCY_FREQUENCY_M2 (0x20000000UL) /*!< 2 Mbps */
-#define SPIM_FREQUENCY_FREQUENCY_M4 (0x40000000UL) /*!< 4 Mbps */
-#define SPIM_FREQUENCY_FREQUENCY_M8 (0x80000000UL) /*!< 8 Mbps */
-
-/* Register: SPIM_RXD_PTR */
-/* Description: Data pointer */
-
-/* Bits 31..0 : Data pointer */
-#define SPIM_RXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
-#define SPIM_RXD_PTR_PTR_Msk (0xFFFFFFFFUL << SPIM_RXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
-
-/* Register: SPIM_RXD_MAXCNT */
-/* Description: Maximum number of bytes in receive buffer */
-
-/* Bits 7..0 : Maximum number of bytes in receive buffer */
-#define SPIM_RXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
-#define SPIM_RXD_MAXCNT_MAXCNT_Msk (0xFFUL << SPIM_RXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
-
-/* Register: SPIM_RXD_AMOUNT */
-/* Description: Number of bytes transferred in the last transaction */
-
-/* Bits 7..0 : Number of bytes transferred in the last transaction */
-#define SPIM_RXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
-#define SPIM_RXD_AMOUNT_AMOUNT_Msk (0xFFUL << SPIM_RXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
-
-/* Register: SPIM_RXD_LIST */
-/* Description: EasyDMA list type */
-
-/* Bits 2..0 : List type */
-#define SPIM_RXD_LIST_LIST_Pos (0UL) /*!< Position of LIST field. */
-#define SPIM_RXD_LIST_LIST_Msk (0x7UL << SPIM_RXD_LIST_LIST_Pos) /*!< Bit mask of LIST field. */
-#define SPIM_RXD_LIST_LIST_Disabled (0UL) /*!< Disable EasyDMA list */
-#define SPIM_RXD_LIST_LIST_ArrayList (1UL) /*!< Use array list */
-
-/* Register: SPIM_TXD_PTR */
-/* Description: Data pointer */
-
-/* Bits 31..0 : Data pointer */
-#define SPIM_TXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
-#define SPIM_TXD_PTR_PTR_Msk (0xFFFFFFFFUL << SPIM_TXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
-
-/* Register: SPIM_TXD_MAXCNT */
-/* Description: Maximum number of bytes in transmit buffer */
-
-/* Bits 7..0 : Maximum number of bytes in transmit buffer */
-#define SPIM_TXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
-#define SPIM_TXD_MAXCNT_MAXCNT_Msk (0xFFUL << SPIM_TXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
-
-/* Register: SPIM_TXD_AMOUNT */
-/* Description: Number of bytes transferred in the last transaction */
-
-/* Bits 7..0 : Number of bytes transferred in the last transaction */
-#define SPIM_TXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
-#define SPIM_TXD_AMOUNT_AMOUNT_Msk (0xFFUL << SPIM_TXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
-
-/* Register: SPIM_TXD_LIST */
-/* Description: EasyDMA list type */
-
-/* Bits 2..0 : List type */
-#define SPIM_TXD_LIST_LIST_Pos (0UL) /*!< Position of LIST field. */
-#define SPIM_TXD_LIST_LIST_Msk (0x7UL << SPIM_TXD_LIST_LIST_Pos) /*!< Bit mask of LIST field. */
-#define SPIM_TXD_LIST_LIST_Disabled (0UL) /*!< Disable EasyDMA list */
-#define SPIM_TXD_LIST_LIST_ArrayList (1UL) /*!< Use array list */
-
-/* Register: SPIM_CONFIG */
-/* Description: Configuration register */
-
-/* Bit 2 : Serial clock (SCK) polarity */
-#define SPIM_CONFIG_CPOL_Pos (2UL) /*!< Position of CPOL field. */
-#define SPIM_CONFIG_CPOL_Msk (0x1UL << SPIM_CONFIG_CPOL_Pos) /*!< Bit mask of CPOL field. */
-#define SPIM_CONFIG_CPOL_ActiveHigh (0UL) /*!< Active high */
-#define SPIM_CONFIG_CPOL_ActiveLow (1UL) /*!< Active low */
-
-/* Bit 1 : Serial clock (SCK) phase */
-#define SPIM_CONFIG_CPHA_Pos (1UL) /*!< Position of CPHA field. */
-#define SPIM_CONFIG_CPHA_Msk (0x1UL << SPIM_CONFIG_CPHA_Pos) /*!< Bit mask of CPHA field. */
-#define SPIM_CONFIG_CPHA_Leading (0UL) /*!< Sample on leading edge of clock, shift serial data on trailing edge */
-#define SPIM_CONFIG_CPHA_Trailing (1UL) /*!< Sample on trailing edge of clock, shift serial data on leading edge */
-
-/* Bit 0 : Bit order */
-#define SPIM_CONFIG_ORDER_Pos (0UL) /*!< Position of ORDER field. */
-#define SPIM_CONFIG_ORDER_Msk (0x1UL << SPIM_CONFIG_ORDER_Pos) /*!< Bit mask of ORDER field. */
-#define SPIM_CONFIG_ORDER_MsbFirst (0UL) /*!< Most significant bit shifted out first */
-#define SPIM_CONFIG_ORDER_LsbFirst (1UL) /*!< Least significant bit shifted out first */
-
-/* Register: SPIM_ORC */
-/* Description: Over-read character. Character clocked out in case and over-read of the TXD buffer. */
-
-/* Bits 7..0 : Over-read character. Character clocked out in case and over-read of the TXD buffer. */
-#define SPIM_ORC_ORC_Pos (0UL) /*!< Position of ORC field. */
-#define SPIM_ORC_ORC_Msk (0xFFUL << SPIM_ORC_ORC_Pos) /*!< Bit mask of ORC field. */
-
-
-/* Peripheral: SPIS */
-/* Description: SPI Slave 0 */
-
-/* Register: SPIS_SHORTS */
-/* Description: Shortcut register */
-
-/* Bit 2 : Shortcut between END event and ACQUIRE task */
-#define SPIS_SHORTS_END_ACQUIRE_Pos (2UL) /*!< Position of END_ACQUIRE field. */
-#define SPIS_SHORTS_END_ACQUIRE_Msk (0x1UL << SPIS_SHORTS_END_ACQUIRE_Pos) /*!< Bit mask of END_ACQUIRE field. */
-#define SPIS_SHORTS_END_ACQUIRE_Disabled (0UL) /*!< Disable shortcut */
-#define SPIS_SHORTS_END_ACQUIRE_Enabled (1UL) /*!< Enable shortcut */
-
-/* Register: SPIS_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 10 : Write '1' to Enable interrupt for ACQUIRED event */
-#define SPIS_INTENSET_ACQUIRED_Pos (10UL) /*!< Position of ACQUIRED field. */
-#define SPIS_INTENSET_ACQUIRED_Msk (0x1UL << SPIS_INTENSET_ACQUIRED_Pos) /*!< Bit mask of ACQUIRED field. */
-#define SPIS_INTENSET_ACQUIRED_Disabled (0UL) /*!< Read: Disabled */
-#define SPIS_INTENSET_ACQUIRED_Enabled (1UL) /*!< Read: Enabled */
-#define SPIS_INTENSET_ACQUIRED_Set (1UL) /*!< Enable */
-
-/* Bit 4 : Write '1' to Enable interrupt for ENDRX event */
-#define SPIS_INTENSET_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
-#define SPIS_INTENSET_ENDRX_Msk (0x1UL << SPIS_INTENSET_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
-#define SPIS_INTENSET_ENDRX_Disabled (0UL) /*!< Read: Disabled */
-#define SPIS_INTENSET_ENDRX_Enabled (1UL) /*!< Read: Enabled */
-#define SPIS_INTENSET_ENDRX_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for END event */
-#define SPIS_INTENSET_END_Pos (1UL) /*!< Position of END field. */
-#define SPIS_INTENSET_END_Msk (0x1UL << SPIS_INTENSET_END_Pos) /*!< Bit mask of END field. */
-#define SPIS_INTENSET_END_Disabled (0UL) /*!< Read: Disabled */
-#define SPIS_INTENSET_END_Enabled (1UL) /*!< Read: Enabled */
-#define SPIS_INTENSET_END_Set (1UL) /*!< Enable */
-
-/* Register: SPIS_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 10 : Write '1' to Disable interrupt for ACQUIRED event */
-#define SPIS_INTENCLR_ACQUIRED_Pos (10UL) /*!< Position of ACQUIRED field. */
-#define SPIS_INTENCLR_ACQUIRED_Msk (0x1UL << SPIS_INTENCLR_ACQUIRED_Pos) /*!< Bit mask of ACQUIRED field. */
-#define SPIS_INTENCLR_ACQUIRED_Disabled (0UL) /*!< Read: Disabled */
-#define SPIS_INTENCLR_ACQUIRED_Enabled (1UL) /*!< Read: Enabled */
-#define SPIS_INTENCLR_ACQUIRED_Clear (1UL) /*!< Disable */
-
-/* Bit 4 : Write '1' to Disable interrupt for ENDRX event */
-#define SPIS_INTENCLR_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
-#define SPIS_INTENCLR_ENDRX_Msk (0x1UL << SPIS_INTENCLR_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
-#define SPIS_INTENCLR_ENDRX_Disabled (0UL) /*!< Read: Disabled */
-#define SPIS_INTENCLR_ENDRX_Enabled (1UL) /*!< Read: Enabled */
-#define SPIS_INTENCLR_ENDRX_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for END event */
-#define SPIS_INTENCLR_END_Pos (1UL) /*!< Position of END field. */
-#define SPIS_INTENCLR_END_Msk (0x1UL << SPIS_INTENCLR_END_Pos) /*!< Bit mask of END field. */
-#define SPIS_INTENCLR_END_Disabled (0UL) /*!< Read: Disabled */
-#define SPIS_INTENCLR_END_Enabled (1UL) /*!< Read: Enabled */
-#define SPIS_INTENCLR_END_Clear (1UL) /*!< Disable */
-
-/* Register: SPIS_SEMSTAT */
-/* Description: Semaphore status register */
-
-/* Bits 1..0 : Semaphore status */
-#define SPIS_SEMSTAT_SEMSTAT_Pos (0UL) /*!< Position of SEMSTAT field. */
-#define SPIS_SEMSTAT_SEMSTAT_Msk (0x3UL << SPIS_SEMSTAT_SEMSTAT_Pos) /*!< Bit mask of SEMSTAT field. */
-#define SPIS_SEMSTAT_SEMSTAT_Free (0UL) /*!< Semaphore is free */
-#define SPIS_SEMSTAT_SEMSTAT_CPU (1UL) /*!< Semaphore is assigned to CPU */
-#define SPIS_SEMSTAT_SEMSTAT_SPIS (2UL) /*!< Semaphore is assigned to SPI slave */
-#define SPIS_SEMSTAT_SEMSTAT_CPUPending (3UL) /*!< Semaphore is assigned to SPI but a handover to the CPU is pending */
-
-/* Register: SPIS_STATUS */
-/* Description: Status from last transaction */
-
-/* Bit 1 : RX buffer overflow detected, and prevented */
-#define SPIS_STATUS_OVERFLOW_Pos (1UL) /*!< Position of OVERFLOW field. */
-#define SPIS_STATUS_OVERFLOW_Msk (0x1UL << SPIS_STATUS_OVERFLOW_Pos) /*!< Bit mask of OVERFLOW field. */
-#define SPIS_STATUS_OVERFLOW_NotPresent (0UL) /*!< Read: error not present */
-#define SPIS_STATUS_OVERFLOW_Present (1UL) /*!< Read: error present */
-#define SPIS_STATUS_OVERFLOW_Clear (1UL) /*!< Write: clear error on writing '1' */
-
-/* Bit 0 : TX buffer over-read detected, and prevented */
-#define SPIS_STATUS_OVERREAD_Pos (0UL) /*!< Position of OVERREAD field. */
-#define SPIS_STATUS_OVERREAD_Msk (0x1UL << SPIS_STATUS_OVERREAD_Pos) /*!< Bit mask of OVERREAD field. */
-#define SPIS_STATUS_OVERREAD_NotPresent (0UL) /*!< Read: error not present */
-#define SPIS_STATUS_OVERREAD_Present (1UL) /*!< Read: error present */
-#define SPIS_STATUS_OVERREAD_Clear (1UL) /*!< Write: clear error on writing '1' */
-
-/* Register: SPIS_ENABLE */
-/* Description: Enable SPI slave */
-
-/* Bits 3..0 : Enable or disable SPI slave */
-#define SPIS_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
-#define SPIS_ENABLE_ENABLE_Msk (0xFUL << SPIS_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
-#define SPIS_ENABLE_ENABLE_Disabled (0UL) /*!< Disable SPI slave */
-#define SPIS_ENABLE_ENABLE_Enabled (2UL) /*!< Enable SPI slave */
-
-/* Register: SPIS_PSEL_SCK */
-/* Description: Pin select for SCK */
-
-/* Bit 31 : Connection */
-#define SPIS_PSEL_SCK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define SPIS_PSEL_SCK_CONNECT_Msk (0x1UL << SPIS_PSEL_SCK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define SPIS_PSEL_SCK_CONNECT_Connected (0UL) /*!< Connect */
-#define SPIS_PSEL_SCK_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define SPIS_PSEL_SCK_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define SPIS_PSEL_SCK_PIN_Msk (0x1FUL << SPIS_PSEL_SCK_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: SPIS_PSEL_MISO */
-/* Description: Pin select for MISO signal */
-
-/* Bit 31 : Connection */
-#define SPIS_PSEL_MISO_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define SPIS_PSEL_MISO_CONNECT_Msk (0x1UL << SPIS_PSEL_MISO_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define SPIS_PSEL_MISO_CONNECT_Connected (0UL) /*!< Connect */
-#define SPIS_PSEL_MISO_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define SPIS_PSEL_MISO_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define SPIS_PSEL_MISO_PIN_Msk (0x1FUL << SPIS_PSEL_MISO_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: SPIS_PSEL_MOSI */
-/* Description: Pin select for MOSI signal */
-
-/* Bit 31 : Connection */
-#define SPIS_PSEL_MOSI_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define SPIS_PSEL_MOSI_CONNECT_Msk (0x1UL << SPIS_PSEL_MOSI_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define SPIS_PSEL_MOSI_CONNECT_Connected (0UL) /*!< Connect */
-#define SPIS_PSEL_MOSI_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define SPIS_PSEL_MOSI_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define SPIS_PSEL_MOSI_PIN_Msk (0x1FUL << SPIS_PSEL_MOSI_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: SPIS_PSEL_CSN */
-/* Description: Pin select for CSN signal */
-
-/* Bit 31 : Connection */
-#define SPIS_PSEL_CSN_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define SPIS_PSEL_CSN_CONNECT_Msk (0x1UL << SPIS_PSEL_CSN_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define SPIS_PSEL_CSN_CONNECT_Connected (0UL) /*!< Connect */
-#define SPIS_PSEL_CSN_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define SPIS_PSEL_CSN_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define SPIS_PSEL_CSN_PIN_Msk (0x1FUL << SPIS_PSEL_CSN_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: SPIS_RXD_PTR */
-/* Description: RXD data pointer */
-
-/* Bits 31..0 : RXD data pointer */
-#define SPIS_RXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
-#define SPIS_RXD_PTR_PTR_Msk (0xFFFFFFFFUL << SPIS_RXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
-
-/* Register: SPIS_RXD_MAXCNT */
-/* Description: Maximum number of bytes in receive buffer */
-
-/* Bits 7..0 : Maximum number of bytes in receive buffer */
-#define SPIS_RXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
-#define SPIS_RXD_MAXCNT_MAXCNT_Msk (0xFFUL << SPIS_RXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
-
-/* Register: SPIS_RXD_AMOUNT */
-/* Description: Number of bytes received in last granted transaction */
-
-/* Bits 7..0 : Number of bytes received in the last granted transaction */
-#define SPIS_RXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
-#define SPIS_RXD_AMOUNT_AMOUNT_Msk (0xFFUL << SPIS_RXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
-
-/* Register: SPIS_TXD_PTR */
-/* Description: TXD data pointer */
-
-/* Bits 31..0 : TXD data pointer */
-#define SPIS_TXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
-#define SPIS_TXD_PTR_PTR_Msk (0xFFFFFFFFUL << SPIS_TXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
-
-/* Register: SPIS_TXD_MAXCNT */
-/* Description: Maximum number of bytes in transmit buffer */
-
-/* Bits 7..0 : Maximum number of bytes in transmit buffer */
-#define SPIS_TXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
-#define SPIS_TXD_MAXCNT_MAXCNT_Msk (0xFFUL << SPIS_TXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
-
-/* Register: SPIS_TXD_AMOUNT */
-/* Description: Number of bytes transmitted in last granted transaction */
-
-/* Bits 7..0 : Number of bytes transmitted in last granted transaction */
-#define SPIS_TXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
-#define SPIS_TXD_AMOUNT_AMOUNT_Msk (0xFFUL << SPIS_TXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
-
-/* Register: SPIS_CONFIG */
-/* Description: Configuration register */
-
-/* Bit 2 : Serial clock (SCK) polarity */
-#define SPIS_CONFIG_CPOL_Pos (2UL) /*!< Position of CPOL field. */
-#define SPIS_CONFIG_CPOL_Msk (0x1UL << SPIS_CONFIG_CPOL_Pos) /*!< Bit mask of CPOL field. */
-#define SPIS_CONFIG_CPOL_ActiveHigh (0UL) /*!< Active high */
-#define SPIS_CONFIG_CPOL_ActiveLow (1UL) /*!< Active low */
-
-/* Bit 1 : Serial clock (SCK) phase */
-#define SPIS_CONFIG_CPHA_Pos (1UL) /*!< Position of CPHA field. */
-#define SPIS_CONFIG_CPHA_Msk (0x1UL << SPIS_CONFIG_CPHA_Pos) /*!< Bit mask of CPHA field. */
-#define SPIS_CONFIG_CPHA_Leading (0UL) /*!< Sample on leading edge of clock, shift serial data on trailing edge */
-#define SPIS_CONFIG_CPHA_Trailing (1UL) /*!< Sample on trailing edge of clock, shift serial data on leading edge */
-
-/* Bit 0 : Bit order */
-#define SPIS_CONFIG_ORDER_Pos (0UL) /*!< Position of ORDER field. */
-#define SPIS_CONFIG_ORDER_Msk (0x1UL << SPIS_CONFIG_ORDER_Pos) /*!< Bit mask of ORDER field. */
-#define SPIS_CONFIG_ORDER_MsbFirst (0UL) /*!< Most significant bit shifted out first */
-#define SPIS_CONFIG_ORDER_LsbFirst (1UL) /*!< Least significant bit shifted out first */
-
-/* Register: SPIS_DEF */
-/* Description: Default character. Character clocked out in case of an ignored transaction. */
-
-/* Bits 7..0 : Default character. Character clocked out in case of an ignored transaction. */
-#define SPIS_DEF_DEF_Pos (0UL) /*!< Position of DEF field. */
-#define SPIS_DEF_DEF_Msk (0xFFUL << SPIS_DEF_DEF_Pos) /*!< Bit mask of DEF field. */
-
-/* Register: SPIS_ORC */
-/* Description: Over-read character */
-
-/* Bits 7..0 : Over-read character. Character clocked out after an over-read of the transmit buffer. */
-#define SPIS_ORC_ORC_Pos (0UL) /*!< Position of ORC field. */
-#define SPIS_ORC_ORC_Msk (0xFFUL << SPIS_ORC_ORC_Pos) /*!< Bit mask of ORC field. */
-
-
-/* Peripheral: TEMP */
-/* Description: Temperature Sensor */
-
-/* Register: TEMP_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 0 : Write '1' to Enable interrupt for DATARDY event */
-#define TEMP_INTENSET_DATARDY_Pos (0UL) /*!< Position of DATARDY field. */
-#define TEMP_INTENSET_DATARDY_Msk (0x1UL << TEMP_INTENSET_DATARDY_Pos) /*!< Bit mask of DATARDY field. */
-#define TEMP_INTENSET_DATARDY_Disabled (0UL) /*!< Read: Disabled */
-#define TEMP_INTENSET_DATARDY_Enabled (1UL) /*!< Read: Enabled */
-#define TEMP_INTENSET_DATARDY_Set (1UL) /*!< Enable */
-
-/* Register: TEMP_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 0 : Write '1' to Disable interrupt for DATARDY event */
-#define TEMP_INTENCLR_DATARDY_Pos (0UL) /*!< Position of DATARDY field. */
-#define TEMP_INTENCLR_DATARDY_Msk (0x1UL << TEMP_INTENCLR_DATARDY_Pos) /*!< Bit mask of DATARDY field. */
-#define TEMP_INTENCLR_DATARDY_Disabled (0UL) /*!< Read: Disabled */
-#define TEMP_INTENCLR_DATARDY_Enabled (1UL) /*!< Read: Enabled */
-#define TEMP_INTENCLR_DATARDY_Clear (1UL) /*!< Disable */
-
-/* Register: TEMP_TEMP */
-/* Description: Temperature in degC (0.25deg steps) */
-
-/* Bits 31..0 : Temperature in degC (0.25deg steps) */
-#define TEMP_TEMP_TEMP_Pos (0UL) /*!< Position of TEMP field. */
-#define TEMP_TEMP_TEMP_Msk (0xFFFFFFFFUL << TEMP_TEMP_TEMP_Pos) /*!< Bit mask of TEMP field. */
-
-/* Register: TEMP_A0 */
-/* Description: Slope of 1st piece wise linear function */
-
-/* Bits 11..0 : Slope of 1st piece wise linear function */
-#define TEMP_A0_A0_Pos (0UL) /*!< Position of A0 field. */
-#define TEMP_A0_A0_Msk (0xFFFUL << TEMP_A0_A0_Pos) /*!< Bit mask of A0 field. */
-
-/* Register: TEMP_A1 */
-/* Description: Slope of 2nd piece wise linear function */
-
-/* Bits 11..0 : Slope of 2nd piece wise linear function */
-#define TEMP_A1_A1_Pos (0UL) /*!< Position of A1 field. */
-#define TEMP_A1_A1_Msk (0xFFFUL << TEMP_A1_A1_Pos) /*!< Bit mask of A1 field. */
-
-/* Register: TEMP_A2 */
-/* Description: Slope of 3rd piece wise linear function */
-
-/* Bits 11..0 : Slope of 3rd piece wise linear function */
-#define TEMP_A2_A2_Pos (0UL) /*!< Position of A2 field. */
-#define TEMP_A2_A2_Msk (0xFFFUL << TEMP_A2_A2_Pos) /*!< Bit mask of A2 field. */
-
-/* Register: TEMP_A3 */
-/* Description: Slope of 4th piece wise linear function */
-
-/* Bits 11..0 : Slope of 4th piece wise linear function */
-#define TEMP_A3_A3_Pos (0UL) /*!< Position of A3 field. */
-#define TEMP_A3_A3_Msk (0xFFFUL << TEMP_A3_A3_Pos) /*!< Bit mask of A3 field. */
-
-/* Register: TEMP_A4 */
-/* Description: Slope of 5th piece wise linear function */
-
-/* Bits 11..0 : Slope of 5th piece wise linear function */
-#define TEMP_A4_A4_Pos (0UL) /*!< Position of A4 field. */
-#define TEMP_A4_A4_Msk (0xFFFUL << TEMP_A4_A4_Pos) /*!< Bit mask of A4 field. */
-
-/* Register: TEMP_A5 */
-/* Description: Slope of 6th piece wise linear function */
-
-/* Bits 11..0 : Slope of 6th piece wise linear function */
-#define TEMP_A5_A5_Pos (0UL) /*!< Position of A5 field. */
-#define TEMP_A5_A5_Msk (0xFFFUL << TEMP_A5_A5_Pos) /*!< Bit mask of A5 field. */
-
-/* Register: TEMP_B0 */
-/* Description: y-intercept of 1st piece wise linear function */
-
-/* Bits 13..0 : y-intercept of 1st piece wise linear function */
-#define TEMP_B0_B0_Pos (0UL) /*!< Position of B0 field. */
-#define TEMP_B0_B0_Msk (0x3FFFUL << TEMP_B0_B0_Pos) /*!< Bit mask of B0 field. */
-
-/* Register: TEMP_B1 */
-/* Description: y-intercept of 2nd piece wise linear function */
-
-/* Bits 13..0 : y-intercept of 2nd piece wise linear function */
-#define TEMP_B1_B1_Pos (0UL) /*!< Position of B1 field. */
-#define TEMP_B1_B1_Msk (0x3FFFUL << TEMP_B1_B1_Pos) /*!< Bit mask of B1 field. */
-
-/* Register: TEMP_B2 */
-/* Description: y-intercept of 3rd piece wise linear function */
-
-/* Bits 13..0 : y-intercept of 3rd piece wise linear function */
-#define TEMP_B2_B2_Pos (0UL) /*!< Position of B2 field. */
-#define TEMP_B2_B2_Msk (0x3FFFUL << TEMP_B2_B2_Pos) /*!< Bit mask of B2 field. */
-
-/* Register: TEMP_B3 */
-/* Description: y-intercept of 4th piece wise linear function */
-
-/* Bits 13..0 : y-intercept of 4th piece wise linear function */
-#define TEMP_B3_B3_Pos (0UL) /*!< Position of B3 field. */
-#define TEMP_B3_B3_Msk (0x3FFFUL << TEMP_B3_B3_Pos) /*!< Bit mask of B3 field. */
-
-/* Register: TEMP_B4 */
-/* Description: y-intercept of 5th piece wise linear function */
-
-/* Bits 13..0 : y-intercept of 5th piece wise linear function */
-#define TEMP_B4_B4_Pos (0UL) /*!< Position of B4 field. */
-#define TEMP_B4_B4_Msk (0x3FFFUL << TEMP_B4_B4_Pos) /*!< Bit mask of B4 field. */
-
-/* Register: TEMP_B5 */
-/* Description: y-intercept of 6th piece wise linear function */
-
-/* Bits 13..0 : y-intercept of 6th piece wise linear function */
-#define TEMP_B5_B5_Pos (0UL) /*!< Position of B5 field. */
-#define TEMP_B5_B5_Msk (0x3FFFUL << TEMP_B5_B5_Pos) /*!< Bit mask of B5 field. */
-
-/* Register: TEMP_T0 */
-/* Description: End point of 1st piece wise linear function */
-
-/* Bits 7..0 : End point of 1st piece wise linear function */
-#define TEMP_T0_T0_Pos (0UL) /*!< Position of T0 field. */
-#define TEMP_T0_T0_Msk (0xFFUL << TEMP_T0_T0_Pos) /*!< Bit mask of T0 field. */
-
-/* Register: TEMP_T1 */
-/* Description: End point of 2nd piece wise linear function */
-
-/* Bits 7..0 : End point of 2nd piece wise linear function */
-#define TEMP_T1_T1_Pos (0UL) /*!< Position of T1 field. */
-#define TEMP_T1_T1_Msk (0xFFUL << TEMP_T1_T1_Pos) /*!< Bit mask of T1 field. */
-
-/* Register: TEMP_T2 */
-/* Description: End point of 3rd piece wise linear function */
-
-/* Bits 7..0 : End point of 3rd piece wise linear function */
-#define TEMP_T2_T2_Pos (0UL) /*!< Position of T2 field. */
-#define TEMP_T2_T2_Msk (0xFFUL << TEMP_T2_T2_Pos) /*!< Bit mask of T2 field. */
-
-/* Register: TEMP_T3 */
-/* Description: End point of 4th piece wise linear function */
-
-/* Bits 7..0 : End point of 4th piece wise linear function */
-#define TEMP_T3_T3_Pos (0UL) /*!< Position of T3 field. */
-#define TEMP_T3_T3_Msk (0xFFUL << TEMP_T3_T3_Pos) /*!< Bit mask of T3 field. */
-
-/* Register: TEMP_T4 */
-/* Description: End point of 5th piece wise linear function */
-
-/* Bits 7..0 : End point of 5th piece wise linear function */
-#define TEMP_T4_T4_Pos (0UL) /*!< Position of T4 field. */
-#define TEMP_T4_T4_Msk (0xFFUL << TEMP_T4_T4_Pos) /*!< Bit mask of T4 field. */
-
-
-/* Peripheral: TIMER */
-/* Description: Timer/Counter 0 */
-
-/* Register: TIMER_SHORTS */
-/* Description: Shortcut register */
-
-/* Bit 13 : Shortcut between COMPARE[5] event and STOP task */
-#define TIMER_SHORTS_COMPARE5_STOP_Pos (13UL) /*!< Position of COMPARE5_STOP field. */
-#define TIMER_SHORTS_COMPARE5_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE5_STOP_Pos) /*!< Bit mask of COMPARE5_STOP field. */
-#define TIMER_SHORTS_COMPARE5_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define TIMER_SHORTS_COMPARE5_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 12 : Shortcut between COMPARE[4] event and STOP task */
-#define TIMER_SHORTS_COMPARE4_STOP_Pos (12UL) /*!< Position of COMPARE4_STOP field. */
-#define TIMER_SHORTS_COMPARE4_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE4_STOP_Pos) /*!< Bit mask of COMPARE4_STOP field. */
-#define TIMER_SHORTS_COMPARE4_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define TIMER_SHORTS_COMPARE4_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 11 : Shortcut between COMPARE[3] event and STOP task */
-#define TIMER_SHORTS_COMPARE3_STOP_Pos (11UL) /*!< Position of COMPARE3_STOP field. */
-#define TIMER_SHORTS_COMPARE3_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE3_STOP_Pos) /*!< Bit mask of COMPARE3_STOP field. */
-#define TIMER_SHORTS_COMPARE3_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define TIMER_SHORTS_COMPARE3_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 10 : Shortcut between COMPARE[2] event and STOP task */
-#define TIMER_SHORTS_COMPARE2_STOP_Pos (10UL) /*!< Position of COMPARE2_STOP field. */
-#define TIMER_SHORTS_COMPARE2_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE2_STOP_Pos) /*!< Bit mask of COMPARE2_STOP field. */
-#define TIMER_SHORTS_COMPARE2_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define TIMER_SHORTS_COMPARE2_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 9 : Shortcut between COMPARE[1] event and STOP task */
-#define TIMER_SHORTS_COMPARE1_STOP_Pos (9UL) /*!< Position of COMPARE1_STOP field. */
-#define TIMER_SHORTS_COMPARE1_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE1_STOP_Pos) /*!< Bit mask of COMPARE1_STOP field. */
-#define TIMER_SHORTS_COMPARE1_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define TIMER_SHORTS_COMPARE1_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 8 : Shortcut between COMPARE[0] event and STOP task */
-#define TIMER_SHORTS_COMPARE0_STOP_Pos (8UL) /*!< Position of COMPARE0_STOP field. */
-#define TIMER_SHORTS_COMPARE0_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE0_STOP_Pos) /*!< Bit mask of COMPARE0_STOP field. */
-#define TIMER_SHORTS_COMPARE0_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define TIMER_SHORTS_COMPARE0_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 5 : Shortcut between COMPARE[5] event and CLEAR task */
-#define TIMER_SHORTS_COMPARE5_CLEAR_Pos (5UL) /*!< Position of COMPARE5_CLEAR field. */
-#define TIMER_SHORTS_COMPARE5_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE5_CLEAR_Pos) /*!< Bit mask of COMPARE5_CLEAR field. */
-#define TIMER_SHORTS_COMPARE5_CLEAR_Disabled (0UL) /*!< Disable shortcut */
-#define TIMER_SHORTS_COMPARE5_CLEAR_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 4 : Shortcut between COMPARE[4] event and CLEAR task */
-#define TIMER_SHORTS_COMPARE4_CLEAR_Pos (4UL) /*!< Position of COMPARE4_CLEAR field. */
-#define TIMER_SHORTS_COMPARE4_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE4_CLEAR_Pos) /*!< Bit mask of COMPARE4_CLEAR field. */
-#define TIMER_SHORTS_COMPARE4_CLEAR_Disabled (0UL) /*!< Disable shortcut */
-#define TIMER_SHORTS_COMPARE4_CLEAR_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 3 : Shortcut between COMPARE[3] event and CLEAR task */
-#define TIMER_SHORTS_COMPARE3_CLEAR_Pos (3UL) /*!< Position of COMPARE3_CLEAR field. */
-#define TIMER_SHORTS_COMPARE3_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE3_CLEAR_Pos) /*!< Bit mask of COMPARE3_CLEAR field. */
-#define TIMER_SHORTS_COMPARE3_CLEAR_Disabled (0UL) /*!< Disable shortcut */
-#define TIMER_SHORTS_COMPARE3_CLEAR_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 2 : Shortcut between COMPARE[2] event and CLEAR task */
-#define TIMER_SHORTS_COMPARE2_CLEAR_Pos (2UL) /*!< Position of COMPARE2_CLEAR field. */
-#define TIMER_SHORTS_COMPARE2_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE2_CLEAR_Pos) /*!< Bit mask of COMPARE2_CLEAR field. */
-#define TIMER_SHORTS_COMPARE2_CLEAR_Disabled (0UL) /*!< Disable shortcut */
-#define TIMER_SHORTS_COMPARE2_CLEAR_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 1 : Shortcut between COMPARE[1] event and CLEAR task */
-#define TIMER_SHORTS_COMPARE1_CLEAR_Pos (1UL) /*!< Position of COMPARE1_CLEAR field. */
-#define TIMER_SHORTS_COMPARE1_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE1_CLEAR_Pos) /*!< Bit mask of COMPARE1_CLEAR field. */
-#define TIMER_SHORTS_COMPARE1_CLEAR_Disabled (0UL) /*!< Disable shortcut */
-#define TIMER_SHORTS_COMPARE1_CLEAR_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 0 : Shortcut between COMPARE[0] event and CLEAR task */
-#define TIMER_SHORTS_COMPARE0_CLEAR_Pos (0UL) /*!< Position of COMPARE0_CLEAR field. */
-#define TIMER_SHORTS_COMPARE0_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE0_CLEAR_Pos) /*!< Bit mask of COMPARE0_CLEAR field. */
-#define TIMER_SHORTS_COMPARE0_CLEAR_Disabled (0UL) /*!< Disable shortcut */
-#define TIMER_SHORTS_COMPARE0_CLEAR_Enabled (1UL) /*!< Enable shortcut */
-
-/* Register: TIMER_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 21 : Write '1' to Enable interrupt for COMPARE[5] event */
-#define TIMER_INTENSET_COMPARE5_Pos (21UL) /*!< Position of COMPARE5 field. */
-#define TIMER_INTENSET_COMPARE5_Msk (0x1UL << TIMER_INTENSET_COMPARE5_Pos) /*!< Bit mask of COMPARE5 field. */
-#define TIMER_INTENSET_COMPARE5_Disabled (0UL) /*!< Read: Disabled */
-#define TIMER_INTENSET_COMPARE5_Enabled (1UL) /*!< Read: Enabled */
-#define TIMER_INTENSET_COMPARE5_Set (1UL) /*!< Enable */
-
-/* Bit 20 : Write '1' to Enable interrupt for COMPARE[4] event */
-#define TIMER_INTENSET_COMPARE4_Pos (20UL) /*!< Position of COMPARE4 field. */
-#define TIMER_INTENSET_COMPARE4_Msk (0x1UL << TIMER_INTENSET_COMPARE4_Pos) /*!< Bit mask of COMPARE4 field. */
-#define TIMER_INTENSET_COMPARE4_Disabled (0UL) /*!< Read: Disabled */
-#define TIMER_INTENSET_COMPARE4_Enabled (1UL) /*!< Read: Enabled */
-#define TIMER_INTENSET_COMPARE4_Set (1UL) /*!< Enable */
-
-/* Bit 19 : Write '1' to Enable interrupt for COMPARE[3] event */
-#define TIMER_INTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
-#define TIMER_INTENSET_COMPARE3_Msk (0x1UL << TIMER_INTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
-#define TIMER_INTENSET_COMPARE3_Disabled (0UL) /*!< Read: Disabled */
-#define TIMER_INTENSET_COMPARE3_Enabled (1UL) /*!< Read: Enabled */
-#define TIMER_INTENSET_COMPARE3_Set (1UL) /*!< Enable */
-
-/* Bit 18 : Write '1' to Enable interrupt for COMPARE[2] event */
-#define TIMER_INTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
-#define TIMER_INTENSET_COMPARE2_Msk (0x1UL << TIMER_INTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
-#define TIMER_INTENSET_COMPARE2_Disabled (0UL) /*!< Read: Disabled */
-#define TIMER_INTENSET_COMPARE2_Enabled (1UL) /*!< Read: Enabled */
-#define TIMER_INTENSET_COMPARE2_Set (1UL) /*!< Enable */
-
-/* Bit 17 : Write '1' to Enable interrupt for COMPARE[1] event */
-#define TIMER_INTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
-#define TIMER_INTENSET_COMPARE1_Msk (0x1UL << TIMER_INTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
-#define TIMER_INTENSET_COMPARE1_Disabled (0UL) /*!< Read: Disabled */
-#define TIMER_INTENSET_COMPARE1_Enabled (1UL) /*!< Read: Enabled */
-#define TIMER_INTENSET_COMPARE1_Set (1UL) /*!< Enable */
-
-/* Bit 16 : Write '1' to Enable interrupt for COMPARE[0] event */
-#define TIMER_INTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
-#define TIMER_INTENSET_COMPARE0_Msk (0x1UL << TIMER_INTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
-#define TIMER_INTENSET_COMPARE0_Disabled (0UL) /*!< Read: Disabled */
-#define TIMER_INTENSET_COMPARE0_Enabled (1UL) /*!< Read: Enabled */
-#define TIMER_INTENSET_COMPARE0_Set (1UL) /*!< Enable */
-
-/* Register: TIMER_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 21 : Write '1' to Disable interrupt for COMPARE[5] event */
-#define TIMER_INTENCLR_COMPARE5_Pos (21UL) /*!< Position of COMPARE5 field. */
-#define TIMER_INTENCLR_COMPARE5_Msk (0x1UL << TIMER_INTENCLR_COMPARE5_Pos) /*!< Bit mask of COMPARE5 field. */
-#define TIMER_INTENCLR_COMPARE5_Disabled (0UL) /*!< Read: Disabled */
-#define TIMER_INTENCLR_COMPARE5_Enabled (1UL) /*!< Read: Enabled */
-#define TIMER_INTENCLR_COMPARE5_Clear (1UL) /*!< Disable */
-
-/* Bit 20 : Write '1' to Disable interrupt for COMPARE[4] event */
-#define TIMER_INTENCLR_COMPARE4_Pos (20UL) /*!< Position of COMPARE4 field. */
-#define TIMER_INTENCLR_COMPARE4_Msk (0x1UL << TIMER_INTENCLR_COMPARE4_Pos) /*!< Bit mask of COMPARE4 field. */
-#define TIMER_INTENCLR_COMPARE4_Disabled (0UL) /*!< Read: Disabled */
-#define TIMER_INTENCLR_COMPARE4_Enabled (1UL) /*!< Read: Enabled */
-#define TIMER_INTENCLR_COMPARE4_Clear (1UL) /*!< Disable */
-
-/* Bit 19 : Write '1' to Disable interrupt for COMPARE[3] event */
-#define TIMER_INTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
-#define TIMER_INTENCLR_COMPARE3_Msk (0x1UL << TIMER_INTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
-#define TIMER_INTENCLR_COMPARE3_Disabled (0UL) /*!< Read: Disabled */
-#define TIMER_INTENCLR_COMPARE3_Enabled (1UL) /*!< Read: Enabled */
-#define TIMER_INTENCLR_COMPARE3_Clear (1UL) /*!< Disable */
-
-/* Bit 18 : Write '1' to Disable interrupt for COMPARE[2] event */
-#define TIMER_INTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
-#define TIMER_INTENCLR_COMPARE2_Msk (0x1UL << TIMER_INTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
-#define TIMER_INTENCLR_COMPARE2_Disabled (0UL) /*!< Read: Disabled */
-#define TIMER_INTENCLR_COMPARE2_Enabled (1UL) /*!< Read: Enabled */
-#define TIMER_INTENCLR_COMPARE2_Clear (1UL) /*!< Disable */
-
-/* Bit 17 : Write '1' to Disable interrupt for COMPARE[1] event */
-#define TIMER_INTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
-#define TIMER_INTENCLR_COMPARE1_Msk (0x1UL << TIMER_INTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
-#define TIMER_INTENCLR_COMPARE1_Disabled (0UL) /*!< Read: Disabled */
-#define TIMER_INTENCLR_COMPARE1_Enabled (1UL) /*!< Read: Enabled */
-#define TIMER_INTENCLR_COMPARE1_Clear (1UL) /*!< Disable */
-
-/* Bit 16 : Write '1' to Disable interrupt for COMPARE[0] event */
-#define TIMER_INTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
-#define TIMER_INTENCLR_COMPARE0_Msk (0x1UL << TIMER_INTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
-#define TIMER_INTENCLR_COMPARE0_Disabled (0UL) /*!< Read: Disabled */
-#define TIMER_INTENCLR_COMPARE0_Enabled (1UL) /*!< Read: Enabled */
-#define TIMER_INTENCLR_COMPARE0_Clear (1UL) /*!< Disable */
-
-/* Register: TIMER_MODE */
-/* Description: Timer mode selection */
-
-/* Bits 1..0 : Timer mode */
-#define TIMER_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
-#define TIMER_MODE_MODE_Msk (0x3UL << TIMER_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
-#define TIMER_MODE_MODE_Timer (0UL) /*!< Select Timer mode */
-#define TIMER_MODE_MODE_Counter (1UL) /*!< Deprecated enumerator -  Select Counter mode */
-#define TIMER_MODE_MODE_LowPowerCounter (2UL) /*!< Select Low Power Counter mode */
-
-/* Register: TIMER_BITMODE */
-/* Description: Configure the number of bits used by the TIMER */
-
-/* Bits 1..0 : Timer bit width */
-#define TIMER_BITMODE_BITMODE_Pos (0UL) /*!< Position of BITMODE field. */
-#define TIMER_BITMODE_BITMODE_Msk (0x3UL << TIMER_BITMODE_BITMODE_Pos) /*!< Bit mask of BITMODE field. */
-#define TIMER_BITMODE_BITMODE_16Bit (0UL) /*!< 16 bit timer bit width */
-#define TIMER_BITMODE_BITMODE_08Bit (1UL) /*!< 8 bit timer bit width */
-#define TIMER_BITMODE_BITMODE_24Bit (2UL) /*!< 24 bit timer bit width */
-#define TIMER_BITMODE_BITMODE_32Bit (3UL) /*!< 32 bit timer bit width */
-
-/* Register: TIMER_PRESCALER */
-/* Description: Timer prescaler register */
-
-/* Bits 3..0 : Prescaler value */
-#define TIMER_PRESCALER_PRESCALER_Pos (0UL) /*!< Position of PRESCALER field. */
-#define TIMER_PRESCALER_PRESCALER_Msk (0xFUL << TIMER_PRESCALER_PRESCALER_Pos) /*!< Bit mask of PRESCALER field. */
-
-/* Register: TIMER_CC */
-/* Description: Description collection[0]:  Capture/Compare register 0 */
-
-/* Bits 31..0 : Capture/Compare value */
-#define TIMER_CC_CC_Pos (0UL) /*!< Position of CC field. */
-#define TIMER_CC_CC_Msk (0xFFFFFFFFUL << TIMER_CC_CC_Pos) /*!< Bit mask of CC field. */
-
-
-/* Peripheral: TWI */
-/* Description: I2C compatible Two-Wire Interface 0 */
-
-/* Register: TWI_SHORTS */
-/* Description: Shortcut register */
-
-/* Bit 1 : Shortcut between BB event and STOP task */
-#define TWI_SHORTS_BB_STOP_Pos (1UL) /*!< Position of BB_STOP field. */
-#define TWI_SHORTS_BB_STOP_Msk (0x1UL << TWI_SHORTS_BB_STOP_Pos) /*!< Bit mask of BB_STOP field. */
-#define TWI_SHORTS_BB_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define TWI_SHORTS_BB_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 0 : Shortcut between BB event and SUSPEND task */
-#define TWI_SHORTS_BB_SUSPEND_Pos (0UL) /*!< Position of BB_SUSPEND field. */
-#define TWI_SHORTS_BB_SUSPEND_Msk (0x1UL << TWI_SHORTS_BB_SUSPEND_Pos) /*!< Bit mask of BB_SUSPEND field. */
-#define TWI_SHORTS_BB_SUSPEND_Disabled (0UL) /*!< Disable shortcut */
-#define TWI_SHORTS_BB_SUSPEND_Enabled (1UL) /*!< Enable shortcut */
-
-/* Register: TWI_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 18 : Write '1' to Enable interrupt for SUSPENDED event */
-#define TWI_INTENSET_SUSPENDED_Pos (18UL) /*!< Position of SUSPENDED field. */
-#define TWI_INTENSET_SUSPENDED_Msk (0x1UL << TWI_INTENSET_SUSPENDED_Pos) /*!< Bit mask of SUSPENDED field. */
-#define TWI_INTENSET_SUSPENDED_Disabled (0UL) /*!< Read: Disabled */
-#define TWI_INTENSET_SUSPENDED_Enabled (1UL) /*!< Read: Enabled */
-#define TWI_INTENSET_SUSPENDED_Set (1UL) /*!< Enable */
-
-/* Bit 14 : Write '1' to Enable interrupt for BB event */
-#define TWI_INTENSET_BB_Pos (14UL) /*!< Position of BB field. */
-#define TWI_INTENSET_BB_Msk (0x1UL << TWI_INTENSET_BB_Pos) /*!< Bit mask of BB field. */
-#define TWI_INTENSET_BB_Disabled (0UL) /*!< Read: Disabled */
-#define TWI_INTENSET_BB_Enabled (1UL) /*!< Read: Enabled */
-#define TWI_INTENSET_BB_Set (1UL) /*!< Enable */
-
-/* Bit 9 : Write '1' to Enable interrupt for ERROR event */
-#define TWI_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
-#define TWI_INTENSET_ERROR_Msk (0x1UL << TWI_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
-#define TWI_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
-#define TWI_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
-#define TWI_INTENSET_ERROR_Set (1UL) /*!< Enable */
-
-/* Bit 7 : Write '1' to Enable interrupt for TXDSENT event */
-#define TWI_INTENSET_TXDSENT_Pos (7UL) /*!< Position of TXDSENT field. */
-#define TWI_INTENSET_TXDSENT_Msk (0x1UL << TWI_INTENSET_TXDSENT_Pos) /*!< Bit mask of TXDSENT field. */
-#define TWI_INTENSET_TXDSENT_Disabled (0UL) /*!< Read: Disabled */
-#define TWI_INTENSET_TXDSENT_Enabled (1UL) /*!< Read: Enabled */
-#define TWI_INTENSET_TXDSENT_Set (1UL) /*!< Enable */
-
-/* Bit 2 : Write '1' to Enable interrupt for RXDREADY event */
-#define TWI_INTENSET_RXDREADY_Pos (2UL) /*!< Position of RXDREADY field. */
-#define TWI_INTENSET_RXDREADY_Msk (0x1UL << TWI_INTENSET_RXDREADY_Pos) /*!< Bit mask of RXDREADY field. */
-#define TWI_INTENSET_RXDREADY_Disabled (0UL) /*!< Read: Disabled */
-#define TWI_INTENSET_RXDREADY_Enabled (1UL) /*!< Read: Enabled */
-#define TWI_INTENSET_RXDREADY_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for STOPPED event */
-#define TWI_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
-#define TWI_INTENSET_STOPPED_Msk (0x1UL << TWI_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define TWI_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define TWI_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define TWI_INTENSET_STOPPED_Set (1UL) /*!< Enable */
-
-/* Register: TWI_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 18 : Write '1' to Disable interrupt for SUSPENDED event */
-#define TWI_INTENCLR_SUSPENDED_Pos (18UL) /*!< Position of SUSPENDED field. */
-#define TWI_INTENCLR_SUSPENDED_Msk (0x1UL << TWI_INTENCLR_SUSPENDED_Pos) /*!< Bit mask of SUSPENDED field. */
-#define TWI_INTENCLR_SUSPENDED_Disabled (0UL) /*!< Read: Disabled */
-#define TWI_INTENCLR_SUSPENDED_Enabled (1UL) /*!< Read: Enabled */
-#define TWI_INTENCLR_SUSPENDED_Clear (1UL) /*!< Disable */
-
-/* Bit 14 : Write '1' to Disable interrupt for BB event */
-#define TWI_INTENCLR_BB_Pos (14UL) /*!< Position of BB field. */
-#define TWI_INTENCLR_BB_Msk (0x1UL << TWI_INTENCLR_BB_Pos) /*!< Bit mask of BB field. */
-#define TWI_INTENCLR_BB_Disabled (0UL) /*!< Read: Disabled */
-#define TWI_INTENCLR_BB_Enabled (1UL) /*!< Read: Enabled */
-#define TWI_INTENCLR_BB_Clear (1UL) /*!< Disable */
-
-/* Bit 9 : Write '1' to Disable interrupt for ERROR event */
-#define TWI_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
-#define TWI_INTENCLR_ERROR_Msk (0x1UL << TWI_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
-#define TWI_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
-#define TWI_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
-#define TWI_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
-
-/* Bit 7 : Write '1' to Disable interrupt for TXDSENT event */
-#define TWI_INTENCLR_TXDSENT_Pos (7UL) /*!< Position of TXDSENT field. */
-#define TWI_INTENCLR_TXDSENT_Msk (0x1UL << TWI_INTENCLR_TXDSENT_Pos) /*!< Bit mask of TXDSENT field. */
-#define TWI_INTENCLR_TXDSENT_Disabled (0UL) /*!< Read: Disabled */
-#define TWI_INTENCLR_TXDSENT_Enabled (1UL) /*!< Read: Enabled */
-#define TWI_INTENCLR_TXDSENT_Clear (1UL) /*!< Disable */
-
-/* Bit 2 : Write '1' to Disable interrupt for RXDREADY event */
-#define TWI_INTENCLR_RXDREADY_Pos (2UL) /*!< Position of RXDREADY field. */
-#define TWI_INTENCLR_RXDREADY_Msk (0x1UL << TWI_INTENCLR_RXDREADY_Pos) /*!< Bit mask of RXDREADY field. */
-#define TWI_INTENCLR_RXDREADY_Disabled (0UL) /*!< Read: Disabled */
-#define TWI_INTENCLR_RXDREADY_Enabled (1UL) /*!< Read: Enabled */
-#define TWI_INTENCLR_RXDREADY_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for STOPPED event */
-#define TWI_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
-#define TWI_INTENCLR_STOPPED_Msk (0x1UL << TWI_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define TWI_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define TWI_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define TWI_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
-
-/* Register: TWI_ERRORSRC */
-/* Description: Error source */
-
-/* Bit 2 : NACK received after sending a data byte (write '1' to clear) */
-#define TWI_ERRORSRC_DNACK_Pos (2UL) /*!< Position of DNACK field. */
-#define TWI_ERRORSRC_DNACK_Msk (0x1UL << TWI_ERRORSRC_DNACK_Pos) /*!< Bit mask of DNACK field. */
-#define TWI_ERRORSRC_DNACK_NotPresent (0UL) /*!< Read: error not present */
-#define TWI_ERRORSRC_DNACK_Present (1UL) /*!< Read: error present */
-#define TWI_ERRORSRC_DNACK_Clear (1UL) /*!< Write: clear error on writing '1' */
-
-/* Bit 1 : NACK received after sending the address (write '1' to clear) */
-#define TWI_ERRORSRC_ANACK_Pos (1UL) /*!< Position of ANACK field. */
-#define TWI_ERRORSRC_ANACK_Msk (0x1UL << TWI_ERRORSRC_ANACK_Pos) /*!< Bit mask of ANACK field. */
-#define TWI_ERRORSRC_ANACK_NotPresent (0UL) /*!< Read: error not present */
-#define TWI_ERRORSRC_ANACK_Present (1UL) /*!< Read: error present */
-#define TWI_ERRORSRC_ANACK_Clear (1UL) /*!< Write: clear error on writing '1' */
-
-/* Bit 0 : Overrun error */
-#define TWI_ERRORSRC_OVERRUN_Pos (0UL) /*!< Position of OVERRUN field. */
-#define TWI_ERRORSRC_OVERRUN_Msk (0x1UL << TWI_ERRORSRC_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
-#define TWI_ERRORSRC_OVERRUN_NotPresent (0UL) /*!< Read: no overrun occured */
-#define TWI_ERRORSRC_OVERRUN_Present (1UL) /*!< Read: overrun occured */
-#define TWI_ERRORSRC_OVERRUN_Clear (1UL) /*!< Write: clear error on writing '1' */
-
-/* Register: TWI_ENABLE */
-/* Description: Enable TWI */
-
-/* Bits 3..0 : Enable or disable TWI */
-#define TWI_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
-#define TWI_ENABLE_ENABLE_Msk (0xFUL << TWI_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
-#define TWI_ENABLE_ENABLE_Disabled (0UL) /*!< Disable TWI */
-#define TWI_ENABLE_ENABLE_Enabled (5UL) /*!< Enable TWI */
-
-/* Register: TWI_PSELSCL */
-/* Description: Pin select for SCL */
-
-/* Bits 31..0 : Pin number configuration for TWI SCL signal */
-#define TWI_PSELSCL_PSELSCL_Pos (0UL) /*!< Position of PSELSCL field. */
-#define TWI_PSELSCL_PSELSCL_Msk (0xFFFFFFFFUL << TWI_PSELSCL_PSELSCL_Pos) /*!< Bit mask of PSELSCL field. */
-#define TWI_PSELSCL_PSELSCL_Disconnected (0xFFFFFFFFUL) /*!< Disconnect */
-
-/* Register: TWI_PSELSDA */
-/* Description: Pin select for SDA */
-
-/* Bits 31..0 : Pin number configuration for TWI SDA signal */
-#define TWI_PSELSDA_PSELSDA_Pos (0UL) /*!< Position of PSELSDA field. */
-#define TWI_PSELSDA_PSELSDA_Msk (0xFFFFFFFFUL << TWI_PSELSDA_PSELSDA_Pos) /*!< Bit mask of PSELSDA field. */
-#define TWI_PSELSDA_PSELSDA_Disconnected (0xFFFFFFFFUL) /*!< Disconnect */
-
-/* Register: TWI_RXD */
-/* Description: RXD register */
-
-/* Bits 7..0 : RXD register */
-#define TWI_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
-#define TWI_RXD_RXD_Msk (0xFFUL << TWI_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
-
-/* Register: TWI_TXD */
-/* Description: TXD register */
-
-/* Bits 7..0 : TXD register */
-#define TWI_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
-#define TWI_TXD_TXD_Msk (0xFFUL << TWI_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
-
-/* Register: TWI_FREQUENCY */
-/* Description: TWI frequency */
-
-/* Bits 31..0 : TWI master clock frequency */
-#define TWI_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
-#define TWI_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << TWI_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
-#define TWI_FREQUENCY_FREQUENCY_K100 (0x01980000UL) /*!< 100 kbps */
-#define TWI_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250 kbps */
-#define TWI_FREQUENCY_FREQUENCY_K400 (0x06680000UL) /*!< 400 kbps (actual rate 410.256 kbps) */
-
-/* Register: TWI_ADDRESS */
-/* Description: Address used in the TWI transfer */
-
-/* Bits 6..0 : Address used in the TWI transfer */
-#define TWI_ADDRESS_ADDRESS_Pos (0UL) /*!< Position of ADDRESS field. */
-#define TWI_ADDRESS_ADDRESS_Msk (0x7FUL << TWI_ADDRESS_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
-
-
-/* Peripheral: TWIM */
-/* Description: I2C compatible Two-Wire Master Interface with EasyDMA 0 */
-
-/* Register: TWIM_SHORTS */
-/* Description: Shortcut register */
-
-/* Bit 12 : Shortcut between LASTRX event and STOP task */
-#define TWIM_SHORTS_LASTRX_STOP_Pos (12UL) /*!< Position of LASTRX_STOP field. */
-#define TWIM_SHORTS_LASTRX_STOP_Msk (0x1UL << TWIM_SHORTS_LASTRX_STOP_Pos) /*!< Bit mask of LASTRX_STOP field. */
-#define TWIM_SHORTS_LASTRX_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define TWIM_SHORTS_LASTRX_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 10 : Shortcut between LASTRX event and STARTTX task */
-#define TWIM_SHORTS_LASTRX_STARTTX_Pos (10UL) /*!< Position of LASTRX_STARTTX field. */
-#define TWIM_SHORTS_LASTRX_STARTTX_Msk (0x1UL << TWIM_SHORTS_LASTRX_STARTTX_Pos) /*!< Bit mask of LASTRX_STARTTX field. */
-#define TWIM_SHORTS_LASTRX_STARTTX_Disabled (0UL) /*!< Disable shortcut */
-#define TWIM_SHORTS_LASTRX_STARTTX_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 9 : Shortcut between LASTTX event and STOP task */
-#define TWIM_SHORTS_LASTTX_STOP_Pos (9UL) /*!< Position of LASTTX_STOP field. */
-#define TWIM_SHORTS_LASTTX_STOP_Msk (0x1UL << TWIM_SHORTS_LASTTX_STOP_Pos) /*!< Bit mask of LASTTX_STOP field. */
-#define TWIM_SHORTS_LASTTX_STOP_Disabled (0UL) /*!< Disable shortcut */
-#define TWIM_SHORTS_LASTTX_STOP_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 8 : Shortcut between LASTTX event and SUSPEND task */
-#define TWIM_SHORTS_LASTTX_SUSPEND_Pos (8UL) /*!< Position of LASTTX_SUSPEND field. */
-#define TWIM_SHORTS_LASTTX_SUSPEND_Msk (0x1UL << TWIM_SHORTS_LASTTX_SUSPEND_Pos) /*!< Bit mask of LASTTX_SUSPEND field. */
-#define TWIM_SHORTS_LASTTX_SUSPEND_Disabled (0UL) /*!< Disable shortcut */
-#define TWIM_SHORTS_LASTTX_SUSPEND_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 7 : Shortcut between LASTTX event and STARTRX task */
-#define TWIM_SHORTS_LASTTX_STARTRX_Pos (7UL) /*!< Position of LASTTX_STARTRX field. */
-#define TWIM_SHORTS_LASTTX_STARTRX_Msk (0x1UL << TWIM_SHORTS_LASTTX_STARTRX_Pos) /*!< Bit mask of LASTTX_STARTRX field. */
-#define TWIM_SHORTS_LASTTX_STARTRX_Disabled (0UL) /*!< Disable shortcut */
-#define TWIM_SHORTS_LASTTX_STARTRX_Enabled (1UL) /*!< Enable shortcut */
-
-/* Register: TWIM_INTEN */
-/* Description: Enable or disable interrupt */
-
-/* Bit 24 : Enable or disable interrupt for LASTTX event */
-#define TWIM_INTEN_LASTTX_Pos (24UL) /*!< Position of LASTTX field. */
-#define TWIM_INTEN_LASTTX_Msk (0x1UL << TWIM_INTEN_LASTTX_Pos) /*!< Bit mask of LASTTX field. */
-#define TWIM_INTEN_LASTTX_Disabled (0UL) /*!< Disable */
-#define TWIM_INTEN_LASTTX_Enabled (1UL) /*!< Enable */
-
-/* Bit 23 : Enable or disable interrupt for LASTRX event */
-#define TWIM_INTEN_LASTRX_Pos (23UL) /*!< Position of LASTRX field. */
-#define TWIM_INTEN_LASTRX_Msk (0x1UL << TWIM_INTEN_LASTRX_Pos) /*!< Bit mask of LASTRX field. */
-#define TWIM_INTEN_LASTRX_Disabled (0UL) /*!< Disable */
-#define TWIM_INTEN_LASTRX_Enabled (1UL) /*!< Enable */
-
-/* Bit 20 : Enable or disable interrupt for TXSTARTED event */
-#define TWIM_INTEN_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
-#define TWIM_INTEN_TXSTARTED_Msk (0x1UL << TWIM_INTEN_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
-#define TWIM_INTEN_TXSTARTED_Disabled (0UL) /*!< Disable */
-#define TWIM_INTEN_TXSTARTED_Enabled (1UL) /*!< Enable */
-
-/* Bit 19 : Enable or disable interrupt for RXSTARTED event */
-#define TWIM_INTEN_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
-#define TWIM_INTEN_RXSTARTED_Msk (0x1UL << TWIM_INTEN_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
-#define TWIM_INTEN_RXSTARTED_Disabled (0UL) /*!< Disable */
-#define TWIM_INTEN_RXSTARTED_Enabled (1UL) /*!< Enable */
-
-/* Bit 18 : Enable or disable interrupt for SUSPENDED event */
-#define TWIM_INTEN_SUSPENDED_Pos (18UL) /*!< Position of SUSPENDED field. */
-#define TWIM_INTEN_SUSPENDED_Msk (0x1UL << TWIM_INTEN_SUSPENDED_Pos) /*!< Bit mask of SUSPENDED field. */
-#define TWIM_INTEN_SUSPENDED_Disabled (0UL) /*!< Disable */
-#define TWIM_INTEN_SUSPENDED_Enabled (1UL) /*!< Enable */
-
-/* Bit 9 : Enable or disable interrupt for ERROR event */
-#define TWIM_INTEN_ERROR_Pos (9UL) /*!< Position of ERROR field. */
-#define TWIM_INTEN_ERROR_Msk (0x1UL << TWIM_INTEN_ERROR_Pos) /*!< Bit mask of ERROR field. */
-#define TWIM_INTEN_ERROR_Disabled (0UL) /*!< Disable */
-#define TWIM_INTEN_ERROR_Enabled (1UL) /*!< Enable */
-
-/* Bit 1 : Enable or disable interrupt for STOPPED event */
-#define TWIM_INTEN_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
-#define TWIM_INTEN_STOPPED_Msk (0x1UL << TWIM_INTEN_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define TWIM_INTEN_STOPPED_Disabled (0UL) /*!< Disable */
-#define TWIM_INTEN_STOPPED_Enabled (1UL) /*!< Enable */
-
-/* Register: TWIM_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 24 : Write '1' to Enable interrupt for LASTTX event */
-#define TWIM_INTENSET_LASTTX_Pos (24UL) /*!< Position of LASTTX field. */
-#define TWIM_INTENSET_LASTTX_Msk (0x1UL << TWIM_INTENSET_LASTTX_Pos) /*!< Bit mask of LASTTX field. */
-#define TWIM_INTENSET_LASTTX_Disabled (0UL) /*!< Read: Disabled */
-#define TWIM_INTENSET_LASTTX_Enabled (1UL) /*!< Read: Enabled */
-#define TWIM_INTENSET_LASTTX_Set (1UL) /*!< Enable */
-
-/* Bit 23 : Write '1' to Enable interrupt for LASTRX event */
-#define TWIM_INTENSET_LASTRX_Pos (23UL) /*!< Position of LASTRX field. */
-#define TWIM_INTENSET_LASTRX_Msk (0x1UL << TWIM_INTENSET_LASTRX_Pos) /*!< Bit mask of LASTRX field. */
-#define TWIM_INTENSET_LASTRX_Disabled (0UL) /*!< Read: Disabled */
-#define TWIM_INTENSET_LASTRX_Enabled (1UL) /*!< Read: Enabled */
-#define TWIM_INTENSET_LASTRX_Set (1UL) /*!< Enable */
-
-/* Bit 20 : Write '1' to Enable interrupt for TXSTARTED event */
-#define TWIM_INTENSET_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
-#define TWIM_INTENSET_TXSTARTED_Msk (0x1UL << TWIM_INTENSET_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
-#define TWIM_INTENSET_TXSTARTED_Disabled (0UL) /*!< Read: Disabled */
-#define TWIM_INTENSET_TXSTARTED_Enabled (1UL) /*!< Read: Enabled */
-#define TWIM_INTENSET_TXSTARTED_Set (1UL) /*!< Enable */
-
-/* Bit 19 : Write '1' to Enable interrupt for RXSTARTED event */
-#define TWIM_INTENSET_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
-#define TWIM_INTENSET_RXSTARTED_Msk (0x1UL << TWIM_INTENSET_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
-#define TWIM_INTENSET_RXSTARTED_Disabled (0UL) /*!< Read: Disabled */
-#define TWIM_INTENSET_RXSTARTED_Enabled (1UL) /*!< Read: Enabled */
-#define TWIM_INTENSET_RXSTARTED_Set (1UL) /*!< Enable */
-
-/* Bit 18 : Write '1' to Enable interrupt for SUSPENDED event */
-#define TWIM_INTENSET_SUSPENDED_Pos (18UL) /*!< Position of SUSPENDED field. */
-#define TWIM_INTENSET_SUSPENDED_Msk (0x1UL << TWIM_INTENSET_SUSPENDED_Pos) /*!< Bit mask of SUSPENDED field. */
-#define TWIM_INTENSET_SUSPENDED_Disabled (0UL) /*!< Read: Disabled */
-#define TWIM_INTENSET_SUSPENDED_Enabled (1UL) /*!< Read: Enabled */
-#define TWIM_INTENSET_SUSPENDED_Set (1UL) /*!< Enable */
-
-/* Bit 9 : Write '1' to Enable interrupt for ERROR event */
-#define TWIM_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
-#define TWIM_INTENSET_ERROR_Msk (0x1UL << TWIM_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
-#define TWIM_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
-#define TWIM_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
-#define TWIM_INTENSET_ERROR_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for STOPPED event */
-#define TWIM_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
-#define TWIM_INTENSET_STOPPED_Msk (0x1UL << TWIM_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define TWIM_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define TWIM_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define TWIM_INTENSET_STOPPED_Set (1UL) /*!< Enable */
-
-/* Register: TWIM_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 24 : Write '1' to Disable interrupt for LASTTX event */
-#define TWIM_INTENCLR_LASTTX_Pos (24UL) /*!< Position of LASTTX field. */
-#define TWIM_INTENCLR_LASTTX_Msk (0x1UL << TWIM_INTENCLR_LASTTX_Pos) /*!< Bit mask of LASTTX field. */
-#define TWIM_INTENCLR_LASTTX_Disabled (0UL) /*!< Read: Disabled */
-#define TWIM_INTENCLR_LASTTX_Enabled (1UL) /*!< Read: Enabled */
-#define TWIM_INTENCLR_LASTTX_Clear (1UL) /*!< Disable */
-
-/* Bit 23 : Write '1' to Disable interrupt for LASTRX event */
-#define TWIM_INTENCLR_LASTRX_Pos (23UL) /*!< Position of LASTRX field. */
-#define TWIM_INTENCLR_LASTRX_Msk (0x1UL << TWIM_INTENCLR_LASTRX_Pos) /*!< Bit mask of LASTRX field. */
-#define TWIM_INTENCLR_LASTRX_Disabled (0UL) /*!< Read: Disabled */
-#define TWIM_INTENCLR_LASTRX_Enabled (1UL) /*!< Read: Enabled */
-#define TWIM_INTENCLR_LASTRX_Clear (1UL) /*!< Disable */
-
-/* Bit 20 : Write '1' to Disable interrupt for TXSTARTED event */
-#define TWIM_INTENCLR_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
-#define TWIM_INTENCLR_TXSTARTED_Msk (0x1UL << TWIM_INTENCLR_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
-#define TWIM_INTENCLR_TXSTARTED_Disabled (0UL) /*!< Read: Disabled */
-#define TWIM_INTENCLR_TXSTARTED_Enabled (1UL) /*!< Read: Enabled */
-#define TWIM_INTENCLR_TXSTARTED_Clear (1UL) /*!< Disable */
-
-/* Bit 19 : Write '1' to Disable interrupt for RXSTARTED event */
-#define TWIM_INTENCLR_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
-#define TWIM_INTENCLR_RXSTARTED_Msk (0x1UL << TWIM_INTENCLR_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
-#define TWIM_INTENCLR_RXSTARTED_Disabled (0UL) /*!< Read: Disabled */
-#define TWIM_INTENCLR_RXSTARTED_Enabled (1UL) /*!< Read: Enabled */
-#define TWIM_INTENCLR_RXSTARTED_Clear (1UL) /*!< Disable */
-
-/* Bit 18 : Write '1' to Disable interrupt for SUSPENDED event */
-#define TWIM_INTENCLR_SUSPENDED_Pos (18UL) /*!< Position of SUSPENDED field. */
-#define TWIM_INTENCLR_SUSPENDED_Msk (0x1UL << TWIM_INTENCLR_SUSPENDED_Pos) /*!< Bit mask of SUSPENDED field. */
-#define TWIM_INTENCLR_SUSPENDED_Disabled (0UL) /*!< Read: Disabled */
-#define TWIM_INTENCLR_SUSPENDED_Enabled (1UL) /*!< Read: Enabled */
-#define TWIM_INTENCLR_SUSPENDED_Clear (1UL) /*!< Disable */
-
-/* Bit 9 : Write '1' to Disable interrupt for ERROR event */
-#define TWIM_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
-#define TWIM_INTENCLR_ERROR_Msk (0x1UL << TWIM_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
-#define TWIM_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
-#define TWIM_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
-#define TWIM_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for STOPPED event */
-#define TWIM_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
-#define TWIM_INTENCLR_STOPPED_Msk (0x1UL << TWIM_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define TWIM_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define TWIM_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define TWIM_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
-
-/* Register: TWIM_ERRORSRC */
-/* Description: Error source */
-
-/* Bit 2 : NACK received after sending a data byte (write '1' to clear) */
-#define TWIM_ERRORSRC_DNACK_Pos (2UL) /*!< Position of DNACK field. */
-#define TWIM_ERRORSRC_DNACK_Msk (0x1UL << TWIM_ERRORSRC_DNACK_Pos) /*!< Bit mask of DNACK field. */
-#define TWIM_ERRORSRC_DNACK_NotReceived (0UL) /*!< Error did not occur */
-#define TWIM_ERRORSRC_DNACK_Received (1UL) /*!< Error occurred */
-
-/* Bit 1 : NACK received after sending the address (write '1' to clear) */
-#define TWIM_ERRORSRC_ANACK_Pos (1UL) /*!< Position of ANACK field. */
-#define TWIM_ERRORSRC_ANACK_Msk (0x1UL << TWIM_ERRORSRC_ANACK_Pos) /*!< Bit mask of ANACK field. */
-#define TWIM_ERRORSRC_ANACK_NotReceived (0UL) /*!< Error did not occur */
-#define TWIM_ERRORSRC_ANACK_Received (1UL) /*!< Error occurred */
-
-/* Bit 0 : Overrun error */
-#define TWIM_ERRORSRC_OVERRUN_Pos (0UL) /*!< Position of OVERRUN field. */
-#define TWIM_ERRORSRC_OVERRUN_Msk (0x1UL << TWIM_ERRORSRC_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
-#define TWIM_ERRORSRC_OVERRUN_NotReceived (0UL) /*!< Error did not occur */
-#define TWIM_ERRORSRC_OVERRUN_Received (1UL) /*!< Error occurred */
-
-/* Register: TWIM_ENABLE */
-/* Description: Enable TWIM */
-
-/* Bits 3..0 : Enable or disable TWIM */
-#define TWIM_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
-#define TWIM_ENABLE_ENABLE_Msk (0xFUL << TWIM_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
-#define TWIM_ENABLE_ENABLE_Disabled (0UL) /*!< Disable TWIM */
-#define TWIM_ENABLE_ENABLE_Enabled (6UL) /*!< Enable TWIM */
-
-/* Register: TWIM_PSEL_SCL */
-/* Description: Pin select for SCL signal */
-
-/* Bit 31 : Connection */
-#define TWIM_PSEL_SCL_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define TWIM_PSEL_SCL_CONNECT_Msk (0x1UL << TWIM_PSEL_SCL_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define TWIM_PSEL_SCL_CONNECT_Connected (0UL) /*!< Connect */
-#define TWIM_PSEL_SCL_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define TWIM_PSEL_SCL_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define TWIM_PSEL_SCL_PIN_Msk (0x1FUL << TWIM_PSEL_SCL_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: TWIM_PSEL_SDA */
-/* Description: Pin select for SDA signal */
-
-/* Bit 31 : Connection */
-#define TWIM_PSEL_SDA_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define TWIM_PSEL_SDA_CONNECT_Msk (0x1UL << TWIM_PSEL_SDA_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define TWIM_PSEL_SDA_CONNECT_Connected (0UL) /*!< Connect */
-#define TWIM_PSEL_SDA_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define TWIM_PSEL_SDA_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define TWIM_PSEL_SDA_PIN_Msk (0x1FUL << TWIM_PSEL_SDA_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: TWIM_FREQUENCY */
-/* Description: TWI frequency */
-
-/* Bits 31..0 : TWI master clock frequency */
-#define TWIM_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
-#define TWIM_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << TWIM_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
-#define TWIM_FREQUENCY_FREQUENCY_K100 (0x01980000UL) /*!< 100 kbps */
-#define TWIM_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250 kbps */
-#define TWIM_FREQUENCY_FREQUENCY_K400 (0x06400000UL) /*!< 400 kbps */
-
-/* Register: TWIM_RXD_PTR */
-/* Description: Data pointer */
-
-/* Bits 31..0 : Data pointer */
-#define TWIM_RXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
-#define TWIM_RXD_PTR_PTR_Msk (0xFFFFFFFFUL << TWIM_RXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
-
-/* Register: TWIM_RXD_MAXCNT */
-/* Description: Maximum number of bytes in receive buffer */
-
-/* Bits 7..0 : Maximum number of bytes in receive buffer */
-#define TWIM_RXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
-#define TWIM_RXD_MAXCNT_MAXCNT_Msk (0xFFUL << TWIM_RXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
-
-/* Register: TWIM_RXD_AMOUNT */
-/* Description: Number of bytes transferred in the last transaction */
-
-/* Bits 7..0 : Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte. */
-#define TWIM_RXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
-#define TWIM_RXD_AMOUNT_AMOUNT_Msk (0xFFUL << TWIM_RXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
-
-/* Register: TWIM_RXD_LIST */
-/* Description: EasyDMA list type */
-
-/* Bits 2..0 : List type */
-#define TWIM_RXD_LIST_LIST_Pos (0UL) /*!< Position of LIST field. */
-#define TWIM_RXD_LIST_LIST_Msk (0x7UL << TWIM_RXD_LIST_LIST_Pos) /*!< Bit mask of LIST field. */
-#define TWIM_RXD_LIST_LIST_Disabled (0UL) /*!< Disable EasyDMA list */
-#define TWIM_RXD_LIST_LIST_ArrayList (1UL) /*!< Use array list */
-
-/* Register: TWIM_TXD_PTR */
-/* Description: Data pointer */
-
-/* Bits 31..0 : Data pointer */
-#define TWIM_TXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
-#define TWIM_TXD_PTR_PTR_Msk (0xFFFFFFFFUL << TWIM_TXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
-
-/* Register: TWIM_TXD_MAXCNT */
-/* Description: Maximum number of bytes in transmit buffer */
-
-/* Bits 7..0 : Maximum number of bytes in transmit buffer */
-#define TWIM_TXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
-#define TWIM_TXD_MAXCNT_MAXCNT_Msk (0xFFUL << TWIM_TXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
-
-/* Register: TWIM_TXD_AMOUNT */
-/* Description: Number of bytes transferred in the last transaction */
-
-/* Bits 7..0 : Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte. */
-#define TWIM_TXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
-#define TWIM_TXD_AMOUNT_AMOUNT_Msk (0xFFUL << TWIM_TXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
-
-/* Register: TWIM_TXD_LIST */
-/* Description: EasyDMA list type */
-
-/* Bits 2..0 : List type */
-#define TWIM_TXD_LIST_LIST_Pos (0UL) /*!< Position of LIST field. */
-#define TWIM_TXD_LIST_LIST_Msk (0x7UL << TWIM_TXD_LIST_LIST_Pos) /*!< Bit mask of LIST field. */
-#define TWIM_TXD_LIST_LIST_Disabled (0UL) /*!< Disable EasyDMA list */
-#define TWIM_TXD_LIST_LIST_ArrayList (1UL) /*!< Use array list */
-
-/* Register: TWIM_ADDRESS */
-/* Description: Address used in the TWI transfer */
-
-/* Bits 6..0 : Address used in the TWI transfer */
-#define TWIM_ADDRESS_ADDRESS_Pos (0UL) /*!< Position of ADDRESS field. */
-#define TWIM_ADDRESS_ADDRESS_Msk (0x7FUL << TWIM_ADDRESS_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
-
-
-/* Peripheral: TWIS */
-/* Description: I2C compatible Two-Wire Slave Interface with EasyDMA 0 */
-
-/* Register: TWIS_SHORTS */
-/* Description: Shortcut register */
-
-/* Bit 14 : Shortcut between READ event and SUSPEND task */
-#define TWIS_SHORTS_READ_SUSPEND_Pos (14UL) /*!< Position of READ_SUSPEND field. */
-#define TWIS_SHORTS_READ_SUSPEND_Msk (0x1UL << TWIS_SHORTS_READ_SUSPEND_Pos) /*!< Bit mask of READ_SUSPEND field. */
-#define TWIS_SHORTS_READ_SUSPEND_Disabled (0UL) /*!< Disable shortcut */
-#define TWIS_SHORTS_READ_SUSPEND_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 13 : Shortcut between WRITE event and SUSPEND task */
-#define TWIS_SHORTS_WRITE_SUSPEND_Pos (13UL) /*!< Position of WRITE_SUSPEND field. */
-#define TWIS_SHORTS_WRITE_SUSPEND_Msk (0x1UL << TWIS_SHORTS_WRITE_SUSPEND_Pos) /*!< Bit mask of WRITE_SUSPEND field. */
-#define TWIS_SHORTS_WRITE_SUSPEND_Disabled (0UL) /*!< Disable shortcut */
-#define TWIS_SHORTS_WRITE_SUSPEND_Enabled (1UL) /*!< Enable shortcut */
-
-/* Register: TWIS_INTEN */
-/* Description: Enable or disable interrupt */
-
-/* Bit 26 : Enable or disable interrupt for READ event */
-#define TWIS_INTEN_READ_Pos (26UL) /*!< Position of READ field. */
-#define TWIS_INTEN_READ_Msk (0x1UL << TWIS_INTEN_READ_Pos) /*!< Bit mask of READ field. */
-#define TWIS_INTEN_READ_Disabled (0UL) /*!< Disable */
-#define TWIS_INTEN_READ_Enabled (1UL) /*!< Enable */
-
-/* Bit 25 : Enable or disable interrupt for WRITE event */
-#define TWIS_INTEN_WRITE_Pos (25UL) /*!< Position of WRITE field. */
-#define TWIS_INTEN_WRITE_Msk (0x1UL << TWIS_INTEN_WRITE_Pos) /*!< Bit mask of WRITE field. */
-#define TWIS_INTEN_WRITE_Disabled (0UL) /*!< Disable */
-#define TWIS_INTEN_WRITE_Enabled (1UL) /*!< Enable */
-
-/* Bit 20 : Enable or disable interrupt for TXSTARTED event */
-#define TWIS_INTEN_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
-#define TWIS_INTEN_TXSTARTED_Msk (0x1UL << TWIS_INTEN_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
-#define TWIS_INTEN_TXSTARTED_Disabled (0UL) /*!< Disable */
-#define TWIS_INTEN_TXSTARTED_Enabled (1UL) /*!< Enable */
-
-/* Bit 19 : Enable or disable interrupt for RXSTARTED event */
-#define TWIS_INTEN_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
-#define TWIS_INTEN_RXSTARTED_Msk (0x1UL << TWIS_INTEN_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
-#define TWIS_INTEN_RXSTARTED_Disabled (0UL) /*!< Disable */
-#define TWIS_INTEN_RXSTARTED_Enabled (1UL) /*!< Enable */
-
-/* Bit 9 : Enable or disable interrupt for ERROR event */
-#define TWIS_INTEN_ERROR_Pos (9UL) /*!< Position of ERROR field. */
-#define TWIS_INTEN_ERROR_Msk (0x1UL << TWIS_INTEN_ERROR_Pos) /*!< Bit mask of ERROR field. */
-#define TWIS_INTEN_ERROR_Disabled (0UL) /*!< Disable */
-#define TWIS_INTEN_ERROR_Enabled (1UL) /*!< Enable */
-
-/* Bit 1 : Enable or disable interrupt for STOPPED event */
-#define TWIS_INTEN_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
-#define TWIS_INTEN_STOPPED_Msk (0x1UL << TWIS_INTEN_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define TWIS_INTEN_STOPPED_Disabled (0UL) /*!< Disable */
-#define TWIS_INTEN_STOPPED_Enabled (1UL) /*!< Enable */
-
-/* Register: TWIS_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 26 : Write '1' to Enable interrupt for READ event */
-#define TWIS_INTENSET_READ_Pos (26UL) /*!< Position of READ field. */
-#define TWIS_INTENSET_READ_Msk (0x1UL << TWIS_INTENSET_READ_Pos) /*!< Bit mask of READ field. */
-#define TWIS_INTENSET_READ_Disabled (0UL) /*!< Read: Disabled */
-#define TWIS_INTENSET_READ_Enabled (1UL) /*!< Read: Enabled */
-#define TWIS_INTENSET_READ_Set (1UL) /*!< Enable */
-
-/* Bit 25 : Write '1' to Enable interrupt for WRITE event */
-#define TWIS_INTENSET_WRITE_Pos (25UL) /*!< Position of WRITE field. */
-#define TWIS_INTENSET_WRITE_Msk (0x1UL << TWIS_INTENSET_WRITE_Pos) /*!< Bit mask of WRITE field. */
-#define TWIS_INTENSET_WRITE_Disabled (0UL) /*!< Read: Disabled */
-#define TWIS_INTENSET_WRITE_Enabled (1UL) /*!< Read: Enabled */
-#define TWIS_INTENSET_WRITE_Set (1UL) /*!< Enable */
-
-/* Bit 20 : Write '1' to Enable interrupt for TXSTARTED event */
-#define TWIS_INTENSET_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
-#define TWIS_INTENSET_TXSTARTED_Msk (0x1UL << TWIS_INTENSET_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
-#define TWIS_INTENSET_TXSTARTED_Disabled (0UL) /*!< Read: Disabled */
-#define TWIS_INTENSET_TXSTARTED_Enabled (1UL) /*!< Read: Enabled */
-#define TWIS_INTENSET_TXSTARTED_Set (1UL) /*!< Enable */
-
-/* Bit 19 : Write '1' to Enable interrupt for RXSTARTED event */
-#define TWIS_INTENSET_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
-#define TWIS_INTENSET_RXSTARTED_Msk (0x1UL << TWIS_INTENSET_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
-#define TWIS_INTENSET_RXSTARTED_Disabled (0UL) /*!< Read: Disabled */
-#define TWIS_INTENSET_RXSTARTED_Enabled (1UL) /*!< Read: Enabled */
-#define TWIS_INTENSET_RXSTARTED_Set (1UL) /*!< Enable */
-
-/* Bit 9 : Write '1' to Enable interrupt for ERROR event */
-#define TWIS_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
-#define TWIS_INTENSET_ERROR_Msk (0x1UL << TWIS_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
-#define TWIS_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
-#define TWIS_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
-#define TWIS_INTENSET_ERROR_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for STOPPED event */
-#define TWIS_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
-#define TWIS_INTENSET_STOPPED_Msk (0x1UL << TWIS_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define TWIS_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define TWIS_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define TWIS_INTENSET_STOPPED_Set (1UL) /*!< Enable */
-
-/* Register: TWIS_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 26 : Write '1' to Disable interrupt for READ event */
-#define TWIS_INTENCLR_READ_Pos (26UL) /*!< Position of READ field. */
-#define TWIS_INTENCLR_READ_Msk (0x1UL << TWIS_INTENCLR_READ_Pos) /*!< Bit mask of READ field. */
-#define TWIS_INTENCLR_READ_Disabled (0UL) /*!< Read: Disabled */
-#define TWIS_INTENCLR_READ_Enabled (1UL) /*!< Read: Enabled */
-#define TWIS_INTENCLR_READ_Clear (1UL) /*!< Disable */
-
-/* Bit 25 : Write '1' to Disable interrupt for WRITE event */
-#define TWIS_INTENCLR_WRITE_Pos (25UL) /*!< Position of WRITE field. */
-#define TWIS_INTENCLR_WRITE_Msk (0x1UL << TWIS_INTENCLR_WRITE_Pos) /*!< Bit mask of WRITE field. */
-#define TWIS_INTENCLR_WRITE_Disabled (0UL) /*!< Read: Disabled */
-#define TWIS_INTENCLR_WRITE_Enabled (1UL) /*!< Read: Enabled */
-#define TWIS_INTENCLR_WRITE_Clear (1UL) /*!< Disable */
-
-/* Bit 20 : Write '1' to Disable interrupt for TXSTARTED event */
-#define TWIS_INTENCLR_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
-#define TWIS_INTENCLR_TXSTARTED_Msk (0x1UL << TWIS_INTENCLR_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
-#define TWIS_INTENCLR_TXSTARTED_Disabled (0UL) /*!< Read: Disabled */
-#define TWIS_INTENCLR_TXSTARTED_Enabled (1UL) /*!< Read: Enabled */
-#define TWIS_INTENCLR_TXSTARTED_Clear (1UL) /*!< Disable */
-
-/* Bit 19 : Write '1' to Disable interrupt for RXSTARTED event */
-#define TWIS_INTENCLR_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
-#define TWIS_INTENCLR_RXSTARTED_Msk (0x1UL << TWIS_INTENCLR_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
-#define TWIS_INTENCLR_RXSTARTED_Disabled (0UL) /*!< Read: Disabled */
-#define TWIS_INTENCLR_RXSTARTED_Enabled (1UL) /*!< Read: Enabled */
-#define TWIS_INTENCLR_RXSTARTED_Clear (1UL) /*!< Disable */
-
-/* Bit 9 : Write '1' to Disable interrupt for ERROR event */
-#define TWIS_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
-#define TWIS_INTENCLR_ERROR_Msk (0x1UL << TWIS_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
-#define TWIS_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
-#define TWIS_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
-#define TWIS_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for STOPPED event */
-#define TWIS_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
-#define TWIS_INTENCLR_STOPPED_Msk (0x1UL << TWIS_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
-#define TWIS_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define TWIS_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define TWIS_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
-
-/* Register: TWIS_ERRORSRC */
-/* Description: Error source */
-
-/* Bit 3 : TX buffer over-read detected, and prevented */
-#define TWIS_ERRORSRC_OVERREAD_Pos (3UL) /*!< Position of OVERREAD field. */
-#define TWIS_ERRORSRC_OVERREAD_Msk (0x1UL << TWIS_ERRORSRC_OVERREAD_Pos) /*!< Bit mask of OVERREAD field. */
-#define TWIS_ERRORSRC_OVERREAD_NotDetected (0UL) /*!< Error did not occur */
-#define TWIS_ERRORSRC_OVERREAD_Detected (1UL) /*!< Error occurred */
-
-/* Bit 2 : NACK sent after receiving a data byte */
-#define TWIS_ERRORSRC_DNACK_Pos (2UL) /*!< Position of DNACK field. */
-#define TWIS_ERRORSRC_DNACK_Msk (0x1UL << TWIS_ERRORSRC_DNACK_Pos) /*!< Bit mask of DNACK field. */
-#define TWIS_ERRORSRC_DNACK_NotReceived (0UL) /*!< Error did not occur */
-#define TWIS_ERRORSRC_DNACK_Received (1UL) /*!< Error occurred */
-
-/* Bit 0 : RX buffer overflow detected, and prevented */
-#define TWIS_ERRORSRC_OVERFLOW_Pos (0UL) /*!< Position of OVERFLOW field. */
-#define TWIS_ERRORSRC_OVERFLOW_Msk (0x1UL << TWIS_ERRORSRC_OVERFLOW_Pos) /*!< Bit mask of OVERFLOW field. */
-#define TWIS_ERRORSRC_OVERFLOW_NotDetected (0UL) /*!< Error did not occur */
-#define TWIS_ERRORSRC_OVERFLOW_Detected (1UL) /*!< Error occurred */
-
-/* Register: TWIS_MATCH */
-/* Description: Status register indicating which address had a match */
-
-/* Bit 0 : Which of the addresses in {ADDRESS} matched the incoming address */
-#define TWIS_MATCH_MATCH_Pos (0UL) /*!< Position of MATCH field. */
-#define TWIS_MATCH_MATCH_Msk (0x1UL << TWIS_MATCH_MATCH_Pos) /*!< Bit mask of MATCH field. */
-
-/* Register: TWIS_ENABLE */
-/* Description: Enable TWIS */
-
-/* Bits 3..0 : Enable or disable TWIS */
-#define TWIS_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
-#define TWIS_ENABLE_ENABLE_Msk (0xFUL << TWIS_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
-#define TWIS_ENABLE_ENABLE_Disabled (0UL) /*!< Disable TWIS */
-#define TWIS_ENABLE_ENABLE_Enabled (9UL) /*!< Enable TWIS */
-
-/* Register: TWIS_PSEL_SCL */
-/* Description: Pin select for SCL signal */
-
-/* Bit 31 : Connection */
-#define TWIS_PSEL_SCL_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define TWIS_PSEL_SCL_CONNECT_Msk (0x1UL << TWIS_PSEL_SCL_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define TWIS_PSEL_SCL_CONNECT_Connected (0UL) /*!< Connect */
-#define TWIS_PSEL_SCL_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define TWIS_PSEL_SCL_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define TWIS_PSEL_SCL_PIN_Msk (0x1FUL << TWIS_PSEL_SCL_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: TWIS_PSEL_SDA */
-/* Description: Pin select for SDA signal */
-
-/* Bit 31 : Connection */
-#define TWIS_PSEL_SDA_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define TWIS_PSEL_SDA_CONNECT_Msk (0x1UL << TWIS_PSEL_SDA_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define TWIS_PSEL_SDA_CONNECT_Connected (0UL) /*!< Connect */
-#define TWIS_PSEL_SDA_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define TWIS_PSEL_SDA_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define TWIS_PSEL_SDA_PIN_Msk (0x1FUL << TWIS_PSEL_SDA_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: TWIS_RXD_PTR */
-/* Description: RXD Data pointer */
-
-/* Bits 31..0 : RXD Data pointer */
-#define TWIS_RXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
-#define TWIS_RXD_PTR_PTR_Msk (0xFFFFFFFFUL << TWIS_RXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
-
-/* Register: TWIS_RXD_MAXCNT */
-/* Description: Maximum number of bytes in RXD buffer */
-
-/* Bits 7..0 : Maximum number of bytes in RXD buffer */
-#define TWIS_RXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
-#define TWIS_RXD_MAXCNT_MAXCNT_Msk (0xFFUL << TWIS_RXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
-
-/* Register: TWIS_RXD_AMOUNT */
-/* Description: Number of bytes transferred in the last RXD transaction */
-
-/* Bits 7..0 : Number of bytes transferred in the last RXD transaction */
-#define TWIS_RXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
-#define TWIS_RXD_AMOUNT_AMOUNT_Msk (0xFFUL << TWIS_RXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
-
-/* Register: TWIS_TXD_PTR */
-/* Description: TXD Data pointer */
-
-/* Bits 31..0 : TXD Data pointer */
-#define TWIS_TXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
-#define TWIS_TXD_PTR_PTR_Msk (0xFFFFFFFFUL << TWIS_TXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
-
-/* Register: TWIS_TXD_MAXCNT */
-/* Description: Maximum number of bytes in TXD buffer */
-
-/* Bits 7..0 : Maximum number of bytes in TXD buffer */
-#define TWIS_TXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
-#define TWIS_TXD_MAXCNT_MAXCNT_Msk (0xFFUL << TWIS_TXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
-
-/* Register: TWIS_TXD_AMOUNT */
-/* Description: Number of bytes transferred in the last TXD transaction */
-
-/* Bits 7..0 : Number of bytes transferred in the last TXD transaction */
-#define TWIS_TXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
-#define TWIS_TXD_AMOUNT_AMOUNT_Msk (0xFFUL << TWIS_TXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
-
-/* Register: TWIS_ADDRESS */
-/* Description: Description collection[0]:  TWI slave address 0 */
-
-/* Bits 6..0 : TWI slave address */
-#define TWIS_ADDRESS_ADDRESS_Pos (0UL) /*!< Position of ADDRESS field. */
-#define TWIS_ADDRESS_ADDRESS_Msk (0x7FUL << TWIS_ADDRESS_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
-
-/* Register: TWIS_CONFIG */
-/* Description: Configuration register for the address match mechanism */
-
-/* Bit 1 : Enable or disable address matching on ADDRESS[1] */
-#define TWIS_CONFIG_ADDRESS1_Pos (1UL) /*!< Position of ADDRESS1 field. */
-#define TWIS_CONFIG_ADDRESS1_Msk (0x1UL << TWIS_CONFIG_ADDRESS1_Pos) /*!< Bit mask of ADDRESS1 field. */
-#define TWIS_CONFIG_ADDRESS1_Disabled (0UL) /*!< Disabled */
-#define TWIS_CONFIG_ADDRESS1_Enabled (1UL) /*!< Enabled */
-
-/* Bit 0 : Enable or disable address matching on ADDRESS[0] */
-#define TWIS_CONFIG_ADDRESS0_Pos (0UL) /*!< Position of ADDRESS0 field. */
-#define TWIS_CONFIG_ADDRESS0_Msk (0x1UL << TWIS_CONFIG_ADDRESS0_Pos) /*!< Bit mask of ADDRESS0 field. */
-#define TWIS_CONFIG_ADDRESS0_Disabled (0UL) /*!< Disabled */
-#define TWIS_CONFIG_ADDRESS0_Enabled (1UL) /*!< Enabled */
-
-/* Register: TWIS_ORC */
-/* Description: Over-read character. Character sent out in case of an over-read of the transmit buffer. */
-
-/* Bits 7..0 : Over-read character. Character sent out in case of an over-read of the transmit buffer. */
-#define TWIS_ORC_ORC_Pos (0UL) /*!< Position of ORC field. */
-#define TWIS_ORC_ORC_Msk (0xFFUL << TWIS_ORC_ORC_Pos) /*!< Bit mask of ORC field. */
-
-
-/* Peripheral: UART */
-/* Description: Universal Asynchronous Receiver/Transmitter */
-
-/* Register: UART_SHORTS */
-/* Description: Shortcut register */
-
-/* Bit 4 : Shortcut between NCTS event and STOPRX task */
-#define UART_SHORTS_NCTS_STOPRX_Pos (4UL) /*!< Position of NCTS_STOPRX field. */
-#define UART_SHORTS_NCTS_STOPRX_Msk (0x1UL << UART_SHORTS_NCTS_STOPRX_Pos) /*!< Bit mask of NCTS_STOPRX field. */
-#define UART_SHORTS_NCTS_STOPRX_Disabled (0UL) /*!< Disable shortcut */
-#define UART_SHORTS_NCTS_STOPRX_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 3 : Shortcut between CTS event and STARTRX task */
-#define UART_SHORTS_CTS_STARTRX_Pos (3UL) /*!< Position of CTS_STARTRX field. */
-#define UART_SHORTS_CTS_STARTRX_Msk (0x1UL << UART_SHORTS_CTS_STARTRX_Pos) /*!< Bit mask of CTS_STARTRX field. */
-#define UART_SHORTS_CTS_STARTRX_Disabled (0UL) /*!< Disable shortcut */
-#define UART_SHORTS_CTS_STARTRX_Enabled (1UL) /*!< Enable shortcut */
-
-/* Register: UART_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 17 : Write '1' to Enable interrupt for RXTO event */
-#define UART_INTENSET_RXTO_Pos (17UL) /*!< Position of RXTO field. */
-#define UART_INTENSET_RXTO_Msk (0x1UL << UART_INTENSET_RXTO_Pos) /*!< Bit mask of RXTO field. */
-#define UART_INTENSET_RXTO_Disabled (0UL) /*!< Read: Disabled */
-#define UART_INTENSET_RXTO_Enabled (1UL) /*!< Read: Enabled */
-#define UART_INTENSET_RXTO_Set (1UL) /*!< Enable */
-
-/* Bit 9 : Write '1' to Enable interrupt for ERROR event */
-#define UART_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
-#define UART_INTENSET_ERROR_Msk (0x1UL << UART_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
-#define UART_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
-#define UART_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
-#define UART_INTENSET_ERROR_Set (1UL) /*!< Enable */
-
-/* Bit 7 : Write '1' to Enable interrupt for TXDRDY event */
-#define UART_INTENSET_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
-#define UART_INTENSET_TXDRDY_Msk (0x1UL << UART_INTENSET_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
-#define UART_INTENSET_TXDRDY_Disabled (0UL) /*!< Read: Disabled */
-#define UART_INTENSET_TXDRDY_Enabled (1UL) /*!< Read: Enabled */
-#define UART_INTENSET_TXDRDY_Set (1UL) /*!< Enable */
-
-/* Bit 2 : Write '1' to Enable interrupt for RXDRDY event */
-#define UART_INTENSET_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
-#define UART_INTENSET_RXDRDY_Msk (0x1UL << UART_INTENSET_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
-#define UART_INTENSET_RXDRDY_Disabled (0UL) /*!< Read: Disabled */
-#define UART_INTENSET_RXDRDY_Enabled (1UL) /*!< Read: Enabled */
-#define UART_INTENSET_RXDRDY_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for NCTS event */
-#define UART_INTENSET_NCTS_Pos (1UL) /*!< Position of NCTS field. */
-#define UART_INTENSET_NCTS_Msk (0x1UL << UART_INTENSET_NCTS_Pos) /*!< Bit mask of NCTS field. */
-#define UART_INTENSET_NCTS_Disabled (0UL) /*!< Read: Disabled */
-#define UART_INTENSET_NCTS_Enabled (1UL) /*!< Read: Enabled */
-#define UART_INTENSET_NCTS_Set (1UL) /*!< Enable */
-
-/* Bit 0 : Write '1' to Enable interrupt for CTS event */
-#define UART_INTENSET_CTS_Pos (0UL) /*!< Position of CTS field. */
-#define UART_INTENSET_CTS_Msk (0x1UL << UART_INTENSET_CTS_Pos) /*!< Bit mask of CTS field. */
-#define UART_INTENSET_CTS_Disabled (0UL) /*!< Read: Disabled */
-#define UART_INTENSET_CTS_Enabled (1UL) /*!< Read: Enabled */
-#define UART_INTENSET_CTS_Set (1UL) /*!< Enable */
-
-/* Register: UART_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 17 : Write '1' to Disable interrupt for RXTO event */
-#define UART_INTENCLR_RXTO_Pos (17UL) /*!< Position of RXTO field. */
-#define UART_INTENCLR_RXTO_Msk (0x1UL << UART_INTENCLR_RXTO_Pos) /*!< Bit mask of RXTO field. */
-#define UART_INTENCLR_RXTO_Disabled (0UL) /*!< Read: Disabled */
-#define UART_INTENCLR_RXTO_Enabled (1UL) /*!< Read: Enabled */
-#define UART_INTENCLR_RXTO_Clear (1UL) /*!< Disable */
-
-/* Bit 9 : Write '1' to Disable interrupt for ERROR event */
-#define UART_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
-#define UART_INTENCLR_ERROR_Msk (0x1UL << UART_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
-#define UART_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
-#define UART_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
-#define UART_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
-
-/* Bit 7 : Write '1' to Disable interrupt for TXDRDY event */
-#define UART_INTENCLR_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
-#define UART_INTENCLR_TXDRDY_Msk (0x1UL << UART_INTENCLR_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
-#define UART_INTENCLR_TXDRDY_Disabled (0UL) /*!< Read: Disabled */
-#define UART_INTENCLR_TXDRDY_Enabled (1UL) /*!< Read: Enabled */
-#define UART_INTENCLR_TXDRDY_Clear (1UL) /*!< Disable */
-
-/* Bit 2 : Write '1' to Disable interrupt for RXDRDY event */
-#define UART_INTENCLR_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
-#define UART_INTENCLR_RXDRDY_Msk (0x1UL << UART_INTENCLR_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
-#define UART_INTENCLR_RXDRDY_Disabled (0UL) /*!< Read: Disabled */
-#define UART_INTENCLR_RXDRDY_Enabled (1UL) /*!< Read: Enabled */
-#define UART_INTENCLR_RXDRDY_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for NCTS event */
-#define UART_INTENCLR_NCTS_Pos (1UL) /*!< Position of NCTS field. */
-#define UART_INTENCLR_NCTS_Msk (0x1UL << UART_INTENCLR_NCTS_Pos) /*!< Bit mask of NCTS field. */
-#define UART_INTENCLR_NCTS_Disabled (0UL) /*!< Read: Disabled */
-#define UART_INTENCLR_NCTS_Enabled (1UL) /*!< Read: Enabled */
-#define UART_INTENCLR_NCTS_Clear (1UL) /*!< Disable */
-
-/* Bit 0 : Write '1' to Disable interrupt for CTS event */
-#define UART_INTENCLR_CTS_Pos (0UL) /*!< Position of CTS field. */
-#define UART_INTENCLR_CTS_Msk (0x1UL << UART_INTENCLR_CTS_Pos) /*!< Bit mask of CTS field. */
-#define UART_INTENCLR_CTS_Disabled (0UL) /*!< Read: Disabled */
-#define UART_INTENCLR_CTS_Enabled (1UL) /*!< Read: Enabled */
-#define UART_INTENCLR_CTS_Clear (1UL) /*!< Disable */
-
-/* Register: UART_ERRORSRC */
-/* Description: Error source */
-
-/* Bit 3 : Break condition */
-#define UART_ERRORSRC_BREAK_Pos (3UL) /*!< Position of BREAK field. */
-#define UART_ERRORSRC_BREAK_Msk (0x1UL << UART_ERRORSRC_BREAK_Pos) /*!< Bit mask of BREAK field. */
-#define UART_ERRORSRC_BREAK_NotPresent (0UL) /*!< Read: error not present */
-#define UART_ERRORSRC_BREAK_Present (1UL) /*!< Read: error present */
-
-/* Bit 2 : Framing error occurred */
-#define UART_ERRORSRC_FRAMING_Pos (2UL) /*!< Position of FRAMING field. */
-#define UART_ERRORSRC_FRAMING_Msk (0x1UL << UART_ERRORSRC_FRAMING_Pos) /*!< Bit mask of FRAMING field. */
-#define UART_ERRORSRC_FRAMING_NotPresent (0UL) /*!< Read: error not present */
-#define UART_ERRORSRC_FRAMING_Present (1UL) /*!< Read: error present */
-
-/* Bit 1 : Parity error */
-#define UART_ERRORSRC_PARITY_Pos (1UL) /*!< Position of PARITY field. */
-#define UART_ERRORSRC_PARITY_Msk (0x1UL << UART_ERRORSRC_PARITY_Pos) /*!< Bit mask of PARITY field. */
-#define UART_ERRORSRC_PARITY_NotPresent (0UL) /*!< Read: error not present */
-#define UART_ERRORSRC_PARITY_Present (1UL) /*!< Read: error present */
-
-/* Bit 0 : Overrun error */
-#define UART_ERRORSRC_OVERRUN_Pos (0UL) /*!< Position of OVERRUN field. */
-#define UART_ERRORSRC_OVERRUN_Msk (0x1UL << UART_ERRORSRC_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
-#define UART_ERRORSRC_OVERRUN_NotPresent (0UL) /*!< Read: error not present */
-#define UART_ERRORSRC_OVERRUN_Present (1UL) /*!< Read: error present */
-
-/* Register: UART_ENABLE */
-/* Description: Enable UART */
-
-/* Bits 3..0 : Enable or disable UART */
-#define UART_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
-#define UART_ENABLE_ENABLE_Msk (0xFUL << UART_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
-#define UART_ENABLE_ENABLE_Disabled (0UL) /*!< Disable UART */
-#define UART_ENABLE_ENABLE_Enabled (4UL) /*!< Enable UART */
-
-/* Register: UART_PSELRTS */
-/* Description: Pin select for RTS */
-
-/* Bits 31..0 : Pin number configuration for UART RTS signal */
-#define UART_PSELRTS_PSELRTS_Pos (0UL) /*!< Position of PSELRTS field. */
-#define UART_PSELRTS_PSELRTS_Msk (0xFFFFFFFFUL << UART_PSELRTS_PSELRTS_Pos) /*!< Bit mask of PSELRTS field. */
-#define UART_PSELRTS_PSELRTS_Disconnected (0xFFFFFFFFUL) /*!< Disconnect */
-
-/* Register: UART_PSELTXD */
-/* Description: Pin select for TXD */
-
-/* Bits 31..0 : Pin number configuration for UART TXD signal */
-#define UART_PSELTXD_PSELTXD_Pos (0UL) /*!< Position of PSELTXD field. */
-#define UART_PSELTXD_PSELTXD_Msk (0xFFFFFFFFUL << UART_PSELTXD_PSELTXD_Pos) /*!< Bit mask of PSELTXD field. */
-#define UART_PSELTXD_PSELTXD_Disconnected (0xFFFFFFFFUL) /*!< Disconnect */
-
-/* Register: UART_PSELCTS */
-/* Description: Pin select for CTS */
-
-/* Bits 31..0 : Pin number configuration for UART CTS signal */
-#define UART_PSELCTS_PSELCTS_Pos (0UL) /*!< Position of PSELCTS field. */
-#define UART_PSELCTS_PSELCTS_Msk (0xFFFFFFFFUL << UART_PSELCTS_PSELCTS_Pos) /*!< Bit mask of PSELCTS field. */
-#define UART_PSELCTS_PSELCTS_Disconnected (0xFFFFFFFFUL) /*!< Disconnect */
-
-/* Register: UART_PSELRXD */
-/* Description: Pin select for RXD */
-
-/* Bits 31..0 : Pin number configuration for UART RXD signal */
-#define UART_PSELRXD_PSELRXD_Pos (0UL) /*!< Position of PSELRXD field. */
-#define UART_PSELRXD_PSELRXD_Msk (0xFFFFFFFFUL << UART_PSELRXD_PSELRXD_Pos) /*!< Bit mask of PSELRXD field. */
-#define UART_PSELRXD_PSELRXD_Disconnected (0xFFFFFFFFUL) /*!< Disconnect */
-
-/* Register: UART_RXD */
-/* Description: RXD register */
-
-/* Bits 7..0 : RX data received in previous transfers, double buffered */
-#define UART_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
-#define UART_RXD_RXD_Msk (0xFFUL << UART_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
-
-/* Register: UART_TXD */
-/* Description: TXD register */
-
-/* Bits 7..0 : TX data to be transferred */
-#define UART_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
-#define UART_TXD_TXD_Msk (0xFFUL << UART_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
-
-/* Register: UART_BAUDRATE */
-/* Description: Baud rate */
-
-/* Bits 31..0 : Baud rate */
-#define UART_BAUDRATE_BAUDRATE_Pos (0UL) /*!< Position of BAUDRATE field. */
-#define UART_BAUDRATE_BAUDRATE_Msk (0xFFFFFFFFUL << UART_BAUDRATE_BAUDRATE_Pos) /*!< Bit mask of BAUDRATE field. */
-#define UART_BAUDRATE_BAUDRATE_Baud1200 (0x0004F000UL) /*!< 1200 baud (actual rate: 1205) */
-#define UART_BAUDRATE_BAUDRATE_Baud2400 (0x0009D000UL) /*!< 2400 baud (actual rate: 2396) */
-#define UART_BAUDRATE_BAUDRATE_Baud4800 (0x0013B000UL) /*!< 4800 baud (actual rate: 4808) */
-#define UART_BAUDRATE_BAUDRATE_Baud9600 (0x00275000UL) /*!< 9600 baud (actual rate: 9598) */
-#define UART_BAUDRATE_BAUDRATE_Baud14400 (0x003B0000UL) /*!< 14400 baud (actual rate: 14414) */
-#define UART_BAUDRATE_BAUDRATE_Baud19200 (0x004EA000UL) /*!< 19200 baud (actual rate: 19208) */
-#define UART_BAUDRATE_BAUDRATE_Baud28800 (0x0075F000UL) /*!< 28800 baud (actual rate: 28829) */
-#define UART_BAUDRATE_BAUDRATE_Baud31250 (0x00800000UL) /*!< 31250 baud */
-#define UART_BAUDRATE_BAUDRATE_Baud38400 (0x009D5000UL) /*!< 38400 baud (actual rate: 38462) */
-#define UART_BAUDRATE_BAUDRATE_Baud56000 (0x00E50000UL) /*!< 56000 baud (actual rate: 55944) */
-#define UART_BAUDRATE_BAUDRATE_Baud57600 (0x00EBF000UL) /*!< 57600 baud (actual rate: 57762) */
-#define UART_BAUDRATE_BAUDRATE_Baud76800 (0x013A9000UL) /*!< 76800 baud (actual rate: 76923) */
-#define UART_BAUDRATE_BAUDRATE_Baud115200 (0x01D7E000UL) /*!< 115200 baud (actual rate: 115942) */
-#define UART_BAUDRATE_BAUDRATE_Baud230400 (0x03AFB000UL) /*!< 230400 baud (actual rate: 231884) */
-#define UART_BAUDRATE_BAUDRATE_Baud250000 (0x04000000UL) /*!< 250000 baud */
-#define UART_BAUDRATE_BAUDRATE_Baud460800 (0x075F7000UL) /*!< 460800 baud (actual rate: 470588) */
-#define UART_BAUDRATE_BAUDRATE_Baud921600 (0x0EBED000UL) /*!< 921600 baud (actual rate: 941176) */
-#define UART_BAUDRATE_BAUDRATE_Baud1M (0x10000000UL) /*!< 1Mega baud */
-
-/* Register: UART_CONFIG */
-/* Description: Configuration of parity and hardware flow control */
-
-/* Bits 3..1 : Parity */
-#define UART_CONFIG_PARITY_Pos (1UL) /*!< Position of PARITY field. */
-#define UART_CONFIG_PARITY_Msk (0x7UL << UART_CONFIG_PARITY_Pos) /*!< Bit mask of PARITY field. */
-#define UART_CONFIG_PARITY_Excluded (0x0UL) /*!< Exclude parity bit */
-#define UART_CONFIG_PARITY_Included (0x7UL) /*!< Include parity bit */
-
-/* Bit 0 : Hardware flow control */
-#define UART_CONFIG_HWFC_Pos (0UL) /*!< Position of HWFC field. */
-#define UART_CONFIG_HWFC_Msk (0x1UL << UART_CONFIG_HWFC_Pos) /*!< Bit mask of HWFC field. */
-#define UART_CONFIG_HWFC_Disabled (0UL) /*!< Disabled */
-#define UART_CONFIG_HWFC_Enabled (1UL) /*!< Enabled */
-
-
-/* Peripheral: UARTE */
-/* Description: UART with EasyDMA */
-
-/* Register: UARTE_SHORTS */
-/* Description: Shortcut register */
-
-/* Bit 6 : Shortcut between ENDRX event and STOPRX task */
-#define UARTE_SHORTS_ENDRX_STOPRX_Pos (6UL) /*!< Position of ENDRX_STOPRX field. */
-#define UARTE_SHORTS_ENDRX_STOPRX_Msk (0x1UL << UARTE_SHORTS_ENDRX_STOPRX_Pos) /*!< Bit mask of ENDRX_STOPRX field. */
-#define UARTE_SHORTS_ENDRX_STOPRX_Disabled (0UL) /*!< Disable shortcut */
-#define UARTE_SHORTS_ENDRX_STOPRX_Enabled (1UL) /*!< Enable shortcut */
-
-/* Bit 5 : Shortcut between ENDRX event and STARTRX task */
-#define UARTE_SHORTS_ENDRX_STARTRX_Pos (5UL) /*!< Position of ENDRX_STARTRX field. */
-#define UARTE_SHORTS_ENDRX_STARTRX_Msk (0x1UL << UARTE_SHORTS_ENDRX_STARTRX_Pos) /*!< Bit mask of ENDRX_STARTRX field. */
-#define UARTE_SHORTS_ENDRX_STARTRX_Disabled (0UL) /*!< Disable shortcut */
-#define UARTE_SHORTS_ENDRX_STARTRX_Enabled (1UL) /*!< Enable shortcut */
-
-/* Register: UARTE_INTEN */
-/* Description: Enable or disable interrupt */
-
-/* Bit 22 : Enable or disable interrupt for TXSTOPPED event */
-#define UARTE_INTEN_TXSTOPPED_Pos (22UL) /*!< Position of TXSTOPPED field. */
-#define UARTE_INTEN_TXSTOPPED_Msk (0x1UL << UARTE_INTEN_TXSTOPPED_Pos) /*!< Bit mask of TXSTOPPED field. */
-#define UARTE_INTEN_TXSTOPPED_Disabled (0UL) /*!< Disable */
-#define UARTE_INTEN_TXSTOPPED_Enabled (1UL) /*!< Enable */
-
-/* Bit 20 : Enable or disable interrupt for TXSTARTED event */
-#define UARTE_INTEN_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
-#define UARTE_INTEN_TXSTARTED_Msk (0x1UL << UARTE_INTEN_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
-#define UARTE_INTEN_TXSTARTED_Disabled (0UL) /*!< Disable */
-#define UARTE_INTEN_TXSTARTED_Enabled (1UL) /*!< Enable */
-
-/* Bit 19 : Enable or disable interrupt for RXSTARTED event */
-#define UARTE_INTEN_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
-#define UARTE_INTEN_RXSTARTED_Msk (0x1UL << UARTE_INTEN_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
-#define UARTE_INTEN_RXSTARTED_Disabled (0UL) /*!< Disable */
-#define UARTE_INTEN_RXSTARTED_Enabled (1UL) /*!< Enable */
-
-/* Bit 17 : Enable or disable interrupt for RXTO event */
-#define UARTE_INTEN_RXTO_Pos (17UL) /*!< Position of RXTO field. */
-#define UARTE_INTEN_RXTO_Msk (0x1UL << UARTE_INTEN_RXTO_Pos) /*!< Bit mask of RXTO field. */
-#define UARTE_INTEN_RXTO_Disabled (0UL) /*!< Disable */
-#define UARTE_INTEN_RXTO_Enabled (1UL) /*!< Enable */
-
-/* Bit 9 : Enable or disable interrupt for ERROR event */
-#define UARTE_INTEN_ERROR_Pos (9UL) /*!< Position of ERROR field. */
-#define UARTE_INTEN_ERROR_Msk (0x1UL << UARTE_INTEN_ERROR_Pos) /*!< Bit mask of ERROR field. */
-#define UARTE_INTEN_ERROR_Disabled (0UL) /*!< Disable */
-#define UARTE_INTEN_ERROR_Enabled (1UL) /*!< Enable */
-
-/* Bit 8 : Enable or disable interrupt for ENDTX event */
-#define UARTE_INTEN_ENDTX_Pos (8UL) /*!< Position of ENDTX field. */
-#define UARTE_INTEN_ENDTX_Msk (0x1UL << UARTE_INTEN_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
-#define UARTE_INTEN_ENDTX_Disabled (0UL) /*!< Disable */
-#define UARTE_INTEN_ENDTX_Enabled (1UL) /*!< Enable */
-
-/* Bit 7 : Enable or disable interrupt for TXDRDY event */
-#define UARTE_INTEN_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
-#define UARTE_INTEN_TXDRDY_Msk (0x1UL << UARTE_INTEN_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
-#define UARTE_INTEN_TXDRDY_Disabled (0UL) /*!< Disable */
-#define UARTE_INTEN_TXDRDY_Enabled (1UL) /*!< Enable */
-
-/* Bit 4 : Enable or disable interrupt for ENDRX event */
-#define UARTE_INTEN_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
-#define UARTE_INTEN_ENDRX_Msk (0x1UL << UARTE_INTEN_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
-#define UARTE_INTEN_ENDRX_Disabled (0UL) /*!< Disable */
-#define UARTE_INTEN_ENDRX_Enabled (1UL) /*!< Enable */
-
-/* Bit 2 : Enable or disable interrupt for RXDRDY event */
-#define UARTE_INTEN_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
-#define UARTE_INTEN_RXDRDY_Msk (0x1UL << UARTE_INTEN_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
-#define UARTE_INTEN_RXDRDY_Disabled (0UL) /*!< Disable */
-#define UARTE_INTEN_RXDRDY_Enabled (1UL) /*!< Enable */
-
-/* Bit 1 : Enable or disable interrupt for NCTS event */
-#define UARTE_INTEN_NCTS_Pos (1UL) /*!< Position of NCTS field. */
-#define UARTE_INTEN_NCTS_Msk (0x1UL << UARTE_INTEN_NCTS_Pos) /*!< Bit mask of NCTS field. */
-#define UARTE_INTEN_NCTS_Disabled (0UL) /*!< Disable */
-#define UARTE_INTEN_NCTS_Enabled (1UL) /*!< Enable */
-
-/* Bit 0 : Enable or disable interrupt for CTS event */
-#define UARTE_INTEN_CTS_Pos (0UL) /*!< Position of CTS field. */
-#define UARTE_INTEN_CTS_Msk (0x1UL << UARTE_INTEN_CTS_Pos) /*!< Bit mask of CTS field. */
-#define UARTE_INTEN_CTS_Disabled (0UL) /*!< Disable */
-#define UARTE_INTEN_CTS_Enabled (1UL) /*!< Enable */
-
-/* Register: UARTE_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 22 : Write '1' to Enable interrupt for TXSTOPPED event */
-#define UARTE_INTENSET_TXSTOPPED_Pos (22UL) /*!< Position of TXSTOPPED field. */
-#define UARTE_INTENSET_TXSTOPPED_Msk (0x1UL << UARTE_INTENSET_TXSTOPPED_Pos) /*!< Bit mask of TXSTOPPED field. */
-#define UARTE_INTENSET_TXSTOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENSET_TXSTOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENSET_TXSTOPPED_Set (1UL) /*!< Enable */
-
-/* Bit 20 : Write '1' to Enable interrupt for TXSTARTED event */
-#define UARTE_INTENSET_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
-#define UARTE_INTENSET_TXSTARTED_Msk (0x1UL << UARTE_INTENSET_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
-#define UARTE_INTENSET_TXSTARTED_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENSET_TXSTARTED_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENSET_TXSTARTED_Set (1UL) /*!< Enable */
-
-/* Bit 19 : Write '1' to Enable interrupt for RXSTARTED event */
-#define UARTE_INTENSET_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
-#define UARTE_INTENSET_RXSTARTED_Msk (0x1UL << UARTE_INTENSET_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
-#define UARTE_INTENSET_RXSTARTED_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENSET_RXSTARTED_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENSET_RXSTARTED_Set (1UL) /*!< Enable */
-
-/* Bit 17 : Write '1' to Enable interrupt for RXTO event */
-#define UARTE_INTENSET_RXTO_Pos (17UL) /*!< Position of RXTO field. */
-#define UARTE_INTENSET_RXTO_Msk (0x1UL << UARTE_INTENSET_RXTO_Pos) /*!< Bit mask of RXTO field. */
-#define UARTE_INTENSET_RXTO_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENSET_RXTO_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENSET_RXTO_Set (1UL) /*!< Enable */
-
-/* Bit 9 : Write '1' to Enable interrupt for ERROR event */
-#define UARTE_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
-#define UARTE_INTENSET_ERROR_Msk (0x1UL << UARTE_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
-#define UARTE_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENSET_ERROR_Set (1UL) /*!< Enable */
-
-/* Bit 8 : Write '1' to Enable interrupt for ENDTX event */
-#define UARTE_INTENSET_ENDTX_Pos (8UL) /*!< Position of ENDTX field. */
-#define UARTE_INTENSET_ENDTX_Msk (0x1UL << UARTE_INTENSET_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
-#define UARTE_INTENSET_ENDTX_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENSET_ENDTX_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENSET_ENDTX_Set (1UL) /*!< Enable */
-
-/* Bit 7 : Write '1' to Enable interrupt for TXDRDY event */
-#define UARTE_INTENSET_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
-#define UARTE_INTENSET_TXDRDY_Msk (0x1UL << UARTE_INTENSET_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
-#define UARTE_INTENSET_TXDRDY_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENSET_TXDRDY_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENSET_TXDRDY_Set (1UL) /*!< Enable */
-
-/* Bit 4 : Write '1' to Enable interrupt for ENDRX event */
-#define UARTE_INTENSET_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
-#define UARTE_INTENSET_ENDRX_Msk (0x1UL << UARTE_INTENSET_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
-#define UARTE_INTENSET_ENDRX_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENSET_ENDRX_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENSET_ENDRX_Set (1UL) /*!< Enable */
-
-/* Bit 2 : Write '1' to Enable interrupt for RXDRDY event */
-#define UARTE_INTENSET_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
-#define UARTE_INTENSET_RXDRDY_Msk (0x1UL << UARTE_INTENSET_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
-#define UARTE_INTENSET_RXDRDY_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENSET_RXDRDY_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENSET_RXDRDY_Set (1UL) /*!< Enable */
-
-/* Bit 1 : Write '1' to Enable interrupt for NCTS event */
-#define UARTE_INTENSET_NCTS_Pos (1UL) /*!< Position of NCTS field. */
-#define UARTE_INTENSET_NCTS_Msk (0x1UL << UARTE_INTENSET_NCTS_Pos) /*!< Bit mask of NCTS field. */
-#define UARTE_INTENSET_NCTS_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENSET_NCTS_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENSET_NCTS_Set (1UL) /*!< Enable */
-
-/* Bit 0 : Write '1' to Enable interrupt for CTS event */
-#define UARTE_INTENSET_CTS_Pos (0UL) /*!< Position of CTS field. */
-#define UARTE_INTENSET_CTS_Msk (0x1UL << UARTE_INTENSET_CTS_Pos) /*!< Bit mask of CTS field. */
-#define UARTE_INTENSET_CTS_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENSET_CTS_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENSET_CTS_Set (1UL) /*!< Enable */
-
-/* Register: UARTE_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 22 : Write '1' to Disable interrupt for TXSTOPPED event */
-#define UARTE_INTENCLR_TXSTOPPED_Pos (22UL) /*!< Position of TXSTOPPED field. */
-#define UARTE_INTENCLR_TXSTOPPED_Msk (0x1UL << UARTE_INTENCLR_TXSTOPPED_Pos) /*!< Bit mask of TXSTOPPED field. */
-#define UARTE_INTENCLR_TXSTOPPED_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENCLR_TXSTOPPED_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENCLR_TXSTOPPED_Clear (1UL) /*!< Disable */
-
-/* Bit 20 : Write '1' to Disable interrupt for TXSTARTED event */
-#define UARTE_INTENCLR_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
-#define UARTE_INTENCLR_TXSTARTED_Msk (0x1UL << UARTE_INTENCLR_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
-#define UARTE_INTENCLR_TXSTARTED_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENCLR_TXSTARTED_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENCLR_TXSTARTED_Clear (1UL) /*!< Disable */
-
-/* Bit 19 : Write '1' to Disable interrupt for RXSTARTED event */
-#define UARTE_INTENCLR_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
-#define UARTE_INTENCLR_RXSTARTED_Msk (0x1UL << UARTE_INTENCLR_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
-#define UARTE_INTENCLR_RXSTARTED_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENCLR_RXSTARTED_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENCLR_RXSTARTED_Clear (1UL) /*!< Disable */
-
-/* Bit 17 : Write '1' to Disable interrupt for RXTO event */
-#define UARTE_INTENCLR_RXTO_Pos (17UL) /*!< Position of RXTO field. */
-#define UARTE_INTENCLR_RXTO_Msk (0x1UL << UARTE_INTENCLR_RXTO_Pos) /*!< Bit mask of RXTO field. */
-#define UARTE_INTENCLR_RXTO_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENCLR_RXTO_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENCLR_RXTO_Clear (1UL) /*!< Disable */
-
-/* Bit 9 : Write '1' to Disable interrupt for ERROR event */
-#define UARTE_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
-#define UARTE_INTENCLR_ERROR_Msk (0x1UL << UARTE_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
-#define UARTE_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
-
-/* Bit 8 : Write '1' to Disable interrupt for ENDTX event */
-#define UARTE_INTENCLR_ENDTX_Pos (8UL) /*!< Position of ENDTX field. */
-#define UARTE_INTENCLR_ENDTX_Msk (0x1UL << UARTE_INTENCLR_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
-#define UARTE_INTENCLR_ENDTX_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENCLR_ENDTX_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENCLR_ENDTX_Clear (1UL) /*!< Disable */
-
-/* Bit 7 : Write '1' to Disable interrupt for TXDRDY event */
-#define UARTE_INTENCLR_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
-#define UARTE_INTENCLR_TXDRDY_Msk (0x1UL << UARTE_INTENCLR_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
-#define UARTE_INTENCLR_TXDRDY_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENCLR_TXDRDY_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENCLR_TXDRDY_Clear (1UL) /*!< Disable */
-
-/* Bit 4 : Write '1' to Disable interrupt for ENDRX event */
-#define UARTE_INTENCLR_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
-#define UARTE_INTENCLR_ENDRX_Msk (0x1UL << UARTE_INTENCLR_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
-#define UARTE_INTENCLR_ENDRX_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENCLR_ENDRX_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENCLR_ENDRX_Clear (1UL) /*!< Disable */
-
-/* Bit 2 : Write '1' to Disable interrupt for RXDRDY event */
-#define UARTE_INTENCLR_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
-#define UARTE_INTENCLR_RXDRDY_Msk (0x1UL << UARTE_INTENCLR_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
-#define UARTE_INTENCLR_RXDRDY_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENCLR_RXDRDY_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENCLR_RXDRDY_Clear (1UL) /*!< Disable */
-
-/* Bit 1 : Write '1' to Disable interrupt for NCTS event */
-#define UARTE_INTENCLR_NCTS_Pos (1UL) /*!< Position of NCTS field. */
-#define UARTE_INTENCLR_NCTS_Msk (0x1UL << UARTE_INTENCLR_NCTS_Pos) /*!< Bit mask of NCTS field. */
-#define UARTE_INTENCLR_NCTS_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENCLR_NCTS_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENCLR_NCTS_Clear (1UL) /*!< Disable */
-
-/* Bit 0 : Write '1' to Disable interrupt for CTS event */
-#define UARTE_INTENCLR_CTS_Pos (0UL) /*!< Position of CTS field. */
-#define UARTE_INTENCLR_CTS_Msk (0x1UL << UARTE_INTENCLR_CTS_Pos) /*!< Bit mask of CTS field. */
-#define UARTE_INTENCLR_CTS_Disabled (0UL) /*!< Read: Disabled */
-#define UARTE_INTENCLR_CTS_Enabled (1UL) /*!< Read: Enabled */
-#define UARTE_INTENCLR_CTS_Clear (1UL) /*!< Disable */
-
-/* Register: UARTE_ERRORSRC */
-/* Description: Error source */
-
-/* Bit 3 : Break condition */
-#define UARTE_ERRORSRC_BREAK_Pos (3UL) /*!< Position of BREAK field. */
-#define UARTE_ERRORSRC_BREAK_Msk (0x1UL << UARTE_ERRORSRC_BREAK_Pos) /*!< Bit mask of BREAK field. */
-#define UARTE_ERRORSRC_BREAK_NotPresent (0UL) /*!< Read: error not present */
-#define UARTE_ERRORSRC_BREAK_Present (1UL) /*!< Read: error present */
-
-/* Bit 2 : Framing error occurred */
-#define UARTE_ERRORSRC_FRAMING_Pos (2UL) /*!< Position of FRAMING field. */
-#define UARTE_ERRORSRC_FRAMING_Msk (0x1UL << UARTE_ERRORSRC_FRAMING_Pos) /*!< Bit mask of FRAMING field. */
-#define UARTE_ERRORSRC_FRAMING_NotPresent (0UL) /*!< Read: error not present */
-#define UARTE_ERRORSRC_FRAMING_Present (1UL) /*!< Read: error present */
-
-/* Bit 1 : Parity error */
-#define UARTE_ERRORSRC_PARITY_Pos (1UL) /*!< Position of PARITY field. */
-#define UARTE_ERRORSRC_PARITY_Msk (0x1UL << UARTE_ERRORSRC_PARITY_Pos) /*!< Bit mask of PARITY field. */
-#define UARTE_ERRORSRC_PARITY_NotPresent (0UL) /*!< Read: error not present */
-#define UARTE_ERRORSRC_PARITY_Present (1UL) /*!< Read: error present */
-
-/* Bit 0 : Overrun error */
-#define UARTE_ERRORSRC_OVERRUN_Pos (0UL) /*!< Position of OVERRUN field. */
-#define UARTE_ERRORSRC_OVERRUN_Msk (0x1UL << UARTE_ERRORSRC_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
-#define UARTE_ERRORSRC_OVERRUN_NotPresent (0UL) /*!< Read: error not present */
-#define UARTE_ERRORSRC_OVERRUN_Present (1UL) /*!< Read: error present */
-
-/* Register: UARTE_ENABLE */
-/* Description: Enable UART */
-
-/* Bits 3..0 : Enable or disable UARTE */
-#define UARTE_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
-#define UARTE_ENABLE_ENABLE_Msk (0xFUL << UARTE_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
-#define UARTE_ENABLE_ENABLE_Disabled (0UL) /*!< Disable UARTE */
-#define UARTE_ENABLE_ENABLE_Enabled (8UL) /*!< Enable UARTE */
-
-/* Register: UARTE_PSEL_RTS */
-/* Description: Pin select for RTS signal */
-
-/* Bit 31 : Connection */
-#define UARTE_PSEL_RTS_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define UARTE_PSEL_RTS_CONNECT_Msk (0x1UL << UARTE_PSEL_RTS_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define UARTE_PSEL_RTS_CONNECT_Connected (0UL) /*!< Connect */
-#define UARTE_PSEL_RTS_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define UARTE_PSEL_RTS_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define UARTE_PSEL_RTS_PIN_Msk (0x1FUL << UARTE_PSEL_RTS_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: UARTE_PSEL_TXD */
-/* Description: Pin select for TXD signal */
-
-/* Bit 31 : Connection */
-#define UARTE_PSEL_TXD_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define UARTE_PSEL_TXD_CONNECT_Msk (0x1UL << UARTE_PSEL_TXD_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define UARTE_PSEL_TXD_CONNECT_Connected (0UL) /*!< Connect */
-#define UARTE_PSEL_TXD_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define UARTE_PSEL_TXD_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define UARTE_PSEL_TXD_PIN_Msk (0x1FUL << UARTE_PSEL_TXD_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: UARTE_PSEL_CTS */
-/* Description: Pin select for CTS signal */
-
-/* Bit 31 : Connection */
-#define UARTE_PSEL_CTS_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define UARTE_PSEL_CTS_CONNECT_Msk (0x1UL << UARTE_PSEL_CTS_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define UARTE_PSEL_CTS_CONNECT_Connected (0UL) /*!< Connect */
-#define UARTE_PSEL_CTS_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define UARTE_PSEL_CTS_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define UARTE_PSEL_CTS_PIN_Msk (0x1FUL << UARTE_PSEL_CTS_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: UARTE_PSEL_RXD */
-/* Description: Pin select for RXD signal */
-
-/* Bit 31 : Connection */
-#define UARTE_PSEL_RXD_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define UARTE_PSEL_RXD_CONNECT_Msk (0x1UL << UARTE_PSEL_RXD_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define UARTE_PSEL_RXD_CONNECT_Connected (0UL) /*!< Connect */
-#define UARTE_PSEL_RXD_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : Pin number */
-#define UARTE_PSEL_RXD_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define UARTE_PSEL_RXD_PIN_Msk (0x1FUL << UARTE_PSEL_RXD_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: UARTE_BAUDRATE */
-/* Description: Baud rate. Accuracy depends on the HFCLK source selected. */
-
-/* Bits 31..0 : Baud rate */
-#define UARTE_BAUDRATE_BAUDRATE_Pos (0UL) /*!< Position of BAUDRATE field. */
-#define UARTE_BAUDRATE_BAUDRATE_Msk (0xFFFFFFFFUL << UARTE_BAUDRATE_BAUDRATE_Pos) /*!< Bit mask of BAUDRATE field. */
-#define UARTE_BAUDRATE_BAUDRATE_Baud1200 (0x0004F000UL) /*!< 1200 baud (actual rate: 1205) */
-#define UARTE_BAUDRATE_BAUDRATE_Baud2400 (0x0009D000UL) /*!< 2400 baud (actual rate: 2396) */
-#define UARTE_BAUDRATE_BAUDRATE_Baud4800 (0x0013B000UL) /*!< 4800 baud (actual rate: 4808) */
-#define UARTE_BAUDRATE_BAUDRATE_Baud9600 (0x00275000UL) /*!< 9600 baud (actual rate: 9598) */
-#define UARTE_BAUDRATE_BAUDRATE_Baud14400 (0x003AF000UL) /*!< 14400 baud (actual rate: 14401) */
-#define UARTE_BAUDRATE_BAUDRATE_Baud19200 (0x004EA000UL) /*!< 19200 baud (actual rate: 19208) */
-#define UARTE_BAUDRATE_BAUDRATE_Baud28800 (0x0075C000UL) /*!< 28800 baud (actual rate: 28777) */
-#define UARTE_BAUDRATE_BAUDRATE_Baud31250 (0x00800000UL) /*!< 31250 baud */
-#define UARTE_BAUDRATE_BAUDRATE_Baud38400 (0x009D0000UL) /*!< 38400 baud (actual rate: 38369) */
-#define UARTE_BAUDRATE_BAUDRATE_Baud56000 (0x00E50000UL) /*!< 56000 baud (actual rate: 55944) */
-#define UARTE_BAUDRATE_BAUDRATE_Baud57600 (0x00EB0000UL) /*!< 57600 baud (actual rate: 57554) */
-#define UARTE_BAUDRATE_BAUDRATE_Baud76800 (0x013A9000UL) /*!< 76800 baud (actual rate: 76923) */
-#define UARTE_BAUDRATE_BAUDRATE_Baud115200 (0x01D60000UL) /*!< 115200 baud (actual rate: 115108) */
-#define UARTE_BAUDRATE_BAUDRATE_Baud230400 (0x03B00000UL) /*!< 230400 baud (actual rate: 231884) */
-#define UARTE_BAUDRATE_BAUDRATE_Baud250000 (0x04000000UL) /*!< 250000 baud */
-#define UARTE_BAUDRATE_BAUDRATE_Baud460800 (0x07400000UL) /*!< 460800 baud (actual rate: 457143) */
-#define UARTE_BAUDRATE_BAUDRATE_Baud921600 (0x0F000000UL) /*!< 921600 baud (actual rate: 941176) */
-#define UARTE_BAUDRATE_BAUDRATE_Baud1M (0x10000000UL) /*!< 1Mega baud */
-
-/* Register: UARTE_RXD_PTR */
-/* Description: Data pointer */
-
-/* Bits 31..0 : Data pointer */
-#define UARTE_RXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
-#define UARTE_RXD_PTR_PTR_Msk (0xFFFFFFFFUL << UARTE_RXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
-
-/* Register: UARTE_RXD_MAXCNT */
-/* Description: Maximum number of bytes in receive buffer */
-
-/* Bits 7..0 : Maximum number of bytes in receive buffer */
-#define UARTE_RXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
-#define UARTE_RXD_MAXCNT_MAXCNT_Msk (0xFFUL << UARTE_RXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
-
-/* Register: UARTE_RXD_AMOUNT */
-/* Description: Number of bytes transferred in the last transaction */
-
-/* Bits 7..0 : Number of bytes transferred in the last transaction */
-#define UARTE_RXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
-#define UARTE_RXD_AMOUNT_AMOUNT_Msk (0xFFUL << UARTE_RXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
-
-/* Register: UARTE_TXD_PTR */
-/* Description: Data pointer */
-
-/* Bits 31..0 : Data pointer */
-#define UARTE_TXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
-#define UARTE_TXD_PTR_PTR_Msk (0xFFFFFFFFUL << UARTE_TXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
-
-/* Register: UARTE_TXD_MAXCNT */
-/* Description: Maximum number of bytes in transmit buffer */
-
-/* Bits 7..0 : Maximum number of bytes in transmit buffer */
-#define UARTE_TXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
-#define UARTE_TXD_MAXCNT_MAXCNT_Msk (0xFFUL << UARTE_TXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
-
-/* Register: UARTE_TXD_AMOUNT */
-/* Description: Number of bytes transferred in the last transaction */
-
-/* Bits 7..0 : Number of bytes transferred in the last transaction */
-#define UARTE_TXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
-#define UARTE_TXD_AMOUNT_AMOUNT_Msk (0xFFUL << UARTE_TXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
-
-/* Register: UARTE_CONFIG */
-/* Description: Configuration of parity and hardware flow control */
-
-/* Bits 3..1 : Parity */
-#define UARTE_CONFIG_PARITY_Pos (1UL) /*!< Position of PARITY field. */
-#define UARTE_CONFIG_PARITY_Msk (0x7UL << UARTE_CONFIG_PARITY_Pos) /*!< Bit mask of PARITY field. */
-#define UARTE_CONFIG_PARITY_Excluded (0x0UL) /*!< Exclude parity bit */
-#define UARTE_CONFIG_PARITY_Included (0x7UL) /*!< Include parity bit */
-
-/* Bit 0 : Hardware flow control */
-#define UARTE_CONFIG_HWFC_Pos (0UL) /*!< Position of HWFC field. */
-#define UARTE_CONFIG_HWFC_Msk (0x1UL << UARTE_CONFIG_HWFC_Pos) /*!< Bit mask of HWFC field. */
-#define UARTE_CONFIG_HWFC_Disabled (0UL) /*!< Disabled */
-#define UARTE_CONFIG_HWFC_Enabled (1UL) /*!< Enabled */
-
-
-/* Peripheral: UICR */
-/* Description: User Information Configuration Registers */
-
-/* Register: UICR_NRFFW */
-/* Description: Description collection[0]:  Reserved for Nordic firmware design */
-
-/* Bits 31..0 : Reserved for Nordic firmware design */
-#define UICR_NRFFW_NRFFW_Pos (0UL) /*!< Position of NRFFW field. */
-#define UICR_NRFFW_NRFFW_Msk (0xFFFFFFFFUL << UICR_NRFFW_NRFFW_Pos) /*!< Bit mask of NRFFW field. */
-
-/* Register: UICR_NRFHW */
-/* Description: Description collection[0]:  Reserved for Nordic hardware design */
-
-/* Bits 31..0 : Reserved for Nordic hardware design */
-#define UICR_NRFHW_NRFHW_Pos (0UL) /*!< Position of NRFHW field. */
-#define UICR_NRFHW_NRFHW_Msk (0xFFFFFFFFUL << UICR_NRFHW_NRFHW_Pos) /*!< Bit mask of NRFHW field. */
-
-/* Register: UICR_CUSTOMER */
-/* Description: Description collection[0]:  Reserved for customer */
-
-/* Bits 31..0 : Reserved for customer */
-#define UICR_CUSTOMER_CUSTOMER_Pos (0UL) /*!< Position of CUSTOMER field. */
-#define UICR_CUSTOMER_CUSTOMER_Msk (0xFFFFFFFFUL << UICR_CUSTOMER_CUSTOMER_Pos) /*!< Bit mask of CUSTOMER field. */
-
-/* Register: UICR_PSELRESET */
-/* Description: Description collection[0]:  Mapping of the nRESET function (see POWER chapter for details) */
-
-/* Bit 31 : Connection */
-#define UICR_PSELRESET_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
-#define UICR_PSELRESET_CONNECT_Msk (0x1UL << UICR_PSELRESET_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
-#define UICR_PSELRESET_CONNECT_Connected (0UL) /*!< Connect */
-#define UICR_PSELRESET_CONNECT_Disconnected (1UL) /*!< Disconnect */
-
-/* Bits 4..0 : GPIO number P0.n onto which Reset is exposed */
-#define UICR_PSELRESET_PIN_Pos (0UL) /*!< Position of PIN field. */
-#define UICR_PSELRESET_PIN_Msk (0x1FUL << UICR_PSELRESET_PIN_Pos) /*!< Bit mask of PIN field. */
-
-/* Register: UICR_APPROTECT */
-/* Description: Access Port protection */
-
-/* Bits 7..0 : Enable or disable Access Port protection. Any other value than 0xFF being written to this field will enable protection. */
-#define UICR_APPROTECT_PALL_Pos (0UL) /*!< Position of PALL field. */
-#define UICR_APPROTECT_PALL_Msk (0xFFUL << UICR_APPROTECT_PALL_Pos) /*!< Bit mask of PALL field. */
-#define UICR_APPROTECT_PALL_Enabled (0x00UL) /*!< Enable */
-#define UICR_APPROTECT_PALL_Disabled (0xFFUL) /*!< Disable */
-
-/* Register: UICR_NFCPINS */
-/* Description: Setting of pins dedicated to NFC functionality: NFC antenna or GPIO */
-
-/* Bit 0 : Setting of pins dedicated to NFC functionality */
-#define UICR_NFCPINS_PROTECT_Pos (0UL) /*!< Position of PROTECT field. */
-#define UICR_NFCPINS_PROTECT_Msk (0x1UL << UICR_NFCPINS_PROTECT_Pos) /*!< Bit mask of PROTECT field. */
-#define UICR_NFCPINS_PROTECT_Disabled (0UL) /*!< Operation as GPIO pins. Same protection as normal GPIO pins */
-#define UICR_NFCPINS_PROTECT_NFC (1UL) /*!< Operation as NFC antenna pins. Configures the protection for NFC operation */
-
-
-/* Peripheral: WDT */
-/* Description: Watchdog Timer */
-
-/* Register: WDT_INTENSET */
-/* Description: Enable interrupt */
-
-/* Bit 0 : Write '1' to Enable interrupt for TIMEOUT event */
-#define WDT_INTENSET_TIMEOUT_Pos (0UL) /*!< Position of TIMEOUT field. */
-#define WDT_INTENSET_TIMEOUT_Msk (0x1UL << WDT_INTENSET_TIMEOUT_Pos) /*!< Bit mask of TIMEOUT field. */
-#define WDT_INTENSET_TIMEOUT_Disabled (0UL) /*!< Read: Disabled */
-#define WDT_INTENSET_TIMEOUT_Enabled (1UL) /*!< Read: Enabled */
-#define WDT_INTENSET_TIMEOUT_Set (1UL) /*!< Enable */
-
-/* Register: WDT_INTENCLR */
-/* Description: Disable interrupt */
-
-/* Bit 0 : Write '1' to Disable interrupt for TIMEOUT event */
-#define WDT_INTENCLR_TIMEOUT_Pos (0UL) /*!< Position of TIMEOUT field. */
-#define WDT_INTENCLR_TIMEOUT_Msk (0x1UL << WDT_INTENCLR_TIMEOUT_Pos) /*!< Bit mask of TIMEOUT field. */
-#define WDT_INTENCLR_TIMEOUT_Disabled (0UL) /*!< Read: Disabled */
-#define WDT_INTENCLR_TIMEOUT_Enabled (1UL) /*!< Read: Enabled */
-#define WDT_INTENCLR_TIMEOUT_Clear (1UL) /*!< Disable */
-
-/* Register: WDT_RUNSTATUS */
-/* Description: Run status */
-
-/* Bit 0 : Indicates whether or not the watchdog is running */
-#define WDT_RUNSTATUS_RUNSTATUS_Pos (0UL) /*!< Position of RUNSTATUS field. */
-#define WDT_RUNSTATUS_RUNSTATUS_Msk (0x1UL << WDT_RUNSTATUS_RUNSTATUS_Pos) /*!< Bit mask of RUNSTATUS field. */
-#define WDT_RUNSTATUS_RUNSTATUS_NotRunning (0UL) /*!< Watchdog not running */
-#define WDT_RUNSTATUS_RUNSTATUS_Running (1UL) /*!< Watchdog is running */
-
-/* Register: WDT_REQSTATUS */
-/* Description: Request status */
-
-/* Bit 7 : Request status for RR[7] register */
-#define WDT_REQSTATUS_RR7_Pos (7UL) /*!< Position of RR7 field. */
-#define WDT_REQSTATUS_RR7_Msk (0x1UL << WDT_REQSTATUS_RR7_Pos) /*!< Bit mask of RR7 field. */
-#define WDT_REQSTATUS_RR7_DisabledOrRequested (0UL) /*!< RR[7] register is not enabled, or are already requesting reload */
-#define WDT_REQSTATUS_RR7_EnabledAndUnrequested (1UL) /*!< RR[7] register is enabled, and are not yet requesting reload */
-
-/* Bit 6 : Request status for RR[6] register */
-#define WDT_REQSTATUS_RR6_Pos (6UL) /*!< Position of RR6 field. */
-#define WDT_REQSTATUS_RR6_Msk (0x1UL << WDT_REQSTATUS_RR6_Pos) /*!< Bit mask of RR6 field. */
-#define WDT_REQSTATUS_RR6_DisabledOrRequested (0UL) /*!< RR[6] register is not enabled, or are already requesting reload */
-#define WDT_REQSTATUS_RR6_EnabledAndUnrequested (1UL) /*!< RR[6] register is enabled, and are not yet requesting reload */
-
-/* Bit 5 : Request status for RR[5] register */
-#define WDT_REQSTATUS_RR5_Pos (5UL) /*!< Position of RR5 field. */
-#define WDT_REQSTATUS_RR5_Msk (0x1UL << WDT_REQSTATUS_RR5_Pos) /*!< Bit mask of RR5 field. */
-#define WDT_REQSTATUS_RR5_DisabledOrRequested (0UL) /*!< RR[5] register is not enabled, or are already requesting reload */
-#define WDT_REQSTATUS_RR5_EnabledAndUnrequested (1UL) /*!< RR[5] register is enabled, and are not yet requesting reload */
-
-/* Bit 4 : Request status for RR[4] register */
-#define WDT_REQSTATUS_RR4_Pos (4UL) /*!< Position of RR4 field. */
-#define WDT_REQSTATUS_RR4_Msk (0x1UL << WDT_REQSTATUS_RR4_Pos) /*!< Bit mask of RR4 field. */
-#define WDT_REQSTATUS_RR4_DisabledOrRequested (0UL) /*!< RR[4] register is not enabled, or are already requesting reload */
-#define WDT_REQSTATUS_RR4_EnabledAndUnrequested (1UL) /*!< RR[4] register is enabled, and are not yet requesting reload */
-
-/* Bit 3 : Request status for RR[3] register */
-#define WDT_REQSTATUS_RR3_Pos (3UL) /*!< Position of RR3 field. */
-#define WDT_REQSTATUS_RR3_Msk (0x1UL << WDT_REQSTATUS_RR3_Pos) /*!< Bit mask of RR3 field. */
-#define WDT_REQSTATUS_RR3_DisabledOrRequested (0UL) /*!< RR[3] register is not enabled, or are already requesting reload */
-#define WDT_REQSTATUS_RR3_EnabledAndUnrequested (1UL) /*!< RR[3] register is enabled, and are not yet requesting reload */
-
-/* Bit 2 : Request status for RR[2] register */
-#define WDT_REQSTATUS_RR2_Pos (2UL) /*!< Position of RR2 field. */
-#define WDT_REQSTATUS_RR2_Msk (0x1UL << WDT_REQSTATUS_RR2_Pos) /*!< Bit mask of RR2 field. */
-#define WDT_REQSTATUS_RR2_DisabledOrRequested (0UL) /*!< RR[2] register is not enabled, or are already requesting reload */
-#define WDT_REQSTATUS_RR2_EnabledAndUnrequested (1UL) /*!< RR[2] register is enabled, and are not yet requesting reload */
-
-/* Bit 1 : Request status for RR[1] register */
-#define WDT_REQSTATUS_RR1_Pos (1UL) /*!< Position of RR1 field. */
-#define WDT_REQSTATUS_RR1_Msk (0x1UL << WDT_REQSTATUS_RR1_Pos) /*!< Bit mask of RR1 field. */
-#define WDT_REQSTATUS_RR1_DisabledOrRequested (0UL) /*!< RR[1] register is not enabled, or are already requesting reload */
-#define WDT_REQSTATUS_RR1_EnabledAndUnrequested (1UL) /*!< RR[1] register is enabled, and are not yet requesting reload */
-
-/* Bit 0 : Request status for RR[0] register */
-#define WDT_REQSTATUS_RR0_Pos (0UL) /*!< Position of RR0 field. */
-#define WDT_REQSTATUS_RR0_Msk (0x1UL << WDT_REQSTATUS_RR0_Pos) /*!< Bit mask of RR0 field. */
-#define WDT_REQSTATUS_RR0_DisabledOrRequested (0UL) /*!< RR[0] register is not enabled, or are already requesting reload */
-#define WDT_REQSTATUS_RR0_EnabledAndUnrequested (1UL) /*!< RR[0] register is enabled, and are not yet requesting reload */
-
-/* Register: WDT_CRV */
-/* Description: Counter reload value */
-
-/* Bits 31..0 : Counter reload value in number of cycles of the 32.768 kHz clock */
-#define WDT_CRV_CRV_Pos (0UL) /*!< Position of CRV field. */
-#define WDT_CRV_CRV_Msk (0xFFFFFFFFUL << WDT_CRV_CRV_Pos) /*!< Bit mask of CRV field. */
-
-/* Register: WDT_RREN */
-/* Description: Enable register for reload request registers */
-
-/* Bit 7 : Enable or disable RR[7] register */
-#define WDT_RREN_RR7_Pos (7UL) /*!< Position of RR7 field. */
-#define WDT_RREN_RR7_Msk (0x1UL << WDT_RREN_RR7_Pos) /*!< Bit mask of RR7 field. */
-#define WDT_RREN_RR7_Disabled (0UL) /*!< Disable RR[7] register */
-#define WDT_RREN_RR7_Enabled (1UL) /*!< Enable RR[7] register */
-
-/* Bit 6 : Enable or disable RR[6] register */
-#define WDT_RREN_RR6_Pos (6UL) /*!< Position of RR6 field. */
-#define WDT_RREN_RR6_Msk (0x1UL << WDT_RREN_RR6_Pos) /*!< Bit mask of RR6 field. */
-#define WDT_RREN_RR6_Disabled (0UL) /*!< Disable RR[6] register */
-#define WDT_RREN_RR6_Enabled (1UL) /*!< Enable RR[6] register */
-
-/* Bit 5 : Enable or disable RR[5] register */
-#define WDT_RREN_RR5_Pos (5UL) /*!< Position of RR5 field. */
-#define WDT_RREN_RR5_Msk (0x1UL << WDT_RREN_RR5_Pos) /*!< Bit mask of RR5 field. */
-#define WDT_RREN_RR5_Disabled (0UL) /*!< Disable RR[5] register */
-#define WDT_RREN_RR5_Enabled (1UL) /*!< Enable RR[5] register */
-
-/* Bit 4 : Enable or disable RR[4] register */
-#define WDT_RREN_RR4_Pos (4UL) /*!< Position of RR4 field. */
-#define WDT_RREN_RR4_Msk (0x1UL << WDT_RREN_RR4_Pos) /*!< Bit mask of RR4 field. */
-#define WDT_RREN_RR4_Disabled (0UL) /*!< Disable RR[4] register */
-#define WDT_RREN_RR4_Enabled (1UL) /*!< Enable RR[4] register */
-
-/* Bit 3 : Enable or disable RR[3] register */
-#define WDT_RREN_RR3_Pos (3UL) /*!< Position of RR3 field. */
-#define WDT_RREN_RR3_Msk (0x1UL << WDT_RREN_RR3_Pos) /*!< Bit mask of RR3 field. */
-#define WDT_RREN_RR3_Disabled (0UL) /*!< Disable RR[3] register */
-#define WDT_RREN_RR3_Enabled (1UL) /*!< Enable RR[3] register */
-
-/* Bit 2 : Enable or disable RR[2] register */
-#define WDT_RREN_RR2_Pos (2UL) /*!< Position of RR2 field. */
-#define WDT_RREN_RR2_Msk (0x1UL << WDT_RREN_RR2_Pos) /*!< Bit mask of RR2 field. */
-#define WDT_RREN_RR2_Disabled (0UL) /*!< Disable RR[2] register */
-#define WDT_RREN_RR2_Enabled (1UL) /*!< Enable RR[2] register */
-
-/* Bit 1 : Enable or disable RR[1] register */
-#define WDT_RREN_RR1_Pos (1UL) /*!< Position of RR1 field. */
-#define WDT_RREN_RR1_Msk (0x1UL << WDT_RREN_RR1_Pos) /*!< Bit mask of RR1 field. */
-#define WDT_RREN_RR1_Disabled (0UL) /*!< Disable RR[1] register */
-#define WDT_RREN_RR1_Enabled (1UL) /*!< Enable RR[1] register */
-
-/* Bit 0 : Enable or disable RR[0] register */
-#define WDT_RREN_RR0_Pos (0UL) /*!< Position of RR0 field. */
-#define WDT_RREN_RR0_Msk (0x1UL << WDT_RREN_RR0_Pos) /*!< Bit mask of RR0 field. */
-#define WDT_RREN_RR0_Disabled (0UL) /*!< Disable RR[0] register */
-#define WDT_RREN_RR0_Enabled (1UL) /*!< Enable RR[0] register */
-
-/* Register: WDT_CONFIG */
-/* Description: Configuration register */
-
-/* Bit 3 : Configure the watchdog to either be paused, or kept running, while the CPU is halted by the debugger */
-#define WDT_CONFIG_HALT_Pos (3UL) /*!< Position of HALT field. */
-#define WDT_CONFIG_HALT_Msk (0x1UL << WDT_CONFIG_HALT_Pos) /*!< Bit mask of HALT field. */
-#define WDT_CONFIG_HALT_Pause (0UL) /*!< Pause watchdog while the CPU is halted by the debugger */
-#define WDT_CONFIG_HALT_Run (1UL) /*!< Keep the watchdog running while the CPU is halted by the debugger */
-
-/* Bit 0 : Configure the watchdog to either be paused, or kept running, while the CPU is sleeping */
-#define WDT_CONFIG_SLEEP_Pos (0UL) /*!< Position of SLEEP field. */
-#define WDT_CONFIG_SLEEP_Msk (0x1UL << WDT_CONFIG_SLEEP_Pos) /*!< Bit mask of SLEEP field. */
-#define WDT_CONFIG_SLEEP_Pause (0UL) /*!< Pause watchdog while the CPU is sleeping */
-#define WDT_CONFIG_SLEEP_Run (1UL) /*!< Keep the watchdog running while the CPU is sleeping */
-
-/* Register: WDT_RR */
-/* Description: Description collection[0]:  Reload request 0 */
-
-/* Bits 31..0 : Reload request register */
-#define WDT_RR_RR_Pos (0UL) /*!< Position of RR field. */
-#define WDT_RR_RR_Msk (0xFFFFFFFFUL << WDT_RR_RR_Pos) /*!< Bit mask of RR field. */
-#define WDT_RR_RR_Reload (0x6E524635UL) /*!< Value to request a reload of the watchdog timer */
-
-
-/*lint --flb "Leave library region" */
-#endif
diff --git a/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_i2s.h b/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_i2s.h
deleted file mode 100644
index f91e8be890..0000000000
--- a/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_i2s.h
+++ /dev/null
@@ -1,536 +0,0 @@
-/* Copyright (c) 2015 Nordic Semiconductor. All Rights Reserved.
- *
- * The information contained herein is property of Nordic Semiconductor ASA.
- * Terms and conditions of usage are described in detail in NORDIC
- * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
- *
- * Licensees are granted free, non-transferable use of the information. NO
- * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
- * the file.
- *
- */
-
-/**
- * @defgroup nrf_i2s_hal I2S HAL
- * @{
- * @ingroup nrf_i2s
- *
- * @brief @tagAPI52 Hardware access layer for managing the Inter-IC Sound (I2S) peripheral.
- */
-
-#ifndef NRF_I2S_H__
-#define NRF_I2S_H__
-
-#include <stddef.h>
-#include <stdbool.h>
-#include <stdint.h>
-
-#include "nrf.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-/**
- * @brief This value can be provided as a parameter for the @ref nrf_i2s_pins_set
- *        function call to specify that a given I2S signal (SDOUT, SDIN, or MCK)
- *        shall not be connected to a physical pin.
- */
-#define NRF_I2S_PIN_NOT_CONNECTED  0xFFFFFFFF
-
-
-/**
- * @brief I2S tasks.
- */
-typedef enum
-{
-  /*lint -save -e30*/
-  NRF_I2S_TASK_START = offsetof(NRF_I2S_Type, TASKS_START), ///< Starts continuous I2S transfer. Also starts the MCK generator if this is enabled.
-  NRF_I2S_TASK_STOP  = offsetof(NRF_I2S_Type, TASKS_STOP)   ///< Stops I2S transfer. Also stops the MCK generator.
-                       /*lint -restore*/
-} nrf_i2s_task_t;
-
-/**
- * @brief I2S events.
- */
-typedef enum
-{
-  /*lint -save -e30*/
-  NRF_I2S_EVENT_RXPTRUPD = offsetof(NRF_I2S_Type, EVENTS_RXPTRUPD), ///< The RXD.PTR register has been copied to internal double-buffers.
-  NRF_I2S_EVENT_TXPTRUPD = offsetof(NRF_I2S_Type, EVENTS_TXPTRUPD), ///< The TXD.PTR register has been copied to internal double-buffers.
-  NRF_I2S_EVENT_STOPPED  = offsetof(NRF_I2S_Type, EVENTS_STOPPED)   ///< I2S transfer stopped.
-                           /*lint -restore*/
-} nrf_i2s_event_t;
-
-/**
- * @brief I2S interrupts.
- */
-typedef enum
-{
-  NRF_I2S_INT_RXPTRUPD_MASK = I2S_INTENSET_RXPTRUPD_Msk, ///< Interrupt on RXPTRUPD event.
-  NRF_I2S_INT_TXPTRUPD_MASK = I2S_INTENSET_TXPTRUPD_Msk, ///< Interrupt on TXPTRUPD event.
-  NRF_I2S_INT_STOPPED_MASK  = I2S_INTENSET_STOPPED_Msk   ///< Interrupt on STOPPED event.
-} nrf_i2s_int_mask_t;
-
-/**
- * @brief I2S modes of operation.
- */
-typedef enum
-{
-  NRF_I2S_MODE_MASTER = I2S_CONFIG_MODE_MODE_Master, ///< Master mode.
-  NRF_I2S_MODE_SLAVE  = I2S_CONFIG_MODE_MODE_Slave   ///< Slave mode.
-} nrf_i2s_mode_t;
-
-/**
- * @brief I2S master clock generator settings.
- */
-typedef enum
-{
-  NRF_I2S_MCK_DISABLED  = 0,                                       ///< MCK disabled.
-  // [conversion to 'int' needed to prevent compilers from complaining
-  //  that the provided value (0x80000000UL) is out of range of "int"]
-  NRF_I2S_MCK_32MDIV2   = (int)I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV2, ///< 32 MHz / 2 = 16.0 MHz.
-  NRF_I2S_MCK_32MDIV3   = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV3,      ///< 32 MHz / 3 = 10.6666667 MHz.
-  NRF_I2S_MCK_32MDIV4   = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV4,      ///< 32 MHz / 4 = 8.0 MHz.
-  NRF_I2S_MCK_32MDIV5   = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV5,      ///< 32 MHz / 5 = 6.4 MHz.
-  NRF_I2S_MCK_32MDIV6   = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV6,      ///< 32 MHz / 6 = 5.3333333 MHz.
-  NRF_I2S_MCK_32MDIV8   = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV8,      ///< 32 MHz / 8 = 4.0 MHz.
-  NRF_I2S_MCK_32MDIV10  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV10,     ///< 32 MHz / 10 = 3.2 MHz.
-  NRF_I2S_MCK_32MDIV11  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV11,     ///< 32 MHz / 11 = 2.9090909 MHz.
-  NRF_I2S_MCK_32MDIV15  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV15,     ///< 32 MHz / 15 = 2.1333333 MHz.
-  NRF_I2S_MCK_32MDIV16  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV16,     ///< 32 MHz / 16 = 2.0 MHz.
-  NRF_I2S_MCK_32MDIV21  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV21,     ///< 32 MHz / 21 = 1.5238095 MHz.
-  NRF_I2S_MCK_32MDIV23  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV23,     ///< 32 MHz / 23 = 1.3913043 MHz.
-  NRF_I2S_MCK_32MDIV31  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV31,     ///< 32 MHz / 31 = 1.0322581 MHz.
-  NRF_I2S_MCK_32MDIV42  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV42,     ///< 32 MHz / 42 = 0.7619048 MHz.
-  NRF_I2S_MCK_32MDIV63  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV63,     ///< 32 MHz / 63 = 0.5079365 MHz.
-  NRF_I2S_MCK_32MDIV125 = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV125     ///< 32 MHz / 125 = 0.256 MHz.
-} nrf_i2s_mck_t;
-
-/**
- * @brief I2S MCK/LRCK ratios.
- */
-typedef enum
-{
-  NRF_I2S_RATIO_32X  = I2S_CONFIG_RATIO_RATIO_32X,  ///< LRCK = MCK / 32.
-  NRF_I2S_RATIO_48X  = I2S_CONFIG_RATIO_RATIO_48X,  ///< LRCK = MCK / 48.
-  NRF_I2S_RATIO_64X  = I2S_CONFIG_RATIO_RATIO_64X,  ///< LRCK = MCK / 64.
-  NRF_I2S_RATIO_96X  = I2S_CONFIG_RATIO_RATIO_96X,  ///< LRCK = MCK / 96.
-  NRF_I2S_RATIO_128X = I2S_CONFIG_RATIO_RATIO_128X, ///< LRCK = MCK / 128.
-  NRF_I2S_RATIO_192X = I2S_CONFIG_RATIO_RATIO_192X, ///< LRCK = MCK / 192.
-  NRF_I2S_RATIO_256X = I2S_CONFIG_RATIO_RATIO_256X, ///< LRCK = MCK / 256.
-  NRF_I2S_RATIO_384X = I2S_CONFIG_RATIO_RATIO_384X, ///< LRCK = MCK / 384.
-  NRF_I2S_RATIO_512X = I2S_CONFIG_RATIO_RATIO_512X  ///< LRCK = MCK / 512.
-} nrf_i2s_ratio_t;
-
-/**
- * @brief I2S sample widths.
- */
-typedef enum
-{
-  NRF_I2S_SWIDTH_8BIT  = I2S_CONFIG_SWIDTH_SWIDTH_8Bit,  ///< 8 bit.
-  NRF_I2S_SWIDTH_16BIT = I2S_CONFIG_SWIDTH_SWIDTH_16Bit, ///< 16 bit.
-  NRF_I2S_SWIDTH_24BIT = I2S_CONFIG_SWIDTH_SWIDTH_24Bit  ///< 24 bit.
-} nrf_i2s_swidth_t;
-
-/**
- * @brief I2S alignments of sample within a frame.
- */
-typedef enum
-{
-  NRF_I2S_ALIGN_LEFT  = I2S_CONFIG_ALIGN_ALIGN_Left, ///< Left-aligned.
-  NRF_I2S_ALIGN_RIGHT = I2S_CONFIG_ALIGN_ALIGN_Right ///< Right-aligned.
-} nrf_i2s_align_t;
-
-/**
- * @brief I2S frame formats.
- */
-typedef enum
-{
-  NRF_I2S_FORMAT_I2S     = I2S_CONFIG_FORMAT_FORMAT_I2S,    ///< Original I2S format.
-  NRF_I2S_FORMAT_ALIGNED = I2S_CONFIG_FORMAT_FORMAT_Aligned ///< Alternate (left- or right-aligned) format.
-} nrf_i2s_format_t;
-
-/**
- * @brief I2S enabled channels.
- */
-typedef enum
-{
-  NRF_I2S_CHANNELS_STEREO = I2S_CONFIG_CHANNELS_CHANNELS_Stereo, ///< Stereo.
-  NRF_I2S_CHANNELS_LEFT   = I2S_CONFIG_CHANNELS_CHANNELS_Left,   ///< Left only.
-  NRF_I2S_CHANNELS_RIGHT  = I2S_CONFIG_CHANNELS_CHANNELS_Right   ///< Right only.
-} nrf_i2s_channels_t;
-
-
-/**
- * @brief Function for activating a specific I2S task.
- *
- * @param[in] p_i2s I2S instance.
- * @param[in] task  Task to activate.
- */
-__STATIC_INLINE void nrf_i2s_task_trigger(NRF_I2S_Type *p_i2s,
-                                          nrf_i2s_task_t task);
-
-/**
- * @brief Function for getting the address of a specific I2S task register.
- *
- * @param[in] p_i2s I2S instance.
- * @param[in] task  Requested task.
- *
- * @return Address of the specified task register.
- */
-__STATIC_INLINE uint32_t nrf_i2s_task_address_get(NRF_I2S_Type const *p_i2s,
-                                                  nrf_i2s_task_t task);
-
-/**
- * @brief Function for clearing a specific I2S event.
- *
- * @param[in] p_i2s I2S instance.
- * @param[in] event Event to clear.
- */
-__STATIC_INLINE void nrf_i2s_event_clear(NRF_I2S_Type *p_i2s,
-                                         nrf_i2s_event_t event);
-
-/**
- * @brief Function for checking the state of a specific I2S event.
- *
- * @param[in] p_i2s I2S instance.
- * @param[in] event Event to check.
- *
- * @retval true  If the event is set.
- * @retval false If the event is not set.
- */
-__STATIC_INLINE bool nrf_i2s_event_check(NRF_I2S_Type const *p_i2s,
-                                         nrf_i2s_event_t event);
-
-/**
- * @brief Function for getting the address of a specific I2S event register.
- *
- * @param[in] p_i2s I2S instance.
- * @param[in] event Requested event.
- *
- * @return Address of the specified event register.
- */
-__STATIC_INLINE uint32_t nrf_i2s_event_address_get(NRF_I2S_Type const *p_i2s,
-                                                   nrf_i2s_event_t event);
-
-/**
- * @brief Function for enabling specified interrupts.
- *
- * @param[in] p_i2s I2S instance.
- * @param[in] mask  Interrupts to enable.
- */
-__STATIC_INLINE void nrf_i2s_int_enable(NRF_I2S_Type *p_i2s, uint32_t mask);
-
-/**
- * @brief Function for disabling specified interrupts.
- *
- * @param[in] p_i2s I2S instance.
- * @param[in] mask  Interrupts to disable.
- */
-__STATIC_INLINE void nrf_i2s_int_disable(NRF_I2S_Type *p_i2s, uint32_t mask);
-
-/**
- * @brief Function for retrieving the state of a given interrupt.
- *
- * @param[in] p_i2s   I2S instance.
- * @param[in] i2s_int Interrupt to check.
- *
- * @retval true  If the interrupt is enabled.
- * @retval false If the interrupt is not enabled.
- */
-__STATIC_INLINE bool nrf_i2s_int_enable_check(NRF_I2S_Type const *p_i2s,
-                                              nrf_i2s_int_mask_t i2s_int);
-
-/**
- * @brief Function for enabling the I2S peripheral.
- *
- * @param[in] p_i2s I2S instance.
- */
-__STATIC_INLINE void nrf_i2s_enable(NRF_I2S_Type *p_i2s);
-
-/**
- * @brief Function for disabling the I2S peripheral.
- *
- * @param[in] p_i2s I2S instance.
- */
-__STATIC_INLINE void nrf_i2s_disable(NRF_I2S_Type *p_i2s);
-
-/**
- * @brief Function for configuring I2S pins.
- *
- * Usage of the SDOUT, SDIN, and MCK signals is optional.
- * If a given signal is not needed, pass the @ref NRF_I2S_PIN_NOT_CONNECTED
- * value instead of its pin number.
- *
- * @param[in] p_i2s     I2S instance.
- * @param[in] sck_pin   SCK pin number.
- * @param[in] lrck_pin  LRCK pin number.
- * @param[in] mck_pin   MCK pin number.
- * @param[in] sdout_pin SDOUT pin number.
- * @param[in] sdin_pin  SDIN pin number.
- */
-__STATIC_INLINE void nrf_i2s_pins_set(NRF_I2S_Type *p_i2s,
-                                      uint32_t sck_pin,
-                                      uint32_t lrck_pin,
-                                      uint32_t mck_pin,
-                                      uint32_t sdout_pin,
-                                      uint32_t sdin_pin);
-
-/**
- * @brief Function for setting the I2S peripheral configuration.
- *
- * @param[in] p_i2s        I2S instance.
- * @param[in] mode         Mode of operation (master or slave).
- * @param[in] format       I2S frame format.
- * @param[in] alignment    Alignment of sample within a frame.
- * @param[in] sample_width Sample width.
- * @param[in] channels     Enabled channels.
- * @param[in] mck_setup    Master clock generator setup.
- * @param[in] ratio        MCK/LRCK ratio.
- *
- * @retval true  If the configuration has been set successfully.
- * @retval false If the requested configuration is not allowed.
- */
-__STATIC_INLINE bool nrf_i2s_configure(NRF_I2S_Type *p_i2s,
-                                       nrf_i2s_mode_t     mode,
-                                       nrf_i2s_format_t   format,
-                                       nrf_i2s_align_t    alignment,
-                                       nrf_i2s_swidth_t   sample_width,
-                                       nrf_i2s_channels_t channels,
-                                       nrf_i2s_mck_t      mck_setup,
-                                       nrf_i2s_ratio_t    ratio);
-
-/**
- * @brief Function for setting up the I2S transfer.
- *
- * This function sets up the RX and TX buffers and enables reception and/or
- * transmission accordingly. If the transfer in a given direction is not
- * required, pass NULL instead of the pointer to the corresponding buffer.
- *
- * @param[in] p_i2s       I2S instance.
- * @param[in] size        Size of the buffers (in 32-bit words).
- * @param[in] p_rx_buffer Pointer to the receive buffer.
- *                        Pass NULL to disable reception.
- * @param[in] p_tx_buffer Pointer to the transmit buffer.
- *                        Pass NULL to disable transmission.
- */
-__STATIC_INLINE void nrf_i2s_transfer_set(NRF_I2S_Type *p_i2s,
-                                          uint16_t         size,
-                                          uint32_t        *p_rx_buffer,
-                                          uint32_t const *p_tx_buffer);
-
-/**
- * @brief Function for setting the pointer to the receive buffer.
- *
- * @note The size of the buffer can be set only by calling
- *       @ref nrf_i2s_transfer_set.
- *
- * @param[in] p_i2s    I2S instance.
- * @param[in] p_buffer Pointer to the receive buffer.
- */
-__STATIC_INLINE void nrf_i2s_rx_buffer_set(NRF_I2S_Type *p_i2s,
-                                           uint32_t *p_buffer);
-
-/**
- * @brief Function for getting the pointer to the receive buffer.
- *
- * @param[in] p_i2s I2S instance.
- *
- * @return Pointer to the receive buffer.
- */
-__STATIC_INLINE uint32_t *nrf_i2s_rx_buffer_get(NRF_I2S_Type const *p_i2s);
-
-/**
- * @brief Function for setting the pointer to the transmit buffer.
- *
- * @note The size of the buffer can be set only by calling
- *       @ref nrf_i2s_transfer_set.
- *
- * @param[in] p_i2s    I2S instance.
- * @param[in] p_buffer Pointer to the transmit buffer.
- */
-__STATIC_INLINE void nrf_i2s_tx_buffer_set(NRF_I2S_Type *p_i2s,
-                                           uint32_t const *p_buffer);
-
-/**
- * @brief Function for getting the pointer to the transmit buffer.
- *
- * @param[in] p_i2s I2S instance.
- *
- * @return Pointer to the transmit buffer.
- */
-__STATIC_INLINE uint32_t *nrf_i2s_tx_buffer_get(NRF_I2S_Type const *p_i2s);
-
-
-#ifndef SUPPRESS_INLINE_IMPLEMENTATION
-
-__STATIC_INLINE void nrf_i2s_task_trigger(NRF_I2S_Type *p_i2s,
-                                          nrf_i2s_task_t task)
-{
-  *((volatile uint32_t *)((uint8_t *)p_i2s + (uint32_t)task)) = 0x1UL;
-}
-
-__STATIC_INLINE uint32_t nrf_i2s_task_address_get(NRF_I2S_Type const *p_i2s,
-                                                  nrf_i2s_task_t task)
-{
-  return ((uint32_t)p_i2s + (uint32_t)task);
-}
-
-__STATIC_INLINE void nrf_i2s_event_clear(NRF_I2S_Type *p_i2s,
-                                         nrf_i2s_event_t event)
-{
-  *((volatile uint32_t *)((uint8_t *)p_i2s + (uint32_t)event)) = 0x0UL;
-#if __CORTEX_M == 0x04
-  volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_i2s + (uint32_t)event));
-  (void)dummy;
-#endif
-}
-
-__STATIC_INLINE bool nrf_i2s_event_check(NRF_I2S_Type const *p_i2s,
-                                         nrf_i2s_event_t event)
-{
-  return (bool) * (volatile uint32_t *)((uint8_t *)p_i2s + (uint32_t)event);
-}
-
-__STATIC_INLINE uint32_t nrf_i2s_event_address_get(NRF_I2S_Type const *p_i2s,
-                                                   nrf_i2s_event_t event)
-{
-  return ((uint32_t)p_i2s + (uint32_t)event);
-}
-
-__STATIC_INLINE void nrf_i2s_int_enable(NRF_I2S_Type *p_i2s, uint32_t mask)
-{
-  p_i2s->INTENSET = mask;
-}
-
-__STATIC_INLINE void nrf_i2s_int_disable(NRF_I2S_Type *p_i2s, uint32_t mask)
-{
-  p_i2s->INTENCLR = mask;
-}
-
-__STATIC_INLINE bool nrf_i2s_int_enable_check(NRF_I2S_Type const *p_i2s,
-                                              nrf_i2s_int_mask_t i2s_int)
-{
-  return (bool)(p_i2s->INTENSET & i2s_int);
-}
-
-__STATIC_INLINE void nrf_i2s_enable(NRF_I2S_Type *p_i2s)
-{
-  p_i2s->ENABLE = (I2S_ENABLE_ENABLE_Enabled << I2S_ENABLE_ENABLE_Pos);
-}
-
-__STATIC_INLINE void nrf_i2s_disable(NRF_I2S_Type *p_i2s)
-{
-  p_i2s->ENABLE = (I2S_ENABLE_ENABLE_Disabled << I2S_ENABLE_ENABLE_Pos);
-}
-
-__STATIC_INLINE void nrf_i2s_pins_set(NRF_I2S_Type *p_i2s,
-                                      uint32_t sck_pin,
-                                      uint32_t lrck_pin,
-                                      uint32_t mck_pin,
-                                      uint32_t sdout_pin,
-                                      uint32_t sdin_pin)
-{
-  p_i2s->PSEL.SCK   = sck_pin;
-  p_i2s->PSEL.LRCK  = lrck_pin;
-  p_i2s->PSEL.MCK   = mck_pin;
-  p_i2s->PSEL.SDOUT = sdout_pin;
-  p_i2s->PSEL.SDIN  = sdin_pin;
-}
-
-__STATIC_INLINE bool nrf_i2s_configure(NRF_I2S_Type *p_i2s,
-                                       nrf_i2s_mode_t     mode,
-                                       nrf_i2s_format_t   format,
-                                       nrf_i2s_align_t    alignment,
-                                       nrf_i2s_swidth_t   sample_width,
-                                       nrf_i2s_channels_t channels,
-                                       nrf_i2s_mck_t      mck_setup,
-                                       nrf_i2s_ratio_t    ratio)
-{
-  if (mode == NRF_I2S_MODE_MASTER)
-    {
-      // The MCK/LRCK ratio shall be a multiple of 2 * sample width.
-      if (((sample_width == NRF_I2S_SWIDTH_16BIT) &&
-           (ratio == NRF_I2S_RATIO_48X))
-          ||
-          ((sample_width == NRF_I2S_SWIDTH_24BIT) &&
-           ((ratio == NRF_I2S_RATIO_32X)  ||
-            (ratio == NRF_I2S_RATIO_64X)  ||
-            (ratio == NRF_I2S_RATIO_128X) ||
-            (ratio == NRF_I2S_RATIO_256X) ||
-            (ratio == NRF_I2S_RATIO_512X))))
-        {
-          return false;
-        }
-    }
-
-  p_i2s->CONFIG.MODE     = mode;
-  p_i2s->CONFIG.FORMAT   = format;
-  p_i2s->CONFIG.ALIGN    = alignment;
-  p_i2s->CONFIG.SWIDTH   = sample_width;
-  p_i2s->CONFIG.CHANNELS = channels;
-  p_i2s->CONFIG.RATIO    = ratio;
-
-  if (mck_setup == NRF_I2S_MCK_DISABLED)
-    {
-      p_i2s->CONFIG.MCKEN =
-        (I2S_CONFIG_MCKEN_MCKEN_Disabled << I2S_CONFIG_MCKEN_MCKEN_Pos);
-    }
-  else
-    {
-      p_i2s->CONFIG.MCKFREQ = mck_setup;
-      p_i2s->CONFIG.MCKEN =
-        (I2S_CONFIG_MCKEN_MCKEN_Enabled << I2S_CONFIG_MCKEN_MCKEN_Pos);
-    }
-
-  return true;
-}
-
-__STATIC_INLINE void nrf_i2s_transfer_set(NRF_I2S_Type *p_i2s,
-                                          uint16_t         size,
-                                          uint32_t        *p_buffer_rx,
-                                          uint32_t const *p_buffer_tx)
-{
-  p_i2s->RXTXD.MAXCNT = size;
-
-  nrf_i2s_rx_buffer_set(p_i2s, p_buffer_rx);
-  p_i2s->CONFIG.RXEN = (p_buffer_rx != NULL) ? 1 : 0;
-
-  nrf_i2s_tx_buffer_set(p_i2s, p_buffer_tx);
-  p_i2s->CONFIG.TXEN = (p_buffer_tx != NULL) ? 1 : 0;
-}
-
-__STATIC_INLINE void nrf_i2s_rx_buffer_set(NRF_I2S_Type *p_i2s,
-                                           uint32_t *p_buffer)
-{
-  p_i2s->RXD.PTR = (uint32_t)p_buffer;
-}
-
-__STATIC_INLINE uint32_t *nrf_i2s_rx_buffer_get(NRF_I2S_Type const *p_i2s)
-{
-  return (uint32_t *)(p_i2s->RXD.PTR);
-}
-
-__STATIC_INLINE void nrf_i2s_tx_buffer_set(NRF_I2S_Type *p_i2s,
-                                           uint32_t const *p_buffer)
-{
-  p_i2s->TXD.PTR = (uint32_t)p_buffer;
-}
-
-__STATIC_INLINE uint32_t *nrf_i2s_tx_buffer_get(NRF_I2S_Type const *p_i2s)
-{
-  return (uint32_t *)(p_i2s->TXD.PTR);
-}
-
-#endif // SUPPRESS_INLINE_IMPLEMENTATION
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif // NRF_I2S_H__
-
-/** @} */
diff --git a/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_nvmc.c b/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_nvmc.c
index d4e62b1159..8a88d010af 100644
--- a/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_nvmc.c
+++ b/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_nvmc.c
@@ -19,7 +19,6 @@
 #include <stdbool.h>
 #include "nrf.h"
 #include "nrf_nvmc.h"
-#include "nrf52_waste.h"
 
 void nrf_nvmc_enable_icache(bool flag)
 {
@@ -145,6 +144,7 @@ void nrf_nvmc_write_byte(uint32_t address, uint8_t value)
 
 void nrf_nvmc_write_word(uint32_t address, uint32_t value)
 {
+  static uint32_t Idle_wastecounter = 0;
   // Enable write.
   NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen;
   while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
@@ -154,7 +154,7 @@ void nrf_nvmc_write_word(uint32_t address, uint32_t value)
   *(uint32_t *)address = value;
   while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
     {
-      up_waste();
+      Idle_wastecounter++;
     }
 
   NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren;
diff --git a/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_rtc.h b/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_rtc.h
deleted file mode 100644
index a9bebcc874..0000000000
--- a/arch/arm/src/nrf52/components/drivers_nrf/hal/nrf_rtc.h
+++ /dev/null
@@ -1,316 +0,0 @@
-/* Copyright (c) 2014 Nordic Semiconductor. All Rights Reserved.
- *
- * The information contained herein is property of Nordic Semiconductor ASA.
- * Terms and conditions of usage are described in detail in NORDIC
- * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
- *
- * Licensees are granted free, non-transferable use of the information. NO
- * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
- * the file.
- *
- */
-
-/**
- * @file
- * @brief RTC HAL API.
- */
-
-#ifndef NRF_RTC_H
-#define NRF_RTC_H
-
-/**
- * @defgroup nrf_rtc_hal RTC HAL
- * @{
- * @ingroup nrf_rtc
- * @brief Hardware access layer for managing the real time counter (RTC).
- */
-
-#include <stdint.h>
-#include <stddef.h>
-#include <stdbool.h>
-#include "nrf.h"
-#include "nrf_assert.h"
-#include "nrf_peripherals.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief Macro for getting the number of compare channels available
- *        in a given RTC instance.
- */
-
-#define NRF_RTC_CC_CHANNEL_COUNT(id) CONCAT_3(RTC, id, _CC_NUM)
-
-#define RTC_INPUT_FREQ 32768 /**< Input frequency of the RTC instance. */
-
-/**
- * @brief Macro for converting expected frequency to prescaler setting.
- */
-#define RTC_FREQ_TO_PRESCALER(FREQ) (uint16_t)((RTC_INPUT_FREQ / (FREQ)) - 1)
-
-/**< Macro for wrapping values to RTC capacity. */
-#define RTC_WRAP(val) (val & RTC_COUNTER_COUNTER_Msk)
-
-#define RTC_CHANNEL_INT_MASK(ch)    ((uint32_t)NRF_RTC_INT_COMPARE0_MASK << ch)
-#define RTC_CHANNEL_EVENT_ADDR(ch)  (nrf_rtc_event_t)(NRF_RTC_EVENT_COMPARE_0 + ch * sizeof(uint32_t))
-/**
- * @enum nrf_rtc_task_t
- * @brief RTC tasks.
- */
-typedef enum
-{
-  /*lint -save -e30*/
-  NRF_RTC_TASK_START            = offsetof(NRF_RTC_Type, TASKS_START),    /**< Start. */
-  NRF_RTC_TASK_STOP             = offsetof(NRF_RTC_Type, TASKS_STOP),     /**< Stop. */
-  NRF_RTC_TASK_CLEAR            = offsetof(NRF_RTC_Type, TASKS_CLEAR),    /**< Clear. */
-  NRF_RTC_TASK_TRIGGER_OVERFLOW = offsetof(NRF_RTC_Type, TASKS_TRIGOVRFLW), /**< Trigger overflow. */
-  /*lint -restore*/
-} nrf_rtc_task_t;
-
-/**
- * @enum nrf_rtc_event_t
- * @brief RTC events.
- */
-typedef enum
-{
-  /*lint -save -e30*/
-  NRF_RTC_EVENT_TICK        = offsetof(NRF_RTC_Type, EVENTS_TICK),      /**< Tick event. */
-  NRF_RTC_EVENT_OVERFLOW    = offsetof(NRF_RTC_Type, EVENTS_OVRFLW),    /**< Overflow event. */
-  NRF_RTC_EVENT_COMPARE_0   = offsetof(NRF_RTC_Type, EVENTS_COMPARE[0]), /**< Compare 0 event. */
-  NRF_RTC_EVENT_COMPARE_1   = offsetof(NRF_RTC_Type, EVENTS_COMPARE[1]), /**< Compare 1 event. */
-  NRF_RTC_EVENT_COMPARE_2   = offsetof(NRF_RTC_Type, EVENTS_COMPARE[2]), /**< Compare 2 event. */
-  NRF_RTC_EVENT_COMPARE_3   = offsetof(NRF_RTC_Type, EVENTS_COMPARE[3]) /**< Compare 3 event. */
-                              /*lint -restore*/
-} nrf_rtc_event_t;
-
-/**
- * @enum nrf_rtc_int_t
- * @brief RTC interrupts.
- */
-typedef enum
-{
-  NRF_RTC_INT_TICK_MASK     = RTC_INTENSET_TICK_Msk,     /**< RTC interrupt from tick event. */
-  NRF_RTC_INT_OVERFLOW_MASK = RTC_INTENSET_OVRFLW_Msk,   /**< RTC interrupt from overflow event. */
-  NRF_RTC_INT_COMPARE0_MASK = RTC_INTENSET_COMPARE0_Msk, /**< RTC interrupt from compare event on channel 0. */
-  NRF_RTC_INT_COMPARE1_MASK = RTC_INTENSET_COMPARE1_Msk, /**< RTC interrupt from compare event on channel 1. */
-  NRF_RTC_INT_COMPARE2_MASK = RTC_INTENSET_COMPARE2_Msk, /**< RTC interrupt from compare event on channel 2. */
-  NRF_RTC_INT_COMPARE3_MASK = RTC_INTENSET_COMPARE3_Msk  /**< RTC interrupt from compare event on channel 3. */
-} nrf_rtc_int_t;
-
-/**@brief Function for setting a compare value for a channel.
- *
- * @param[in]  p_rtc         Pointer to the peripheral registers structure.
- * @param[in]  ch            Channel.
- * @param[in]  cc_val        Compare value to set.
- */
-__STATIC_INLINE  void nrf_rtc_cc_set(NRF_RTC_Type *p_rtc, uint32_t ch, uint32_t cc_val);
-
-/**@brief Function for returning the compare value for a channel.
- *
- * @param[in]  p_rtc         Pointer to the peripheral registers structure.
- * @param[in]  ch            Channel.
- *
- * @return                   COMPARE[ch] value.
- */
-__STATIC_INLINE  uint32_t nrf_rtc_cc_get(NRF_RTC_Type *p_rtc, uint32_t ch);
-
-/**@brief Function for enabling interrupts.
- *
- * @param[in]  p_rtc         Pointer to the peripheral registers structure.
- * @param[in]  mask          Interrupt mask to be enabled.
- */
-__STATIC_INLINE void nrf_rtc_int_enable(NRF_RTC_Type *p_rtc, uint32_t mask);
-
-/**@brief Function for disabling interrupts.
- *
- * @param[in]  p_rtc         Pointer to the peripheral registers structure.
- * @param[in]  mask          Interrupt mask to be disabled.
- */
-__STATIC_INLINE void nrf_rtc_int_disable(NRF_RTC_Type *p_rtc, uint32_t mask);
-
-/**@brief Function for checking if interrupts are enabled.
- *
- * @param[in]  p_rtc         Pointer to the peripheral registers structure.
- * @param[in]  mask          Mask of interrupt flags to check.
- *
- * @return                   Mask with enabled interrupts.
- */
-__STATIC_INLINE uint32_t nrf_rtc_int_is_enabled(NRF_RTC_Type *p_rtc, uint32_t mask);
-
-/**@brief Function for returning the status of currently enabled interrupts.
- *
- * @param[in]  p_rtc         Pointer to the peripheral registers structure.
- *
- * @return                   Value in INTEN register.
- */
-__STATIC_INLINE uint32_t nrf_rtc_int_get(NRF_RTC_Type *p_rtc);
-
-/**@brief Function for checking if an event is pending.
- *
- * @param[in]  p_rtc         Pointer to the peripheral registers structure.
- * @param[in]  event         Address of the event.
- *
- * @return                   Mask of pending events.
- */
-__STATIC_INLINE uint32_t nrf_rtc_event_pending(NRF_RTC_Type *p_rtc, nrf_rtc_event_t event);
-
-/**@brief Function for clearing an event.
- *
- * @param[in]  p_rtc         Pointer to the peripheral registers structure.
- * @param[in]  event         Event to clear.
- */
-__STATIC_INLINE void nrf_rtc_event_clear(NRF_RTC_Type *p_rtc, nrf_rtc_event_t event);
-
-/**@brief Function for returning a counter value.
- *
- * @param[in]  p_rtc         Pointer to the peripheral registers structure.
- *
- * @return                   Counter value.
- */
-__STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type *p_rtc);
-
-/**@brief Function for setting a prescaler value.
- *
- * @param[in]  p_rtc         Pointer to the peripheral registers structure.
- * @param[in]  val           Value to set the prescaler to.
- */
-__STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type *p_rtc, uint32_t val);
-
-/**@brief Function for returning the address of an event.
- *
- * @param[in]  p_rtc         Pointer to the peripheral registers structure.
- * @param[in]  event         Requested event.
- *
- * @return     Address of the requested event register.
- */
-__STATIC_INLINE uint32_t nrf_rtc_event_address_get(NRF_RTC_Type *p_rtc, nrf_rtc_event_t event);
-
-/**@brief Function for returning the address of a task.
- *
- * @param[in]  p_rtc         Pointer to the peripheral registers structure.
- * @param[in]  task          Requested task.
- *
- * @return     Address of the requested task register.
- */
-__STATIC_INLINE uint32_t nrf_rtc_task_address_get(NRF_RTC_Type *p_rtc, nrf_rtc_task_t task);
-
-/**@brief Function for starting a task.
- *
- * @param[in]  p_rtc         Pointer to the peripheral registers structure.
- * @param[in]  task          Requested task.
- */
-__STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type *p_rtc, nrf_rtc_task_t task);
-
-/**@brief Function for enabling events.
- *
- * @param[in]  p_rtc         Pointer to the peripheral registers structure.
- * @param[in]  mask          Mask of event flags to enable.
- */
-__STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type *p_rtc, uint32_t mask);
-
-/**@brief Function for disabling an event.
- *
- * @param[in]  p_rtc         Pointer to the peripheral registers structure.
- * @param[in]  event         Requested event.
- */
-__STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type *p_rtc, uint32_t event);
-
-/**
- *@}
- **/
-
-
-#ifndef SUPPRESS_INLINE_IMPLEMENTATION
-
-__STATIC_INLINE  void nrf_rtc_cc_set(NRF_RTC_Type *p_rtc, uint32_t ch, uint32_t cc_val)
-{
-  p_rtc->CC[ch] = cc_val;
-}
-
-__STATIC_INLINE  uint32_t nrf_rtc_cc_get(NRF_RTC_Type *p_rtc, uint32_t ch)
-{
-  return p_rtc->CC[ch];
-}
-
-__STATIC_INLINE void nrf_rtc_int_enable(NRF_RTC_Type *p_rtc, uint32_t mask)
-{
-  p_rtc->INTENSET = mask;
-}
-
-__STATIC_INLINE void nrf_rtc_int_disable(NRF_RTC_Type *p_rtc, uint32_t mask)
-{
-  p_rtc->INTENCLR = mask;
-}
-
-__STATIC_INLINE uint32_t nrf_rtc_int_is_enabled(NRF_RTC_Type *p_rtc, uint32_t mask)
-{
-  return (p_rtc->INTENSET & mask);
-}
-
-__STATIC_INLINE uint32_t nrf_rtc_int_get(NRF_RTC_Type *p_rtc)
-{
-  return p_rtc->INTENSET;
-}
-
-__STATIC_INLINE uint32_t nrf_rtc_event_pending(NRF_RTC_Type *p_rtc, nrf_rtc_event_t event)
-{
-  return *(volatile uint32_t *)((uint8_t *)p_rtc + (uint32_t)event);
-}
-
-__STATIC_INLINE void nrf_rtc_event_clear(NRF_RTC_Type *p_rtc, nrf_rtc_event_t event)
-{
-  *((volatile uint32_t *)((uint8_t *)p_rtc + (uint32_t)event)) = 0;
-#if __CORTEX_M == 0x04
-  volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_rtc + (uint32_t)event));
-  (void)dummy;
-#endif
-}
-
-__STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type *p_rtc)
-{
-  return p_rtc->COUNTER;
-}
-
-__STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type *p_rtc, uint32_t val)
-{
-  ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
-  p_rtc->PRESCALER = val;
-}
-__STATIC_INLINE uint32_t rtc_prescaler_get(NRF_RTC_Type *p_rtc)
-{
-  return p_rtc->PRESCALER;
-}
-
-__STATIC_INLINE uint32_t nrf_rtc_event_address_get(NRF_RTC_Type *p_rtc, nrf_rtc_event_t event)
-{
-  return (uint32_t)p_rtc + event;
-}
-
-__STATIC_INLINE uint32_t nrf_rtc_task_address_get(NRF_RTC_Type *p_rtc, nrf_rtc_task_t task)
-{
-  return (uint32_t)p_rtc + task;
-}
-
-__STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type *p_rtc, nrf_rtc_task_t task)
-{
-  *(__IO uint32_t *)((uint32_t)p_rtc + task) = 1;
-}
-
-__STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type *p_rtc, uint32_t mask)
-{
-  p_rtc->EVTENSET = mask;
-}
-__STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type *p_rtc, uint32_t mask)
-{
-  p_rtc->EVTENCLR = mask;
-}
-#endif
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif  /* NRF_RTC_H */
diff --git a/arch/arm/src/nrf52/components/toolchain/cmsis/include/cmsis_armcc.h b/arch/arm/src/nrf52/components/toolchain/cmsis/include/cmsis_armcc.h
deleted file mode 100644
index c097366f92..0000000000
--- a/arch/arm/src/nrf52/components/toolchain/cmsis/include/cmsis_armcc.h
+++ /dev/null
@@ -1,734 +0,0 @@
-/**************************************************************************//**
- * @file     cmsis_armcc.h
- * @brief    CMSIS Cortex-M Core Function/Instruction Header File
- * @version  V4.30
- * @date     20. October 2015
- ******************************************************************************/
-/* Copyright (c) 2009 - 2015 ARM LIMITED
-
-   All rights reserved.
-   Redistribution and use in source and binary forms, with or without
-   modification, are permitted provided that the following conditions are met:
-   - Redistributions of source code must retain the above copyright
-     notice, this list of conditions and the following disclaimer.
-   - Redistributions in binary form must reproduce the above copyright
-     notice, this list of conditions and the following disclaimer in the
-     documentation and/or other materials provided with the distribution.
-   - Neither the name of ARM nor the names of its contributors may be used
-     to endorse or promote products derived from this software without
-     specific prior written permission.
-   *
-   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
-   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-   POSSIBILITY OF SUCH DAMAGE.
-   ---------------------------------------------------------------------------*/
-
-
-#ifndef __CMSIS_ARMCC_H
-#define __CMSIS_ARMCC_H
-
-
-#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
-#error "Please use ARM Compiler Toolchain V4.0.677 or later!"
-#endif
-
-/* ###########################  Core Function Access  ########################### */
-/** \ingroup  CMSIS_Core_FunctionInterface
-    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
-  @{
- */
-
-/* intrinsic void __enable_irq();     */
-/* intrinsic void __disable_irq();    */
-
-/**
-  \brief   Get Control Register
-  \details Returns the content of the Control Register.
-  \return               Control Register value
- */
-__STATIC_INLINE uint32_t __get_CONTROL(void)
-{
-  register uint32_t __regControl         __ASM("control");
-  return (__regControl);
-}
-
-
-/**
-  \brief   Set Control Register
-  \details Writes the given value to the Control Register.
-  \param [in]    control  Control Register value to set
- */
-__STATIC_INLINE void __set_CONTROL(uint32_t control)
-{
-  register uint32_t __regControl         __ASM("control");
-  __regControl = control;
-}
-
-
-/**
-  \brief   Get IPSR Register
-  \details Returns the content of the IPSR Register.
-  \return               IPSR Register value
- */
-__STATIC_INLINE uint32_t __get_IPSR(void)
-{
-  register uint32_t __regIPSR          __ASM("ipsr");
-  return (__regIPSR);
-}
-
-
-/**
-  \brief   Get APSR Register
-  \details Returns the content of the APSR Register.
-  \return               APSR Register value
- */
-__STATIC_INLINE uint32_t __get_APSR(void)
-{
-  register uint32_t __regAPSR          __ASM("apsr");
-  return (__regAPSR);
-}
-
-
-/**
-  \brief   Get xPSR Register
-  \details Returns the content of the xPSR Register.
-  \return               xPSR Register value
- */
-__STATIC_INLINE uint32_t __get_xPSR(void)
-{
-  register uint32_t __regXPSR          __ASM("xpsr");
-  return (__regXPSR);
-}
-
-
-/**
-  \brief   Get Process Stack Pointer
-  \details Returns the current value of the Process Stack Pointer (PSP).
-  \return               PSP Register value
- */
-__STATIC_INLINE uint32_t __get_PSP(void)
-{
-  register uint32_t __regProcessStackPointer  __ASM("psp");
-  return (__regProcessStackPointer);
-}
-
-
-/**
-  \brief   Set Process Stack Pointer
-  \details Assigns the given value to the Process Stack Pointer (PSP).
-  \param [in]    topOfProcStack  Process Stack Pointer value to set
- */
-__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
-{
-  register uint32_t __regProcessStackPointer  __ASM("psp");
-  __regProcessStackPointer = topOfProcStack;
-}
-
-
-/**
-  \brief   Get Main Stack Pointer
-  \details Returns the current value of the Main Stack Pointer (MSP).
-  \return               MSP Register value
- */
-__STATIC_INLINE uint32_t __get_MSP(void)
-{
-  register uint32_t __regMainStackPointer     __ASM("msp");
-  return (__regMainStackPointer);
-}
-
-
-/**
-  \brief   Set Main Stack Pointer
-  \details Assigns the given value to the Main Stack Pointer (MSP).
-  \param [in]    topOfMainStack  Main Stack Pointer value to set
- */
-__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
-{
-  register uint32_t __regMainStackPointer     __ASM("msp");
-  __regMainStackPointer = topOfMainStack;
-}
-
-
-/**
-  \brief   Get Priority Mask
-  \details Returns the current state of the priority mask bit from the Priority Mask Register.
-  \return               Priority Mask value
- */
-__STATIC_INLINE uint32_t __get_PRIMASK(void)
-{
-  register uint32_t __regPriMask         __ASM("primask");
-  return (__regPriMask);
-}
-
-
-/**
-  \brief   Set Priority Mask
-  \details Assigns the given value to the Priority Mask Register.
-  \param [in]    priMask  Priority Mask
- */
-__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
-{
-  register uint32_t __regPriMask         __ASM("primask");
-  __regPriMask = (priMask);
-}
-
-
-#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
-
-/**
-  \brief   Enable FIQ
-  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
-           Can only be executed in Privileged modes.
- */
-#define __enable_fault_irq                __enable_fiq
-
-
-/**
-  \brief   Disable FIQ
-  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
-           Can only be executed in Privileged modes.
- */
-#define __disable_fault_irq               __disable_fiq
-
-
-/**
-  \brief   Get Base Priority
-  \details Returns the current value of the Base Priority register.
-  \return               Base Priority register value
- */
-__STATIC_INLINE uint32_t  __get_BASEPRI(void)
-{
-  register uint32_t __regBasePri         __ASM("basepri");
-  return (__regBasePri);
-}
-
-
-/**
-  \brief   Set Base Priority
-  \details Assigns the given value to the Base Priority register.
-  \param [in]    basePri  Base Priority value to set
- */
-__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
-{
-  register uint32_t __regBasePri         __ASM("basepri");
-  __regBasePri = (basePri & 0xFFU);
-}
-
-
-/**
-  \brief   Set Base Priority with condition
-  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
-           or the new value increases the BASEPRI priority level.
-  \param [in]    basePri  Base Priority value to set
- */
-__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
-{
-  register uint32_t __regBasePriMax      __ASM("basepri_max");
-  __regBasePriMax = (basePri & 0xFFU);
-}
-
-
-/**
-  \brief   Get Fault Mask
-  \details Returns the current value of the Fault Mask register.
-  \return               Fault Mask register value
- */
-__STATIC_INLINE uint32_t __get_FAULTMASK(void)
-{
-  register uint32_t __regFaultMask       __ASM("faultmask");
-  return (__regFaultMask);
-}
-
-
-/**
-  \brief   Set Fault Mask
-  \details Assigns the given value to the Fault Mask register.
-  \param [in]    faultMask  Fault Mask value to set
- */
-__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
-{
-  register uint32_t __regFaultMask       __ASM("faultmask");
-  __regFaultMask = (faultMask & (uint32_t)1);
-}
-
-#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
-
-
-#if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
-
-/**
-  \brief   Get FPSCR
-  \details Returns the current value of the Floating Point Status/Control register.
-  \return               Floating Point Status/Control register value
- */
-__STATIC_INLINE uint32_t __get_FPSCR(void)
-{
-#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
-  register uint32_t __regfpscr         __ASM("fpscr");
-  return (__regfpscr);
-#else
-  return (0U);
-#endif
-}
-
-
-/**
-  \brief   Set FPSCR
-  \details Assigns the given value to the Floating Point Status/Control register.
-  \param [in]    fpscr  Floating Point Status/Control value to set
- */
-__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
-{
-#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
-  register uint32_t __regfpscr         __ASM("fpscr");
-  __regfpscr = (fpscr);
-#endif
-}
-
-#endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
-
-
-
-/*@} end of CMSIS_Core_RegAccFunctions */
-
-
-/* ##########################  Core Instruction Access  ######################### */
-/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
-  Access to dedicated instructions
-  @{
-*/
-
-/**
-  \brief   No Operation
-  \details No Operation does nothing. This instruction can be used for code alignment purposes.
- */
-#define __NOP                             __nop
-
-
-/**
-  \brief   Wait For Interrupt
-  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
- */
-#define __WFI                             __wfi
-
-
-/**
-  \brief   Wait For Event
-  \details Wait For Event is a hint instruction that permits the processor to enter
-           a low-power state until one of a number of events occurs.
- */
-#define __WFE                             __wfe
-
-
-/**
-  \brief   Send Event
-  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
- */
-#define __SEV                             __sev
-
-
-/**
-  \brief   Instruction Synchronization Barrier
-  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
-           so that all instructions following the ISB are fetched from cache or memory,
-           after the instruction has been completed.
- */
-#define __ISB() do {\
-                   __schedule_barrier();\
-                   __isb(0xF);\
-                   __schedule_barrier();\
-                } while (0U)
-
-/**
-  \brief   Data Synchronization Barrier
-  \details Acts as a special kind of Data Memory Barrier.
-           It completes when all explicit memory accesses before this instruction complete.
- */
-#define __DSB() do {\
-                   __schedule_barrier();\
-                   __dsb(0xF);\
-                   __schedule_barrier();\
-                } while (0U)
-
-/**
-  \brief   Data Memory Barrier
-  \details Ensures the apparent order of the explicit memory operations before
-           and after the instruction, without ensuring their completion.
- */
-#define __DMB() do {\
-                   __schedule_barrier();\
-                   __dmb(0xF);\
-                   __schedule_barrier();\
-                } while (0U)
-
-/**
-  \brief   Reverse byte order (32 bit)
-  \details Reverses the byte order in integer value.
-  \param [in]    value  Value to reverse
-  \return               Reversed value
- */
-#define __REV                             __rev
-
-
-/**
-  \brief   Reverse byte order (16 bit)
-  \details Reverses the byte order in two unsigned short values.
-  \param [in]    value  Value to reverse
-  \return               Reversed value
- */
-#ifndef __NO_EMBEDDED_ASM
-__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
-{
-  rev16 r0, r0
-  bx lr
-}
-#endif
-
-/**
-  \brief   Reverse byte order in signed short value
-  \details Reverses the byte order in a signed short value with sign extension to integer.
-  \param [in]    value  Value to reverse
-  \return               Reversed value
- */
-#ifndef __NO_EMBEDDED_ASM
-__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
-{
-  revsh r0, r0
-  bx lr
-}
-#endif
-
-
-/**
-  \brief   Rotate Right in unsigned value (32 bit)
-  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
-  \param [in]    value  Value to rotate
-  \param [in]    value  Number of Bits to rotate
-  \return               Rotated value
- */
-#define __ROR                             __ror
-
-
-/**
-  \brief   Breakpoint
-  \details Causes the processor to enter Debug state.
-           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
-  \param [in]    value  is ignored by the processor.
-                 If required, a debugger can use it to store additional information about the breakpoint.
- */
-#define __BKPT(value)                       __breakpoint(value)
-
-
-/**
-  \brief   Reverse bit order of value
-  \details Reverses the bit order of the given value.
-  \param [in]    value  Value to reverse
-  \return               Reversed value
- */
-#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
-#define __RBIT                          __rbit
-#else
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
-{
-  uint32_t result;
-  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; /* extra shift needed at end */
-
-  result = value;                      /* r will be reversed bits of v; first get LSB of v */
-  for (value >>= 1U; value; value >>= 1U)
-    {
-      result <<= 1U;
-      result |= value & 1U;
-      s--;
-    }
-  result <<= s;                        /* shift when v's highest bits are zero */
-  return (result);
-}
-#endif
-
-
-/**
-  \brief   Count leading zeros
-  \details Counts the number of leading zeros of a data value.
-  \param [in]  value  Value to count the leading zeros
-  \return             number of leading zeros in value
- */
-#define __CLZ                             __clz
-
-
-#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
-
-/**
-  \brief   LDR Exclusive (8 bit)
-  \details Executes a exclusive LDR instruction for 8 bit value.
-  \param [in]    ptr  Pointer to data
-  \return             value of type uint8_t at (*ptr)
- */
-#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
-#define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
-#else
-#define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
-#endif
-
-
-/**
-  \brief   LDR Exclusive (16 bit)
-  \details Executes a exclusive LDR instruction for 16 bit values.
-  \param [in]    ptr  Pointer to data
-  \return        value of type uint16_t at (*ptr)
- */
-#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
-#define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
-#else
-#define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
-#endif
-
-
-/**
-  \brief   LDR Exclusive (32 bit)
-  \details Executes a exclusive LDR instruction for 32 bit values.
-  \param [in]    ptr  Pointer to data
-  \return        value of type uint32_t at (*ptr)
- */
-#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
-#define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
-#else
-#define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
-#endif
-
-
-/**
-  \brief   STR Exclusive (8 bit)
-  \details Executes a exclusive STR instruction for 8 bit values.
-  \param [in]  value  Value to store
-  \param [in]    ptr  Pointer to location
-  \return          0  Function succeeded
-  \return          1  Function failed
- */
-#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
-#define __STREXB(value, ptr)                                                 __strex(value, ptr)
-#else
-#define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
-#endif
-
-
-/**
-  \brief   STR Exclusive (16 bit)
-  \details Executes a exclusive STR instruction for 16 bit values.
-  \param [in]  value  Value to store
-  \param [in]    ptr  Pointer to location
-  \return          0  Function succeeded
-  \return          1  Function failed
- */
-#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
-#define __STREXH(value, ptr)                                                 __strex(value, ptr)
-#else
-#define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
-#endif
-
-
-/**
-  \brief   STR Exclusive (32 bit)
-  \details Executes a exclusive STR instruction for 32 bit values.
-  \param [in]  value  Value to store
-  \param [in]    ptr  Pointer to location
-  \return          0  Function succeeded
-  \return          1  Function failed
- */
-#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
-#define __STREXW(value, ptr)                                                 __strex(value, ptr)
-#else
-#define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
-#endif
-
-
-/**
-  \brief   Remove the exclusive lock
-  \details Removes the exclusive lock which is created by LDREX.
- */
-#define __CLREX                           __clrex
-
-
-/**
-  \brief   Signed Saturate
-  \details Saturates a signed value.
-  \param [in]  value  Value to be saturated
-  \param [in]    sat  Bit position to saturate to (1..32)
-  \return             Saturated value
- */
-#define __SSAT                            __ssat
-
-
-/**
-  \brief   Unsigned Saturate
-  \details Saturates an unsigned value.
-  \param [in]  value  Value to be saturated
-  \param [in]    sat  Bit position to saturate to (0..31)
-  \return             Saturated value
- */
-#define __USAT                            __usat
-
-
-/**
-  \brief   Rotate Right with Extend (32 bit)
-  \details Moves each bit of a bitstring right by one bit.
-           The carry input is shifted in at the left end of the bitstring.
-  \param [in]    value  Value to rotate
-  \return               Rotated value
- */
-#ifndef __NO_EMBEDDED_ASM
-__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
-{
-  rrx r0, r0
-  bx lr
-}
-#endif
-
-
-/**
-  \brief   LDRT Unprivileged (8 bit)
-  \details Executes a Unprivileged LDRT instruction for 8 bit value.
-  \param [in]    ptr  Pointer to data
-  \return             value of type uint8_t at (*ptr)
- */
-#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
-
-
-/**
-  \brief   LDRT Unprivileged (16 bit)
-  \details Executes a Unprivileged LDRT instruction for 16 bit values.
-  \param [in]    ptr  Pointer to data
-  \return        value of type uint16_t at (*ptr)
- */
-#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
-
-
-/**
-  \brief   LDRT Unprivileged (32 bit)
-  \details Executes a Unprivileged LDRT instruction for 32 bit values.
-  \param [in]    ptr  Pointer to data
-  \return        value of type uint32_t at (*ptr)
- */
-#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
-
-
-/**
-  \brief   STRT Unprivileged (8 bit)
-  \details Executes a Unprivileged STRT instruction for 8 bit values.
-  \param [in]  value  Value to store
-  \param [in]    ptr  Pointer to location
- */
-#define __STRBT(value, ptr)               __strt(value, ptr)
-
-
-/**
-  \brief   STRT Unprivileged (16 bit)
-  \details Executes a Unprivileged STRT instruction for 16 bit values.
-  \param [in]  value  Value to store
-  \param [in]    ptr  Pointer to location
- */
-#define __STRHT(value, ptr)               __strt(value, ptr)
-
-
-/**
-  \brief   STRT Unprivileged (32 bit)
-  \details Executes a Unprivileged STRT instruction for 32 bit values.
-  \param [in]  value  Value to store
-  \param [in]    ptr  Pointer to location
- */
-#define __STRT(value, ptr)                __strt(value, ptr)
-
-#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
-
-/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
-
-
-/* ###################  Compiler specific Intrinsics  ########################### */
-/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
-  Access to dedicated SIMD instructions
-  @{
-*/
-
-#if (__CORTEX_M >= 0x04U)  /* only for Cortex-M4 and above */
-
-#define __SADD8                           __sadd8
-#define __QADD8                           __qadd8
-#define __SHADD8                          __shadd8
-#define __UADD8                           __uadd8
-#define __UQADD8                          __uqadd8
-#define __UHADD8                          __uhadd8
-#define __SSUB8                           __ssub8
-#define __QSUB8                           __qsub8
-#define __SHSUB8                          __shsub8
-#define __USUB8                           __usub8
-#define __UQSUB8                          __uqsub8
-#define __UHSUB8                          __uhsub8
-#define __SADD16                          __sadd16
-#define __QADD16                          __qadd16
-#define __SHADD16                         __shadd16
-#define __UADD16                          __uadd16
-#define __UQADD16                         __uqadd16
-#define __UHADD16                         __uhadd16
-#define __SSUB16                          __ssub16
-#define __QSUB16                          __qsub16
-#define __SHSUB16                         __shsub16
-#define __USUB16                          __usub16
-#define __UQSUB16                         __uqsub16
-#define __UHSUB16                         __uhsub16
-#define __SASX                            __sasx
-#define __QASX                            __qasx
-#define __SHASX                           __shasx
-#define __UASX                            __uasx
-#define __UQASX                           __uqasx
-#define __UHASX                           __uhasx
-#define __SSAX                            __ssax
-#define __QSAX                            __qsax
-#define __SHSAX                           __shsax
-#define __USAX                            __usax
-#define __UQSAX                           __uqsax
-#define __UHSAX                           __uhsax
-#define __USAD8                           __usad8
-#define __USADA8                          __usada8
-#define __SSAT16                          __ssat16
-#define __USAT16                          __usat16
-#define __UXTB16                          __uxtb16
-#define __UXTAB16                         __uxtab16
-#define __SXTB16                          __sxtb16
-#define __SXTAB16                         __sxtab16
-#define __SMUAD                           __smuad
-#define __SMUADX                          __smuadx
-#define __SMLAD                           __smlad
-#define __SMLADX                          __smladx
-#define __SMLALD                          __smlald
-#define __SMLALDX                         __smlaldx
-#define __SMUSD                           __smusd
-#define __SMUSDX                          __smusdx
-#define __SMLSD                           __smlsd
-#define __SMLSDX                          __smlsdx
-#define __SMLSLD                          __smlsld
-#define __SMLSLDX                         __smlsldx
-#define __SEL                             __sel
-#define __QADD                            __qadd
-#define __QSUB                            __qsub
-
-#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
-                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
-
-#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
-                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
-
-#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
-                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
-
-#endif /* (__CORTEX_M >= 0x04) */
-/*@} end of group CMSIS_SIMD_intrinsics */
-
-
-#endif /* __CMSIS_ARMCC_H */
diff --git a/arch/arm/src/nrf52/components/toolchain/cmsis/include/cmsis_armcc_V6.h b/arch/arm/src/nrf52/components/toolchain/cmsis/include/cmsis_armcc_V6.h
deleted file mode 100644
index 411b67f120..0000000000
--- a/arch/arm/src/nrf52/components/toolchain/cmsis/include/cmsis_armcc_V6.h
+++ /dev/null
@@ -1,1812 +0,0 @@
-/**************************************************************************//**
- * @file     cmsis_armcc_V6.h
- * @brief    CMSIS Cortex-M Core Function/Instruction Header File
- * @version  V4.30
- * @date     20. October 2015
- ******************************************************************************/
-/* Copyright (c) 2009 - 2015 ARM LIMITED
-
-   All rights reserved.
-   Redistribution and use in source and binary forms, with or without
-   modification, are permitted provided that the following conditions are met:
-   - Redistributions of source code must retain the above copyright
-     notice, this list of conditions and the following disclaimer.
-   - Redistributions in binary form must reproduce the above copyright
-     notice, this list of conditions and the following disclaimer in the
-     documentation and/or other materials provided with the distribution.
-   - Neither the name of ARM nor the names of its contributors may be used
-     to endorse or promote products derived from this software without
-     specific prior written permission.
-   *
-   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
-   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-   POSSIBILITY OF SUCH DAMAGE.
-   ---------------------------------------------------------------------------*/
-
-
-#ifndef __CMSIS_ARMCC_V6_H
-#define __CMSIS_ARMCC_V6_H
-
-
-/* ###########################  Core Function Access  ########################### */
-/** \ingroup  CMSIS_Core_FunctionInterface
-    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
-  @{
- */
-
-/**
-  \brief   Enable IRQ Interrupts
-  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
-           Can only be executed in Privileged modes.
- */
-__attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
-{
-  __ASM volatile ("cpsie i" : : : "memory");
-}
-
-
-/**
-  \brief   Disable IRQ Interrupts
-  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
-           Can only be executed in Privileged modes.
- */
-__attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
-{
-  __ASM volatile ("cpsid i" : : : "memory");
-}
-
-
-/**
-  \brief   Get Control Register
-  \details Returns the content of the Control Register.
-  \return               Control Register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __get_CONTROL(void)
-{
-  uint32_t result;
-
-  __ASM volatile ("MRS %0, control" : "=r" (result) );
-  return (result);
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U)
-/**
-  \brief   Get Control Register (non-secure)
-  \details Returns the content of the non-secure Control Register when in secure mode.
-  \return               non-secure Control Register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_CONTROL_NS(void)
-{
-  uint32_t result;
-
-  __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
-  return (result);
-}
-#endif
-
-
-/**
-  \brief   Set Control Register
-  \details Writes the given value to the Control Register.
-  \param [in]    control  Control Register value to set
- */
-__attribute__((always_inline)) __STATIC_INLINE void __set_CONTROL(uint32_t control)
-{
-  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U)
-/**
-  \brief   Set Control Register (non-secure)
-  \details Writes the given value to the non-secure Control Register when in secure state.
-  \param [in]    control  Control Register value to set
- */
-__attribute__((always_inline)) __STATIC_INLINE void __TZ_set_CONTROL_NS(uint32_t control)
-{
-  __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
-}
-#endif
-
-
-/**
-  \brief   Get IPSR Register
-  \details Returns the content of the IPSR Register.
-  \return               IPSR Register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __get_IPSR(void)
-{
-  uint32_t result;
-
-  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
-  return (result);
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U)
-/**
-  \brief   Get IPSR Register (non-secure)
-  \details Returns the content of the non-secure IPSR Register when in secure state.
-  \return               IPSR Register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_IPSR_NS(void)
-{
-  uint32_t result;
-
-  __ASM volatile ("MRS %0, ipsr_ns" : "=r" (result) );
-  return (result);
-}
-#endif
-
-
-/**
-  \brief   Get APSR Register
-  \details Returns the content of the APSR Register.
-  \return               APSR Register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __get_APSR(void)
-{
-  uint32_t result;
-
-  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
-  return (result);
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U)
-/**
-  \brief   Get APSR Register (non-secure)
-  \details Returns the content of the non-secure APSR Register when in secure state.
-  \return               APSR Register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_APSR_NS(void)
-{
-  uint32_t result;
-
-  __ASM volatile ("MRS %0, apsr_ns" : "=r" (result) );
-  return (result);
-}
-#endif
-
-
-/**
-  \brief   Get xPSR Register
-  \details Returns the content of the xPSR Register.
-  \return               xPSR Register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __get_xPSR(void)
-{
-  uint32_t result;
-
-  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
-  return (result);
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U)
-/**
-  \brief   Get xPSR Register (non-secure)
-  \details Returns the content of the non-secure xPSR Register when in secure state.
-  \return               xPSR Register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_xPSR_NS(void)
-{
-  uint32_t result;
-
-  __ASM volatile ("MRS %0, xpsr_ns" : "=r" (result) );
-  return (result);
-}
-#endif
-
-
-/**
-  \brief   Get Process Stack Pointer
-  \details Returns the current value of the Process Stack Pointer (PSP).
-  \return               PSP Register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSP(void)
-{
-  register uint32_t result;
-
-  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
-  return (result);
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U)
-/**
-  \brief   Get Process Stack Pointer (non-secure)
-  \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure state.
-  \return               PSP Register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSP_NS(void)
-{
-  register uint32_t result;
-
-  __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
-  return (result);
-}
-#endif
-
-
-/**
-  \brief   Set Process Stack Pointer
-  \details Assigns the given value to the Process Stack Pointer (PSP).
-  \param [in]    topOfProcStack  Process Stack Pointer value to set
- */
-__attribute__((always_inline)) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
-{
-  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : "sp");
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U)
-/**
-  \brief   Set Process Stack Pointer (non-secure)
-  \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure state.
-  \param [in]    topOfProcStack  Process Stack Pointer value to set
- */
-__attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
-{
-  __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : "sp");
-}
-#endif
-
-
-/**
-  \brief   Get Main Stack Pointer
-  \details Returns the current value of the Main Stack Pointer (MSP).
-  \return               MSP Register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSP(void)
-{
-  register uint32_t result;
-
-  __ASM volatile ("MRS %0, msp" : "=r" (result) );
-  return (result);
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U)
-/**
-  \brief   Get Main Stack Pointer (non-secure)
-  \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure state.
-  \return               MSP Register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSP_NS(void)
-{
-  register uint32_t result;
-
-  __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
-  return (result);
-}
-#endif
-
-
-/**
-  \brief   Set Main Stack Pointer
-  \details Assigns the given value to the Main Stack Pointer (MSP).
-  \param [in]    topOfMainStack  Main Stack Pointer value to set
- */
-__attribute__((always_inline)) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
-{
-  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : "sp");
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U)
-/**
-  \brief   Set Main Stack Pointer (non-secure)
-  \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
-  \param [in]    topOfMainStack  Main Stack Pointer value to set
- */
-__attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
-{
-  __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : "sp");
-}
-#endif
-
-
-/**
-  \brief   Get Priority Mask
-  \details Returns the current state of the priority mask bit from the Priority Mask Register.
-  \return               Priority Mask value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PRIMASK(void)
-{
-  uint32_t result;
-
-  __ASM volatile ("MRS %0, primask" : "=r" (result) );
-  return (result);
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U)
-/**
-  \brief   Get Priority Mask (non-secure)
-  \details Returns the current state of the non-secure priority mask bit from the Priority Mask Register when in secure state.
-  \return               Priority Mask value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PRIMASK_NS(void)
-{
-  uint32_t result;
-
-  __ASM volatile ("MRS %0, primask_ns" : "=r" (result) );
-  return (result);
-}
-#endif
-
-
-/**
-  \brief   Set Priority Mask
-  \details Assigns the given value to the Priority Mask Register.
-  \param [in]    priMask  Priority Mask
- */
-__attribute__((always_inline)) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
-{
-  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U)
-/**
-  \brief   Set Priority Mask (non-secure)
-  \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
-  \param [in]    priMask  Priority Mask
- */
-__attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
-{
-  __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
-}
-#endif
-
-
-#if ((__ARM_ARCH_7M__ == 1U) || (__ARM_ARCH_7EM__ == 1U) || (__ARM_ARCH_8M__ == 1U))  /* ToDo:  ARMCC_V6: check if this is ok for cortex >=3 */
-
-/**
-  \brief   Enable FIQ
-  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
-           Can only be executed in Privileged modes.
- */
-__attribute__((always_inline)) __STATIC_INLINE void __enable_fault_irq(void)
-{
-  __ASM volatile ("cpsie f" : : : "memory");
-}
-
-
-/**
-  \brief   Disable FIQ
-  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
-           Can only be executed in Privileged modes.
- */
-__attribute__((always_inline)) __STATIC_INLINE void __disable_fault_irq(void)
-{
-  __ASM volatile ("cpsid f" : : : "memory");
-}
-
-
-/**
-  \brief   Get Base Priority
-  \details Returns the current value of the Base Priority register.
-  \return               Base Priority register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __get_BASEPRI(void)
-{
-  uint32_t result;
-
-  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
-  return (result);
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U)
-/**
-  \brief   Get Base Priority (non-secure)
-  \details Returns the current value of the non-secure Base Priority register when in secure state.
-  \return               Base Priority register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_BASEPRI_NS(void)
-{
-  uint32_t result;
-
-  __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
-  return (result);
-}
-#endif
-
-
-/**
-  \brief   Set Base Priority
-  \details Assigns the given value to the Base Priority register.
-  \param [in]    basePri  Base Priority value to set
- */
-__attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
-{
-  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U)
-/**
-  \brief   Set Base Priority (non-secure)
-  \details Assigns the given value to the non-secure Base Priority register when in secure state.
-  \param [in]    basePri  Base Priority value to set
- */
-__attribute__((always_inline)) __STATIC_INLINE void __TZ_set_BASEPRI_NS(uint32_t value)
-{
-  __ASM volatile ("MSR basepri_ns, %0" : : "r" (value) : "memory");
-}
-#endif
-
-
-/**
-  \brief   Set Base Priority with condition
-  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
-           or the new value increases the BASEPRI priority level.
-  \param [in]    basePri  Base Priority value to set
- */
-__attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t value)
-{
-  __ASM volatile ("MSR basepri_max, %0" : : "r" (value) : "memory");
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U)
-/**
-  \brief   Set Base Priority with condition (non_secure)
-  \details Assigns the given value to the non-secure Base Priority register when in secure state only if BASEPRI masking is disabled,
-	       or the new value increases the BASEPRI priority level.
-  \param [in]    basePri  Base Priority value to set
- */
-__attribute__((always_inline)) __STATIC_INLINE void __TZ_set_BASEPRI_MAX_NS(uint32_t value)
-{
-  __ASM volatile ("MSR basepri_max_ns, %0" : : "r" (value) : "memory");
-}
-#endif
-
-
-/**
-  \brief   Get Fault Mask
-  \details Returns the current value of the Fault Mask register.
-  \return               Fault Mask register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
-{
-  uint32_t result;
-
-  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
-  return (result);
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U)
-/**
-  \brief   Get Fault Mask (non-secure)
-  \details Returns the current value of the non-secure Fault Mask register when in secure state.
-  \return               Fault Mask register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_FAULTMASK_NS(void)
-{
-  uint32_t result;
-
-  __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
-  return (result);
-}
-#endif
-
-
-/**
-  \brief   Set Fault Mask
-  \details Assigns the given value to the Fault Mask register.
-  \param [in]    faultMask  Fault Mask value to set
- */
-__attribute__((always_inline)) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
-{
-  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U)
-/**
-  \brief   Set Fault Mask (non-secure)
-  \details Assigns the given value to the non-secure Fault Mask register when in secure state.
-  \param [in]    faultMask  Fault Mask value to set
- */
-__attribute__((always_inline)) __STATIC_INLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
-{
-  __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
-}
-#endif
-
-
-#endif /* ((__ARM_ARCH_7M__ == 1U) || (__ARM_ARCH_8M__ == 1U)) */
-
-
-#if (__ARM_ARCH_8M__ == 1U)
-
-/**
-  \brief   Get Process Stack Pointer Limit
-  \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
-  \return               PSPLIM Register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSPLIM(void)
-{
-  register uint32_t result;
-
-  __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
-  return (result);
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U) && (__ARM_ARCH_PROFILE == 'M')     /* ToDo:  ARMCC_V6: check predefined macro for mainline */
-/**
-  \brief   Get Process Stack Pointer Limit (non-secure)
-  \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in secure state.
-  \return               PSPLIM Register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSPLIM_NS(void)
-{
-  register uint32_t result;
-
-  __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
-  return (result);
-}
-#endif
-
-
-/**
-  \brief   Set Process Stack Pointer Limit
-  \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
-  \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
- */
-__attribute__((always_inline)) __STATIC_INLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
-{
-  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U) && (__ARM_ARCH_PROFILE == 'M')     /* ToDo:  ARMCC_V6: check predefined macro for mainline */
-/**
-  \brief   Set Process Stack Pointer (non-secure)
-  \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in secure state.
-  \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
- */
-__attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
-{
-  __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
-}
-#endif
-
-
-/**
-  \brief   Get Main Stack Pointer Limit
-  \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
-  \return               MSPLIM Register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSPLIM(void)
-{
-  register uint32_t result;
-
-  __ASM volatile ("MRS %0, msplim" : "=r" (result) );
-
-  return (result);
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U) && (__ARM_ARCH_PROFILE == 'M')     /* ToDo:  ARMCC_V6: check predefined macro for mainline */
-/**
-  \brief   Get Main Stack Pointer Limit (non-secure)
-  \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in secure state.
-  \return               MSPLIM Register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSPLIM_NS(void)
-{
-  register uint32_t result;
-
-  __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
-  return (result);
-}
-#endif
-
-
-/**
-  \brief   Set Main Stack Pointer Limit
-  \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
-  \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
- */
-__attribute__((always_inline)) __STATIC_INLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
-{
-  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
-}
-
-
-#if  (__ARM_FEATURE_CMSE == 3U) && (__ARM_ARCH_PROFILE == 'M')     /* ToDo:  ARMCC_V6: check predefined macro for mainline */
-/**
-  \brief   Set Main Stack Pointer Limit (non-secure)
-  \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secure state.
-  \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
- */
-__attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
-{
-  __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
-}
-#endif
-
-#endif /* (__ARM_ARCH_8M__ == 1U) */
-
-
-#if ((__ARM_ARCH_7EM__ == 1U) || (__ARM_ARCH_8M__ == 1U))  /* ToDo:  ARMCC_V6: check if this is ok for cortex >=4 */
-
-/**
-  \brief   Get FPSCR
-  \details eturns the current value of the Floating Point Status/Control register.
-  \return               Floating Point Status/Control register value
- */
-#define __get_FPSCR      __builtin_arm_get_fpscr
-#if 0
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __get_FPSCR(void)
-{
-#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
-  uint32_t result;
-
-  __ASM volatile ("");                                 /* Empty asm statement works as a scheduling barrier */
-  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
-  __ASM volatile ("");
-  return (result);
-#else
-  return (0);
-#endif
-}
-#endif
-
-#if  (__ARM_FEATURE_CMSE == 3U)
-/**
-  \brief   Get FPSCR (non-secure)
-  \details Returns the current value of the non-secure Floating Point Status/Control register when in secure state.
-  \return               Floating Point Status/Control register value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_FPSCR_NS(void)
-{
-#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
-  uint32_t result;
-
-  __ASM volatile ("");                                 /* Empty asm statement works as a scheduling barrier */
-  __ASM volatile ("VMRS %0, fpscr_ns" : "=r" (result) );
-  __ASM volatile ("");
-  return (result);
-#else
-  return (0);
-#endif
-}
-#endif
-
-
-/**
-  \brief   Set FPSCR
-  \details Assigns the given value to the Floating Point Status/Control register.
-  \param [in]    fpscr  Floating Point Status/Control value to set
- */
-#define __set_FPSCR      __builtin_arm_set_fpscr
-#if 0
-__attribute__((always_inline)) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
-{
-#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
-  __ASM volatile ("");                                 /* Empty asm statement works as a scheduling barrier */
-  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
-  __ASM volatile ("");
-#endif
-}
-#endif
-
-#if  (__ARM_FEATURE_CMSE == 3U)
-/**
-  \brief   Set FPSCR (non-secure)
-  \details Assigns the given value to the non-secure Floating Point Status/Control register when in secure state.
-  \param [in]    fpscr  Floating Point Status/Control value to set
- */
-__attribute__((always_inline)) __STATIC_INLINE void __TZ_set_FPSCR_NS(uint32_t fpscr)
-{
-#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
-  __ASM volatile ("");                                 /* Empty asm statement works as a scheduling barrier */
-  __ASM volatile ("VMSR fpscr_ns, %0" : : "r" (fpscr) : "vfpcc");
-  __ASM volatile ("");
-#endif
-}
-#endif
-
-#endif /* ((__ARM_ARCH_7EM__ == 1U) || (__ARM_ARCH_8M__ == 1U)) */
-
-
-
-/*@} end of CMSIS_Core_RegAccFunctions */
-
-
-/* ##########################  Core Instruction Access  ######################### */
-/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
-  Access to dedicated instructions
-  @{
-*/
-
-/* Define macros for porting to both thumb1 and thumb2.
- * For thumb1, use low register (r0-r7), specified by constraint "l"
- * Otherwise, use general registers, specified by constraint "r" */
-#if defined (__thumb__) && !defined (__thumb2__)
-#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
-#define __CMSIS_GCC_USE_REG(r) "l" (r)
-#else
-#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
-#define __CMSIS_GCC_USE_REG(r) "r" (r)
-#endif
-
-/**
-  \brief   No Operation
-  \details No Operation does nothing. This instruction can be used for code alignment purposes.
- */
-#define __NOP          __builtin_arm_nop
-
-/**
-  \brief   Wait For Interrupt
-  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
- */
-#define __WFI          __builtin_arm_wfi
-
-
-/**
-  \brief   Wait For Event
-  \details Wait For Event is a hint instruction that permits the processor to enter
-           a low-power state until one of a number of events occurs.
- */
-#define __WFE          __builtin_arm_wfe
-
-
-/**
-  \brief   Send Event
-  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
- */
-#define __SEV          __builtin_arm_sev
-
-
-/**
-  \brief   Instruction Synchronization Barrier
-  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
-           so that all instructions following the ISB are fetched from cache or memory,
-           after the instruction has been completed.
- */
-#define __ISB()        __builtin_arm_isb(0xF);
-
-/**
-  \brief   Data Synchronization Barrier
-  \details Acts as a special kind of Data Memory Barrier.
-           It completes when all explicit memory accesses before this instruction complete.
- */
-#define __DSB()        __builtin_arm_dsb(0xF);
-
-
-/**
-  \brief   Data Memory Barrier
-  \details Ensures the apparent order of the explicit memory operations before
-           and after the instruction, without ensuring their completion.
- */
-#define __DMB()        __builtin_arm_dmb(0xF);
-
-
-/**
-  \brief   Reverse byte order (32 bit)
-  \details Reverses the byte order in integer value.
-  \param [in]    value  Value to reverse
-  \return               Reversed value
- */
-#define __REV          __builtin_bswap32
-
-
-/**
-  \brief   Reverse byte order (16 bit)
-  \details Reverses the byte order in two unsigned short values.
-  \param [in]    value  Value to reverse
-  \return               Reversed value
- */
-#define __REV16          __builtin_bswap16                           /* ToDo:  ARMCC_V6: check if __builtin_bswap16 could be used */
-#if 0
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __REV16(uint32_t value)
-{
-  uint32_t result;
-
-  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
-  return (result);
-}
-#endif
-
-
-/**
-  \brief   Reverse byte order in signed short value
-  \details Reverses the byte order in a signed short value with sign extension to integer.
-  \param [in]    value  Value to reverse
-  \return               Reversed value
- */
-/* ToDo:  ARMCC_V6: check if __builtin_bswap16 could be used */
-__attribute__((always_inline)) __STATIC_INLINE int32_t __REVSH(int32_t value)
-{
-  int32_t result;
-
-  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
-  return (result);
-}
-
-
-/**
-  \brief   Rotate Right in unsigned value (32 bit)
-  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
-  \param [in]    op1  Value to rotate
-  \param [in]    op2  Number of Bits to rotate
-  \return               Rotated value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
-{
-  return (op1 >> op2) | (op1 << (32U - op2));
-}
-
-
-/**
-  \brief   Breakpoint
-  \details Causes the processor to enter Debug state.
-            Debug tools can use this to investigate system state when the instruction at a particular address is reached.
-    \param [in]    value  is ignored by the processor.
-                   If required, a debugger can use it to store additional information about the breakpoint.
- */
-#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
-
-
-/**
-  \brief   Reverse bit order of value
-  \details Reverses the bit order of the given value.
-  \param [in]    value  Value to reverse
-  \return               Reversed value
- */
-/* ToDo:  ARMCC_V6: check if __builtin_arm_rbit is supported */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
-{
-  uint32_t result;
-
-#if ((__ARM_ARCH_7M__ == 1U) || (__ARM_ARCH_7EM__ == 1U) || (__ARM_ARCH_8M__ == 1U))  /* ToDo:  ARMCC_V6: check if this is ok for cortex >=3 */
-  __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
-#else
-  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; /* extra shift needed at end */
-
-  result = value;                      /* r will be reversed bits of v; first get LSB of v */
-  for (value >>= 1U; value; value >>= 1U)
-    {
-      result <<= 1U;
-      result |= value & 1U;
-      s--;
-    }
-  result <<= s;                        /* shift when v's highest bits are zero */
-#endif
-  return (result);
-}
-
-
-/**
-  \brief   Count leading zeros
-  \details Counts the number of leading zeros of a data value.
-  \param [in]  value  Value to count the leading zeros
-  \return             number of leading zeros in value
- */
-#define __CLZ             __builtin_clz
-
-
-#if ((__ARM_ARCH_7M__ == 1U) || (__ARM_ARCH_7EM__ == 1U) || (__ARM_ARCH_8M__ == 1U))  /* ToDo:  ARMCC_V6: check if this is ok for cortex >=3 */
-
-/**
-  \brief   LDR Exclusive (8 bit)
-  \details Executes a exclusive LDR instruction for 8 bit value.
-  \param [in]    ptr  Pointer to data
-  \return             value of type uint8_t at (*ptr)
- */
-#define __LDREXB        (uint8_t)__builtin_arm_ldrex
-
-
-/**
-  \brief   LDR Exclusive (16 bit)
-  \details Executes a exclusive LDR instruction for 16 bit values.
-  \param [in]    ptr  Pointer to data
-  \return        value of type uint16_t at (*ptr)
- */
-#define __LDREXH        (uint16_t)__builtin_arm_ldrex
-
-
-/**
-  \brief   LDR Exclusive (32 bit)
-  \details Executes a exclusive LDR instruction for 32 bit values.
-  \param [in]    ptr  Pointer to data
-  \return        value of type uint32_t at (*ptr)
- */
-#define __LDREXW        (uint32_t)__builtin_arm_ldrex
-
-
-/**
-  \brief   STR Exclusive (8 bit)
-  \details Executes a exclusive STR instruction for 8 bit values.
-  \param [in]  value  Value to store
-  \param [in]    ptr  Pointer to location
-  \return          0  Function succeeded
-  \return          1  Function failed
- */
-#define __STREXB        (uint32_t)__builtin_arm_strex
-
-
-/**
-  \brief   STR Exclusive (16 bit)
-  \details Executes a exclusive STR instruction for 16 bit values.
-  \param [in]  value  Value to store
-  \param [in]    ptr  Pointer to location
-  \return          0  Function succeeded
-  \return          1  Function failed
- */
-#define __STREXH        (uint32_t)__builtin_arm_strex
-
-
-/**
-  \brief   STR Exclusive (32 bit)
-  \details Executes a exclusive STR instruction for 32 bit values.
-  \param [in]  value  Value to store
-  \param [in]    ptr  Pointer to location
-  \return          0  Function succeeded
-  \return          1  Function failed
- */
-#define __STREXW        (uint32_t)__builtin_arm_strex
-
-
-/**
-  \brief   Remove the exclusive lock
-  \details Removes the exclusive lock which is created by LDREX.
- */
-#define __CLREX             __builtin_arm_clrex
-
-
-/**
-  \brief   Signed Saturate
-  \details Saturates a signed value.
-  \param [in]  value  Value to be saturated
-  \param [in]    sat  Bit position to saturate to (1..32)
-  \return             Saturated value
- */
-/*#define __SSAT             __builtin_arm_ssat*/
-#define __SSAT(ARG1,ARG2) \
-({                          \
-  int32_t __RES, __ARG1 = (ARG1); \
-  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
-  __RES; \
- })
-
-
-/**
-  \brief   Unsigned Saturate
-  \details Saturates an unsigned value.
-  \param [in]  value  Value to be saturated
-  \param [in]    sat  Bit position to saturate to (0..31)
-  \return             Saturated value
- */
-#define __USAT             __builtin_arm_usat
-#if 0
-#define __USAT(ARG1,ARG2) \
-({                          \
-  uint32_t __RES, __ARG1 = (ARG1); \
-  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
-  __RES; \
- })
-#endif
-
-
-/**
-  \brief   Rotate Right with Extend (32 bit)
-  \details Moves each bit of a bitstring right by one bit.
-           The carry input is shifted in at the left end of the bitstring.
-  \param [in]    value  Value to rotate
-  \return               Rotated value
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __RRX(uint32_t value)
-{
-  uint32_t result;
-
-  __ASM volatile ("rrx %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
-  return (result);
-}
-
-
-/**
-  \brief   LDRT Unprivileged (8 bit)
-  \details Executes a Unprivileged LDRT instruction for 8 bit value.
-  \param [in]    ptr  Pointer to data
-  \return             value of type uint8_t at (*ptr)
- */
-__attribute__((always_inline)) __STATIC_INLINE uint8_t __LDRBT(volatile uint8_t *ptr)
-{
-  uint32_t result;
-
-  __ASM volatile ("ldrbt %0, %1" : "=r" (result) : "Q" (*ptr) );
-  return ((uint8_t) result);    /* Add explicit type cast here */
-}
-
-
-/**
-  \brief   LDRT Unprivileged (16 bit)
-  \details Executes a Unprivileged LDRT instruction for 16 bit values.
-  \param [in]    ptr  Pointer to data
-  \return        value of type uint16_t at (*ptr)
- */
-__attribute__((always_inline)) __STATIC_INLINE uint16_t __LDRHT(volatile uint16_t *ptr)
-{
-  uint32_t result;
-
-  __ASM volatile ("ldrht %0, %1" : "=r" (result) : "Q" (*ptr) );
-  return ((uint16_t) result);    /* Add explicit type cast here */
-}
-
-
-/**
-  \brief   LDRT Unprivileged (32 bit)
-  \details Executes a Unprivileged LDRT instruction for 32 bit values.
-  \param [in]    ptr  Pointer to data
-  \return        value of type uint32_t at (*ptr)
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __LDRT(volatile uint32_t *ptr)
-{
-  uint32_t result;
-
-  __ASM volatile ("ldrt %0, %1" : "=r" (result) : "Q" (*ptr) );
-  return (result);
-}
-
-
-/**
-  \brief   STRT Unprivileged (8 bit)
-  \details Executes a Unprivileged STRT instruction for 8 bit values.
-  \param [in]  value  Value to store
-  \param [in]    ptr  Pointer to location
- */
-__attribute__((always_inline)) __STATIC_INLINE void __STRBT(uint8_t value, volatile uint8_t *ptr)
-{
-  __ASM volatile ("strbt %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) );
-}
-
-
-/**
-  \brief   STRT Unprivileged (16 bit)
-  \details Executes a Unprivileged STRT instruction for 16 bit values.
-  \param [in]  value  Value to store
-  \param [in]    ptr  Pointer to location
- */
-__attribute__((always_inline)) __STATIC_INLINE void __STRHT(uint16_t value, volatile uint16_t *ptr)
-{
-  __ASM volatile ("strht %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) );
-}
-
-
-/**
-  \brief   STRT Unprivileged (32 bit)
-  \details Executes a Unprivileged STRT instruction for 32 bit values.
-  \param [in]  value  Value to store
-  \param [in]    ptr  Pointer to location
- */
-__attribute__((always_inline)) __STATIC_INLINE void __STRT(uint32_t value, volatile uint32_t *ptr)
-{
-  __ASM volatile ("strt %1, %0" : "=Q" (*ptr) : "r" (value) );
-}
-
-#endif /* ((__ARM_ARCH_7M__ == 1U) || (__ARM_ARCH_7EM__ == 1U) || (__ARM_ARCH_8M__ == 1U)) */
-
-
-#if (__ARM_ARCH_8M__ == 1U)
-
-/**
-  \brief   Load-Acquire (8 bit)
-  \details Executes a LDAB instruction for 8 bit value.
-  \param [in]    ptr  Pointer to data
-  \return             value of type uint8_t at (*ptr)
- */
-__attribute__((always_inline)) __STATIC_INLINE uint8_t __LDAB(volatile uint8_t *ptr)
-{
-  uint32_t result;
-
-  __ASM volatile ("ldab %0, %1" : "=r" (result) : "Q" (*ptr) );
-  return ((uint8_t) result);
-}
-
-
-/**
-  \brief   Load-Acquire (16 bit)
-  \details Executes a LDAH instruction for 16 bit values.
-  \param [in]    ptr  Pointer to data
-  \return        value of type uint16_t at (*ptr)
- */
-__attribute__((always_inline)) __STATIC_INLINE uint16_t __LDAH(volatile uint16_t *ptr)
-{
-  uint32_t result;
-
-  __ASM volatile ("ldah %0, %1" : "=r" (result) : "Q" (*ptr) );
-  return ((uint16_t) result);
-}
-
-
-/**
-  \brief   Load-Acquire (32 bit)
-  \details Executes a LDA instruction for 32 bit values.
-  \param [in]    ptr  Pointer to data
-  \return        value of type uint32_t at (*ptr)
- */
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __LDA(volatile uint32_t *ptr)
-{
-  uint32_t result;
-
-  __ASM volatile ("lda %0, %1" : "=r" (result) : "Q" (*ptr) );
-  return (result);
-}
-
-
-/**
-  \brief   Store-Release (8 bit)
-  \details Executes a STLB instruction for 8 bit values.
-  \param [in]  value  Value to store
-  \param [in]    ptr  Pointer to location
- */
-__attribute__((always_inline)) __STATIC_INLINE void __STLB(uint8_t value, volatile uint8_t *ptr)
-{
-  __ASM volatile ("stlb %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) );
-}
-
-
-/**
-  \brief   Store-Release (16 bit)
-  \details Executes a STLH instruction for 16 bit values.
-  \param [in]  value  Value to store
-  \param [in]    ptr  Pointer to location
- */
-__attribute__((always_inline)) __STATIC_INLINE void __STLH(uint16_t value, volatile uint16_t *ptr)
-{
-  __ASM volatile ("stlh %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) );
-}
-
-
-/**
-  \brief   Store-Release (32 bit)
-  \details Executes a STL instruction for 32 bit values.
-  \param [in]  value  Value to store
-  \param [in]    ptr  Pointer to location
- */
-__attribute__((always_inline)) __STATIC_INLINE void __STL(uint32_t value, volatile uint32_t *ptr)
-{
-  __ASM volatile ("stl %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) );
-}
-
-
-/**
-  \brief   Load-Acquire Exclusive (8 bit)
-  \details Executes a LDAB exclusive instruction for 8 bit value.
-  \param [in]    ptr  Pointer to data
-  \return             value of type uint8_t at (*ptr)
- */
-#define     __LDAEXB                 (uint8_t)__builtin_arm_ldaex
-
-
-/**
-  \brief   Load-Acquire Exclusive (16 bit)
-  \details Executes a LDAH exclusive instruction for 16 bit values.
-  \param [in]    ptr  Pointer to data
-  \return        value of type uint16_t at (*ptr)
- */
-#define     __LDAEXH                 (uint16_t)__builtin_arm_ldaex
-
-
-/**
-  \brief   Load-Acquire Exclusive (32 bit)
-  \details Executes a LDA exclusive instruction for 32 bit values.
-  \param [in]    ptr  Pointer to data
-  \return        value of type uint32_t at (*ptr)
- */
-#define     __LDAEX                  (uint32_t)__builtin_arm_ldaex
-
-
-/**
-  \brief   Store-Release Exclusive (8 bit)
-  \details Executes a STLB exclusive instruction for 8 bit values.
-  \param [in]  value  Value to store
-  \param [in]    ptr  Pointer to location
-  \return          0  Function succeeded
-  \return          1  Function failed
- */
-#define     __STLEXB                 (uint32_t)__builtin_arm_stlex
-
-
-/**
-  \brief   Store-Release Exclusive (16 bit)
-  \details Executes a STLH exclusive instruction for 16 bit values.
-  \param [in]  value  Value to store
-  \param [in]    ptr  Pointer to location
-  \return          0  Function succeeded
-  \return          1  Function failed
- */
-#define     __STLEXH                 (uint32_t)__builtin_arm_stlex
-
-
-/**
-  \brief   Store-Release Exclusive (32 bit)
-  \details Executes a STL exclusive instruction for 32 bit values.
-  \param [in]  value  Value to store
-  \param [in]    ptr  Pointer to location
-  \return          0  Function succeeded
-  \return          1  Function failed
- */
-#define     __STLEX                  (uint32_t)__builtin_arm_stlex
-
-#endif /* (__ARM_ARCH_8M__ == 1U) */
-
-/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
-
-
-/* ###################  Compiler specific Intrinsics  ########################### */
-/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
-  Access to dedicated SIMD instructions
-  @{
-*/
-
-#if (__ARM_FEATURE_DSP == 1U)        /* ToDo:  ARMCC_V6: This should be ARCH >= ARMv7-M + SIMD */
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SADD8(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("sadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __QADD8(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("qadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SHADD8(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("shadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __UADD8(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("uadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __UQADD8(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("uqadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __UHADD8(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("uhadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SSUB8(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("ssub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __QSUB8(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("qsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SHSUB8(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("shsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __USUB8(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("usub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __UQSUB8(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("uqsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __UHSUB8(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("uhsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SADD16(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("sadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __QADD16(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("qadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SHADD16(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("shadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __UADD16(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("uadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __UQADD16(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("uqadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __UHADD16(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("uhadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SSUB16(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("ssub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __QSUB16(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("qsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SHSUB16(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("shsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __USUB16(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("usub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __UQSUB16(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("uqsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __UHSUB16(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("uhsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SASX(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("sasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __QASX(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("qasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SHASX(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("shasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __UASX(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("uasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __UQASX(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("uqasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __UHASX(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("uhasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SSAX(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("ssax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __QSAX(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("qsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SHSAX(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("shsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __USAX(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("usax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __UQSAX(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("uqsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __UHSAX(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("uhsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __USAD8(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("usad8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __USADA8(uint32_t op1, uint32_t op2, uint32_t op3)
-{
-  uint32_t result;
-
-  __ASM volatile ("usada8 %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
-  return (result);
-}
-
-#define __SSAT16(ARG1,ARG2) \
-({                          \
-  uint32_t __RES, __ARG1 = (ARG1); \
-  __ASM ("ssat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
-  __RES; \
- })
-
-#define __USAT16(ARG1,ARG2) \
-({                          \
-  uint32_t __RES, __ARG1 = (ARG1); \
-  __ASM ("usat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
-  __RES; \
- })
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __UXTB16(uint32_t op1)
-{
-  uint32_t result;
-
-  __ASM volatile ("uxtb16 %0, %1" : "=r" (result) : "r" (op1));
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __UXTAB16(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("uxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SXTB16(uint32_t op1)
-{
-  uint32_t result;
-
-  __ASM volatile ("sxtb16 %0, %1" : "=r" (result) : "r" (op1));
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SXTAB16(uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("sxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SMUAD  (uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("smuad %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SMUADX (uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("smuadx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SMLAD (uint32_t op1, uint32_t op2, uint32_t op3)
-{
-  uint32_t result;
-
-  __ASM volatile ("smlad %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SMLADX (uint32_t op1, uint32_t op2, uint32_t op3)
-{
-  uint32_t result;
-
-  __ASM volatile ("smladx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint64_t __SMLALD (uint32_t op1, uint32_t op2, uint64_t acc)
-{
-  union llreg_u
-  {
-    uint32_t w32[2];
-    uint64_t w64;
-  } llr;
-  llr.w64 = acc;
-
-#ifndef __ARMEB__   /* Little endian */
-  __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2), "0" (llr.w32[0]),
-                  "1" (llr.w32[1]) );
-#else               /* Big endian */
-  __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2), "0" (llr.w32[1]),
-                  "1" (llr.w32[0]) );
-#endif
-
-  return (llr.w64);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint64_t __SMLALDX (uint32_t op1, uint32_t op2, uint64_t acc)
-{
-  union llreg_u
-  {
-    uint32_t w32[2];
-    uint64_t w64;
-  } llr;
-  llr.w64 = acc;
-
-#ifndef __ARMEB__   /* Little endian */
-  __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2), "0" (llr.w32[0]),
-                  "1" (llr.w32[1]) );
-#else               /* Big endian */
-  __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2), "0" (llr.w32[1]),
-                  "1" (llr.w32[0]) );
-#endif
-
-  return (llr.w64);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SMUSD  (uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("smusd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SMUSDX (uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("smusdx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SMLSD (uint32_t op1, uint32_t op2, uint32_t op3)
-{
-  uint32_t result;
-
-  __ASM volatile ("smlsd %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SMLSDX (uint32_t op1, uint32_t op2, uint32_t op3)
-{
-  uint32_t result;
-
-  __ASM volatile ("smlsdx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint64_t __SMLSLD (uint32_t op1, uint32_t op2, uint64_t acc)
-{
-  union llreg_u
-  {
-    uint32_t w32[2];
-    uint64_t w64;
-  } llr;
-  llr.w64 = acc;
-
-#ifndef __ARMEB__   /* Little endian */
-  __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2), "0" (llr.w32[0]),
-                  "1" (llr.w32[1]) );
-#else               /* Big endian */
-  __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2), "0" (llr.w32[1]),
-                  "1" (llr.w32[0]) );
-#endif
-
-  return (llr.w64);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint64_t __SMLSLDX (uint32_t op1, uint32_t op2, uint64_t acc)
-{
-  union llreg_u
-  {
-    uint32_t w32[2];
-    uint64_t w64;
-  } llr;
-  llr.w64 = acc;
-
-#ifndef __ARMEB__   /* Little endian */
-  __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2), "0" (llr.w32[0]),
-                  "1" (llr.w32[1]) );
-#else               /* Big endian */
-  __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2), "0" (llr.w32[1]),
-                  "1" (llr.w32[0]) );
-#endif
-
-  return (llr.w64);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SEL  (uint32_t op1, uint32_t op2)
-{
-  uint32_t result;
-
-  __ASM volatile ("sel %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE  int32_t __QADD( int32_t op1,  int32_t op2)
-{
-  int32_t result;
-
-  __ASM volatile ("qadd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-__attribute__((always_inline)) __STATIC_INLINE  int32_t __QSUB( int32_t op1,  int32_t op2)
-{
-  int32_t result;
-
-  __ASM volatile ("qsub %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
-  return (result);
-}
-
-#define __PKHBT(ARG1,ARG2,ARG3) \
-({                          \
-  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
-  __ASM ("pkhbt %0, %1, %2, lsl %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
-  __RES; \
- })
-
-#define __PKHTB(ARG1,ARG2,ARG3) \
-({                          \
-  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
-  if (ARG3 == 0) \
-    __ASM ("pkhtb %0, %1, %2" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2)  ); \
-  else \
-    __ASM ("pkhtb %0, %1, %2, asr %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
-  __RES; \
- })
-
-__attribute__((always_inline)) __STATIC_INLINE uint32_t __SMMLA (int32_t op1, int32_t op2, int32_t op3)
-{
-  int32_t result;
-
-  __ASM volatile ("smmla %0, %1, %2, %3" : "=r" (result): "r"  (op1), "r" (op2), "r" (op3) );
-  return (result);
-}
-
-#endif /* (__ARM_FEATURE_DSP == 1U) */
-/*@} end of group CMSIS_SIMD_intrinsics */
-
-
-#endif /* __CMSIS_ARMCC_V6_H */
diff --git a/arch/arm/src/nrf52/components/toolchain/cmsis/include/core_sc000.h b/arch/arm/src/nrf52/components/toolchain/cmsis/include/core_sc000.h
deleted file mode 100644
index 8c23b37635..0000000000
--- a/arch/arm/src/nrf52/components/toolchain/cmsis/include/core_sc000.h
+++ /dev/null
@@ -1,926 +0,0 @@
-/**************************************************************************//**
- * @file     core_sc000.h
- * @brief    CMSIS SC000 Core Peripheral Access Layer Header File
- * @version  V4.30
- * @date     20. October 2015
- ******************************************************************************/
-/* Copyright (c) 2009 - 2015 ARM LIMITED
-
-   All rights reserved.
-   Redistribution and use in source and binary forms, with or without
-   modification, are permitted provided that the following conditions are met:
-   - Redistributions of source code must retain the above copyright
-     notice, this list of conditions and the following disclaimer.
-   - Redistributions in binary form must reproduce the above copyright
-     notice, this list of conditions and the following disclaimer in the
-     documentation and/or other materials provided with the distribution.
-   - Neither the name of ARM nor the names of its contributors may be used
-     to endorse or promote products derived from this software without
-     specific prior written permission.
-   *
-   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
-   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-   POSSIBILITY OF SUCH DAMAGE.
-   ---------------------------------------------------------------------------*/
-
-
-#if   defined ( __ICCARM__ )
-#pragma system_include         /* treat file as system include file for MISRA check */
-#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
-#pragma clang system_header   /* treat file as system include file */
-#endif
-
-#ifndef __CORE_SC000_H_GENERIC
-#define __CORE_SC000_H_GENERIC
-
-#include <stdint.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
-  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
-  CMSIS violates the following MISRA-C:2004 rules:
-
-   \li Required Rule 8.5, object/function definition in header file.<br>
-     Function definitions in header files are used to allow 'inlining'.
-
-   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
-     Unions are used for effective representation of core registers.
-
-   \li Advisory Rule 19.7, Function-like macro defined.<br>
-     Function-like macros are used to allow more efficient code.
- */
-
-
-/*******************************************************************************
- *                 CMSIS definitions
- ******************************************************************************/
-/**
-  \ingroup SC000
-  @{
- */
-
-/*  CMSIS SC000 definitions */
-#define __SC000_CMSIS_VERSION_MAIN  (0x04U)                                    /*!< [31:16] CMSIS HAL main version */
-#define __SC000_CMSIS_VERSION_SUB   (0x1EU)                                    /*!< [15:0]  CMSIS HAL sub version */
-#define __SC000_CMSIS_VERSION       ((__SC000_CMSIS_VERSION_MAIN << 16U) | \
-                                      __SC000_CMSIS_VERSION_SUB           )    /*!< CMSIS HAL version number */
-
-#define __CORTEX_SC                 (000U)                                     /*!< Cortex secure core */
-
-
-#if   defined ( __CC_ARM )
-#define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
-#define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
-#define __STATIC_INLINE  static __inline
-
-#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
-#define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
-#define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
-#define __STATIC_INLINE  static __inline
-
-#elif defined ( __GNUC__ )
-#define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
-#define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
-#define __STATIC_INLINE  static inline
-
-#elif defined ( __ICCARM__ )
-#define __ASM            __asm                                      /*!< asm keyword for IAR Compiler */
-#define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
-#define __STATIC_INLINE  static inline
-
-#elif defined ( __TMS470__ )
-#define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler */
-#define __STATIC_INLINE  static inline
-
-#elif defined ( __TASKING__ )
-#define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler */
-#define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler */
-#define __STATIC_INLINE  static inline
-
-#elif defined ( __CSMC__ )
-#define __packed
-#define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler */
-#define __INLINE         inline                                    /*!< inline keyword for COSMIC Compiler. Use -pc99 on compile line */
-#define __STATIC_INLINE  static inline
-
-#else
-#error Unknown compiler
-#endif
-
-/** __FPU_USED indicates whether an FPU is used or not.
-    This core does not support an FPU at all
-*/
-#define __FPU_USED       0U
-
-#if defined ( __CC_ARM )
-#if defined __TARGET_FPU_VFP
-#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
-#endif
-
-#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
-#if defined __ARM_PCS_VFP
-#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
-#endif
-
-#elif defined ( __GNUC__ )
-#if defined (__VFP_FP__) && !defined(__SOFTFP__)
-#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
-#endif
-
-#elif defined ( __ICCARM__ )
-#if defined __ARMVFP__
-#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
-#endif
-
-#elif defined ( __TMS470__ )
-#if defined __TI_VFP_SUPPORT__
-#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
-#endif
-
-#elif defined ( __TASKING__ )
-#if defined __FPU_VFP__
-#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
-#endif
-
-#elif defined ( __CSMC__ )
-#if ( __CSMC__ & 0x400U)
-#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
-#endif
-
-#endif
-
-#include "core_cmInstr.h"                /* Core Instruction Access */
-#include "core_cmFunc.h"                 /* Core Function Access */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __CORE_SC000_H_GENERIC */
-
-#ifndef __CMSIS_GENERIC
-
-#ifndef __CORE_SC000_H_DEPENDANT
-#define __CORE_SC000_H_DEPENDANT
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* check device defines and use defaults */
-#if defined __CHECK_DEVICE_DEFINES
-#ifndef __SC000_REV
-#define __SC000_REV             0x0000U
-#warning "__SC000_REV not defined in device header file; using default!"
-#endif
-
-#ifndef __MPU_PRESENT
-#define __MPU_PRESENT             0U
-#warning "__MPU_PRESENT not defined in device header file; using default!"
-#endif
-
-#ifndef __NVIC_PRIO_BITS
-#define __NVIC_PRIO_BITS          2U
-#warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
-#endif
-
-#ifndef __Vendor_SysTickConfig
-#define __Vendor_SysTickConfig    0U
-#warning "__Vendor_SysTickConfig not defined in device header file; using default!"
-#endif
-#endif
-
-/* IO definitions (access restrictions to peripheral registers) */
-/**
-    \defgroup CMSIS_glob_defs CMSIS Global Defines
-
-    <strong>IO Type Qualifiers</strong> are used
-    \li to specify the access to peripheral variables.
-    \li for automatic generation of peripheral register debug information.
-*/
-#ifdef __cplusplus
-#define   __I     volatile             /*!< Defines 'read only' permissions */
-#else
-#define   __I     volatile const       /*!< Defines 'read only' permissions */
-#endif
-#define     __O     volatile             /*!< Defines 'write only' permissions */
-#define     __IO    volatile             /*!< Defines 'read / write' permissions */
-
-/* following defines should be used for structure members */
-#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
-#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
-#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
-
-/*@} end of group SC000 */
-
-
-
-/*******************************************************************************
- *                 Register Abstraction
-  Core Register contain:
-  - Core Register
-  - Core NVIC Register
-  - Core SCB Register
-  - Core SysTick Register
-  - Core MPU Register
- ******************************************************************************/
-/**
-  \defgroup CMSIS_core_register Defines and Type Definitions
-  \brief Type definitions and defines for Cortex-M processor based devices.
-*/
-
-/**
-  \ingroup    CMSIS_core_register
-  \defgroup   CMSIS_CORE  Status and Control Registers
-  \brief      Core Register type definitions.
-  @{
- */
-
-/**
-  \brief  Union type to access the Application Program Status Register (APSR).
- */
-typedef union
-{
-  struct
-  {
-    uint32_t _reserved0: 28;             /*!< bit:  0..27  Reserved */
-    uint32_t V: 1;                       /*!< bit:     28  Overflow condition code flag */
-    uint32_t C: 1;                       /*!< bit:     29  Carry condition code flag */
-    uint32_t Z: 1;                       /*!< bit:     30  Zero condition code flag */
-    uint32_t N: 1;                       /*!< bit:     31  Negative condition code flag */
-  } b;                                   /*!< Structure used for bit  access */
-  uint32_t w;                            /*!< Type      used for word access */
-} APSR_Type;
-
-/* APSR Register Definitions */
-#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
-#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
-
-#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
-#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
-
-#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
-#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
-
-#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
-#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
-
-
-/**
-  \brief  Union type to access the Interrupt Program Status Register (IPSR).
- */
-typedef union
-{
-  struct
-  {
-    uint32_t ISR: 9;                     /*!< bit:  0.. 8  Exception number */
-    uint32_t _reserved0: 23;             /*!< bit:  9..31  Reserved */
-  } b;                                   /*!< Structure used for bit  access */
-  uint32_t w;                            /*!< Type      used for word access */
-} IPSR_Type;
-
-/* IPSR Register Definitions */
-#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
-#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
-
-
-/**
-  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
- */
-typedef union
-{
-  struct
-  {
-    uint32_t ISR: 9;                     /*!< bit:  0.. 8  Exception number */
-    uint32_t _reserved0: 15;             /*!< bit:  9..23  Reserved */
-    uint32_t T: 1;                       /*!< bit:     24  Thumb bit        (read 0) */
-    uint32_t _reserved1: 3;              /*!< bit: 25..27  Reserved */
-    uint32_t V: 1;                       /*!< bit:     28  Overflow condition code flag */
-    uint32_t C: 1;                       /*!< bit:     29  Carry condition code flag */
-    uint32_t Z: 1;                       /*!< bit:     30  Zero condition code flag */
-    uint32_t N: 1;                       /*!< bit:     31  Negative condition code flag */
-  } b;                                   /*!< Structure used for bit  access */
-  uint32_t w;                            /*!< Type      used for word access */
-} xPSR_Type;
-
-/* xPSR Register Definitions */
-#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
-#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
-
-#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
-#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
-
-#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
-#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
-
-#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
-#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
-
-#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
-#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
-
-#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
-#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
-
-
-/**
-  \brief  Union type to access the Control Registers (CONTROL).
- */
-typedef union
-{
-  struct
-  {
-    uint32_t _reserved0: 1;              /*!< bit:      0  Reserved */
-    uint32_t SPSEL: 1;                   /*!< bit:      1  Stack to be used */
-    uint32_t _reserved1: 30;             /*!< bit:  2..31  Reserved */
-  } b;                                   /*!< Structure used for bit  access */
-  uint32_t w;                            /*!< Type      used for word access */
-} CONTROL_Type;
-
-/* CONTROL Register Definitions */
-#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
-#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
-
-/*@} end of group CMSIS_CORE */
-
-
-/**
-  \ingroup    CMSIS_core_register
-  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
-  \brief      Type definitions for the NVIC Registers
-  @{
- */
-
-/**
-  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
- */
-typedef struct
-{
-  __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
-  uint32_t RESERVED0[31U];
-  __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
-  uint32_t RSERVED1[31U];
-  __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
-  uint32_t RESERVED2[31U];
-  __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
-  uint32_t RESERVED3[31U];
-  uint32_t RESERVED4[64U];
-  __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
-}  NVIC_Type;
-
-/*@} end of group CMSIS_NVIC */
-
-
-/**
-  \ingroup  CMSIS_core_register
-  \defgroup CMSIS_SCB     System Control Block (SCB)
-  \brief    Type definitions for the System Control Block Registers
-  @{
- */
-
-/**
-  \brief  Structure type to access the System Control Block (SCB).
- */
-typedef struct
-{
-  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
-  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
-  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
-  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
-  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
-  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
-  uint32_t RESERVED0[1U];
-  __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
-  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
-  uint32_t RESERVED1[154U];
-  __IOM uint32_t SFCR;                   /*!< Offset: 0x290 (R/W)  Security Features Control Register */
-} SCB_Type;
-
-/* SCB CPUID Register Definitions */
-#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
-#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
-
-#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
-#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
-
-#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
-#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
-
-#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
-#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
-
-#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
-#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
-
-/* SCB Interrupt Control State Register Definitions */
-#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
-#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
-
-#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
-#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
-
-#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
-#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
-
-#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
-#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
-
-#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
-#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
-
-#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
-#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
-
-#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
-#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
-
-#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
-#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
-
-#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
-#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
-
-/* SCB Interrupt Control State Register Definitions */
-#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
-#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
-
-/* SCB Application Interrupt and Reset Control Register Definitions */
-#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
-#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
-
-#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
-#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
-
-#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
-#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
-
-#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
-#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
-
-#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
-#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
-
-/* SCB System Control Register Definitions */
-#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
-#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
-
-#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
-#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
-
-#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
-#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
-
-/* SCB Configuration Control Register Definitions */
-#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
-#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
-
-#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
-#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
-
-/* SCB System Handler Control and State Register Definitions */
-#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
-#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
-
-/*@} end of group CMSIS_SCB */
-
-
-/**
-  \ingroup  CMSIS_core_register
-  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
-  \brief    Type definitions for the System Control and ID Register not in the SCB
-  @{
- */
-
-/**
-  \brief  Structure type to access the System Control and ID Register not in the SCB.
- */
-typedef struct
-{
-  uint32_t RESERVED0[2U];
-  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
-} SCnSCB_Type;
-
-/* Auxiliary Control Register Definitions */
-#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
-#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
-
-/*@} end of group CMSIS_SCnotSCB */
-
-
-/**
-  \ingroup  CMSIS_core_register
-  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
-  \brief    Type definitions for the System Timer Registers.
-  @{
- */
-
-/**
-  \brief  Structure type to access the System Timer (SysTick).
- */
-typedef struct
-{
-  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
-  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
-  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
-  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
-} SysTick_Type;
-
-/* SysTick Control / Status Register Definitions */
-#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
-#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
-
-#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
-#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
-
-#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
-#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
-
-#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
-#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
-
-/* SysTick Reload Register Definitions */
-#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
-#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
-
-/* SysTick Current Register Definitions */
-#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
-#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
-
-/* SysTick Calibration Register Definitions */
-#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
-#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
-
-#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
-#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
-
-#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
-#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
-
-/*@} end of group CMSIS_SysTick */
-
-#if (__MPU_PRESENT == 1U)
-/**
-  \ingroup  CMSIS_core_register
-  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
-  \brief    Type definitions for the Memory Protection Unit (MPU)
-  @{
- */
-
-/**
-  \brief  Structure type to access the Memory Protection Unit (MPU).
- */
-typedef struct
-{
-  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
-  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
-  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
-  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
-  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
-} MPU_Type;
-
-/* MPU Type Register Definitions */
-#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
-#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
-
-#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
-#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
-
-#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
-#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
-
-/* MPU Control Register Definitions */
-#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
-#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
-
-#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
-#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
-
-#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
-#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
-
-/* MPU Region Number Register Definitions */
-#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
-#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
-
-/* MPU Region Base Address Register Definitions */
-#define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU RBAR: ADDR Position */
-#define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU RBAR: ADDR Mask */
-
-#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
-#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
-
-#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
-#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
-
-/* MPU Region Attribute and Size Register Definitions */
-#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
-#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
-
-#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
-#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
-
-#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
-#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
-
-#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
-#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
-
-#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
-#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
-
-#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
-#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
-
-#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
-#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
-
-#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
-#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
-
-#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
-#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
-
-#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
-#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
-
-/*@} end of group CMSIS_MPU */
-#endif
-
-
-/**
-  \ingroup  CMSIS_core_register
-  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
-  \brief    SC000 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
-            Therefore they are not covered by the SC000 header file.
-  @{
- */
-/*@} end of group CMSIS_CoreDebug */
-
-
-/**
-  \ingroup    CMSIS_core_register
-  \defgroup   CMSIS_core_bitfield     Core register bit field macros
-  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
-  @{
- */
-
-/**
-  \brief   Mask and shift a bit field value for use in a register bit range.
-  \param[in] field  Name of the register bit field.
-  \param[in] value  Value of the bit field.
-  \return           Masked and shifted value.
-*/
-#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
-
-/**
-  \brief     Mask and shift a register value to extract a bit filed value.
-  \param[in] field  Name of the register bit field.
-  \param[in] value  Value of register.
-  \return           Masked and shifted bit field value.
-*/
-#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
-
-/*@} end of group CMSIS_core_bitfield */
-
-
-/**
-  \ingroup    CMSIS_core_register
-  \defgroup   CMSIS_core_base     Core Definitions
-  \brief      Definitions for base addresses, unions, and structures.
-  @{
- */
-
-/* Memory mapping of SC000 Hardware */
-#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
-#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
-#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
-#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
-
-#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
-#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
-#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
-#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
-
-#if (__MPU_PRESENT == 1U)
-#define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
-#define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
-#endif
-
-/*@} */
-
-
-
-/*******************************************************************************
- *                Hardware Abstraction Layer
-  Core Function Interface contains:
-  - Core NVIC Functions
-  - Core SysTick Functions
-  - Core Register Access Functions
- ******************************************************************************/
-/**
-  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
-*/
-
-
-
-/* ##########################   NVIC functions  #################################### */
-/**
-  \ingroup  CMSIS_Core_FunctionInterface
-  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
-  \brief    Functions that manage interrupts and exceptions via the NVIC.
-  @{
- */
-
-/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
-/* The following MACROS handle generation of the register offset and byte masks */
-#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
-#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
-#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
-
-
-/**
-  \brief   Enable External Interrupt
-  \details Enables a device-specific interrupt in the NVIC interrupt controller.
-  \param [in]      IRQn  External interrupt number. Value cannot be negative.
- */
-__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
-{
-  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
-}
-
-
-/**
-  \brief   Disable External Interrupt
-  \details Disables a device-specific interrupt in the NVIC interrupt controller.
-  \param [in]      IRQn  External interrupt number. Value cannot be negative.
- */
-__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
-{
-  NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
-}
-
-
-/**
-  \brief   Get Pending Interrupt
-  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
-  \param [in]      IRQn  Interrupt number.
-  \return             0  Interrupt status is not pending.
-  \return             1  Interrupt status is pending.
- */
-__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
-{
-  return ((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
-}
-
-
-/**
-  \brief   Set Pending Interrupt
-  \details Sets the pending bit of an external interrupt.
-  \param [in]      IRQn  Interrupt number. Value cannot be negative.
- */
-__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
-{
-  NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
-}
-
-
-/**
-  \brief   Clear Pending Interrupt
-  \details Clears the pending bit of an external interrupt.
-  \param [in]      IRQn  External interrupt number. Value cannot be negative.
- */
-__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
-{
-  NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
-}
-
-
-/**
-  \brief   Set Interrupt Priority
-  \details Sets the priority of an interrupt.
-  \note    The priority cannot be set for every core interrupt.
-  \param [in]      IRQn  Interrupt number.
-  \param [in]  priority  Priority to set.
- */
-__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
-{
-  if ((int32_t)(IRQn) < 0)
-    {
-      SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
-                                  (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
-    }
-  else
-    {
-      NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
-                                  (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
-    }
-}
-
-
-/**
-  \brief   Get Interrupt Priority
-  \details Reads the priority of an interrupt.
-           The interrupt number can be positive to specify an external (device specific) interrupt,
-           or negative to specify an internal (core) interrupt.
-  \param [in]   IRQn  Interrupt number.
-  \return             Interrupt Priority.
-                      Value is aligned automatically to the implemented priority bits of the microcontroller.
- */
-__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
-{
-
-  if ((int32_t)(IRQn) < 0)
-    {
-      return ((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
-    }
-  else
-    {
-      return ((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
-    }
-}
-
-
-/**
-  \brief   System Reset
-  \details Initiates a system reset request to reset the MCU.
- */
-__STATIC_INLINE void NVIC_SystemReset(void)
-{
-  __DSB();                                                          /* Ensure all outstanding memory accesses included
-                                                                       buffered write are completed before reset */
-  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
-                 SCB_AIRCR_SYSRESETREQ_Msk);
-  __DSB();                                                          /* Ensure completion of memory access */
-
-  for (;;)                                                           /* wait until reset */
-    {
-      __NOP();
-    }
-}
-
-/*@} end of CMSIS_Core_NVICFunctions */
-
-
-
-/* ##################################    SysTick function  ############################################ */
-/**
-  \ingroup  CMSIS_Core_FunctionInterface
-  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
-  \brief    Functions that configure the System.
-  @{
- */
-
-#if (__Vendor_SysTickConfig == 0U)
-
-/**
-  \brief   System Tick Configuration
-  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
-           Counter is in free running mode to generate periodic interrupts.
-  \param [in]  ticks  Number of ticks between two interrupts.
-  \return          0  Function succeeded.
-  \return          1  Function failed.
-  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
-           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
-           must contain a vendor-specific implementation of this function.
- */
-__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
-{
-  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
-    {
-      return (1UL);                                                   /* Reload value impossible */
-    }
-
-  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
-  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
-  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
-  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
-                   SysTick_CTRL_TICKINT_Msk   |
-                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
-  return (0UL);                                                     /* Function successful */
-}
-
-#endif
-
-/*@} end of CMSIS_Core_SysTickFunctions */
-
-
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __CORE_SC000_H_DEPENDANT */
-
-#endif /* __CMSIS_GENERIC */
diff --git a/arch/arm/src/nrf52/components/toolchain/cmsis/include/core_sc300.h b/arch/arm/src/nrf52/components/toolchain/cmsis/include/core_sc300.h
deleted file mode 100644
index 9b4140c454..0000000000
--- a/arch/arm/src/nrf52/components/toolchain/cmsis/include/core_sc300.h
+++ /dev/null
@@ -1,1752 +0,0 @@
-/**************************************************************************//**
- * @file     core_sc300.h
- * @brief    CMSIS SC300 Core Peripheral Access Layer Header File
- * @version  V4.30
- * @date     20. October 2015
- ******************************************************************************/
-/* Copyright (c) 2009 - 2015 ARM LIMITED
-
-   All rights reserved.
-   Redistribution and use in source and binary forms, with or without
-   modification, are permitted provided that the following conditions are met:
-   - Redistributions of source code must retain the above copyright
-     notice, this list of conditions and the following disclaimer.
-   - Redistributions in binary form must reproduce the above copyright
-     notice, this list of conditions and the following disclaimer in the
-     documentation and/or other materials provided with the distribution.
-   - Neither the name of ARM nor the names of its contributors may be used
-     to endorse or promote products derived from this software without
-     specific prior written permission.
-   *
-   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
-   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-   POSSIBILITY OF SUCH DAMAGE.
-   ---------------------------------------------------------------------------*/
-
-
-#if   defined ( __ICCARM__ )
-#pragma system_include         /* treat file as system include file for MISRA check */
-#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
-#pragma clang system_header   /* treat file as system include file */
-#endif
-
-#ifndef __CORE_SC300_H_GENERIC
-#define __CORE_SC300_H_GENERIC
-
-#include <stdint.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
-  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
-  CMSIS violates the following MISRA-C:2004 rules:
-
-   \li Required Rule 8.5, object/function definition in header file.<br>
-     Function definitions in header files are used to allow 'inlining'.
-
-   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
-     Unions are used for effective representation of core registers.
-
-   \li Advisory Rule 19.7, Function-like macro defined.<br>
-     Function-like macros are used to allow more efficient code.
- */
-
-
-/*******************************************************************************
- *                 CMSIS definitions
- ******************************************************************************/
-/**
-  \ingroup SC3000
-  @{
- */
-
-/*  CMSIS SC300 definitions */
-#define __SC300_CMSIS_VERSION_MAIN  (0x04U)                                    /*!< [31:16] CMSIS HAL main version */
-#define __SC300_CMSIS_VERSION_SUB   (0x1EU)                                    /*!< [15:0]  CMSIS HAL sub version */
-#define __SC300_CMSIS_VERSION       ((__SC300_CMSIS_VERSION_MAIN << 16U) | \
-                                      __SC300_CMSIS_VERSION_SUB           )    /*!< CMSIS HAL version number */
-
-#define __CORTEX_SC                 (300U)                                     /*!< Cortex secure core */
-
-
-#if   defined ( __CC_ARM )
-#define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
-#define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
-#define __STATIC_INLINE  static __inline
-
-#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
-#define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
-#define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
-#define __STATIC_INLINE  static __inline
-
-#elif defined ( __GNUC__ )
-#define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
-#define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
-#define __STATIC_INLINE  static inline
-
-#elif defined ( __ICCARM__ )
-#define __ASM            __asm                                      /*!< asm keyword for IAR Compiler */
-#define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
-#define __STATIC_INLINE  static inline
-
-#elif defined ( __TMS470__ )
-#define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler */
-#define __STATIC_INLINE  static inline
-
-#elif defined ( __TASKING__ )
-#define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler */
-#define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler */
-#define __STATIC_INLINE  static inline
-
-#elif defined ( __CSMC__ )
-#define __packed
-#define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler */
-#define __INLINE         inline                                    /*!< inline keyword for COSMIC Compiler. Use -pc99 on compile line */
-#define __STATIC_INLINE  static inline
-
-#else
-#error Unknown compiler
-#endif
-
-/** __FPU_USED indicates whether an FPU is used or not.
-    This core does not support an FPU at all
-*/
-#define __FPU_USED       0U
-
-#if defined ( __CC_ARM )
-#if defined __TARGET_FPU_VFP
-#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
-#endif
-
-#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
-#if defined __ARM_PCS_VFP
-#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
-#endif
-
-#elif defined ( __GNUC__ )
-#if defined (__VFP_FP__) && !defined(__SOFTFP__)
-#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
-#endif
-
-#elif defined ( __ICCARM__ )
-#if defined __ARMVFP__
-#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
-#endif
-
-#elif defined ( __TMS470__ )
-#if defined __TI_VFP_SUPPORT__
-#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
-#endif
-
-#elif defined ( __TASKING__ )
-#if defined __FPU_VFP__
-#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
-#endif
-
-#elif defined ( __CSMC__ )
-#if ( __CSMC__ & 0x400U)
-#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
-#endif
-
-#endif
-
-#include "core_cmInstr.h"                /* Core Instruction Access */
-#include "core_cmFunc.h"                 /* Core Function Access */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __CORE_SC300_H_GENERIC */
-
-#ifndef __CMSIS_GENERIC
-
-#ifndef __CORE_SC300_H_DEPENDANT
-#define __CORE_SC300_H_DEPENDANT
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* check device defines and use defaults */
-#if defined __CHECK_DEVICE_DEFINES
-#ifndef __SC300_REV
-#define __SC300_REV               0x0000U
-#warning "__SC300_REV not defined in device header file; using default!"
-#endif
-
-#ifndef __MPU_PRESENT
-#define __MPU_PRESENT             0U
-#warning "__MPU_PRESENT not defined in device header file; using default!"
-#endif
-
-#ifndef __NVIC_PRIO_BITS
-#define __NVIC_PRIO_BITS          4U
-#warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
-#endif
-
-#ifndef __Vendor_SysTickConfig
-#define __Vendor_SysTickConfig    0U
-#warning "__Vendor_SysTickConfig not defined in device header file; using default!"
-#endif
-#endif
-
-/* IO definitions (access restrictions to peripheral registers) */
-/**
-    \defgroup CMSIS_glob_defs CMSIS Global Defines
-
-    <strong>IO Type Qualifiers</strong> are used
-    \li to specify the access to peripheral variables.
-    \li for automatic generation of peripheral register debug information.
-*/
-#ifdef __cplusplus
-#define   __I     volatile             /*!< Defines 'read only' permissions */
-#else
-#define   __I     volatile const       /*!< Defines 'read only' permissions */
-#endif
-#define     __O     volatile             /*!< Defines 'write only' permissions */
-#define     __IO    volatile             /*!< Defines 'read / write' permissions */
-
-/* following defines should be used for structure members */
-#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
-#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
-#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
-
-/*@} end of group SC300 */
-
-
-
-/*******************************************************************************
- *                 Register Abstraction
-  Core Register contain:
-  - Core Register
-  - Core NVIC Register
-  - Core SCB Register
-  - Core SysTick Register
-  - Core Debug Register
-  - Core MPU Register
- ******************************************************************************/
-/**
-  \defgroup CMSIS_core_register Defines and Type Definitions
-  \brief Type definitions and defines for Cortex-M processor based devices.
-*/
-
-/**
-  \ingroup    CMSIS_core_register
-  \defgroup   CMSIS_CORE  Status and Control Registers
-  \brief      Core Register type definitions.
-  @{
- */
-
-/**
-  \brief  Union type to access the Application Program Status Register (APSR).
- */
-typedef union
-{
-  struct
-  {
-    uint32_t _reserved0: 27;             /*!< bit:  0..26  Reserved */
-    uint32_t Q: 1;                       /*!< bit:     27  Saturation condition flag */
-    uint32_t V: 1;                       /*!< bit:     28  Overflow condition code flag */
-    uint32_t C: 1;                       /*!< bit:     29  Carry condition code flag */
-    uint32_t Z: 1;                       /*!< bit:     30  Zero condition code flag */
-    uint32_t N: 1;                       /*!< bit:     31  Negative condition code flag */
-  } b;                                   /*!< Structure used for bit  access */
-  uint32_t w;                            /*!< Type      used for word access */
-} APSR_Type;
-
-/* APSR Register Definitions */
-#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
-#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
-
-#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
-#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
-
-#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
-#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
-
-#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
-#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
-
-#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
-#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
-
-
-/**
-  \brief  Union type to access the Interrupt Program Status Register (IPSR).
- */
-typedef union
-{
-  struct
-  {
-    uint32_t ISR: 9;                     /*!< bit:  0.. 8  Exception number */
-    uint32_t _reserved0: 23;             /*!< bit:  9..31  Reserved */
-  } b;                                   /*!< Structure used for bit  access */
-  uint32_t w;                            /*!< Type      used for word access */
-} IPSR_Type;
-
-/* IPSR Register Definitions */
-#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
-#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
-
-
-/**
-  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
- */
-typedef union
-{
-  struct
-  {
-    uint32_t ISR: 9;                     /*!< bit:  0.. 8  Exception number */
-    uint32_t _reserved0: 15;             /*!< bit:  9..23  Reserved */
-    uint32_t T: 1;                       /*!< bit:     24  Thumb bit        (read 0) */
-    uint32_t IT: 2;                      /*!< bit: 25..26  saved IT state   (read 0) */
-    uint32_t Q: 1;                       /*!< bit:     27  Saturation condition flag */
-    uint32_t V: 1;                       /*!< bit:     28  Overflow condition code flag */
-    uint32_t C: 1;                       /*!< bit:     29  Carry condition code flag */
-    uint32_t Z: 1;                       /*!< bit:     30  Zero condition code flag */
-    uint32_t N: 1;                       /*!< bit:     31  Negative condition code flag */
-  } b;                                   /*!< Structure used for bit  access */
-  uint32_t w;                            /*!< Type      used for word access */
-} xPSR_Type;
-
-/* xPSR Register Definitions */
-#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
-#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
-
-#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
-#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
-
-#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
-#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
-
-#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
-#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
-
-#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
-#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
-
-#define xPSR_IT_Pos                        25U                                            /*!< xPSR: IT Position */
-#define xPSR_IT_Msk                        (3UL << xPSR_IT_Pos)                           /*!< xPSR: IT Mask */
-
-#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
-#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
-
-#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
-#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
-
-
-/**
-  \brief  Union type to access the Control Registers (CONTROL).
- */
-typedef union
-{
-  struct
-  {
-    uint32_t nPRIV: 1;                   /*!< bit:      0  Execution privilege in Thread mode */
-    uint32_t SPSEL: 1;                   /*!< bit:      1  Stack to be used */
-    uint32_t _reserved1: 30;             /*!< bit:  2..31  Reserved */
-  } b;                                   /*!< Structure used for bit  access */
-  uint32_t w;                            /*!< Type      used for word access */
-} CONTROL_Type;
-
-/* CONTROL Register Definitions */
-#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
-#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
-
-#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
-#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
-
-/*@} end of group CMSIS_CORE */
-
-
-/**
-  \ingroup    CMSIS_core_register
-  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
-  \brief      Type definitions for the NVIC Registers
-  @{
- */
-
-/**
-  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
- */
-typedef struct
-{
-  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
-  uint32_t RESERVED0[24U];
-  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
-  uint32_t RSERVED1[24U];
-  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
-  uint32_t RESERVED2[24U];
-  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
-  uint32_t RESERVED3[24U];
-  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
-  uint32_t RESERVED4[56U];
-  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
-  uint32_t RESERVED5[644U];
-  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
-}  NVIC_Type;
-
-/* Software Triggered Interrupt Register Definitions */
-#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
-#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
-
-/*@} end of group CMSIS_NVIC */
-
-
-/**
-  \ingroup  CMSIS_core_register
-  \defgroup CMSIS_SCB     System Control Block (SCB)
-  \brief    Type definitions for the System Control Block Registers
-  @{
- */
-
-/**
-  \brief  Structure type to access the System Control Block (SCB).
- */
-typedef struct
-{
-  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
-  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
-  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
-  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
-  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
-  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
-  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
-  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
-  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
-  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
-  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
-  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
-  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
-  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
-  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
-  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
-  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
-  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
-  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
-  uint32_t RESERVED0[5U];
-  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
-  uint32_t RESERVED1[129U];
-  __IOM uint32_t SFCR;                   /*!< Offset: 0x290 (R/W)  Security Features Control Register */
-} SCB_Type;
-
-/* SCB CPUID Register Definitions */
-#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
-#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
-
-#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
-#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
-
-#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
-#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
-
-#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
-#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
-
-#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
-#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
-
-/* SCB Interrupt Control State Register Definitions */
-#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
-#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
-
-#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
-#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
-
-#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
-#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
-
-#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
-#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
-
-#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
-#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
-
-#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
-#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
-
-#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
-#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
-
-#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
-#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
-
-#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
-#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
-
-#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
-#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
-
-/* SCB Vector Table Offset Register Definitions */
-#define SCB_VTOR_TBLBASE_Pos               29U                                            /*!< SCB VTOR: TBLBASE Position */
-#define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB VTOR: TBLBASE Mask */
-
-#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
-#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
-
-/* SCB Application Interrupt and Reset Control Register Definitions */
-#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
-#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
-
-#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
-#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
-
-#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
-#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
-
-#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
-#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
-
-#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
-#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
-
-#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
-#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
-
-#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
-#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
-
-/* SCB System Control Register Definitions */
-#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
-#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
-
-#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
-#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
-
-#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
-#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
-
-/* SCB Configuration Control Register Definitions */
-#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
-#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
-
-#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
-#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
-
-#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
-#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
-
-#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
-#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
-
-#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
-#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
-
-#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
-#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
-
-/* SCB System Handler Control and State Register Definitions */
-#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
-#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
-
-#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
-#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
-
-#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
-#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
-
-#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
-#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
-
-#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
-#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
-
-#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
-#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
-
-#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
-#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
-
-#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
-#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
-
-#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
-#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
-
-#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
-#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
-
-#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
-#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
-
-#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
-#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
-
-#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
-#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
-
-#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
-#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
-
-/* SCB Configurable Fault Status Register Definitions */
-#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
-#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
-
-#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
-#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
-
-#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
-#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
-
-/* SCB Hard Fault Status Register Definitions */
-#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
-#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
-
-#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
-#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
-
-#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
-#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
-
-/* SCB Debug Fault Status Register Definitions */
-#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
-#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
-
-#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
-#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
-
-#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
-#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
-
-#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
-#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
-
-#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
-#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
-
-/*@} end of group CMSIS_SCB */
-
-
-/**
-  \ingroup  CMSIS_core_register
-  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
-  \brief    Type definitions for the System Control and ID Register not in the SCB
-  @{
- */
-
-/**
-  \brief  Structure type to access the System Control and ID Register not in the SCB.
- */
-typedef struct
-{
-  uint32_t RESERVED0[1U];
-  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
-  uint32_t RESERVED1[1U];
-} SCnSCB_Type;
-
-/* Interrupt Controller Type Register Definitions */
-#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
-#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
-
-/*@} end of group CMSIS_SCnotSCB */
-
-
-/**
-  \ingroup  CMSIS_core_register
-  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
-  \brief    Type definitions for the System Timer Registers.
-  @{
- */
-
-/**
-  \brief  Structure type to access the System Timer (SysTick).
- */
-typedef struct
-{
-  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
-  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
-  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
-  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
-} SysTick_Type;
-
-/* SysTick Control / Status Register Definitions */
-#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
-#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
-
-#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
-#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
-
-#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
-#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
-
-#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
-#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
-
-/* SysTick Reload Register Definitions */
-#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
-#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
-
-/* SysTick Current Register Definitions */
-#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
-#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
-
-/* SysTick Calibration Register Definitions */
-#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
-#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
-
-#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
-#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
-
-#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
-#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
-
-/*@} end of group CMSIS_SysTick */
-
-
-/**
-  \ingroup  CMSIS_core_register
-  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
-  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
-  @{
- */
-
-/**
-  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
- */
-typedef struct
-{
-  __OM  union
-  {
-    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
-    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
-    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
-  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
-  uint32_t RESERVED0[864U];
-  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
-  uint32_t RESERVED1[15U];
-  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
-  uint32_t RESERVED2[15U];
-  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
-  uint32_t RESERVED3[29U];
-  __OM  uint32_t IWR;                    /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register */
-  __IM  uint32_t IRR;                    /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register */
-  __IOM uint32_t IMCR;                   /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register */
-  uint32_t RESERVED4[43U];
-  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
-  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
-  uint32_t RESERVED5[6U];
-  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
-  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
-  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
-  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
-  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
-  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
-  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
-  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
-  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
-  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
-  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
-  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
-} ITM_Type;
-
-/* ITM Trace Privilege Register Definitions */
-#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
-#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
-
-/* ITM Trace Control Register Definitions */
-#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
-#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
-
-#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
-#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
-
-#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
-#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
-
-#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
-#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
-
-#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
-#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
-
-#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
-#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
-
-#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
-#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
-
-#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
-#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
-
-#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
-#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
-
-/* ITM Integration Write Register Definitions */
-#define ITM_IWR_ATVALIDM_Pos                0U                                            /*!< ITM IWR: ATVALIDM Position */
-#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
-
-/* ITM Integration Read Register Definitions */
-#define ITM_IRR_ATREADYM_Pos                0U                                            /*!< ITM IRR: ATREADYM Position */
-#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
-
-/* ITM Integration Mode Control Register Definitions */
-#define ITM_IMCR_INTEGRATION_Pos            0U                                            /*!< ITM IMCR: INTEGRATION Position */
-#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
-
-/* ITM Lock Status Register Definitions */
-#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
-#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
-
-#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
-#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
-
-#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
-#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
-
-/*@}*/ /* end of group CMSIS_ITM */
-
-
-/**
-  \ingroup  CMSIS_core_register
-  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
-  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
-  @{
- */
-
-/**
-  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
- */
-typedef struct
-{
-  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
-  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
-  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
-  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
-  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
-  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
-  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
-  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
-  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
-  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
-  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
-  uint32_t RESERVED0[1U];
-  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
-  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
-  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
-  uint32_t RESERVED1[1U];
-  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
-  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
-  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
-  uint32_t RESERVED2[1U];
-  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
-  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
-  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
-} DWT_Type;
-
-/* DWT Control Register Definitions */
-#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
-#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
-
-#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
-#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
-
-#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
-#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
-
-#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
-#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
-
-#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
-#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
-
-#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
-#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
-
-#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
-#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
-
-#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
-#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
-
-#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
-#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
-
-#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
-#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
-
-#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
-#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
-
-#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
-#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
-
-#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
-#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
-
-#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
-#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
-
-#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
-#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
-
-#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
-#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
-
-#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
-#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
-
-#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
-#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
-
-/* DWT CPI Count Register Definitions */
-#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
-#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
-
-/* DWT Exception Overhead Count Register Definitions */
-#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
-#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
-
-/* DWT Sleep Count Register Definitions */
-#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
-#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
-
-/* DWT LSU Count Register Definitions */
-#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
-#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
-
-/* DWT Folded-instruction Count Register Definitions */
-#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
-#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
-
-/* DWT Comparator Mask Register Definitions */
-#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
-#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
-
-/* DWT Comparator Function Register Definitions */
-#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
-#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
-
-#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
-#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
-
-#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
-#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
-
-#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
-#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
-
-#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
-#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
-
-#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
-#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
-
-#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
-#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
-
-#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
-#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
-
-#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
-#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
-
-/*@}*/ /* end of group CMSIS_DWT */
-
-
-/**
-  \ingroup  CMSIS_core_register
-  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
-  \brief    Type definitions for the Trace Port Interface (TPI)
-  @{
- */
-
-/**
-  \brief  Structure type to access the Trace Port Interface Register (TPI).
- */
-typedef struct
-{
-  __IOM uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
-  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
-  uint32_t RESERVED0[2U];
-  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
-  uint32_t RESERVED1[55U];
-  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
-  uint32_t RESERVED2[131U];
-  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
-  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
-  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
-  uint32_t RESERVED3[759U];
-  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER */
-  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
-  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
-  uint32_t RESERVED4[1U];
-  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
-  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
-  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
-  uint32_t RESERVED5[39U];
-  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
-  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
-  uint32_t RESERVED7[8U];
-  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
-  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
-} TPI_Type;
-
-/* TPI Asynchronous Clock Prescaler Register Definitions */
-#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
-#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
-
-/* TPI Selected Pin Protocol Register Definitions */
-#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
-#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
-
-/* TPI Formatter and Flush Status Register Definitions */
-#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
-#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
-
-#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
-#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
-
-#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
-#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
-
-#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
-#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
-
-/* TPI Formatter and Flush Control Register Definitions */
-#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
-#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
-
-#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
-#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
-
-/* TPI TRIGGER Register Definitions */
-#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
-#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
-
-/* TPI Integration ETM Data Register Definitions (FIFO0) */
-#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
-#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
-
-#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
-#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
-
-#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
-#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
-
-#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
-#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
-
-#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
-#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
-
-#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
-#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
-
-#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
-#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
-
-/* TPI ITATBCTR2 Register Definitions */
-#define TPI_ITATBCTR2_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR2: ATREADY Position */
-#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
-
-/* TPI Integration ITM Data Register Definitions (FIFO1) */
-#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
-#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
-
-#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
-#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
-
-#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
-#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
-
-#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
-#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
-
-#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
-#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
-
-#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
-#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
-
-#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
-#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
-
-/* TPI ITATBCTR0 Register Definitions */
-#define TPI_ITATBCTR0_ATREADY_Pos           0U                                         /*!< TPI ITATBCTR0: ATREADY Position */
-#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
-
-/* TPI Integration Mode Control Register Definitions */
-#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
-#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
-
-/* TPI DEVID Register Definitions */
-#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
-#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
-
-#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
-#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
-
-#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
-#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
-
-#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
-#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
-
-#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
-#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
-
-#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
-#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
-
-/* TPI DEVTYPE Register Definitions */
-#define TPI_DEVTYPE_MajorType_Pos           4U                                         /*!< TPI DEVTYPE: MajorType Position */
-#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
-
-#define TPI_DEVTYPE_SubType_Pos             0U                                         /*!< TPI DEVTYPE: SubType Position */
-#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
-
-/*@}*/ /* end of group CMSIS_TPI */
-
-
-#if (__MPU_PRESENT == 1U)
-/**
-  \ingroup  CMSIS_core_register
-  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
-  \brief    Type definitions for the Memory Protection Unit (MPU)
-  @{
- */
-
-/**
-  \brief  Structure type to access the Memory Protection Unit (MPU).
- */
-typedef struct
-{
-  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
-  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
-  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
-  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
-  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
-  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
-  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
-  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
-  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
-  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
-  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
-} MPU_Type;
-
-/* MPU Type Register Definitions */
-#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
-#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
-
-#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
-#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
-
-#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
-#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
-
-/* MPU Control Register Definitions */
-#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
-#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
-
-#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
-#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
-
-#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
-#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
-
-/* MPU Region Number Register Definitions */
-#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
-#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
-
-/* MPU Region Base Address Register Definitions */
-#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
-#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
-
-#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
-#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
-
-#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
-#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
-
-/* MPU Region Attribute and Size Register Definitions */
-#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
-#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
-
-#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
-#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
-
-#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
-#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
-
-#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
-#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
-
-#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
-#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
-
-#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
-#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
-
-#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
-#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
-
-#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
-#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
-
-#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
-#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
-
-#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
-#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
-
-/*@} end of group CMSIS_MPU */
-#endif
-
-
-/**
-  \ingroup  CMSIS_core_register
-  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
-  \brief    Type definitions for the Core Debug Registers
-  @{
- */
-
-/**
-  \brief  Structure type to access the Core Debug Register (CoreDebug).
- */
-typedef struct
-{
-  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
-  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
-  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
-  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
-} CoreDebug_Type;
-
-/* Debug Halting Control and Status Register Definitions */
-#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
-#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
-
-#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
-#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
-
-#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
-#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
-
-#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
-#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
-
-#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
-#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
-
-#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
-#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
-
-#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
-#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
-
-#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
-#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
-
-#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
-#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
-
-#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
-#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
-
-#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
-#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
-
-#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
-#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
-
-/* Debug Core Register Selector Register Definitions */
-#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
-#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
-
-#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
-#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
-
-/* Debug Exception and Monitor Control Register Definitions */
-#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
-#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
-
-#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
-#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
-
-#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
-#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
-
-#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
-#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
-
-#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
-#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
-
-#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
-#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
-
-#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
-#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
-
-#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
-#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
-
-#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
-#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
-
-#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
-#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
-
-#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
-#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
-
-#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
-#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
-
-#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
-#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
-
-/*@} end of group CMSIS_CoreDebug */
-
-
-/**
-  \ingroup    CMSIS_core_register
-  \defgroup   CMSIS_core_bitfield     Core register bit field macros
-  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
-  @{
- */
-
-/**
-  \brief   Mask and shift a bit field value for use in a register bit range.
-  \param[in] field  Name of the register bit field.
-  \param[in] value  Value of the bit field.
-  \return           Masked and shifted value.
-*/
-#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
-
-/**
-  \brief     Mask and shift a register value to extract a bit filed value.
-  \param[in] field  Name of the register bit field.
-  \param[in] value  Value of register.
-  \return           Masked and shifted bit field value.
-*/
-#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
-
-/*@} end of group CMSIS_core_bitfield */
-
-
-/**
-  \ingroup    CMSIS_core_register
-  \defgroup   CMSIS_core_base     Core Definitions
-  \brief      Definitions for base addresses, unions, and structures.
-  @{
- */
-
-/* Memory mapping of Cortex-M3 Hardware */
-#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
-#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
-#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
-#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
-#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
-#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
-#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
-#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
-
-#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
-#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
-#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
-#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
-#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
-#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
-#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
-#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
-
-#if (__MPU_PRESENT == 1U)
-#define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
-#define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
-#endif
-
-/*@} */
-
-
-
-/*******************************************************************************
- *                Hardware Abstraction Layer
-  Core Function Interface contains:
-  - Core NVIC Functions
-  - Core SysTick Functions
-  - Core Debug Functions
-  - Core Register Access Functions
- ******************************************************************************/
-/**
-  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
-*/
-
-
-
-/* ##########################   NVIC functions  #################################### */
-/**
-  \ingroup  CMSIS_Core_FunctionInterface
-  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
-  \brief    Functions that manage interrupts and exceptions via the NVIC.
-  @{
- */
-
-/**
-  \brief   Set Priority Grouping
-  \details Sets the priority grouping field using the required unlock sequence.
-           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
-           Only values from 0..7 are used.
-           In case of a conflict between priority grouping and available
-           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
-  \param [in]      PriorityGroup  Priority grouping field.
- */
-__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
-{
-  uint32_t reg_value;
-  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
-
-  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
-  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
-  reg_value  =  (reg_value                                   |
-                 ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
-                 (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
-  SCB->AIRCR =  reg_value;
-}
-
-
-/**
-  \brief   Get Priority Grouping
-  \details Reads the priority grouping field from the NVIC Interrupt Controller.
-  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
- */
-__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
-{
-  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
-}
-
-
-/**
-  \brief   Enable External Interrupt
-  \details Enables a device-specific interrupt in the NVIC interrupt controller.
-  \param [in]      IRQn  External interrupt number. Value cannot be negative.
- */
-__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
-{
-  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
-}
-
-
-/**
-  \brief   Disable External Interrupt
-  \details Disables a device-specific interrupt in the NVIC interrupt controller.
-  \param [in]      IRQn  External interrupt number. Value cannot be negative.
- */
-__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
-{
-  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
-}
-
-
-/**
-  \brief   Get Pending Interrupt
-  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
-  \param [in]      IRQn  Interrupt number.
-  \return             0  Interrupt status is not pending.
-  \return             1  Interrupt status is pending.
- */
-__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
-{
-  return ((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL :
-                     0UL));
-}
-
-
-/**
-  \brief   Set Pending Interrupt
-  \details Sets the pending bit of an external interrupt.
-  \param [in]      IRQn  Interrupt number. Value cannot be negative.
- */
-__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
-{
-  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
-}
-
-
-/**
-  \brief   Clear Pending Interrupt
-  \details Clears the pending bit of an external interrupt.
-  \param [in]      IRQn  External interrupt number. Value cannot be negative.
- */
-__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
-{
-  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
-}
-
-
-/**
-  \brief   Get Active Interrupt
-  \details Reads the active register in NVIC and returns the active bit.
-  \param [in]      IRQn  Interrupt number.
-  \return             0  Interrupt status is not active.
-  \return             1  Interrupt status is active.
- */
-__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
-{
-  return ((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL :
-                     0UL));
-}
-
-
-/**
-  \brief   Set Interrupt Priority
-  \details Sets the priority of an interrupt.
-  \note    The priority cannot be set for every core interrupt.
-  \param [in]      IRQn  Interrupt number.
-  \param [in]  priority  Priority to set.
- */
-__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
-{
-  if ((int32_t)(IRQn) < 0)
-    {
-      SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL) - 4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
-    }
-  else
-    {
-      NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
-    }
-}
-
-
-/**
-  \brief   Get Interrupt Priority
-  \details Reads the priority of an interrupt.
-           The interrupt number can be positive to specify an external (device specific) interrupt,
-           or negative to specify an internal (core) interrupt.
-  \param [in]   IRQn  Interrupt number.
-  \return             Interrupt Priority.
-                      Value is aligned automatically to the implemented priority bits of the microcontroller.
- */
-__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
-{
-
-  if ((int32_t)(IRQn) < 0)
-    {
-      return (((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL) - 4UL] >> (8U - __NVIC_PRIO_BITS)));
-    }
-  else
-    {
-      return (((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
-    }
-}
-
-
-/**
-  \brief   Encode Priority
-  \details Encodes the priority for an interrupt with the given priority group,
-           preemptive priority value, and subpriority value.
-           In case of a conflict between priority grouping and available
-           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
-  \param [in]     PriorityGroup  Used priority group.
-  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
-  \param [in]       SubPriority  Subpriority value (starting from 0).
-  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
- */
-__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
-{
-  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
-  uint32_t PreemptPriorityBits;
-  uint32_t SubPriorityBits;
-
-  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(
-                          7UL - PriorityGroupTmp);
-  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((
-                          PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
-
-  return (
-           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
-           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
-         );
-}
-
-
-/**
-  \brief   Decode Priority
-  \details Decodes an interrupt priority value with a given priority group to
-           preemptive priority value and subpriority value.
-           In case of a conflict between priority grouping and available
-           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
-  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
-  \param [in]     PriorityGroup  Used priority group.
-  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
-  \param [out]     pSubPriority  Subpriority value (starting from 0).
- */
-__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t * const pPreemptPriority,
-                                          uint32_t * const pSubPriority)
-{
-  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
-  uint32_t PreemptPriorityBits;
-  uint32_t SubPriorityBits;
-
-  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(
-                          7UL - PriorityGroupTmp);
-  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((
-                          PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
-
-  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
-  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
-}
-
-
-/**
-  \brief   System Reset
-  \details Initiates a system reset request to reset the MCU.
- */
-__STATIC_INLINE void NVIC_SystemReset(void)
-{
-  __DSB();                                                          /* Ensure all outstanding memory accesses included
-                                                                       buffered write are completed before reset */
-  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
-                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
-                           SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
-  __DSB();                                                          /* Ensure completion of memory access */
-
-  for (;;)                                                           /* wait until reset */
-    {
-      __NOP();
-    }
-}
-
-/*@} end of CMSIS_Core_NVICFunctions */
-
-
-
-/* ##################################    SysTick function  ############################################ */
-/**
-  \ingroup  CMSIS_Core_FunctionInterface
-  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
-  \brief    Functions that configure the System.
-  @{
- */
-
-#if (__Vendor_SysTickConfig == 0U)
-
-/**
-  \brief   System Tick Configuration
-  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
-           Counter is in free running mode to generate periodic interrupts.
-  \param [in]  ticks  Number of ticks between two interrupts.
-  \return          0  Function succeeded.
-  \return          1  Function failed.
-  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
-           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
-           must contain a vendor-specific implementation of this function.
- */
-__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
-{
-  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
-    {
-      return (1UL);                                                   /* Reload value impossible */
-    }
-
-  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
-  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
-  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
-  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
-                   SysTick_CTRL_TICKINT_Msk   |
-                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
-  return (0UL);                                                     /* Function successful */
-}
-
-#endif
-
-/*@} end of CMSIS_Core_SysTickFunctions */
-
-
-
-/* ##################################### Debug In/Output function ########################################### */
-/**
-  \ingroup  CMSIS_Core_FunctionInterface
-  \defgroup CMSIS_core_DebugFunctions ITM Functions
-  \brief    Functions that access the ITM debug interface.
-  @{
- */
-
-extern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters. */
-#define                 ITM_RXBUFFER_EMPTY   0x5AA55AA5U /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
-
-
-/**
-  \brief   ITM Send Character
-  \details Transmits a character via the ITM channel 0, and
-           \li Just returns when no debugger is connected that has booked the output.
-           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
-  \param [in]     ch  Character to transmit.
-  \returns            Character to transmit.
- */
-__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
-{
-  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
-      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
-    {
-      while (ITM->PORT[0U].u32 == 0UL)
-        {
-          __NOP();
-        }
-      ITM->PORT[0U].u8 = (uint8_t)ch;
-    }
-  return (ch);
-}
-
-
-/**
-  \brief   ITM Receive Character
-  \details Inputs a character via the external variable \ref ITM_RxBuffer.
-  \return             Received character.
-  \return         -1  No character pending.
- */
-__STATIC_INLINE int32_t ITM_ReceiveChar (void)
-{
-  int32_t ch = -1;                           /* no character available */
-
-  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
-    {
-      ch = ITM_RxBuffer;
-      ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
-    }
-
-  return (ch);
-}
-
-
-/**
-  \brief   ITM Check Character
-  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
-  \return          0  No character available.
-  \return          1  Character available.
- */
-__STATIC_INLINE int32_t ITM_CheckChar (void)
-{
-
-  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
-    {
-      return (0);                              /* no character available */
-    }
-  else
-    {
-      return (1);                              /*    character available */
-    }
-}
-
-/*@} end of CMSIS_core_DebugFunctions */
-
-
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __CORE_SC300_H_DEPENDANT */
-
-#endif /* __CMSIS_GENERIC */
diff --git a/arch/arm/src/nrf52/nrf52_adc.c b/arch/arm/src/nrf52/nrf52_adc.c
index 891d1c6e68..066d029639 100644
--- a/arch/arm/src/nrf52/nrf52_adc.c
+++ b/arch/arm/src/nrf52/nrf52_adc.c
@@ -64,9 +64,8 @@
 #include "up_arch.h"
 
 #include "chip.h"
-#include "nrf52.h"
+#include "nrf.h"
 #include "nrf_drv_common.h"
-#include "nrf52_bitfields.h"
 #include "nrf_saadc.h"
 #include "nrf52_adc.h"
 
diff --git a/arch/arm/src/nrf52/nrf52_exti.h b/arch/arm/src/nrf52/nrf52_exti.h
deleted file mode 100644
index c91244e6b6..0000000000
--- a/arch/arm/src/nrf52/nrf52_exti.h
+++ /dev/null
@@ -1,145 +0,0 @@
-/************************************************************************************
- * arch/arm/src/nrf52/nrf52_exti.h
- *
- *   Copyright (C) 2009, 2012, 2015, 2017 Gregory Nutt. All rights reserved.
- *   Author: Gregory Nutt <gnutt@nuttx.org>
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ************************************************************************************/
-
-#ifndef __ARCH_ARM_SRC_NRF52_NRF52_EXTI_H
-#define __ARCH_ARM_SRC_NRF52_NRF52_EXTI_H
-
-/************************************************************************************
- * Included Files
- ************************************************************************************/
-
-#include <nuttx/config.h>
-
-#include <nuttx/irq.h>
-
-#include "chip.h"
-#include "chip/nrf52_exti.h"
-
-/************************************************************************************
- * Public Data
- ************************************************************************************/
-
-#ifndef __ASSEMBLY__
-
-#undef EXTERN
-#if defined(__cplusplus)
-#define EXTERN extern "C"
-extern "C"
-{
-#else
-#define EXTERN extern
-#endif
-
-/************************************************************************************
- * Public Function Prototypes
- ************************************************************************************/
-
-/************************************************************************************
- * Name: nrf52_gpiosetevent
- *
- * Description:
- *   Sets/clears GPIO based event and interrupt triggers.
- *
- * Input Parameters:
- *  pinset      - GPIO pin configuration
- *  risingedge  - Enables interrupt on rising edges
- *  fallingedge - Enables interrupt on falling edges
- *  event       - Generate event when set
- *  func        - When non-NULL, generate interrupt
- *  arg         - Argument passed to the interrupt callback
- *
- * Returned Value:
- *  Zero (OK) is returned on success, otherwise a negated errno value is returned
- *  to indicate the nature of the failure.
- *
- ************************************************************************************/
-
-int nrf52_gpiosetevent(uint32_t pinset, bool risingedge, bool fallingedge,
-                       bool event, xcpt_t func, void *arg);
-
-/****************************************************************************
- * Name: nrf52_exti_alarm
- *
- * Description:
- *   Sets/clears EXTI alarm interrupt.
- *
- * Parameters:
- *  - rising/falling edge: enables interrupt on rising/falling edges
- *  - event:  generate event when set
- *  - func:   when non-NULL, generate interrupt
- *  - arg:    Argument passed to the interrupt callback
- *
- * Returns:
- *   Zero (OK) on success; a negated errno value on failure indicating the
- *   nature of the failure.
- *
- ****************************************************************************/
-
-#ifdef CONFIG_RTC_ALARM
-int nrf52_exti_alarm(bool risingedge, bool fallingedge, bool event,
-                     xcpt_t func, void *arg);
-#endif
-
-/****************************************************************************
- * Name: nrf52_exti_comp
- *
- * Description:
- *   Sets/clears comparator based events and interrupt triggers.
- *
- * Parameters:
- *  - cmp: comparator
- *  - rising/falling edge: enables interrupt on rising/falling edget
- *  - event:  generate event when set
- *  - func:   when non-NULL, generate interrupt
- *  - arg:    Argument passed to the interrupt callback
- *
- * Returns:
- *   Zero (OK) returned on success; a negated errno value is returned on
- *   failure.
- *
- ****************************************************************************/
-
-#ifdef CONFIG_NRF52_COMP
-int nrf52_exti_comp(int cmp, bool risingedge, bool fallingedge,
-                    bool event, xcpt_t func, void *arg);
-#endif
-
-#undef EXTERN
-#if defined(__cplusplus)
-}
-#endif
-
-#endif /* __ASSEMBLY__ */
-#endif /* __ARCH_ARM_SRC_NRF52_NRF52_EXTI_H */
diff --git a/arch/arm/src/nrf52/nrf52_exti_alarm.c b/arch/arm/src/nrf52/nrf52_exti_alarm.c
deleted file mode 100644
index 38fe16e05a..0000000000
--- a/arch/arm/src/nrf52/nrf52_exti_alarm.c
+++ /dev/null
@@ -1,159 +0,0 @@
-/****************************************************************************
- * arch/arm/src/stm32l4/stm32l4_exti_alarm.c
- *
- *   Copyright (C) 2009, 2012, 2017 Gregory Nutt. All rights reserved.
- *   Author: Gregory Nutt <gnutt@nuttx.org>
- *           Diego Sanchez <dsanchez@nx-engineering.com>
- *           dev@ziggurat29.com (adaptation to stm32l4)
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ****************************************************************************/
-
-/****************************************************************************
- * Included Files
- ****************************************************************************/
-
-#include <nuttx/config.h>
-#include <nuttx/irq.h>
-#include <nuttx/arch.h>
-
-#include <stdint.h>
-#include <stdbool.h>
-#include <errno.h>
-
-#include <arch/irq.h>
-
-#include "up_arch.h"
-#include "chip.h"
-#include "nrf52_gpio.h"
-#include "nrf52_exti.h"
-
-/****************************************************************************
- * Private Data
- ****************************************************************************/
-
-/* Interrupt handlers attached to the ALARM EXTI */
-
-static xcpt_t g_alarm_callback;
-static void  *g_callback_arg;
-
-/****************************************************************************
- * Private Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_exti_alarm_isr
- *
- * Description:
- *   EXTI ALARM interrupt service routine/dispatcher
- *
- ****************************************************************************/
-
-static int nrf52_exti_alarm_isr(int irq, void *context, FAR void *arg)
-{
-  int ret = OK;
-
-  /*
-  // Dispatch the interrupt to the handler //
-
-  if (g_alarm_callback != NULL)
-    {
-      ret = g_alarm_callback(irq, context, g_callback_arg);
-    }
-
-  // Clear the pending EXTI interrupt //
-
-  putreg32(EXTI1_RTC_ALARM, STM32L4_EXTI1_PR);*/
-
-  return ret;
-}
-
-/****************************************************************************
- * Public Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_exti_alarm
- *
- * Description:
- *   Sets/clears EXTI alarm interrupt.
- *
- * Parameters:
- *  - rising/falling edge: enables interrupt on rising/falling edget
- *  - event:  generate event when set
- *  - func:   when non-NULL, generate interrupt
- *
- * Returns:
- *   Zero (OK) on success; a negated errno value on failure indicating the
- *   nature of the failure.
- *
- ****************************************************************************/
-
-int nrf52_exti_alarm(bool risingedge, bool fallingedge, bool event,
-                     xcpt_t func, void *arg)
-{
-  /* Get the previous GPIO IRQ handler; Save the new IRQ handler. */
-
-  g_alarm_callback = func;
-  g_callback_arg   = arg;
-
-  /* Install external interrupt handlers (if not already attached) */
-
-  /* if (func)
-     {
-       irq_attach(STM32L4_IRQ_RTCALRM, stm32l4_exti_alarm_isr, NULL);
-       up_enable_irq(STM32L4_IRQ_RTCALRM);
-     }
-   else
-     {
-       up_disable_irq(STM32L4_IRQ_RTCALRM);
-     }
-
-   // Configure rising/falling edges //
-
-   modifyreg32(STM32L4_EXTI1_RTSR,
-               risingedge ? 0 : EXTI1_RTC_ALARM,
-               risingedge ? EXTI1_RTC_ALARM : 0);
-   modifyreg32(STM32L4_EXTI1_FTSR,
-               fallingedge ? 0 : EXTI1_RTC_ALARM,
-               fallingedge ? EXTI1_RTC_ALARM : 0);
-
-   // Enable Events and Interrupts //
-
-   modifyreg32(STM32L4_EXTI1_EMR,
-               event ? 0 : EXTI1_RTC_ALARM,
-               event ? EXTI1_RTC_ALARM : 0);
-   modifyreg32(STM32L4_EXTI1_IMR,
-               func ? 0 : EXTI1_RTC_ALARM,
-               func ? EXTI1_RTC_ALARM : 0);
-
-   // Return the old IRQ handler //*/
-
-  return OK;
-}
diff --git a/arch/arm/src/nrf52/nrf52_exti_comp.c b/arch/arm/src/nrf52/nrf52_exti_comp.c
deleted file mode 100644
index 642c0447e1..0000000000
--- a/arch/arm/src/nrf52/nrf52_exti_comp.c
+++ /dev/null
@@ -1,180 +0,0 @@
-/****************************************************************************
- * arch/arm/src/stm32/stm32l4_exti_comp.c
- *
- *   Copyright (c) 2017 Gregory Nutt. All rights reserved
- *   Copyright (c) 2016 Motorola Mobility, LLC. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ****************************************************************************/
-
-/****************************************************************************
- * Included Files
- ****************************************************************************/
-
-#include <nuttx/config.h>
-
-#include <nuttx/irq.h>
-#include <nuttx/arch.h>
-
-#include "up_arch.h"
-#include "nrf52_comp.h"
-#include "nrf52_exti.h"
-#include "chip/nrf52_exti.h"
-
-/****************************************************************************
- * Private Types
- ****************************************************************************/
-
-struct comp_callback_s
-{
-  xcpt_t callback;
-  void  *arg;
-};
-
-/****************************************************************************
- * Private Data
- ****************************************************************************/
-
-/* Interrupt handlers attached to the COMP EXTI lines */
-
-static struct comp_callback_s g_comp_handlers[STM32L4_COMP_NUM];
-
-/* Comparator EXTI lines */
-
-static const uint32_t g_comp_lines[STM32L4_COMP_NUM] =
-{
-#if defined(CONFIG_STM32L4_STM32L4X3) || defined (CONFIG_STM32L4_STM32L4X6)
-  EXTI1_COMP1,
-  EXTI1_COMP2
-#else
-#  error "Unrecognized STM32L4 chip"
-#endif
-};
-
-/****************************************************************************
- * Private Functions
- ****************************************************************************/
-
-static int stm32l4_exti_comp_isr(int irq, void *context)
-{
-  uint32_t pr;
-  uint32_t ln;
-  int ret = 0;
-  int i;
-
-  /* Examine the state of each comparator line and dispatch interrupts */
-
-  pr = getreg32(STM32L4_EXTI1_PR);
-  for (i = 0; i < STM32L4_COMP_NUM; i++)
-    {
-      ln = g_comp_lines[i];
-      if ((pr & ln) != 0)
-        {
-          /* Clear the pending interrupt */
-
-          putreg32(ln, STM32L4_EXTI1_PR);
-          if (g_comp_handlers[i].callback != NULL)
-            {
-              xcpt_t callback = g_comp_handlers[i].callback;
-              vid   *arg      = g_comp_handlers[i].arg;
-              ret = callback(irq, context, arg);
-            }
-        }
-    }
-
-  return ret;
-}
-
-/****************************************************************************
- * Public Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_exti_comp
- *
- * Description:
- *   Sets/clears comparator based events and interrupt triggers.
- *
- * Parameters:
- *  - cmp: comparator
- *  - rising/falling edge: enables interrupt on rising/falling edget
- *  - event:  generate event when set
- *  - func:   when non-NULL, generate interrupt
- *  - arg:    Argument passed to the interrupt callback
- *
- * Returns:
- *   Zero (OK) returned on success; a negated errno value is returned on
- *   failure.
- *
- ****************************************************************************/
-
-int stm32l4_exti_comp(int cmp, bool risingedge, bool fallingedge,
-                      bool event, xcpt_t func, void *arg)
-{
-  irqstate_t flags;
-  uint32_t ln = g_comp_lines[cmp];
-
-  /* Perform the following within a critical section so that the handler gets
-   * installed correctly before the next interrupt is received.
-   */
-
-  flags = enter_critical_section();
-
-  /* Install external interrupt handlers */
-
-  if (func != NULL)
-    {
-      irq_attach(STM32L4_IRQ_COMP, stm32l4_exti_comp_isr, NULL);
-      up_enable_irq(STM32L4_IRQ_COMP);
-    }
-  else
-    {
-      up_disable_irq(STM32L4_IRQ_COMP);
-    }
-
-  /* Configure rising/falling edges */
-
-  modifyreg32(STM32L4_EXTI1_RTSR, risingedge  ? 0 : ln, risingedge  ? ln : 0);
-  modifyreg32(STM32L4_EXTI1_FTSR, fallingedge ? 0 : ln, fallingedge ? ln : 0);
-
-  /* Enable Events and Interrupts */
-
-  modifyreg32(STM32L4_EXTI1_EMR, event ? 0 : ln, event ? ln : 0);
-  modifyreg32(STM32L4_EXTI1_IMR, func  ? 0 : ln, func  ? ln : 0);
-
-  /* Get the previous IRQ handler and save the new IRQ handler. */
-
-  g_comp_handlers[cmp].callback = func;
-  g_comp_handlers[cmp].arg      = arg;
-
-  /* Leave the critical section */
-
-  leave_critical_section(flags);
-  return OK;
-}
diff --git a/arch/arm/src/nrf52/nrf52_exti_gpio.c b/arch/arm/src/nrf52/nrf52_exti_gpio.c
deleted file mode 100644
index 1a93821b04..0000000000
--- a/arch/arm/src/nrf52/nrf52_exti_gpio.c
+++ /dev/null
@@ -1,389 +0,0 @@
-/****************************************************************************
- * arch/arm/src/nrf52/nrf52_exti_gpio.c
- *
- *   Copyright (C) 2009, 2011-2012, 2015 Gregory Nutt. All rights reserved.
- *   Copyright (C) 2011 Uros Platise. All rights reserved.
- *   Author: Gregory Nutt <gnutt@nuttx.org>
- *           Uros Platise <uros.platise@isotel.eu>
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ****************************************************************************/
-
-/****************************************************************************
- * Included Files
- ****************************************************************************/
-
-#include <nuttx/config.h>
-#include <nuttx/irq.h>
-#include <nuttx/arch.h>
-
-#include <stdint.h>
-#include <stdbool.h>
-#include <errno.h>
-#include <debug.h>
-
-#include <arch/irq.h>
-
-#include "up_arch.h"
-#include "chip.h"
-#include "nrf52_gpio.h"
-#include "nrf52_exti.h"
-
-/****************************************************************************
- * Private Types
- ****************************************************************************/
-
-struct gpio_callback_s
-{
-  xcpt_t callback;   /* Callback entry point */
-  void  *arg;        /* The argument that accompanies the callback */
-};
-
-/****************************************************************************
- * Private Data
- ****************************************************************************/
-
-/* Interrupt handlers attached to each EXTI */
-
-static struct gpio_callback_s g_gpio_handlers[16];
-
-/****************************************************************************
- * Private Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Interrupt Service Routines - Dispatchers
- ****************************************************************************/
-
-static int nrf52_exti0_isr(int irq, void *context, FAR void *arg)
-{
-  int ret = OK;
-
-  /* Clear the pending interrupt */
-
-  putreg32(0x0001, STM32L4_EXTI1_PR);
-
-  /* And dispatch the interrupt to the handler */
-
-  if (g_gpio_handlers[0].callback != NULL)
-    {
-      xcpt_t callback = g_gpio_handlers[0].callback;
-      void  *cbarg    = g_gpio_handlers[0].arg;
-
-      ret = callback(irq, context, cbarg);
-    }
-
-  return ret;
-}
-
-static int nrf52_exti1_isr(int irq, void *context, FAR void *arg)
-{
-  int ret = OK;
-
-  /* Clear the pending interrupt */
-
-  putreg32(0x0002, STM32L4_EXTI1_PR);
-
-  /* And dispatch the interrupt to the handler */
-
-  if (g_gpio_handlers[1].callback != NULL)
-    {
-      xcpt_t callback = g_gpio_handlers[1].callback;
-      void  *cbarg    = g_gpio_handlers[1].arg;
-
-      ret = callback(irq, context, cbarg);
-    }
-
-  return ret;
-}
-
-static int nrf52_exti2_isr(int irq, void *context, FAR void *arg)
-{
-  int ret = OK;
-
-  /* Clear the pending interrupt */
-
-  putreg32(0x0004, STM32L4_EXTI1_PR);
-
-  /* And dispatch the interrupt to the handler */
-
-  if (g_gpio_handlers[2].callback != NULL)
-    {
-      xcpt_t callback = g_gpio_handlers[2].callback;
-      void  *cbarg    = g_gpio_handlers[2].arg;
-
-      ret = callback(irq, context, cbarg);
-    }
-
-  return ret;
-}
-
-static int nrf52_exti3_isr(int irq, void *context, FAR void *arg)
-{
-  int ret = OK;
-
-  /* Clear the pending interrupt */
-
-  putreg32(0x0008, STM32L4_EXTI1_PR);
-
-  /* And dispatch the interrupt to the handler */
-
-  if (g_gpio_handlers[3].callback != NULL)
-    {
-      xcpt_t callback = g_gpio_handlers[3].callback;
-      void  *cbarg    = g_gpio_handlers[3].arg;
-
-      ret = callback(irq, context, cbarg);
-    }
-
-  return ret;
-}
-
-static int nrf52_exti4_isr(int irq, void *context, FAR void *arg)
-{
-  int ret = OK;
-
-  /* Clear the pending interrupt */
-
-  putreg32(0x0010, STM32L4_EXTI1_PR);
-
-  /* And dispatch the interrupt to the handler */
-
-  if (g_gpio_handlers[4].callback != NULL)
-    {
-      xcpt_t callback = g_gpio_handlers[4].callback;
-      void  *cbarg    = g_gpio_handlers[4].arg;
-
-      ret = callback(irq, context, cbarg);
-    }
-
-  return ret;
-}
-
-static int nrf52_exti_multiisr(int irq, void *context, void *arg, int first, int last)
-{
-  uint32_t pr;
-  int pin;
-  int ret = OK;
-
-  /* Examine the state of each pin in the group */
-
-  pr = getreg32(STM32L4_EXTI1_PR);
-
-  /* And dispatch the interrupt to the handler */
-
-  for (pin = first; pin <= last; pin++)
-    {
-      /* Is an interrupt pending on this pin? */
-
-      uint32_t mask = (1 << pin);
-      if ((pr & mask) != 0)
-        {
-          /* Clear the pending interrupt */
-
-          putreg32(mask, STM32L4_EXTI1_PR);
-
-          /* And dispatch the interrupt to the handler */
-
-          if (g_gpio_handlers[pin].callback != NULL)
-            {
-              xcpt_t callback = g_gpio_handlers[pin].callback;
-              void  *cbarg    = g_gpio_handlers[pin].arg;
-              int tmp;
-
-              tmp = callback(irq, context, cbarg);
-              if (tmp < 0)
-                {
-                  ret = tmp;
-                }
-            }
-        }
-    }
-
-  return ret;
-}
-
-static int nrf52_exti95_isr(int irq, void *context, void *arg)
-{
-  return nrf52_exti_multiisr(irq, context, arg, 5, 9);
-}
-
-static int nrf52_exti1510_isr(int irq, void *context, FAR void *arg)
-{
-  return nrf52_exti_multiisr(irq, context, arg, 10, 15);
-}
-
-/****************************************************************************
- * Public Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: nrf52_gpiosetevent
- *
- * Description:
- *   Sets/clears GPIO based event and interrupt triggers.
- *
- * Description:
- *   Sets/clears GPIO based event and interrupt triggers.
- *
- * Input Parameters:
- *  pinset      - GPIO pin configuration
- *  risingedge  - Enables interrupt on rising edges
- *  fallingedge - Enables interrupt on falling edges
- *  event       - Generate event when set
- *  func        - When non-NULL, generate interrupt
- *  arg         - Argument passed to the interrupt callback
- *
- * Returned Value:
- *  Zero (OK) is returned on success, otherwise a negated errno value is returned
- *  to indicate the nature of the failure.
- *
- ************************************************************************************/
-
-int nrf52_gpiosetevent(uint32_t pinset, bool risingedge, bool fallingedge,
-                       bool event, xcpt_t func, void *arg)
-{
-  struct gpio_callback_s *shared_cbs;
-  uint32_t pin = pinset & GPIO_PIN_MASK;
-  uint32_t exti = STM32L4_EXTI1_BIT(pin);
-  int      irq;
-  xcpt_t   handler;
-  int      nshared;
-  int      i;
-
-  /* Select the interrupt handler for this EXTI pin */
-
-  if (pin < 5)
-    {
-      irq        = pin + STM32L4_IRQ_EXTI0;
-      nshared    = 1;
-      shared_cbs = &g_gpio_handlers[pin];
-      switch (pin)
-        {
-          case 0:
-            handler = nrf52_exti0_isr;
-            break;
-
-          case 1:
-            handler = nrf52_exti1_isr;
-            break;
-
-          case 2:
-            handler = nrf52_exti2_isr;
-            break;
-
-          case 3:
-            handler = nrf52_exti3_isr;
-            break;
-
-          default:
-            handler = nrf52_exti4_isr;
-            break;
-        }
-    }
-  else if (pin < 10)
-    {
-      irq        = STM32L4_IRQ_EXTI95;
-      handler    = nrf52_exti95_isr;
-      shared_cbs = &g_gpio_handlers[5];
-      nshared    = 5;
-    }
-  else
-    {
-      irq        = STM32L4_IRQ_EXTI1510;
-      handler    = nrf52_exti1510_isr;
-      shared_cbs = &g_gpio_handlers[10];
-      nshared    = 6;
-    }
-
-  /* Get the previous GPIO IRQ handler; Save the new IRQ handler. */
-
-  g_gpio_handlers[pin].callback = func;
-  g_gpio_handlers[pin].arg      = arg;
-
-  /* Install external interrupt handlers */
-
-  if (func)
-    {
-      irq_attach(irq, handler, NULL);
-      up_enable_irq(irq);
-    }
-  else
-    {
-      /* Only disable IRQ if shared handler does not have any active
-       * callbacks.
-       */
-
-      for (i = 0; i < nshared; i++)
-        {
-          if (shared_cbs[i].callback != NULL)
-            {
-              break;
-            }
-        }
-
-      if (i == nshared)
-        {
-          up_disable_irq(irq);
-        }
-    }
-
-  /* Configure GPIO, enable EXTI line enabled if event or interrupt is
-   * enabled.
-   */
-
-  if (event || func)
-    {
-      pinset |= GPIO_EXTI;
-    }
-
-  nrf52_configgpio(pinset);
-
-  /* Configure rising/falling edges */
-
-  modifyreg32(STM32L4_EXTI1_RTSR,
-              risingedge ? 0 : exti,
-              risingedge ? exti : 0);
-  modifyreg32(STM32L4_EXTI1_FTSR,
-              fallingedge ? 0 : exti,
-              fallingedge ? exti : 0);
-
-  /* Enable Events and Interrupts */
-
-  modifyreg32(STM32L4_EXTI1_EMR,
-              event ? 0 : exti,
-              event ? exti : 0);
-  modifyreg32(STM32L4_EXTI1_IMR,
-              func ? 0 : exti,
-              func ? exti : 0);
-
-  /* Return the old IRQ handler */
-
-  return OK;
-}
diff --git a/arch/arm/src/nrf52/nrf52_exti_pwr.c b/arch/arm/src/nrf52/nrf52_exti_pwr.c
deleted file mode 100644
index 23aedfae28..0000000000
--- a/arch/arm/src/nrf52/nrf52_exti_pwr.c
+++ /dev/null
@@ -1,161 +0,0 @@
-/****************************************************************************
- * arch/arm/src/stm32l4/stm32l4_exti_pwr.c
- *
- *   Copyright (C) 2009, 2011-2012, 2015 Gregory Nutt. All rights reserved.
- *   Copyright (C) 2015 Haltian Ltd. All rights reserved.
- *   Authors: Gregory Nutt <gnutt@nuttx.org>
- *            Dmitry Nikolaev <dmitry.nikolaev@haltian.com>
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ****************************************************************************/
-
-/****************************************************************************
- * Included Files
- ****************************************************************************/
-
-#include <nuttx/config.h>
-#include <nuttx/irq.h>
-#include <nuttx/arch.h>
-
-#include <stdint.h>
-#include <stdbool.h>
-#include <errno.h>
-
-#include <arch/irq.h>
-
-#include "up_arch.h"
-#include "chip.h"
-#include "stm32l4_gpio.h"
-#include "stm32l4_exti.h"
-#include "stm32l4_exti_pwr.h"
-
-/****************************************************************************
- * Pre-processor Definitions
- ****************************************************************************/
-
-/****************************************************************************
- * Private Data
- ****************************************************************************/
-
-/* Interrupt handlers attached to the PVD EXTI */
-
-static xcpt_t g_pvd_callback;
-static void  *g_callback_arg;
-
-/****************************************************************************
- * Private Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_exti_pvd_isr
- *
- * Description:
- *   EXTI PVD interrupt service routine/dispatcher
- *
- ****************************************************************************/
-
-static int stm32l4_exti_pvd_isr(int irq, void *context, FAR void *arg)
-{
-  int ret = OK;
-
-  /* Clear the pending EXTI interrupt */
-
-  putreg32(EXTI1_PVD_LINE, STM32L4_EXTI1_PR);
-
-  /* And dispatch the interrupt to the handler */
-
-  if (g_pvd_callback != NULL)
-    {
-      ret = g_pvd_callback(irq, context, g_callback_arg);
-    }
-
-  return ret;
-}
-
-/****************************************************************************
- * Public Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_exti_pvd
- *
- * Description:
- *   Sets/clears EXTI PVD interrupt.
- *
- * Parameters:
- *  - rising/falling edge: enables interrupt on rising/falling edge
- *  - event:  generate event when set
- *  - func:   when non-NULL, generate interrupt
- *
- * Returns:
- *   Zero (OK) returned on success; a negated errno value is returned on
- *   failure.
- *
- ****************************************************************************/
-
-int stm32l4_exti_pvd(bool risingedge, bool fallingedge, bool event,
-                     xcpt_t func, void *arg)
-{
-  /* Get the previous GPIO IRQ handler; Save the new IRQ handler. */
-
-  g_pvd_callback = func;
-  g_callback_arg = arg;
-
-  /* Install external interrupt handlers (if not already attached) */
-
-  if (func)
-    {
-      irq_attach(STM32L4_IRQ_PVD, stm32l4_exti_pvd_isr, NULL);
-      up_enable_irq(STM32L4_IRQ_PVD);
-    }
-  else
-    {
-      up_disable_irq(STM32L4_IRQ_PVD);
-    }
-
-  /* Configure rising/falling edges */
-
-  modifyreg32(STM32L4_EXTI1_RTSR,
-              risingedge ? 0 : EXTI1_PVD_LINE,
-              risingedge ? EXTI1_PVD_LINE : 0);
-  modifyreg32(STM32L4_EXTI1_FTSR,
-              fallingedge ? 0 : EXTI1_PVD_LINE,
-              fallingedge ? EXTI1_PVD_LINE : 0);
-
-  /* Enable Events and Interrupts */
-
-  modifyreg32(STM32L4_EXTI1_EMR,
-              event ? 0 : EXTI1_PVD_LINE,
-              event ? EXTI1_PVD_LINE : 0);
-  modifyreg32(STM32L4_EXTI1_IMR,
-              func ? 0 : EXTI1_PVD_LINE,
-              func ? EXTI1_PVD_LINE : 0);
-
-  return OK;
-}
diff --git a/arch/arm/src/nrf52/nrf52_exti_pwr.h b/arch/arm/src/nrf52/nrf52_exti_pwr.h
deleted file mode 100644
index 27e584779b..0000000000
--- a/arch/arm/src/nrf52/nrf52_exti_pwr.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/****************************************************************************
- * arch/arm/src/stm32l4/stm32l4_exti_pwr.h
- *
- *   Copyright (C) 2015 Haltian Ltd. All rights reserved.
- *   Authors: Dmitry Nikolaev <dmitry.nikolaev@haltian.com>
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ****************************************************************************/
-
-#ifndef STM32L4_EXTI_PWR_H_
-#define STM32L4_EXTI_PWR_H_
-
-/****************************************************************************
- * Included Files
- ****************************************************************************/
-
-#include <stdbool.h>
-#include <nuttx/irq.h>
-
-/****************************************************************************
- * Public Function Prototypes
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_exti_pvd
- *
- * Description:
- *   Sets/clears EXTI PVD interrupt.
- *
- * Parameters:
- *  - rising/falling edge: enables interrupt on rising/falling edge
- *  - event:  generate event when set
- *  - func:   when non-NULL, generate interrupt
- *  - arg:    Argument passed to the interrupt callback
- *
- * Returns:
- *   Zero (OK) returned on success; a negated errno value is returned on
- *   failure.
- *
- ****************************************************************************/
-
-int stm32l4_exti_pvd(bool risingedge, bool fallingedge, bool event,
-                     xcpt_t func, void *arg);
-
-#endif /* STM32L4_EXTI_PWR_H_ */
diff --git a/arch/arm/src/nrf52/nrf52_flash.c b/arch/arm/src/nrf52/nrf52_flash.c
index 5b577adf15..bd1f91c2ea 100644
--- a/arch/arm/src/nrf52/nrf52_flash.c
+++ b/arch/arm/src/nrf52/nrf52_flash.c
@@ -60,7 +60,6 @@
 #include "nrf_drv_common.h"
 
 #include "nrf_nvmc.h"
-#include "nrf52_waste.h"
 
 
 /************************************************************************************
@@ -79,7 +78,7 @@
 
 size_t up_progmem_pagesize(size_t page)
 {
- size_t npage = up_progmem_npages();
+  size_t npage = up_progmem_npages();
 
   if (page >= npage)
     {
@@ -102,7 +101,7 @@ ssize_t up_progmem_getpage(size_t addr)
       return -EFAULT;
     }
 
-  page_end = addr/NRF52_FLASH_PAGE_SIZE;
+  page_end = addr / NRF52_FLASH_PAGE_SIZE;
 
   return page_end;
 }
@@ -115,12 +114,12 @@ size_t up_progmem_getaddress(size_t page)
       return SIZE_MAX;
     }
 
-  return page*NRF52_FLASH_PAGE_SIZE;
+  return page * NRF52_FLASH_PAGE_SIZE;
 }
 
 size_t up_progmem_npages(void)
 {
-  return nrf_nvmc_get_flash_size()/NRF52_FLASH_PAGE_SIZE;
+  return nrf_nvmc_get_flash_size() / NRF52_FLASH_PAGE_SIZE;
 }
 
 bool up_progmem_isuniform(void)
@@ -194,7 +193,7 @@ ssize_t up_progmem_write(size_t addr, const void *buf, size_t count)
 
   /* Check for valid address range */
 
-  if ((addr+count) > nrf_nvmc_get_flash_size())
+  if ((addr + count) > nrf_nvmc_get_flash_size())
     {
       return -EFAULT;
     }
diff --git a/arch/arm/src/nrf52/nrf52_freerun.c b/arch/arm/src/nrf52/nrf52_freerun.c
deleted file mode 100644
index df351ed89f..0000000000
--- a/arch/arm/src/nrf52/nrf52_freerun.c
+++ /dev/null
@@ -1,288 +0,0 @@
-/****************************************************************************
- * arch/arm/src/stm32l4/stm32l4_freerun.c
- *
- *   Copyright (C) 2016 Gregory Nutt. All rights reserved.
- *   Author: Gregory Nutt <gnutt@nuttx.org>
- *           dev@ziggurat29.com
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the names NuttX nor Atmel nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ****************************************************************************/
-
-/****************************************************************************
- * Included Files
- ****************************************************************************/
-
-#include <nuttx/config.h>
-
-#include <sys/types.h>
-#include <stdint.h>
-#include <stdbool.h>
-#include <assert.h>
-#include <errno.h>
-
-#include <nuttx/irq.h>
-#include <nuttx/clock.h>
-
-#include "stm32l4_freerun.h"
-
-#ifdef CONFIG_STM32L4_FREERUN
-
-/****************************************************************************
- * Private Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_freerun_handler
- *
- * Description:
- *   Timer interrupt callback.  When the freerun timer counter overflows,
- *   this interrupt will occur.  We will just increment an overflow count.
- *
- * Input Parameters:
- *   tch - The handle that represents the timer state
- *   arg - An opaque argument provided when the interrupt was registered
- *   sr  - The value of the timer interrupt status register at the time
- *         that the interrupt occurred.
- *
- * Returned Value:
- *   None
- *
- ****************************************************************************/
-
-static int stm32l4_freerun_handler(int irq, FAR void *context, void *arg)
-{
-  FAR struct stm32l4_freerun_s *freerun = (FAR struct stm32l4_freerun_s *) arg;
-
-  DEBUGASSERT(freerun != NULL && freerun->overflow < UINT32_MAX);
-  freerun->overflow++;
-
-  STM32L4_TIM_ACKINT(freerun->tch, 0);
-  return OK;
-}
-
-/****************************************************************************
- * Public Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_freerun_initialize
- *
- * Description:
- *   Initialize the freerun timer wrapper
- *
- * Input Parameters:
- *   freerun    Caller allocated instance of the freerun state structure
- *   chan       Timer counter channel to be used.
- *   resolution The required resolution of the timer in units of
- *              microseconds.  NOTE that the range is restricted to the
- *              range of uint16_t (excluding zero).
- *
- * Returned Value:
- *   Zero (OK) is returned on success; a negated errno value is returned
- *   on failure.
- *
- ****************************************************************************/
-
-int stm32l4_freerun_initialize(FAR struct stm32l4_freerun_s *freerun, int chan,
-                               uint16_t resolution)
-{
-  uint32_t frequency;
-
-  tmrinfo("chan=%d resolution=%d usec\n", chan, resolution);
-  DEBUGASSERT(freerun != NULL && resolution > 0);
-
-  /* Get the TC frequency the corresponds to the requested resolution */
-
-  frequency = USEC_PER_SEC / (uint32_t)resolution;
-  freerun->frequency = frequency;
-
-  freerun->tch = stm32l4_tim_init(chan);
-  if (!freerun->tch)
-    {
-      tmrerr("ERROR: Failed to allocate TIM%d\n", chan);
-      return -EBUSY;
-    }
-
-  STM32L4_TIM_SETCLOCK(freerun->tch, frequency);
-
-  /* Initialize the remaining fields in the state structure and return
-   * success.
-   */
-
-  freerun->chan     = chan;
-  freerun->running  = false;
-  freerun->overflow = 0;
-
-  /* Set up to receive the callback when the counter overflow occurs */
-
-  STM32L4_TIM_SETISR(freerun->tch, stm32l4_freerun_handler, freerun, 0);
-
-  /* Set timer period */
-
-  STM32L4_TIM_SETPERIOD(freerun->tch, UINT32_MAX);
-
-  /* Start the counter */
-
-  STM32L4_TIM_SETMODE(freerun->tch, STM32L4_TIM_MODE_UP);
-  STM32L4_TIM_ACKINT(freerun->tch, 0);
-  STM32L4_TIM_ENABLEINT(freerun->tch, 0);
-
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_freerun_counter
- *
- * Description:
- *   Read the counter register of the free-running timer.
- *
- * Input Parameters:
- *   freerun Caller allocated instance of the freerun state structure.  This
- *           structure must have been previously initialized via a call to
- *           stm32l4_freerun_initialize();
- *   ts      The location in which to return the time from the free-running
- *           timer.
- *
- * Returned Value:
- *   Zero (OK) is returned on success; a negated errno value is returned
- *   on failure.
- *
- ****************************************************************************/
-
-int stm32l4_freerun_counter(FAR struct stm32l4_freerun_s *freerun,
-                            FAR struct timespec *ts)
-{
-  uint64_t usec;
-  uint32_t counter;
-  uint32_t verify;
-  uint32_t overflow;
-  uint32_t sec;
-  int pending;
-  irqstate_t flags;
-
-  DEBUGASSERT(freerun && freerun->tch && ts);
-
-  /* Temporarily disable the overflow counter.  NOTE that we have to be
-   * careful here because  stm32l4_tc_getpending() will reset the pending
-   * interrupt status.  If we do not handle the overflow here then, it will
-   * be lost.
-   */
-
-  flags    = enter_critical_section();
-
-  overflow = freerun->overflow;
-  counter  = STM32L4_TIM_GETCOUNTER(freerun->tch);
-  pending  = STM32L4_TIM_CHECKINT(freerun->tch, 0);
-  verify   = STM32L4_TIM_GETCOUNTER(freerun->tch);
-
-  /* If an interrupt was pending before we re-enabled interrupts,
-   * then the overflow needs to be incremented.
-   */
-
-  if (pending)
-    {
-      STM32L4_TIM_ACKINT(freerun->tch, 0);
-
-      /* Increment the overflow count and use the value of the
-       * guaranteed to be AFTER the overflow occurred.
-       */
-
-      overflow++;
-      counter = verify;
-
-      /* Update freerun overflow counter. */
-
-      freerun->overflow = overflow;
-    }
-
-  leave_critical_section(flags);
-
-  tmrinfo("counter=%lu (%lu) overflow=%lu, pending=%i\n",
-          (unsigned long)counter,  (unsigned long)verify,
-          (unsigned long)overflow, pending);
-  tmrinfo("frequency=%u\n", freerun->frequency);
-
-  /* Convert the whole thing to units of microseconds.
-   *
-   *   frequency = ticks / second
-   *   seconds   = ticks * frequency
-   *   usecs     = (ticks * USEC_PER_SEC) / frequency;
-   */
-
-  usec = ((((uint64_t)overflow << 32) + (uint64_t)counter) * USEC_PER_SEC) /
-         freerun->frequency;
-
-  /* And return the value of the timer */
-
-  sec         = (uint32_t)(usec / USEC_PER_SEC);
-  ts->tv_sec  = sec;
-  ts->tv_nsec = (usec - (sec * USEC_PER_SEC)) * NSEC_PER_USEC;
-
-  tmrinfo("usec=%llu ts=(%u, %lu)\n",
-          usec, (unsigned long)ts->tv_sec, (unsigned long)ts->tv_nsec);
-
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_freerun_uninitialize
- *
- * Description:
- *   Stop the free-running timer and release all resources that it uses.
- *
- * Input Parameters:
- *   freerun Caller allocated instance of the freerun state structure.  This
- *           structure must have been previously initialized via a call to
- *           stm32l4_freerun_initialize();
- *
- * Returned Value:
- *   Zero (OK) is returned on success; a negated errno value is returned
- *   on failure.
- *
- ****************************************************************************/
-
-int stm32l4_freerun_uninitialize(FAR struct stm32l4_freerun_s *freerun)
-{
-  DEBUGASSERT(freerun && freerun->tch);
-
-  /* Now we can disable the timer interrupt and disable the timer. */
-
-  STM32L4_TIM_DISABLEINT(freerun->tch, 0);
-  STM32L4_TIM_SETMODE(freerun->tch, STM32L4_TIM_MODE_DISABLED);
-  STM32L4_TIM_SETISR(freerun->tch, NULL, NULL, 0);
-
-  /* Free the timer */
-
-  stm32l4_tim_deinit(freerun->tch);
-  freerun->tch = NULL;
-
-  return OK;
-}
-
-#endif /* CONFIG_STM32L4_FREERUN */
diff --git a/arch/arm/src/nrf52/nrf52_freerun.h b/arch/arm/src/nrf52/nrf52_freerun.h
deleted file mode 100644
index 3128a9844d..0000000000
--- a/arch/arm/src/nrf52/nrf52_freerun.h
+++ /dev/null
@@ -1,159 +0,0 @@
-/****************************************************************************
- * arch/arm/src/stm32l4/stm32l4_freerun.h
- *
- *   Copyright (C) 2016 Gregory Nutt. All rights reserved.
- *   Author: Gregory Nutt <gnutt@nuttx.org>
- *           dev@ziggurat29.com
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ****************************************************************************/
-
-#ifndef __ARCH_ARM_SRC_STM32L4_FREERUN_H
-#define __ARCH_ARM_SRC_STM32L4_FREERUN_H
-
-/****************************************************************************
- * Included Files
- ****************************************************************************/
-
-#include <nuttx/config.h>
-
-#include <stdint.h>
-#include <time.h>
-#include <debug.h>
-
-#include "stm32l4_tim.h"
-
-#ifdef CONFIG_STM32L4_FREERUN
-
-/****************************************************************************
- * Public Types
- ****************************************************************************/
-
-/* The freerun client must allocate an instance of this structure and called
- * stm32l4_freerun_initialize() before using the freerun facilities.  The client
- * should not access the contents of this structure directly since the
- * contents are subject to change.
- */
-
-struct stm32l4_freerun_s
-{
-  uint8_t chan;                    /* The timer/counter in use */
-  bool running;                    /* True: the timer is running */
-  uint32_t overflow;               /* Timer counter overflow */
-  FAR struct stm32l4_tim_dev_s *tch; /* Handle returned by stm32l4_tim_init() */
-  uint32_t frequency;
-};
-
-/****************************************************************************
- * Public Data
- ****************************************************************************/
-
-#undef EXTERN
-#if defined(__cplusplus)
-#define EXTERN extern "C"
-extern "C"
-{
-#else
-#define EXTERN extern
-#endif
-
-/****************************************************************************
- * Public Function Prototypes
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_freerun_initialize
- *
- * Description:
- *   Initialize the freerun timer wrapper
- *
- * Input Parameters:
- *   freerun    Caller allocated instance of the freerun state structure
- *   chan       Timer counter channel to be used.
- *   resolution The required resolution of the timer in units of
- *              microseconds.  NOTE that the range is restricted to the
- *              range of uint16_t (excluding zero).
- *
- * Returned Value:
- *   Zero (OK) is returned on success; a negated errno value is returned
- *   on failure.
- *
- ****************************************************************************/
-
-int stm32l4_freerun_initialize(struct stm32l4_freerun_s *freerun, int chan,
-                               uint16_t resolution);
-
-/****************************************************************************
- * Name: stm32l4_freerun_counter
- *
- * Description:
- *   Read the counter register of the free-running timer.
- *
- * Input Parameters:
- *   freerun Caller allocated instance of the freerun state structure.  This
- *           structure must have been previously initialized via a call to
- *           stm32l4_freerun_initialize();
- *   ts      The location in which to return the time remaining on the
- *           oneshot timer.
- *
- * Returned Value:
- *   Zero (OK) is returned on success; a negated errno value is returned
- *   on failure.
- *
- ****************************************************************************/
-
-int stm32l4_freerun_counter(struct stm32l4_freerun_s *freerun,
-                            struct timespec *ts);
-
-/****************************************************************************
- * Name: stm32l4_freerun_uninitialize
- *
- * Description:
- *   Stop the free-running timer and release all resources that it uses.
- *
- * Input Parameters:
- *   freerun Caller allocated instance of the freerun state structure.  This
- *           structure must have been previously initialized via a call to
- *           stm32l4_freerun_initialize();
- *
- * Returned Value:
- *   Zero (OK) is returned on success; a negated errno value is returned
- *   on failure.
- *
- ****************************************************************************/
-
-int stm32l4_freerun_uninitialize(struct stm32l4_freerun_s *freerun);
-
-#undef EXTERN
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* CONFIG_STM32L4_FREERUN */
-#endif /* __ARCH_ARM_SRC_STM32L4_FREERUN_H */
diff --git a/arch/arm/src/nrf52/nrf52_lse.c b/arch/arm/src/nrf52/nrf52_lse.c
deleted file mode 100644
index d0c78ec281..0000000000
--- a/arch/arm/src/nrf52/nrf52_lse.c
+++ /dev/null
@@ -1,93 +0,0 @@
-/****************************************************************************
- * arch/arm/src/stm32l4/stm32l4_lse.c
- *
- *   Copyright (C) 2016 Gregory Nutt. All rights reserved.
- *   Author: dev@ziggurat29.com
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ****************************************************************************/
-
-/****************************************************************************
- * Included Files
- ****************************************************************************/
-
-#include <nuttx/config.h>
-
-#include "up_arch.h"
-
-#include "stm32l4_pwr.h"
-#include "stm32l4_rcc.h"
-#include "stm32l4_waste.h"
-
-/****************************************************************************
- * Public Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_rcc_enablelse
- *
- * Description:
- *   Enable the External Low-Speed (LSE) oscillator.
- *
- * Todo:
- *   Check for LSE good timeout and return with -1,
- *
- ****************************************************************************/
-
-void stm32l4_rcc_enablelse(void)
-{
-  bool writable;
-  uint32_t regval;
-
-  /* The LSE is in the RTC domain and write access is denied to this domain
-   * after reset, you have to enable write access using DBP bit in the PWR CR
-   * register before to configuring the LSE.
-   */
-
-  writable = stm32l4_pwr_enablebkp(true);
-
-  /* Enable the External Low-Speed (LSE) oscillator by setting the LSEON bit
-   * the RCC BDCR register.
-   */
-
-  regval  = getreg32(STM32L4_RCC_BDCR);
-  regval |= RCC_BDCR_LSEON;
-  putreg32(regval, STM32L4_RCC_BDCR);
-
-  /* Wait for the LSE clock to be ready */
-
-  while (((regval = getreg32(STM32L4_RCC_BDCR)) & RCC_BDCR_LSERDY) == 0)
-    {
-      up_waste();
-    }
-
-  /* Disable backup domain access if it was disabled on entry */
-
-  (void)stm32l4_pwr_enablebkp(writable);
-}
diff --git a/arch/arm/src/nrf52/nrf52_oneshot.c b/arch/arm/src/nrf52/nrf52_oneshot.c
deleted file mode 100644
index 72d7ccc025..0000000000
--- a/arch/arm/src/nrf52/nrf52_oneshot.c
+++ /dev/null
@@ -1,475 +0,0 @@
-/****************************************************************************
- * arch/arm/src/stm32l4/stm32l4_oneshot.c
- *
- *   Copyright (C) 2016-2017 Gregory Nutt. All rights reserved.
- *   Author: Gregory Nutt <gnutt@nuttx.org>
- *           dev@ziggurat29.com
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the names NuttX nor Atmel nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ****************************************************************************/
-
-/****************************************************************************
- * Included Files
- ****************************************************************************/
-
-#include <nuttx/config.h>
-
-#include <sys/types.h>
-#include <stdint.h>
-#include <stdbool.h>
-#include <sched.h>
-#include <assert.h>
-#include <errno.h>
-#include <debug.h>
-
-#include <nuttx/irq.h>
-#include <nuttx/clock.h>
-
-#include "stm32l4_oneshot.h"
-
-#ifdef CONFIG_STM32L4_ONESHOT
-
-/****************************************************************************
- * Private Function Prototypes
- ****************************************************************************/
-
-static int stm32l4_oneshot_handler(int irq, void *context, void *arg);
-
-/****************************************************************************
- * Private Data
- ****************************************************************************/
-
-static struct stm32l4_oneshot_s *g_oneshot[CONFIG_STM32L4_ONESHOT_MAXTIMERS];
-
-/****************************************************************************
- * Private Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_oneshot_handler
- *
- * Description:
- *   Common timer interrupt callback.  When any oneshot timer interrupt
- *   expires, this function will be called.  It will forward the call to
- *   the next level up.
- *
- * Input Parameters:
- *   oneshot - The state associated with the expired timer
- *
- * Returned Value:
- *   Always returns OK
- *
- ****************************************************************************/
-
-static int stm32l4_oneshot_handler(int irq, void *context, void *arg)
-{
-  struct stm32l4_oneshot_s *oneshot = (struct stm32l4_oneshot_s *) arg;
-  oneshot_handler_t oneshot_handler;
-  FAR void *oneshot_arg;
-
-  tmrinfo("Expired...\n");
-  DEBUGASSERT(oneshot != NULL && oneshot->handler);
-
-  /* The clock was stopped, but not disabled when the RC match occurred.
-   * Disable the TC now and disable any further interrupts.
-   */
-
-  STM32L4_TIM_SETISR(oneshot->tch, NULL, NULL, 0);
-  STM32L4_TIM_DISABLEINT(oneshot->tch, 0);
-  STM32L4_TIM_SETMODE(oneshot->tch, STM32L4_TIM_MODE_DISABLED);
-  STM32L4_TIM_ACKINT(oneshot->tch, 0);
-
-  /* The timer is no longer running */
-
-  oneshot->running = false;
-
-  /* Forward the event, clearing out any vestiges */
-
-  oneshot_handler  = (oneshot_handler_t)oneshot->handler;
-  oneshot->handler = NULL;
-  oneshot_arg      = (void *)oneshot->arg;
-  oneshot->arg     = NULL;
-
-  oneshot_handler(oneshot_arg);
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_allocate_handler
- *
- * Description:
- *   Allocate a timer callback handler for the oneshot instance.
- *
- * Input Parameters:
- *   oneshot - The state instance the new oneshot timer
- *
- * Returned Value:
- *   Returns zero (OK) on success.  This can only fail if the number of
- *   timers exceeds CONFIG_STM32L4_ONESHOT_MAXTIMERS.
- *
- ****************************************************************************/
-
-static inline int stm32l4_allocate_handler(struct stm32l4_oneshot_s *oneshot)
-{
-#if CONFIG_STM32L4_ONESHOT_MAXTIMERS > 1
-  int ret = -EBUSY;
-  int i;
-
-  /* Search for an unused handler */
-
-  sched_lock();
-  for (i = 0; i < CONFIG_STM32L4_ONESHOT_MAXTIMERS; i++)
-    {
-      /* Is this handler available? */
-
-      if (g_oneshot[i] == NULL)
-        {
-          /* Yes... assign it to this oneshot */
-
-          g_oneshot[i]   = oneshot;
-          oneshot->cbndx = i;
-          ret            = OK;
-          break;
-        }
-    }
-
-  sched_unlock();
-  return ret;
-
-#else
-  if (g_oneshot[0] == NULL)
-    {
-      g_oneshot[0] = oneshot;
-      return OK;
-    }
-
-  return -EBUSY;
-#endif
-}
-
-/****************************************************************************
- * Public Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_oneshot_initialize
- *
- * Description:
- *   Initialize the oneshot timer wrapper
- *
- * Input Parameters:
- *   oneshot    Caller allocated instance of the oneshot state structure
- *   chan       Timer counter channel to be used.
- *   resolution The required resolution of the timer in units of
- *              microseconds.  NOTE that the range is restricted to the
- *              range of uint16_t (excluding zero).
- *
- * Returned Value:
- *   Zero (OK) is returned on success; a negated errno value is returned
- *   on failure.
- *
- ****************************************************************************/
-
-int stm32l4_oneshot_initialize(FAR struct stm32l4_oneshot_s *oneshot,
-                               int chan, uint16_t resolution)
-{
-  uint32_t frequency;
-
-  tmrinfo("chan=%d resolution=%d usec\n", chan, resolution);
-  DEBUGASSERT(oneshot && resolution > 0);
-
-  /* Get the TC frequency the corresponds to the requested resolution */
-
-  frequency = USEC_PER_SEC / (uint32_t)resolution;
-  oneshot->frequency = frequency;
-
-  oneshot->tch = stm32l4_tim_init(chan);
-  if (!oneshot->tch)
-    {
-      tmrerr("ERROR: Failed to allocate TIM%d\n", chan);
-      return -EBUSY;
-    }
-
-  STM32L4_TIM_SETCLOCK(oneshot->tch, frequency);
-
-  /* Initialize the remaining fields in the state structure. */
-
-  oneshot->chan       = chan;
-  oneshot->running    = false;
-  oneshot->handler    = NULL;
-  oneshot->arg        = NULL;
-
-  /* Assign a callback handler to the oneshot */
-
-  return stm32l4_allocate_handler(oneshot);
-}
-
-/****************************************************************************
- * Name: stm32l4_oneshot_max_delay
- *
- * Description:
- *   Determine the maximum delay of the one-shot timer (in microseconds)
- *
- ****************************************************************************/
-
-int stm32l4_oneshot_max_delay(FAR struct stm32l4_oneshot_s *oneshot,
-                              FAR uint64_t *usec)
-{
-  DEBUGASSERT(oneshot != NULL && usec != NULL);
-
-  *usec = (uint64_t)(UINT32_MAX / oneshot->frequency) *
-          (uint64_t)USEC_PER_SEC;
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_oneshot_start
- *
- * Description:
- *   Start the oneshot timer
- *
- * Input Parameters:
- *   oneshot Caller allocated instance of the oneshot state structure.  This
- *           structure must have been previously initialized via a call to
- *           stm32l4_oneshot_initialize();
- *   handler The function to call when when the oneshot timer expires.
- *   arg     An opaque argument that will accompany the callback.
- *   ts      Provides the duration of the one shot timer.
- *
- * Returned Value:
- *   Zero (OK) is returned on success; a negated errno value is returned
- *   on failure.
- *
- ****************************************************************************/
-
-int stm32l4_oneshot_start(FAR struct stm32l4_oneshot_s *oneshot,
-                          oneshot_handler_t handler, FAR void *arg,
-                          FAR const struct timespec *ts)
-{
-  uint64_t usec;
-  uint64_t period;
-  irqstate_t flags;
-
-  tmrinfo("handler=%p arg=%p, ts=(%lu, %lu)\n",
-          handler, arg, (unsigned long)ts->tv_sec, (unsigned long)ts->tv_nsec);
-  DEBUGASSERT(oneshot && handler && ts);
-  DEBUGASSERT(oneshot->tch);
-
-  /* Was the oneshot already running? */
-
-  flags = enter_critical_section();
-  if (oneshot->running)
-    {
-      /* Yes.. then cancel it */
-
-      tmrinfo("Already running... cancelling\n");
-      (void)stm32l4_oneshot_cancel(oneshot, NULL);
-    }
-
-  /* Save the new handler and its argument */
-
-  oneshot->handler = handler;
-  oneshot->arg     = arg;
-
-  /* Express the delay in microseconds */
-
-  usec = (uint64_t)ts->tv_sec * USEC_PER_SEC +
-         (uint64_t)(ts->tv_nsec / NSEC_PER_USEC);
-
-  /* Get the timer counter frequency and determine the number of counts need
-   * to achieve the requested delay.
-   *
-   *   frequency = ticks / second
-   *   ticks     = seconds * frequency
-   *             = (usecs * frequency) / USEC_PER_SEC;
-   */
-
-  period = (usec * (uint64_t)oneshot->frequency) / USEC_PER_SEC;
-
-  tmrinfo("usec=%llu period=%08llx\n", usec, period);
-  DEBUGASSERT(period <= UINT32_MAX);
-
-  /* Set up to receive the callback when the interrupt occurs */
-
-  STM32L4_TIM_SETISR(oneshot->tch, stm32l4_oneshot_handler, oneshot, 0);
-
-  /* Set timer period */
-
-  oneshot->period = (uint32_t)period;
-  STM32L4_TIM_SETPERIOD(oneshot->tch, (uint32_t)period);
-
-  /* Start the counter */
-
-  STM32L4_TIM_SETMODE(oneshot->tch, STM32L4_TIM_MODE_PULSE);
-
-  STM32L4_TIM_ACKINT(oneshot->tch, 0);
-  STM32L4_TIM_ENABLEINT(oneshot->tch, 0);
-
-  /* Enable interrupts.  We should get the callback when the interrupt
-   * occurs.
-   */
-
-  oneshot->running = true;
-  leave_critical_section(flags);
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_oneshot_cancel
- *
- * Description:
- *   Cancel the oneshot timer and return the time remaining on the timer.
- *
- *   NOTE: This function may execute at a high rate with no timer running (as
- *   when pre-emption is enabled and disabled).
- *
- * Input Parameters:
- *   oneshot Caller allocated instance of the oneshot state structure.  This
- *           structure must have been previously initialized via a call to
- *           stm32l4_oneshot_initialize();
- *   ts      The location in which to return the time remaining on the
- *           oneshot timer.  A time of zero is returned if the timer is
- *           not running.  ts may be zero in which case the time remaining
- *           is not returned.
- *
- * Returned Value:
- *   Zero (OK) is returned on success.  A call to up_timer_cancel() when
- *   the timer is not active should also return success; a negated errno
- *   value is returned on any failure.
- *
- ****************************************************************************/
-
-int stm32l4_oneshot_cancel(FAR struct stm32l4_oneshot_s *oneshot,
-                           FAR struct timespec *ts)
-{
-  irqstate_t flags;
-  uint64_t usec;
-  uint64_t sec;
-  uint64_t nsec;
-  uint32_t count;
-  uint32_t period;
-
-  /* Was the timer running? */
-
-  flags = enter_critical_section();
-  if (!oneshot->running)
-    {
-      /* No.. Just return zero timer remaining and successful cancellation.
-       * This function may execute at a high rate with no timer running
-       * (as when pre-emption is enabled and disabled).
-       */
-
-      ts->tv_sec  = 0;
-      ts->tv_nsec = 0;
-      leave_critical_section(flags);
-      return OK;
-    }
-
-  /* Yes.. Get the timer counter and period registers and stop the counter.
-   * If the counter expires while we are doing this, the counter clock will
-   * be stopped, but the clock will not be disabled.
-   *
-   * The expected behavior is that the the counter register will freezes at
-   * a value equal to the RC register when the timer expires.  The counter
-   * should have values between 0 and RC in all other cased.
-   *
-   * REVISIT:  This does not appear to be the case.
-   */
-
-  tmrinfo("Cancelling...\n");
-
-  count  = STM32L4_TIM_GETCOUNTER(oneshot->tch);
-  period = oneshot->period;
-
-  /* Now we can disable the interrupt and stop the timer. */
-
-  STM32L4_TIM_DISABLEINT(oneshot->tch, 0);
-  STM32L4_TIM_SETISR(oneshot->tch, NULL, NULL, 0);
-  STM32L4_TIM_SETMODE(oneshot->tch, STM32L4_TIM_MODE_DISABLED);
-
-  oneshot->running = false;
-  oneshot->handler = NULL;
-  oneshot->arg     = NULL;
-  leave_critical_section(flags);
-
-  /* Did the caller provide us with a location to return the time
-   * remaining?
-   */
-
-  if (ts)
-    {
-      /* Yes.. then calculate and return the time remaining on the
-       * oneshot timer.
-       */
-
-      tmrinfo("period=%lu count=%lu\n",
-              (unsigned long)period, (unsigned long)count);
-
-      /* REVISIT: I am not certain why the timer counter value sometimes
-       * exceeds RC.  Might be a bug, or perhaps the counter does not stop
-       * in all cases.
-       */
-
-      if (count >= period)
-        {
-          /* No time remaining (?) */
-
-          ts->tv_sec  = 0;
-          ts->tv_nsec = 0;
-        }
-      else
-        {
-          /* The total time remaining is the difference.  Convert the that
-           * to units of microseconds.
-           *
-           *   frequency = ticks / second
-           *   seconds   = ticks * frequency
-           *   usecs     = (ticks * USEC_PER_SEC) / frequency;
-           */
-
-          usec        = (((uint64_t)(period - count)) * USEC_PER_SEC) /
-                        oneshot->frequency;
-
-          /* Return the time remaining in the correct form */
-
-          sec         = usec / USEC_PER_SEC;
-          nsec        = ((usec) - (sec * USEC_PER_SEC)) * NSEC_PER_USEC;
-
-          ts->tv_sec  = (time_t)sec;
-          ts->tv_nsec = (unsigned long)nsec;
-        }
-
-      tmrinfo("remaining (%lu, %lu)\n",
-              (unsigned long)ts->tv_sec, (unsigned long)ts->tv_nsec);
-    }
-
-  return OK;
-}
-
-#endif /* CONFIG_STM32L4_ONESHOT */
diff --git a/arch/arm/src/nrf52/nrf52_oneshot.h b/arch/arm/src/nrf52/nrf52_oneshot.h
deleted file mode 100644
index 410f0930d7..0000000000
--- a/arch/arm/src/nrf52/nrf52_oneshot.h
+++ /dev/null
@@ -1,212 +0,0 @@
-/****************************************************************************
- * arch/arm/src/stm32l4/stm32l4_oneshot.h
- *
- *   Copyright (C) 2016-2017 Gregory Nutt. All rights reserved.
- *   Author: Gregory Nutt <gnutt@nuttx.org>
- *           dev@ziggurat29.com
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ****************************************************************************/
-
-#ifndef __ARCH_ARM_SRC_STM32L4_ONESHOT_H
-#define __ARCH_ARM_SRC_STM32L4_ONESHOT_H
-
-/****************************************************************************
- * Included Files
- ****************************************************************************/
-
-#include <nuttx/config.h>
-
-#include <stdint.h>
-#include <time.h>
-
-#include <nuttx/irq.h>
-
-#include "stm32l4_tim.h"
-
-#ifdef CONFIG_STM32L4_ONESHOT
-
-/****************************************************************************
- * Pre-processor Definitions
- ****************************************************************************/
-
-#if !defined(CONFIG_STM32L4_ONESHOT_MAXTIMERS) || \
-    CONFIG_STM32L4_ONESHOT_MAXTIMERS < 1
-#  undef CONFIG_STM32L4_ONESHOT_MAXTIMERS
-#  define CONFIG_STM32L4_ONESHOT_MAXTIMERS 1
-#endif
-
-#if CONFIG_STM32L4_ONESHOT_MAXTIMERS > 8
-#  warning Additional logic required to handle more than 8 timers
-#  undef CONFIG_STM32L4_ONESHOT_MAXTIMERS
-#  define CONFIG_STM32L4_ONESHOT_MAXTIMERS 8
-#endif
-
-/****************************************************************************
- * Public Types
- ****************************************************************************/
-
-/* This describes the callback function that will be invoked when the oneshot
- * timer expires.  The oneshot fires, the client will receive:
- *
- *   arg - The opaque argument provided when the interrupt was registered
- */
-
-typedef void (*oneshot_handler_t)(void *arg);
-
-/* The oneshot client must allocate an instance of this structure and called
- * stm32l4_oneshot_initialize() before using the oneshot facilities.  The client
- * should not access the contents of this structure directly since the
- * contents are subject to change.
- */
-
-struct stm32l4_oneshot_s
-{
-  uint8_t chan;                       /* The timer/counter in use */
-#if CONFIG_STM32L4_ONESHOT_MAXTIMERS > 1
-  uint8_t cbndx;                      /* Timer callback handler index */
-#endif
-  volatile bool running;              /* True: the timer is running */
-  FAR struct stm32l4_tim_dev_s *tch;  /* Pointer returned by
-                                       * stm32l4_tim_init() */
-  volatile oneshot_handler_t handler; /* Oneshot expiration callback */
-  volatile void *arg;                 /* The argument that will accompany
-                                       * the callback */
-  uint32_t frequency;
-  uint32_t period;
-};
-
-/****************************************************************************
- * Public Data
- ****************************************************************************/
-
-#undef EXTERN
-#if defined(__cplusplus)
-#define EXTERN extern "C"
-extern "C"
-{
-#else
-#define EXTERN extern
-#endif
-
-/****************************************************************************
- * Public Function Prototypes
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_oneshot_initialize
- *
- * Description:
- *   Initialize the oneshot timer wrapper
- *
- * Input Parameters:
- *   oneshot    Caller allocated instance of the oneshot state structure
- *   chan       Timer counter channel to be used.
- *   resolution The required resolution of the timer in units of
- *              microseconds.  NOTE that the range is restricted to the
- *              range of uint16_t (excluding zero).
- *
- * Returned Value:
- *   Zero (OK) is returned on success; a negated errno value is returned
- *   on failure.
- *
- ****************************************************************************/
-
-int stm32l4_oneshot_initialize(struct stm32l4_oneshot_s *oneshot, int chan,
-                               uint16_t resolution);
-
-/****************************************************************************
- * Name: stm32l4_oneshot_max_delay
- *
- * Description:
- *   Determine the maximum delay of the one-shot timer (in microseconds)
- *
- ****************************************************************************/
-
-int stm32l4_oneshot_max_delay(struct stm32l4_oneshot_s *oneshot,
-                              uint64_t *usec);
-
-/****************************************************************************
- * Name: stm32l4_oneshot_start
- *
- * Description:
- *   Start the oneshot timer
- *
- * Input Parameters:
- *   oneshot Caller allocated instance of the oneshot state structure.  This
- *           structure must have been previously initialized via a call to
- *           stm32l4_oneshot_initialize();
- *   handler The function to call when when the oneshot timer expires.
- *   arg     An opaque argument that will accompany the callback.
- *   ts      Provides the duration of the one shot timer.
- *
- * Returned Value:
- *   Zero (OK) is returned on success; a negated errno value is returned
- *   on failure.
- *
- ****************************************************************************/
-
-int stm32l4_oneshot_start(struct stm32l4_oneshot_s *oneshot,
-                          oneshot_handler_t handler, void *arg,
-                          const struct timespec *ts);
-
-/****************************************************************************
- * Name: stm32l4_oneshot_cancel
- *
- * Description:
- *   Cancel the oneshot timer and return the time remaining on the timer.
- *
- *   NOTE: This function may execute at a high rate with no timer running (as
- *   when pre-emption is enabled and disabled).
- *
- * Input Parameters:
- *   oneshot Caller allocated instance of the oneshot state structure.  This
- *           structure must have been previously initialized via a call to
- *           stm32l4_oneshot_initialize();
- *   ts      The location in which to return the time remaining on the
- *           oneshot timer.  A time of zero is returned if the timer is
- *           not running.
- *
- * Returned Value:
- *   Zero (OK) is returned on success.  A call to up_timer_cancel() when
- *   the timer is not active should also return success; a negated errno
- *   value is returned on any failure.
- *
- ****************************************************************************/
-
-int stm32l4_oneshot_cancel(struct stm32l4_oneshot_s *oneshot,
-                           struct timespec *ts);
-
-#undef EXTERN
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* CONFIG_STM32L4_ONESHOT */
-#endif /* __ARCH_ARM_SRC_STM32L4_ONESHOT_H */
diff --git a/arch/arm/src/nrf52/nrf52_oneshot_lowerhalf.c b/arch/arm/src/nrf52/nrf52_oneshot_lowerhalf.c
deleted file mode 100644
index 6088513883..0000000000
--- a/arch/arm/src/nrf52/nrf52_oneshot_lowerhalf.c
+++ /dev/null
@@ -1,345 +0,0 @@
-/****************************************************************************
- *  arch/arm/src/stm32l4/stm32l4_oneshot_lowerhalf.c
- *
- *   Copyright (C) 2016 Gregory Nutt. All rights reserved.
- *   Authors: Gregory Nutt <gnutt@nuttx.org>
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ****************************************************************************/
-
-/****************************************************************************
- * Included Files
- ****************************************************************************/
-
-#include <nuttx/config.h>
-
-#include <stdint.h>
-#include <time.h>
-#include <assert.h>
-#include <debug.h>
-
-#include <nuttx/irq.h>
-#include <nuttx/kmalloc.h>
-#include <nuttx/timers/oneshot.h>
-
-#include "stm32l4_oneshot.h"
-
-/****************************************************************************
- * Private Types
- ****************************************************************************/
-
-/* This structure describes the state of the oneshot timer lower-half driver */
-
-struct stm32l4_oneshot_lowerhalf_s
-{
-  /* This is the part of the lower half driver that is visible to the upper-
-   * half client of the driver.  This must be the first thing in this
-   * structure so that pointers to struct oneshot_lowerhalf_s are cast
-   * compatible to struct stm32l4_oneshot_lowerhalf_s and vice versa.
-   */
-
-  struct oneshot_lowerhalf_s lh;  /* Common lower-half driver fields */
-
-  /* Private lower half data follows */
-
-  struct stm32l4_oneshot_s oneshot; /* STM32-specific oneshot state */
-  oneshot_callback_t callback;    /* internal handler that receives callback */
-  FAR void *arg;                  /* Argument that is passed to the handler */
-};
-
-/****************************************************************************
- * Private Function Prototypes
- ****************************************************************************/
-
-static void stm32l4_oneshot_handler(void *arg);
-
-static int stm32l4_max_delay(FAR struct oneshot_lowerhalf_s *lower,
-                             FAR struct timespec *ts);
-static int stm32l4_start(FAR struct oneshot_lowerhalf_s *lower,
-                         oneshot_callback_t callback, FAR void *arg,
-                         FAR const struct timespec *ts);
-static int stm32l4_cancel(FAR struct oneshot_lowerhalf_s *lower,
-                          FAR struct timespec *ts);
-
-/****************************************************************************
- * Private Data
- ****************************************************************************/
-
-/* Lower half operations */
-
-static const struct oneshot_operations_s g_oneshot_ops =
-{
-  .max_delay = stm32l4_max_delay,
-  .start     = stm32l4_start,
-  .cancel    = stm32l4_cancel,
-};
-
-/****************************************************************************
- * Private Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_oneshot_handler
- *
- * Description:
- *   Timer expiration handler
- *
- * Input Parameters:
- *   arg - Should be the same argument provided when stm32l4_oneshot_start()
- *         was called.
- *
- * Returned Value:
- *   None
- *
- ****************************************************************************/
-
-static void stm32l4_oneshot_handler(void *arg)
-{
-  FAR struct stm32l4_oneshot_lowerhalf_s *priv =
-    (FAR struct stm32l4_oneshot_lowerhalf_s *)arg;
-  oneshot_callback_t callback;
-  FAR void *cbarg;
-
-  DEBUGASSERT(priv != NULL);
-
-  /* Perhaps the callback was nullified in a race condition with
-   * stm32l4_cancel?
-   */
-
-  if (priv->callback)
-    {
-      /* Sample and nullify BEFORE executing callback (in case the callback
-       * restarts the oneshot).
-       */
-
-      callback       = priv->callback;
-      cbarg          = priv->arg;
-      priv->callback = NULL;
-      priv->arg      = NULL;
-
-      /* Then perform the callback */
-
-      callback(&priv->lh, cbarg);
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_max_delay
- *
- * Description:
- *   Determine the maximum delay of the one-shot timer (in microseconds)
- *
- * Input Parameters:
- *   lower   An instance of the lower-half oneshot state structure.  This
- *           structure must have been previously initialized via a call to
- *           oneshot_initialize();
- *   ts      The location in which to return the maxumum delay.
- *
- * Returned Value:
- *   Zero (OK) is returned on success; a negated errno value is returned
- *   on failure.
- *
- ****************************************************************************/
-
-static int stm32l4_max_delay(FAR struct oneshot_lowerhalf_s *lower,
-                             FAR struct timespec *ts)
-{
-  FAR struct stm32l4_oneshot_lowerhalf_s *priv =
-    (FAR struct stm32l4_oneshot_lowerhalf_s *)lower;
-  uint64_t usecs;
-  int ret;
-
-  DEBUGASSERT(priv != NULL && ts != NULL);
-  ret = stm32l4_oneshot_max_delay(&priv->oneshot, &usecs);
-  if (ret >= 0)
-    {
-      uint64_t sec = usecs / 1000000;
-      usecs -= 1000000 * sec;
-
-      ts->tv_sec  = (time_t)sec;
-      ts->tv_nsec = (long)(usecs * 1000);
-    }
-
-  return ret;
-}
-
-/****************************************************************************
- * Name: stm32l4_start
- *
- * Description:
- *   Start the oneshot timer
- *
- * Input Parameters:
- *   lower   An instance of the lower-half oneshot state structure.  This
- *           structure must have been previously initialized via a call to
- *           oneshot_initialize();
- *   handler The function to call when when the oneshot timer expires.
- *   arg     An opaque argument that will accompany the callback.
- *   ts      Provides the duration of the one shot timer.
- *
- * Returned Value:
- *   Zero (OK) is returned on success; a negated errno value is returned
- *   on failure.
- *
- ****************************************************************************/
-
-static int stm32l4_start(FAR struct oneshot_lowerhalf_s *lower,
-                         oneshot_callback_t callback, FAR void *arg,
-                         FAR const struct timespec *ts)
-{
-  FAR struct stm32l4_oneshot_lowerhalf_s *priv =
-    (FAR struct stm32l4_oneshot_lowerhalf_s *)lower;
-  irqstate_t flags;
-  int ret;
-
-  DEBUGASSERT(priv != NULL && callback != NULL && ts != NULL);
-
-  /* Save the callback information and start the timer */
-
-  flags          = enter_critical_section();
-  priv->callback = callback;
-  priv->arg      = arg;
-  ret            = stm32l4_oneshot_start(&priv->oneshot,
-                                         stm32l4_oneshot_handler, priv, ts);
-  leave_critical_section(flags);
-
-  if (ret < 0)
-    {
-      tmrerr("ERROR: stm32l4_oneshot_start failed: %d\n", flags);
-    }
-
-  return ret;
-}
-
-/****************************************************************************
- * Name: stm32l4_cancel
- *
- * Description:
- *   Cancel the oneshot timer and return the time remaining on the timer.
- *
- *   NOTE: This function may execute at a high rate with no timer running (as
- *   when pre-emption is enabled and disabled).
- *
- * Input Parameters:
- *   lower   Caller allocated instance of the oneshot state structure.  This
- *           structure must have been previously initialized via a call to
- *           oneshot_initialize();
- *   ts      The location in which to return the time remaining on the
- *           oneshot timer.  A time of zero is returned if the timer is
- *           not running.
- *
- * Returned Value:
- *   Zero (OK) is returned on success.  A call to up_timer_cancel() when
- *   the timer is not active should also return success; a negated errno
- *   value is returned on any failure.
- *
- ****************************************************************************/
-
-static int stm32l4_cancel(FAR struct oneshot_lowerhalf_s *lower,
-                          FAR struct timespec *ts)
-{
-  FAR struct stm32l4_oneshot_lowerhalf_s *priv =
-    (FAR struct stm32l4_oneshot_lowerhalf_s *)lower;
-  irqstate_t flags;
-  int ret;
-
-  DEBUGASSERT(priv != NULL);
-
-  /* Cancel the timer */
-
-  flags          = enter_critical_section();
-  ret            = stm32l4_oneshot_cancel(&priv->oneshot, ts);
-  priv->callback = NULL;
-  priv->arg      = NULL;
-  leave_critical_section(flags);
-
-  if (ret < 0)
-    {
-      tmrerr("ERROR: stm32l4_oneshot_cancel failed: %d\n", flags);
-    }
-
-  return ret;
-}
-
-/****************************************************************************
- * Public Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: oneshot_initialize
- *
- * Description:
- *   Initialize the oneshot timer and return a oneshot lower half driver
- *   instance.
- *
- * Input Parameters:
- *   chan       Timer counter channel to be used.
- *   resolution The required resolution of the timer in units of
- *              microseconds.  NOTE that the range is restricted to the
- *              range of uint16_t (excluding zero).
- *
- * Returned Value:
- *   On success, a non-NULL instance of the oneshot lower-half driver is
- *   returned.  NULL is return on any failure.
- *
- ****************************************************************************/
-
-FAR struct oneshot_lowerhalf_s *oneshot_initialize(int chan,
-                                                   uint16_t resolution)
-{
-  FAR struct stm32l4_oneshot_lowerhalf_s *priv;
-  int ret;
-
-  /* Allocate an instance of the lower half driver */
-
-  priv = (FAR struct stm32l4_oneshot_lowerhalf_s *)
-         kmm_zalloc(sizeof(struct stm32l4_oneshot_lowerhalf_s));
-
-  if (priv == NULL)
-    {
-      tmrerr("ERROR: Failed to initialized state structure\n");
-      return NULL;
-    }
-
-  /* Initialize the lower-half driver structure */
-
-  priv->lh.ops = &g_oneshot_ops;
-
-  /* Initialize the contained STM32 oneshot timer */
-
-  ret = stm32l4_oneshot_initialize(&priv->oneshot, chan, resolution);
-  if (ret < 0)
-    {
-      tmrerr("ERROR: stm32l4_oneshot_initialize failed: %d\n", ret);
-      kmm_free(priv);
-      return NULL;
-    }
-
-  return &priv->lh;
-}
diff --git a/arch/arm/src/nrf52/nrf52_otgfs.h b/arch/arm/src/nrf52/nrf52_otgfs.h
deleted file mode 100644
index 0d64e0a72c..0000000000
--- a/arch/arm/src/nrf52/nrf52_otgfs.h
+++ /dev/null
@@ -1,128 +0,0 @@
-/************************************************************************************
- * arch/arm/src/stm32l4/stm32l4_otgfs.h
- *
- *   Copyright (C) 2012-2013 Gregory Nutt. All rights reserved.
- *   Author: Gregory Nutt <gnutt@nuttx.org>
- *           dev@ziggurat29.com
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ************************************************************************************/
-
-#ifndef __ARCH_ARM_SRC_STM32L4_STM32L4_OTGFS_H
-#define __ARCH_ARM_SRC_STM32L4_STM32L4_OTGFS_H
-
-/************************************************************************************
- * Included Files
- ************************************************************************************/
-
-#include <nuttx/config.h>
-
-#include <stdint.h>
-
-#include "stm32l4.h"
-
-#include "chip/stm32l4x6xx_otgfs.h"
-
-#if defined(CONFIG_STM32L4_OTGFS)
-
-/************************************************************************************
- * Pre-processor Definitions
- ************************************************************************************/
-/* Configuration ********************************************************************/
-
-#ifndef CONFIG_OTGFS_PRI
-#  define CONFIG_OTGFS_PRI NVIC_SYSH_PRIORITY_DEFAULT
-#endif
-
-/************************************************************************************
- * Public Functions
- ************************************************************************************/
-
-#ifndef __ASSEMBLY__
-
-#undef EXTERN
-#if defined(__cplusplus)
-#define EXTERN extern "C"
-extern "C"
-{
-#else
-#define EXTERN extern
-#endif
-
-/****************************************************************************
- * Name: stm32l4_otgfshost_initialize
- *
- * Description:
- *   Initialize USB host device controller hardware.
- *
- * Input Parameters:
- *   controller -- If the device supports more than USB host controller, then
- *     this identifies which controller is being initialized.  Normally, this
- *     is just zero.
- *
- * Returned Value:
- *   And instance of the USB host interface.  The controlling task should
- *   use this interface to (1) call the wait() method to wait for a device
- *   to be connected, and (2) call the enumerate() method to bind the device
- *   to a class driver.
- *
- * Assumptions:
- * - This function should called in the initialization sequence in order
- *   to initialize the USB device functionality.
- * - Class drivers should be initialized prior to calling this function.
- *   Otherwise, there is a race condition if the device is already connected.
- *
- ****************************************************************************/
-
-#ifdef CONFIG_USBHOST
-struct usbhost_connection_s;
-FAR struct usbhost_connection_s *stm32l4_otgfshost_initialize(int controller);
-#endif
-
-/************************************************************************************
- * Name:  stm32l4_usbsuspend
- *
- * Description:
- *   Board logic must provide the stm32l4_usbsuspend logic if the OTG FS device driver
- *   is used.  This function is called whenever the USB enters or leaves suspend
- *   mode. This is an opportunity for the board logic to shutdown clocks, power,
- *   etc. while the USB is suspended.
- *
- ************************************************************************************/
-
-void stm32l4_usbsuspend(FAR struct usbdev_s *dev, bool resume);
-
-#undef EXTERN
-#if defined(__cplusplus)
-}
-#endif
-
-#endif /* __ASSEMBLY__ */
-#endif /* CONFIG_STM32L4_OTGFS */
-#endif /* __ARCH_ARM_SRC_STM32L4_STM32L4_OTGFS_H */
diff --git a/arch/arm/src/nrf52/nrf52_otgfsdev.c b/arch/arm/src/nrf52/nrf52_otgfsdev.c
deleted file mode 100644
index 23c91088da..0000000000
--- a/arch/arm/src/nrf52/nrf52_otgfsdev.c
+++ /dev/null
@@ -1,5811 +0,0 @@
-/****************************************************************************
- * arch/arm/src/stm32l4/stm32l4_otgfsdev.c
- *
- *   Copyright (C) 2012-2014 Gregory Nutt. All rights reserved.
- *   Author: Gregory Nutt <gnutt@nuttx.org>
- *           dev@ziggurat29.com
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ****************************************************************************/
-
-/****************************************************************************
- * Included Files
- ****************************************************************************/
-
-#include <nuttx/config.h>
-
-#include <sys/types.h>
-#include <stdint.h>
-#include <stdbool.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-#include <debug.h>
-
-#include <nuttx/arch.h>
-#include <nuttx/kmalloc.h>
-#include <nuttx/usb/usb.h>
-#include <nuttx/usb/usbdev.h>
-#include <nuttx/usb/usbdev_trace.h>
-
-#include <nuttx/irq.h>
-#include <arch/board/board.h>
-
-#include "chip.h"
-#include "up_arch.h"
-#include "up_internal.h"
-
-#include "stm32l4_otgfs.h"
-#include "stm32l4_pwr.h"
-
-#if defined(CONFIG_USBDEV) && (defined(CONFIG_STM32L4_OTGFS))
-
-/****************************************************************************
- * Pre-processor Definitions
- ****************************************************************************/
-/* Configuration ***************************************************************/
-
-#ifndef CONFIG_USBDEV_EP0_MAXSIZE
-#  define CONFIG_USBDEV_EP0_MAXSIZE 64
-#endif
-
-#ifndef CONFIG_USBDEV_SETUP_MAXDATASIZE
-#  define CONFIG_USBDEV_SETUP_MAXDATASIZE CONFIG_USBDEV_EP0_MAXSIZE
-#endif
-
-#ifndef CONFIG_USBDEV_MAXPOWER
-#  define CONFIG_USBDEV_MAXPOWER 100  /* mA */
-#endif
-
-/* There is 1.25Kb of FIFO memory.  The default partitions this memory
- * so that there is a TxFIFO allocated for each endpoint and with more
- * memory provided for the common RxFIFO.  A more knowledge-able
- * configuration would not allocate any TxFIFO space to OUT endpoints.
- */
-
-#ifndef CONFIG_USBDEV_RXFIFO_SIZE
-#  define CONFIG_USBDEV_RXFIFO_SIZE 512
-#endif
-
-#ifndef CONFIG_USBDEV_EP0_TXFIFO_SIZE
-#  define CONFIG_USBDEV_EP0_TXFIFO_SIZE 128
-#endif
-
-#ifndef CONFIG_USBDEV_EP1_TXFIFO_SIZE
-#  define CONFIG_USBDEV_EP1_TXFIFO_SIZE 128
-#endif
-
-#ifndef CONFIG_USBDEV_EP2_TXFIFO_SIZE
-#  define CONFIG_USBDEV_EP2_TXFIFO_SIZE 128
-#endif
-
-#ifndef CONFIG_USBDEV_EP3_TXFIFO_SIZE
-#  define CONFIG_USBDEV_EP3_TXFIFO_SIZE 128
-#endif
-
-#ifndef CONFIG_USBDEV_EP4_TXFIFO_SIZE
-#  define CONFIG_USBDEV_EP4_TXFIFO_SIZE 128
-#endif
-
-#ifndef CONFIG_USBDEV_EP5_TXFIFO_SIZE
-#  define CONFIG_USBDEV_EP5_TXFIFO_SIZE 128
-#endif
-
-/* Number of endpoints */
-
-#define STM32L4_NENDPOINTS  (6)          /* ep0-5 x 2 for IN and OUT */
-
-/* Adjust actual number of endpoints based upon size; 0 means 'not available',
- * and we expect that the first 0-length endpoint implies that all others
- * after are unused as well (irrespective of what their size is set to be).
- */
-
-#if CONFIG_USBDEV_EP1_TXFIFO_SIZE == 0
-#  undef STM32L4_NENDPOINTS
-#  define STM32L4_NENDPOINTS 1
-#  undef CONFIG_USBDEV_EP2_TXFIFO_SIZE
-#  define CONFIG_USBDEV_EP2_TXFIFO_SIZE 0
-#  undef CONFIG_USBDEV_EP3_TXFIFO_SIZE
-#  define CONFIG_USBDEV_EP3_TXFIFO_SIZE 0
-#  undef CONFIG_USBDEV_EP4_TXFIFO_SIZE
-#  define CONFIG_USBDEV_EP4_TXFIFO_SIZE 0
-#  undef CONFIG_USBDEV_EP5_TXFIFO_SIZE
-#  define CONFIG_USBDEV_EP5_TXFIFO_SIZE 0
-#elif CONFIG_USBDEV_EP2_TXFIFO_SIZE == 0
-#  undef STM32L4_NENDPOINTS
-#  define STM32L4_NENDPOINTS 2
-#  undef CONFIG_USBDEV_EP3_TXFIFO_SIZE
-#  define CONFIG_USBDEV_EP3_TXFIFO_SIZE 0
-#  undef CONFIG_USBDEV_EP4_TXFIFO_SIZE
-#  define CONFIG_USBDEV_EP4_TXFIFO_SIZE 0
-#  undef CONFIG_USBDEV_EP5_TXFIFO_SIZE
-#  define CONFIG_USBDEV_EP5_TXFIFO_SIZE 0
-#elif CONFIG_USBDEV_EP3_TXFIFO_SIZE == 0
-#  undef STM32L4_NENDPOINTS
-#  define STM32L4_NENDPOINTS 3
-#  undef CONFIG_USBDEV_EP4_TXFIFO_SIZE
-#  define CONFIG_USBDEV_EP4_TXFIFO_SIZE 0
-#  undef CONFIG_USBDEV_EP5_TXFIFO_SIZE
-#  define CONFIG_USBDEV_EP5_TXFIFO_SIZE 0
-#elif CONFIG_USBDEV_EP4_TXFIFO_SIZE == 0
-#  undef STM32L4_NENDPOINTS
-#  define STM32L4_NENDPOINTS 4
-#  undef CONFIG_USBDEV_EP5_TXFIFO_SIZE
-#  define CONFIG_USBDEV_EP5_TXFIFO_SIZE 0
-#elif CONFIG_USBDEV_EP5_TXFIFO_SIZE == 0
-#  undef STM32L4_NENDPOINTS
-#  define STM32L4_NENDPOINTS 5
-#endif
-
-/* Sanity check on allocations specified. */
-
-#if (CONFIG_USBDEV_RXFIFO_SIZE +\
-     CONFIG_USBDEV_EP0_TXFIFO_SIZE +\
-     CONFIG_USBDEV_EP1_TXFIFO_SIZE +\
-     CONFIG_USBDEV_EP2_TXFIFO_SIZE +\
-     CONFIG_USBDEV_EP3_TXFIFO_SIZE +\
-     CONFIG_USBDEV_EP4_TXFIFO_SIZE +\
-     CONFIG_USBDEV_EP5_TXFIFO_SIZE +\
-     0 ) > 1280
-#  error "FIFO allocations exceed FIFO memory size"
-#endif
-
-/* The actual FIFO addresses that we use must be aligned to 4-byte boundaries;
- * FIFO sizes must be provided in units of 32-bit words.
- */
-
-#define STM32L4_RXFIFO_BYTES     ((CONFIG_USBDEV_RXFIFO_SIZE + 3) & ~3)
-#define STM32L4_RXFIFO_WORDS     ((CONFIG_USBDEV_RXFIFO_SIZE + 3) >> 2)
-
-#define STM32L4_EP0_TXFIFO_BYTES ((CONFIG_USBDEV_EP0_TXFIFO_SIZE + 3) & ~3)
-#define STM32L4_EP0_TXFIFO_WORDS ((CONFIG_USBDEV_EP0_TXFIFO_SIZE + 3) >> 2)
-
-#if STM32L4_EP0_TXFIFO_WORDS < 16 || STM32L4_EP0_TXFIFO_WORDS > 256
-#  error "CONFIG_USBDEV_EP0_TXFIFO_SIZE is out of range"
-#endif
-
-#define STM32L4_EP1_TXFIFO_BYTES ((CONFIG_USBDEV_EP1_TXFIFO_SIZE + 3) & ~3)
-#define STM32L4_EP1_TXFIFO_WORDS ((CONFIG_USBDEV_EP1_TXFIFO_SIZE + 3) >> 2)
-
-#if STM32L4_EP1_TXFIFO_BYTES != 0 && STM32L4_EP1_TXFIFO_WORDS < 16
-#  error "CONFIG_USBDEV_EP1_TXFIFO_SIZE is out of range"
-#endif
-
-#define STM32L4_EP2_TXFIFO_BYTES ((CONFIG_USBDEV_EP2_TXFIFO_SIZE + 3) & ~3)
-#define STM32L4_EP2_TXFIFO_WORDS ((CONFIG_USBDEV_EP2_TXFIFO_SIZE + 3) >> 2)
-
-#if STM32L4_EP2_TXFIFO_BYTES != 0 && STM32L4_EP2_TXFIFO_WORDS < 16
-#  error "CONFIG_USBDEV_EP2_TXFIFO_SIZE is out of range"
-#endif
-
-#define STM32L4_EP3_TXFIFO_BYTES ((CONFIG_USBDEV_EP3_TXFIFO_SIZE + 3) & ~3)
-#define STM32L4_EP3_TXFIFO_WORDS ((CONFIG_USBDEV_EP3_TXFIFO_SIZE + 3) >> 2)
-
-#if STM32L4_EP3_TXFIFO_BYTES != 0 && STM32L4_EP3_TXFIFO_WORDS < 16
-#  error "CONFIG_USBDEV_EP3_TXFIFO_SIZE is out of range"
-#endif
-
-#define STM32L4_EP4_TXFIFO_BYTES ((CONFIG_USBDEV_EP4_TXFIFO_SIZE + 3) & ~3)
-#define STM32L4_EP4_TXFIFO_WORDS ((CONFIG_USBDEV_EP4_TXFIFO_SIZE + 3) >> 2)
-
-#if STM32L4_EP4_TXFIFO_BYTES != 0 && STM32L4_EP4_TXFIFO_WORDS < 16
-#  error "CONFIG_USBDEV_EP4_TXFIFO_SIZE is out of range"
-#endif
-
-#define STM32L4_EP5_TXFIFO_BYTES ((CONFIG_USBDEV_EP5_TXFIFO_SIZE + 3) & ~3)
-#define STM32L4_EP5_TXFIFO_WORDS ((CONFIG_USBDEV_EP5_TXFIFO_SIZE + 3) >> 2)
-
-#if STM32L4_EP5_TXFIFO_BYTES != 0 && STM32L4_EP5_TXFIFO_WORDS < 16
-#  error "CONFIG_USBDEV_EP5_TXFIFO_SIZE is out of range"
-#endif
-
-#define OTGFS_GINT_RESERVED (OTGFS_GINT_RES89 | \
-                             OTGFS_GINT_RES1617 | \
-                             OTGFS_GINT_RES22)
-
-#define OTGFS_GINT_RC_W1 (OTGFS_GINT_MMIS     | \
-                          OTGFS_GINT_SOF      | \
-                          OTGFS_GINT_ESUSP    | \
-                          OTGFS_GINT_USBSUSP  | \
-                          OTGFS_GINT_USBRST   | \
-                          OTGFS_GINT_ENUMDNE  | \
-                          OTGFS_GINT_ISOODRP  | \
-                          OTGFS_GINT_EOPF     | \
-                          OTGFS_GINT_IISOIXFR | \
-                          OTGFS_GINT_IISOOXFR | \
-                          OTGFS_GINT_RSTDET   | \
-                          OTGFS_GINT_LPMINT   | \
-                          OTGFS_GINT_CIDSCHG  | \
-                          OTGFS_GINT_DISC     | \
-                          OTGFS_GINT_SRQ      | \
-                          OTGFS_GINT_WKUP)
-
-/* Debug ***********************************************************************/
-/* Trace error codes */
-
-#define STM32L4_TRACEERR_ALLOCFAIL            0x01
-#define STM32L4_TRACEERR_BADCLEARFEATURE      0x02
-#define STM32L4_TRACEERR_BADDEVGETSTATUS      0x03
-#define STM32L4_TRACEERR_BADEPNO              0x04
-#define STM32L4_TRACEERR_BADEPGETSTATUS       0x05
-#define STM32L4_TRACEERR_BADGETCONFIG         0x06
-#define STM32L4_TRACEERR_BADGETSETDESC        0x07
-#define STM32L4_TRACEERR_BADGETSTATUS         0x08
-#define STM32L4_TRACEERR_BADSETADDRESS        0x09
-#define STM32L4_TRACEERR_BADSETCONFIG         0x0a
-#define STM32L4_TRACEERR_BADSETFEATURE        0x0b
-#define STM32L4_TRACEERR_BADTESTMODE          0x0c
-#define STM32L4_TRACEERR_BINDFAILED           0x0d
-#define STM32L4_TRACEERR_DISPATCHSTALL        0x0e
-#define STM32L4_TRACEERR_DRIVER               0x0f
-#define STM32L4_TRACEERR_DRIVERREGISTERED     0x10
-#define STM32L4_TRACEERR_EP0NOSETUP           0x11
-#define STM32L4_TRACEERR_EP0SETUPSTALLED      0x12
-#define STM32L4_TRACEERR_EPINNULLPACKET       0x13
-#define STM32L4_TRACEERR_EPINUNEXPECTED       0x14
-#define STM32L4_TRACEERR_EPOUTNULLPACKET      0x15
-#define STM32L4_TRACEERR_EPOUTUNEXPECTED      0x16
-#define STM32L4_TRACEERR_INVALIDCTRLREQ       0x17
-#define STM32L4_TRACEERR_INVALIDPARMS         0x18
-#define STM32L4_TRACEERR_IRQREGISTRATION      0x19
-#define STM32L4_TRACEERR_NOEP                 0x1a
-#define STM32L4_TRACEERR_NOTCONFIGURED        0x1b
-#define STM32L4_TRACEERR_EPOUTQEMPTY          0x1c
-#define STM32L4_TRACEERR_EPINREQEMPTY         0x1d
-#define STM32L4_TRACEERR_NOOUTSETUP           0x1e
-#define STM32L4_TRACEERR_POLLTIMEOUT          0x1f
-
-/* Trace interrupt codes */
-
-#define STM32L4_TRACEINTID_USB                1       /* USB Interrupt entry/exit */
-#define STM32L4_TRACEINTID_INTPENDING         2       /* On each pass through the loop */
-
-#define STM32L4_TRACEINTID_EPOUT              (10 + 0) /* First level interrupt decode */
-#define STM32L4_TRACEINTID_EPIN               (10 + 1)
-#define STM32L4_TRACEINTID_MISMATCH           (10 + 2)
-#define STM32L4_TRACEINTID_WAKEUP             (10 + 3)
-#define STM32L4_TRACEINTID_SUSPEND            (10 + 4)
-#define STM32L4_TRACEINTID_SOF                (10 + 5)
-#define STM32L4_TRACEINTID_RXFIFO             (10 + 6)
-#define STM32L4_TRACEINTID_DEVRESET           (10 + 7)
-#define STM32L4_TRACEINTID_ENUMDNE            (10 + 8)
-#define STM32L4_TRACEINTID_IISOIXFR           (10 + 9)
-#define STM32L4_TRACEINTID_IISOOXFR           (10 + 10)
-#define STM32L4_TRACEINTID_SRQ                (10 + 11)
-#define STM32L4_TRACEINTID_OTG                (10 + 12)
-
-#define STM32L4_TRACEINTID_EPOUT_XFRC         (40 + 0) /* EPOUT second level decode */
-#define STM32L4_TRACEINTID_EPOUT_EPDISD       (40 + 1)
-#define STM32L4_TRACEINTID_EPOUT_SETUP        (40 + 2)
-#define STM32L4_TRACEINTID_DISPATCH           (40 + 3)
-
-#define STM32L4_TRACEINTID_GETSTATUS          (50 + 0) /* EPOUT third level decode */
-#define STM32L4_TRACEINTID_EPGETSTATUS        (50 + 1)
-#define STM32L4_TRACEINTID_DEVGETSTATUS       (50 + 2)
-#define STM32L4_TRACEINTID_IFGETSTATUS        (50 + 3)
-#define STM32L4_TRACEINTID_CLEARFEATURE       (50 + 4)
-#define STM32L4_TRACEINTID_SETFEATURE         (50 + 5)
-#define STM32L4_TRACEINTID_SETADDRESS         (50 + 6)
-#define STM32L4_TRACEINTID_GETSETDESC         (50 + 7)
-#define STM32L4_TRACEINTID_GETCONFIG          (50 + 8)
-#define STM32L4_TRACEINTID_SETCONFIG          (50 + 9)
-#define STM32L4_TRACEINTID_GETSETIF           (50 + 10)
-#define STM32L4_TRACEINTID_SYNCHFRAME         (50 + 11)
-
-#define STM32L4_TRACEINTID_EPIN_XFRC          (70 + 0) /* EPIN second level decode */
-#define STM32L4_TRACEINTID_EPIN_TOC           (70 + 1)
-#define STM32L4_TRACEINTID_EPIN_ITTXFE        (70 + 2)
-#define STM32L4_TRACEINTID_EPIN_EPDISD        (70 + 3)
-#define STM32L4_TRACEINTID_EPIN_TXFE          (70 + 4)
-
-#define STM32L4_TRACEINTID_EPIN_EMPWAIT       (80 + 0) /* EPIN second level decode */
-
-#define STM32L4_TRACEINTID_OUTNAK             (90 + 0) /* RXFLVL second level decode */
-#define STM32L4_TRACEINTID_OUTRECVD           (90 + 1)
-#define STM32L4_TRACEINTID_OUTDONE            (90 + 2)
-#define STM32L4_TRACEINTID_SETUPDONE          (90 + 3)
-#define STM32L4_TRACEINTID_SETUPRECVD         (90 + 4)
-
-/* CONFIG_USB_DUMPBUFFER will dump the contents of buffers to the console. */
-
-#define CONFIG_USB_DUMPBUFFER
-
-#if !defined(CONFIG_DEBUG_INFO) || !defined(CONFIG_DEBUG_FEATURES)
-#  undef CONFIG_USB_DUMPBUFFER
-#endif
-#ifdef CONFIG_USB_DUMPBUFFER
-#  define usb_dumpbuffer(t,b,l) lib_dumpbuffer(t,b,l)
-#else
-#  define usb_dumpbuffer(t,b,l)
-#endif
-
-/* Endpoints ******************************************************************/
-
-/* Odd physical endpoint numbers are IN; even are OUT */
-
-#define STM32L4_EPPHYIN2LOG(epphy)     ((uint8_t)(epphy)|USB_DIR_IN)
-#define STM32L4_EPPHYOUT2LOG(epphy)    ((uint8_t)(epphy)|USB_DIR_OUT)
-
-/* Endpoint 0 */
-
-#define EP0                            (0)
-
-/* The set of all endpoints available to the class implementation (1-n).
- * This is a bitmap, and the first endpoint (0) is reserved.
- */
-
-#define STM32L4_EP_AVAILABLE           (((1 << STM32L4_NENDPOINTS) - 1) & ~1)
-
-/* Maximum packet sizes for full speed endpoints */
-
-#define STM32L4_MAXPACKET              (64)         /* Max packet size (1-64) */
-
-/* Delays **********************************************************************/
-
-#define STM32L4_READY_DELAY            200000
-#define STM32L4_FLUSH_DELAY            200000
-
-/* Request queue operations ****************************************************/
-
-#define stm32l4_rqempty(ep)            ((ep)->head == NULL)
-#define stm32l4_rqpeek(ep)             ((ep)->head)
-
-/* Standard stuff **************************************************************/
-
-#ifndef MIN
-#  define MIN(a,b) ((a) < (b) ? (a) : (b))
-#endif
-
-#ifndef MAX
-#  define MAX(a,b) ((a) > (b) ? (a) : (b))
-#endif
-
-/****************************************************************************
- * Private Types
- ****************************************************************************/
-
-/* Overall device state */
-
-enum stm32l4_devstate_e
-{
-  DEVSTATE_DEFAULT = 0,    /* Power-up, unconfigured state.  This state simply
-                            * means that the device is not yet been given an
-                            * address.
-                            *   SET:    At initialization, uninitialization,
-                            *           reset, and whenever the device address
-                            *           is set to zero
-                            *   TESTED: Never
-                            */
-  DEVSTATE_ADDRESSED,      /* Device address has been assigned, not no
-                            * configuration has yet been selected.
-                            *   SET:    When either a non-zero device address
-                            *           is first assigned or when the device
-                            *           is unconfigured (with configuration == 0)
-                            *   TESTED: never
-                            */
-  DEVSTATE_CONFIGURED,     /* Address assigned and configured:
-                            *   SET:    When the device has been addressed and
-                            *           an non-zero configuration has been selected.
-                            *   TESTED: In many places to assure that the USB device
-                            *           has been properly configured by the host.
-                            */
-};
-
-/* Endpoint 0 states */
-
-enum stm32l4_ep0state_e
-{
-  EP0STATE_IDLE = 0,       /* Idle State, leave on receiving a SETUP packet or
-                            * epsubmit:
-                            *   SET:    In stm32l4_epin() and stm32l4_epout() when
-                            *           we revert from request processing to
-                            *           SETUP processing.
-                            *   TESTED: Never
-                            */
-  EP0STATE_SETUP_OUT,      /* OUT SETUP packet received.  Waiting for the DATA
-                            * OUT phase of SETUP Packet to complete before
-                            * processing a SETUP command (without a USB request):
-                            *   SET:    Set in stm32l4_rxinterrupt() when SETUP OUT
-                            *           packet is received.
-                            *   TESTED: In stm32l4_ep0out_receive()
-                            */
-  EP0STATE_SETUP_READY,    /* IN SETUP packet received -OR- OUT SETUP packet and
-                            * accompanying data have been received.  Processing
-                            * of SETUP command will happen soon.
-                            *   SET:    (1) stm32l4_ep0out_receive() when the OUT
-                            *           SETUP data phase completes, or (2)
-                            *           stm32l4_rxinterrupt() when an IN SETUP is
-                            *           packet received.
-                            *   TESTED: Tested in stm32l4_epout_interrupt() when
-                            *           SETUP phase is done to see if the SETUP
-                            *           command is ready to be processed.  Also
-                            *           tested in stm32l4_ep0out_setup() just to
-                            *           double-check that we have a SETUP request
-                            *           and any accompanying data.
-                            */
-  EP0STATE_SETUP_PROCESS,  /* SETUP Packet is being processed by stm32l4_ep0out_setup():
-                            *   SET:    When SETUP packet received in EP0 OUT
-                            *   TESTED: Never
-                            */
-  EP0STATE_SETUPRESPONSE,  /* Short SETUP response write (without a USB request):
-                            *   SET:    When SETUP response is sent by
-                            *           stm32l4_ep0in_setupresponse()
-                            *   TESTED: Never
-                            */
-  EP0STATE_DATA_IN,        /* Waiting for data out stage (with a USB request):
-                            *   SET:    In stm32l4_epin_request() when a write
-                            *           request is processed on EP0.
-                            *   TESTED: In stm32l4_epin() to see if we should
-                            *           revert to SETUP processing.
-                            */
-  EP0STATE_DATA_OUT        /* Waiting for data in phase to complete ( with a
-                            * USB request)
-                            *   SET:    In stm32l4_epout_request() when a read
-                            *           request is processed on EP0.
-                            *   TESTED: In stm32l4_epout() to see if we should
-                            *           revert to SETUP processing
-                            */
-};
-
-/* Parsed control request */
-
-struct stm32l4_ctrlreq_s
-{
-  uint8_t  type;
-  uint8_t  req;
-  uint16_t value;
-  uint16_t index;
-  uint16_t len;
-};
-
-/* A container for a request so that the request may be retained in a list */
-
-struct stm32l4_req_s
-{
-  struct usbdev_req_s      req;           /* Standard USB request */
-  struct stm32l4_req_s    *flink;         /* Supports a singly linked list */
-};
-
-/* This is the internal representation of an endpoint */
-
-struct stm32l4_ep_s
-{
-  /* Common endpoint fields.  This must be the first thing defined in the
-   * structure so that it is possible to simply cast from struct usbdev_ep_s
-   * to struct stm32l4_ep_s.
-   */
-
-  struct usbdev_ep_s       ep;            /* Standard endpoint structure */
-
-  /* STM32-specific fields */
-
-  struct stm32l4_usbdev_s *dev;           /* Reference to private driver data */
-  struct stm32l4_req_s    *head;          /* Request list for this endpoint */
-  struct stm32l4_req_s    *tail;
-  uint8_t                  epphy;         /* Physical EP address */
-  uint8_t                  eptype: 2;     /* Endpoint type */
-  uint8_t                  active: 1;     /* 1: A request is being processed */
-  uint8_t                  stalled: 1;    /* 1: Endpoint is stalled */
-  uint8_t                  isin: 1;       /* 1: IN Endpoint */
-  uint8_t                  odd: 1;        /* 1: Odd frame */
-  uint8_t                  zlp: 1;        /* 1: Transmit a zero-length-packet (IN EPs only) */
-};
-
-/* This structure retains the state of the USB device controller */
-
-struct stm32l4_usbdev_s
-{
-  /* Common device fields.  This must be the first thing defined in the
-   * structure so that it is possible to simply cast from struct usbdev_s
-   * to struct stm32l4_usbdev_s.
-   */
-
-  struct usbdev_s          usbdev;
-
-  /* The bound device class driver */
-
-  struct usbdevclass_driver_s *driver;
-
-  /* STM32-specific fields */
-
-  uint8_t                  stalled: 1;    /* 1: Protocol stalled */
-  uint8_t                  selfpowered: 1; /* 1: Device is self powered */
-  uint8_t                  addressed: 1;  /* 1: Peripheral address has been set */
-  uint8_t                  configured: 1; /* 1: Class driver has been configured */
-  uint8_t                  wakeup: 1;     /* 1: Device remote wake-up */
-  uint8_t                  dotest: 1;     /* 1: Test mode selected */
-
-  uint8_t                  devstate: 4;   /* See enum stm32l4_devstate_e */
-  uint8_t                  ep0state: 4;   /* See enum stm32l4_ep0state_e */
-  uint8_t                  testmode: 4;   /* Selected test mode */
-  uint8_t                  epavail[2];    /* Bitset of available OUT/IN endpoints */
-
-  /* E0 SETUP data buffering.
-   *
-   * ctrlreq:
-   *   The 8-byte SETUP request is received on the EP0 OUT endpoint and is
-   *   saved.
-   *
-   * ep0data
-   *   For OUT SETUP requests, the SETUP data phase must also complete before
-   *   the SETUP command can be processed.  The pack receipt logic will save
-   *   the accompanying EP0 IN data in ep0data[] before the SETUP command is
-   *   processed.
-   *
-   *   For IN SETUP requests, the DATA phase will occur AFTER the SETUP
-   *   control request is processed.  In that case, ep0data[] may be used as
-   *   the response buffer.
-   *
-   * ep0datlen
-   *   Length of OUT DATA received in ep0data[] (Not used with OUT data)
-   */
-
-  struct usb_ctrlreq_s     ctrlreq;
-  uint8_t                  ep0data[CONFIG_USBDEV_SETUP_MAXDATASIZE];
-  uint16_t                 ep0datlen;
-
-  /* The endpoint lists */
-
-  struct stm32l4_ep_s      epin[STM32L4_NENDPOINTS];
-  struct stm32l4_ep_s      epout[STM32L4_NENDPOINTS];
-};
-
-/****************************************************************************
- * Private Function Prototypes
- ****************************************************************************/
-
-/* Register operations ********************************************************/
-
-#if defined(CONFIG_STM32L4_USBDEV_REGDEBUG) && defined(CONFIG_DEBUG_FEATURES)
-static uint32_t    stm32l4_getreg(uint32_t addr);
-static void        stm32l4_putreg(uint32_t val, uint32_t addr);
-#else
-# define stm32l4_getreg(addr)     getreg32(addr)
-# define stm32l4_putreg(val,addr) putreg32(val,addr)
-#endif
-
-/* Request queue operations ****************************************************/
-
-static FAR struct stm32l4_req_s *stm32l4_req_remfirst(FAR struct stm32l4_ep_s *privep);
-static bool       stm32l4_req_addlast(FAR struct stm32l4_ep_s *privep,
-                                      FAR struct stm32l4_req_s *req);
-
-/* Low level data transfers and request operations *****************************/
-/* Special endpoint 0 data transfer logic */
-
-static void        stm32l4_ep0in_setupresponse(FAR struct stm32l4_usbdev_s *priv,
-                                               FAR uint8_t *data, uint32_t nbytes);
-static inline void stm32l4_ep0in_transmitzlp(FAR struct stm32l4_usbdev_s *priv);
-static void        stm32l4_ep0in_activate(void);
-
-static void        stm32l4_ep0out_ctrlsetup(FAR struct stm32l4_usbdev_s *priv);
-
-/* IN request and TxFIFO handling */
-
-static void        stm32l4_txfifo_write(FAR struct stm32l4_ep_s *privep,
-                                        FAR uint8_t *buf, int nbytes);
-static void        stm32l4_epin_transfer(FAR struct stm32l4_ep_s *privep,
-                                         FAR uint8_t *buf, int nbytes);
-static void        stm32l4_epin_request(FAR struct stm32l4_usbdev_s *priv,
-                                        FAR struct stm32l4_ep_s *privep);
-
-/* OUT request and RxFIFO handling */
-
-static void        stm32l4_rxfifo_read(FAR struct stm32l4_ep_s *privep,
-                                       FAR uint8_t *dest, uint16_t len);
-static void        stm32l4_rxfifo_discard(FAR struct stm32l4_ep_s *privep, int len);
-static void        stm32l4_epout_complete(FAR struct stm32l4_usbdev_s *priv,
-                                          FAR struct stm32l4_ep_s *privep);
-static inline void stm32l4_ep0out_receive(FAR struct stm32l4_ep_s *privep, int bcnt);
-static inline void stm32l4_epout_receive(FAR struct stm32l4_ep_s *privep, int bcnt);
-static void        stm32l4_epout_request(FAR struct stm32l4_usbdev_s *priv,
-                                         FAR struct stm32l4_ep_s *privep);
-
-/* General request handling */
-
-static void        stm32l4_ep_flush(FAR struct stm32l4_ep_s *privep);
-static void        stm32l4_req_complete(FAR struct stm32l4_ep_s *privep,
-                                        int16_t result);
-static void        stm32l4_req_cancel(FAR struct stm32l4_ep_s *privep,
-                                      int16_t status);
-
-/* Interrupt handling **********************************************************/
-
-static struct      stm32l4_ep_s *stm32l4_ep_findbyaddr(struct stm32l4_usbdev_s *priv,
-                                                       uint16_t eplog);
-static int         stm32l4_req_dispatch(FAR struct stm32l4_usbdev_s *priv,
-                                        FAR const struct usb_ctrlreq_s *ctrl);
-static void        stm32l4_usbreset(FAR struct stm32l4_usbdev_s *priv);
-
-/* Second level OUT endpoint interrupt processing */
-
-static inline void stm32l4_ep0out_testmode(FAR struct stm32l4_usbdev_s *priv,
-                                           uint16_t index);
-static inline void stm32l4_ep0out_stdrequest(struct stm32l4_usbdev_s *priv,
-                                             FAR struct stm32l4_ctrlreq_s *ctrlreq);
-static inline void stm32l4_ep0out_setup(struct stm32l4_usbdev_s *priv);
-static inline void stm32l4_epout(FAR struct stm32l4_usbdev_s *priv,
-                                 uint8_t epno);
-static inline void stm32l4_epout_interrupt(FAR struct stm32l4_usbdev_s *priv);
-
-/* Second level IN endpoint interrupt processing */
-
-static inline void stm32l4_epin_runtestmode(FAR struct stm32l4_usbdev_s *priv);
-static inline void stm32l4_epin(FAR struct stm32l4_usbdev_s *priv, uint8_t epno);
-static inline void stm32l4_epin_txfifoempty(FAR struct stm32l4_usbdev_s *priv, int epno);
-static inline void stm32l4_epin_interrupt(FAR struct stm32l4_usbdev_s *priv);
-
-/* Other second level interrupt processing */
-
-static inline void stm32l4_resumeinterrupt(FAR struct stm32l4_usbdev_s *priv);
-static inline void stm32l4_suspendinterrupt(FAR struct stm32l4_usbdev_s *priv);
-static inline void stm32l4_rxinterrupt(FAR struct stm32l4_usbdev_s *priv);
-static inline void stm32l4_enuminterrupt(FAR struct stm32l4_usbdev_s *priv);
-#ifdef CONFIG_USBDEV_ISOCHRONOUS
-static inline void stm32l4_isocininterrupt(FAR struct stm32l4_usbdev_s *priv);
-static inline void stm32l4_isocoutinterrupt(FAR struct stm32l4_usbdev_s *priv);
-#endif
-#ifdef CONFIG_USBDEV_VBUSSENSING
-static inline void stm32l4_sessioninterrupt(FAR struct stm32l4_usbdev_s *priv);
-static inline void stm32l4_otginterrupt(FAR struct stm32l4_usbdev_s *priv);
-#endif
-
-/* First level interrupt processing */
-
-static int         stm32l4_usbinterrupt(int irq, FAR void *context, FAR void *arg);
-
-/* Endpoint operations *********************************************************/
-/* Global OUT NAK controls */
-
-static void        stm32l4_enablegonak(FAR struct stm32l4_ep_s *privep);
-static void        stm32l4_disablegonak(FAR struct stm32l4_ep_s *privep);
-
-/* Endpoint configuration */
-
-static int         stm32l4_epout_configure(FAR struct stm32l4_ep_s *privep,
-                                           uint8_t eptype, uint16_t maxpacket);
-static int         stm32l4_epin_configure(FAR struct stm32l4_ep_s *privep,
-                                          uint8_t eptype, uint16_t maxpacket);
-static int         stm32l4_ep_configure(FAR struct usbdev_ep_s *ep,
-                                        FAR const struct usb_epdesc_s *desc, bool last);
-static void        stm32l4_ep0_configure(FAR struct stm32l4_usbdev_s *priv);
-
-/* Endpoint disable */
-
-static void        stm32l4_epout_disable(FAR struct stm32l4_ep_s *privep);
-static void        stm32l4_epin_disable(FAR struct stm32l4_ep_s *privep);
-static int         stm32l4_ep_disable(FAR struct usbdev_ep_s *ep);
-
-/* Endpoint request management */
-
-static FAR struct usbdev_req_s *stm32l4_ep_allocreq(FAR struct usbdev_ep_s *ep);
-static void        stm32l4_ep_freereq(FAR struct usbdev_ep_s *ep,
-                                      FAR struct usbdev_req_s *);
-
-/* Endpoint buffer management */
-
-#ifdef CONFIG_USBDEV_DMA
-static void       *stm32l4_ep_allocbuffer(FAR struct usbdev_ep_s *ep, unsigned bytes);
-static void        stm32l4_ep_freebuffer(FAR struct usbdev_ep_s *ep, FAR void *buf);
-#endif
-
-/* Endpoint request submission */
-
-static int         stm32l4_ep_submit(FAR struct usbdev_ep_s *ep,
-                                     struct usbdev_req_s *req);
-
-/* Endpoint request cancellation */
-
-static int         stm32l4_ep_cancel(FAR struct usbdev_ep_s *ep,
-                                     struct usbdev_req_s *req);
-
-/* Stall handling */
-
-static int         stm32l4_epout_setstall(FAR struct stm32l4_ep_s *privep);
-static int         stm32l4_epin_setstall(FAR struct stm32l4_ep_s *privep);
-static int         stm32l4_ep_setstall(FAR struct stm32l4_ep_s *privep);
-static int         stm32l4_ep_clrstall(FAR struct stm32l4_ep_s *privep);
-static int         stm32l4_ep_stall(FAR struct usbdev_ep_s *ep, bool resume);
-static void        stm32l4_ep0_stall(FAR struct stm32l4_usbdev_s *priv);
-
-/* Endpoint allocation */
-
-static FAR struct usbdev_ep_s *stm32l4_ep_alloc(FAR struct usbdev_s *dev,
-                                                uint8_t epno, bool in, uint8_t eptype);
-static void        stm32l4_ep_free(FAR struct usbdev_s *dev,
-                                   FAR struct usbdev_ep_s *ep);
-
-/* USB device controller operations ********************************************/
-
-static int         stm32l4_getframe(struct usbdev_s *dev);
-static int         stm32l4_wakeup(struct usbdev_s *dev);
-static int         stm32l4_selfpowered(struct usbdev_s *dev, bool selfpowered);
-static int         stm32l4_pullup(struct usbdev_s *dev, bool enable);
-static void        stm32l4_setaddress(struct stm32l4_usbdev_s *priv,
-                                      uint16_t address);
-static int         stm32l4_txfifo_flush(uint32_t txfnum);
-static int         stm32l4_rxfifo_flush(void);
-
-/* Initialization **************************************************************/
-
-static void        stm32l4_swinitialize(FAR struct stm32l4_usbdev_s *priv);
-static void        stm32l4_hwinitialize(FAR struct stm32l4_usbdev_s *priv);
-
-/****************************************************************************
- * Private Data
- ****************************************************************************/
-/* Since there is only a single USB interface, all status information can be
- * be simply retained in a single global instance.
- */
-
-static struct stm32l4_usbdev_s g_otgfsdev;
-
-static const struct usbdev_epops_s g_epops =
-{
-  .configure   = stm32l4_ep_configure,
-  .disable     = stm32l4_ep_disable,
-  .allocreq    = stm32l4_ep_allocreq,
-  .freereq     = stm32l4_ep_freereq,
-#ifdef CONFIG_USBDEV_DMA
-  .allocbuffer = stm32l4_ep_allocbuffer,
-  .freebuffer  = stm32l4_ep_freebuffer,
-#endif
-  .submit      = stm32l4_ep_submit,
-  .cancel      = stm32l4_ep_cancel,
-  .stall       = stm32l4_ep_stall,
-};
-
-static const struct usbdev_ops_s g_devops =
-{
-  .allocep     = stm32l4_ep_alloc,
-  .freeep      = stm32l4_ep_free,
-  .getframe    = stm32l4_getframe,
-  .wakeup      = stm32l4_wakeup,
-  .selfpowered = stm32l4_selfpowered,
-  .pullup      = stm32l4_pullup,
-};
-
-/* Device error strings that may be enabled for more descriptive USB trace
- * output.
- */
-
-#ifdef CONFIG_USBDEV_TRACE_STRINGS
-const struct trace_msg_t g_usb_trace_strings_deverror[] =
-{
-  TRACE_STR(STM32L4_TRACEERR_ALLOCFAIL       ),
-  TRACE_STR(STM32L4_TRACEERR_BADCLEARFEATURE ),
-  TRACE_STR(STM32L4_TRACEERR_BADDEVGETSTATUS ),
-  TRACE_STR(STM32L4_TRACEERR_BADEPNO         ),
-  TRACE_STR(STM32L4_TRACEERR_BADEPGETSTATUS  ),
-  TRACE_STR(STM32L4_TRACEERR_BADGETCONFIG    ),
-  TRACE_STR(STM32L4_TRACEERR_BADGETSETDESC   ),
-  TRACE_STR(STM32L4_TRACEERR_BADGETSTATUS    ),
-  TRACE_STR(STM32L4_TRACEERR_BADSETADDRESS   ),
-  TRACE_STR(STM32L4_TRACEERR_BADSETCONFIG    ),
-  TRACE_STR(STM32L4_TRACEERR_BADSETFEATURE   ),
-  TRACE_STR(STM32L4_TRACEERR_BADTESTMODE     ),
-  TRACE_STR(STM32L4_TRACEERR_BINDFAILED      ),
-  TRACE_STR(STM32L4_TRACEERR_DISPATCHSTALL   ),
-  TRACE_STR(STM32L4_TRACEERR_DRIVER          ),
-  TRACE_STR(STM32L4_TRACEERR_DRIVERREGISTERED),
-  TRACE_STR(STM32L4_TRACEERR_EP0NOSETUP      ),
-  TRACE_STR(STM32L4_TRACEERR_EP0SETUPSTALLED ),
-  TRACE_STR(STM32L4_TRACEERR_EPINNULLPACKET  ),
-  TRACE_STR(STM32L4_TRACEERR_EPINUNEXPECTED  ),
-  TRACE_STR(STM32L4_TRACEERR_EPOUTNULLPACKET ),
-  TRACE_STR(STM32L4_TRACEERR_EPOUTUNEXPECTED ),
-  TRACE_STR(STM32L4_TRACEERR_INVALIDCTRLREQ  ),
-  TRACE_STR(STM32L4_TRACEERR_INVALIDPARMS    ),
-  TRACE_STR(STM32L4_TRACEERR_IRQREGISTRATION ),
-  TRACE_STR(STM32L4_TRACEERR_NOEP            ),
-  TRACE_STR(STM32L4_TRACEERR_NOTCONFIGURED   ),
-  TRACE_STR(STM32L4_TRACEERR_EPOUTQEMPTY     ),
-  TRACE_STR(STM32L4_TRACEERR_EPINREQEMPTY    ),
-  TRACE_STR(STM32L4_TRACEERR_NOOUTSETUP      ),
-  TRACE_STR(STM32L4_TRACEERR_POLLTIMEOUT     ),
-  TRACE_STR_END
-};
-#endif
-
-/* Interrupt event strings that may be enabled for more descriptive USB trace
- * output.
- */
-
-#ifdef CONFIG_USBDEV_TRACE_STRINGS
-const struct trace_msg_t g_usb_trace_strings_intdecode[] =
-{
-  TRACE_STR(STM32L4_TRACEINTID_USB         ),
-  TRACE_STR(STM32L4_TRACEINTID_INTPENDING  ),
-  TRACE_STR(STM32L4_TRACEINTID_EPOUT       ),
-  TRACE_STR(STM32L4_TRACEINTID_EPIN        ),
-  TRACE_STR(STM32L4_TRACEINTID_MISMATCH    ),
-  TRACE_STR(STM32L4_TRACEINTID_WAKEUP      ),
-  TRACE_STR(STM32L4_TRACEINTID_SUSPEND     ),
-  TRACE_STR(STM32L4_TRACEINTID_SOF         ),
-  TRACE_STR(STM32L4_TRACEINTID_RXFIFO      ),
-  TRACE_STR(STM32L4_TRACEINTID_DEVRESET    ),
-  TRACE_STR(STM32L4_TRACEINTID_ENUMDNE     ),
-  TRACE_STR(STM32L4_TRACEINTID_IISOIXFR    ),
-  TRACE_STR(STM32L4_TRACEINTID_IISOOXFR    ),
-  TRACE_STR(STM32L4_TRACEINTID_SRQ         ),
-  TRACE_STR(STM32L4_TRACEINTID_OTG         ),
-  TRACE_STR(STM32L4_TRACEINTID_EPOUT_XFRC  ),
-  TRACE_STR(STM32L4_TRACEINTID_EPOUT_EPDISD),
-  TRACE_STR(STM32L4_TRACEINTID_EPOUT_SETUP ),
-  TRACE_STR(STM32L4_TRACEINTID_DISPATCH    ),
-  TRACE_STR(STM32L4_TRACEINTID_GETSTATUS   ),
-  TRACE_STR(STM32L4_TRACEINTID_EPGETSTATUS ),
-  TRACE_STR(STM32L4_TRACEINTID_DEVGETSTATUS),
-  TRACE_STR(STM32L4_TRACEINTID_IFGETSTATUS ),
-  TRACE_STR(STM32L4_TRACEINTID_CLEARFEATURE),
-  TRACE_STR(STM32L4_TRACEINTID_SETFEATURE  ),
-  TRACE_STR(STM32L4_TRACEINTID_SETADDRESS  ),
-  TRACE_STR(STM32L4_TRACEINTID_GETSETDESC  ),
-  TRACE_STR(STM32L4_TRACEINTID_GETCONFIG   ),
-  TRACE_STR(STM32L4_TRACEINTID_SETCONFIG   ),
-  TRACE_STR(STM32L4_TRACEINTID_GETSETIF    ),
-  TRACE_STR(STM32L4_TRACEINTID_SYNCHFRAME  ),
-  TRACE_STR(STM32L4_TRACEINTID_EPIN_XFRC   ),
-  TRACE_STR(STM32L4_TRACEINTID_EPIN_TOC    ),
-  TRACE_STR(STM32L4_TRACEINTID_EPIN_ITTXFE ),
-  TRACE_STR(STM32L4_TRACEINTID_EPIN_EPDISD ),
-  TRACE_STR(STM32L4_TRACEINTID_EPIN_TXFE   ),
-  TRACE_STR(STM32L4_TRACEINTID_EPIN_EMPWAIT),
-  TRACE_STR(STM32L4_TRACEINTID_OUTNAK      ),
-  TRACE_STR(STM32L4_TRACEINTID_OUTRECVD    ),
-  TRACE_STR(STM32L4_TRACEINTID_OUTDONE     ),
-  TRACE_STR(STM32L4_TRACEINTID_SETUPDONE   ),
-  TRACE_STR(STM32L4_TRACEINTID_SETUPRECVD  ),
-  TRACE_STR_END
-};
-#endif
-
-/****************************************************************************
- * Public Data
- ****************************************************************************/
-
-/****************************************************************************
- * Private Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_getreg
- *
- * Description:
- *   Get the contents of an STM32 register
- *
- ****************************************************************************/
-
-#if defined(CONFIG_STM32L4_USBDEV_REGDEBUG) && defined(CONFIG_DEBUG_FEATURES)
-static uint32_t stm32l4_getreg(uint32_t addr)
-{
-  static uint32_t prevaddr = 0;
-  static uint32_t preval = 0;
-  static uint32_t count = 0;
-
-  /* Read the value from the register */
-
-  uint32_t val = getreg32(addr);
-
-  /* Is this the same value that we read from the same register last time?  Are
-   * we polling the register?  If so, suppress some of the output.
-   */
-
-  if (addr == prevaddr && val == preval)
-    {
-      if (count == 0xffffffff || ++count > 3)
-        {
-          if (count == 4)
-            {
-              uinfo("...\n");
-            }
-
-          return val;
-        }
-    }
-
-  /* No this is a new address or value */
-
-  else
-    {
-      /* Did we print "..." for the previous value? */
-
-      if (count > 3)
-        {
-          /* Yes.. then show how many times the value repeated */
-
-          uinfo("[repeats %d more times]\n", count - 3);
-        }
-
-      /* Save the new address, value, and count */
-
-      prevaddr = addr;
-      preval   = val;
-      count    = 1;
-    }
-
-  /* Show the register value read */
-
-  uinfo("%08x->%08x\n", addr, val);
-  return val;
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_putreg
- *
- * Description:
- *   Set the contents of an STM32 register to a value
- *
- ****************************************************************************/
-
-#if defined(CONFIG_STM32L4_USBDEV_REGDEBUG) && defined(CONFIG_DEBUG_FEATURES)
-static void stm32l4_putreg(uint32_t val, uint32_t addr)
-{
-  /* Show the register value being written */
-
-  uinfo("%08x<-%08x\n", addr, val);
-
-  /* Write the value */
-
-  putreg32(val, addr);
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_req_remfirst
- *
- * Description:
- *   Remove a request from the head of an endpoint request queue
- *
- ****************************************************************************/
-
-static FAR struct stm32l4_req_s *stm32l4_req_remfirst(FAR struct stm32l4_ep_s *privep)
-{
-  FAR struct stm32l4_req_s *ret = privep->head;
-
-  if (ret)
-    {
-      privep->head = ret->flink;
-      if (!privep->head)
-        {
-          privep->tail = NULL;
-        }
-
-      ret->flink = NULL;
-    }
-
-  return ret;
-}
-
-/****************************************************************************
- * Name: stm32l4_req_addlast
- *
- * Description:
- *   Add a request to the end of an endpoint request queue
- *
- ****************************************************************************/
-
-static bool stm32l4_req_addlast(FAR struct stm32l4_ep_s *privep,
-                                FAR struct stm32l4_req_s *req)
-{
-  bool is_empty = !privep->head;
-
-  req->flink = NULL;
-  if (is_empty)
-    {
-      privep->head = req;
-      privep->tail = req;
-    }
-  else
-    {
-      privep->tail->flink = req;
-      privep->tail        = req;
-    }
-
-  return is_empty;
-}
-
-/****************************************************************************
- * Name: stm32l4_ep0in_setupresponse
- *
- * Description:
- *   Schedule a short transfer on Endpoint 0 (IN or OUT)
- *
- ****************************************************************************/
-
-static void stm32l4_ep0in_setupresponse(FAR struct stm32l4_usbdev_s *priv,
-                                        FAR uint8_t *buf, uint32_t nbytes)
-{
-  stm32l4_epin_transfer(&priv->epin[EP0], buf, nbytes);
-  priv->ep0state = EP0STATE_SETUPRESPONSE;
-  stm32l4_ep0out_ctrlsetup(priv);
-}
-
-/****************************************************************************
- * Name: stm32l4_ep0in_transmitzlp
- *
- * Description:
- *   Send a zero length packet (ZLP) on endpoint 0 IN
- *
- ****************************************************************************/
-
-static inline void stm32l4_ep0in_transmitzlp(FAR struct stm32l4_usbdev_s *priv)
-{
-  stm32l4_ep0in_setupresponse(priv, NULL, 0);
-}
-
-/****************************************************************************
- * Name: stm32l4_ep0in_activate
- *
- * Description:
- *   Activate the endpoint 0 IN endpoint.
- *
- ****************************************************************************/
-
-static void stm32l4_ep0in_activate(void)
-{
-  uint32_t regval;
-
-  /* Set the max packet size  of the IN EP. */
-
-  regval  = stm32l4_getreg(STM32L4_OTGFS_DIEPCTL(0));
-  regval &= ~OTGFS_DIEPCTL0_MPSIZ_MASK;
-
-#if CONFIG_USBDEV_EP0_MAXSIZE == 8
-  regval |= OTGFS_DIEPCTL0_MPSIZ_8;
-#elif CONFIG_USBDEV_EP0_MAXSIZE == 16
-  regval |= OTGFS_DIEPCTL0_MPSIZ_16;
-#elif CONFIG_USBDEV_EP0_MAXSIZE == 32
-  regval |= OTGFS_DIEPCTL0_MPSIZ_32;
-#elif CONFIG_USBDEV_EP0_MAXSIZE == 64
-  regval |= OTGFS_DIEPCTL0_MPSIZ_64;
-#else
-#  error "Unsupported value of CONFIG_USBDEV_EP0_MAXSIZE"
-#endif
-
-  stm32l4_putreg(regval, STM32L4_OTGFS_DIEPCTL(0));
-
-  /* Clear global IN NAK */
-
-  regval  = stm32l4_getreg(STM32L4_OTGFS_DCTL);
-  regval |= OTGFS_DCTL_CGINAK;
-  stm32l4_putreg(regval, STM32L4_OTGFS_DCTL);
-}
-
-/****************************************************************************
- * Name: stm32l4_ep0out_ctrlsetup
- *
- * Description:
- *   Setup to receive a SETUP packet.
- *
- ****************************************************************************/
-
-static void stm32l4_ep0out_ctrlsetup(FAR struct stm32l4_usbdev_s *priv)
-{
-  uint32_t regval;
-
-  /* Setup the hardware to perform the SETUP transfer */
-
-  regval = (USB_SIZEOF_CTRLREQ * 3 << OTGFS_DOEPTSIZ0_XFRSIZ_SHIFT) |
-           (OTGFS_DOEPTSIZ0_PKTCNT) |
-           (3 << OTGFS_DOEPTSIZ0_STUPCNT_SHIFT);
-  stm32l4_putreg(regval, STM32L4_OTGFS_DOEPTSIZ(0));
-
-  /* Then clear NAKing and enable the transfer */
-
-  regval  = stm32l4_getreg(STM32L4_OTGFS_DOEPCTL(0));
-  regval |= (OTGFS_DOEPCTL0_CNAK | OTGFS_DOEPCTL0_EPENA);
-  stm32l4_putreg(regval, STM32L4_OTGFS_DOEPCTL(0));
-}
-
-/****************************************************************************
- * Name: stm32l4_txfifo_write
- *
- * Description:
- *   Send data to the endpoint's TxFIFO.
- *
- ****************************************************************************/
-
-static void stm32l4_txfifo_write(FAR struct stm32l4_ep_s *privep,
-                                 FAR uint8_t *buf, int nbytes)
-{
-  uint32_t regaddr;
-  uint32_t regval;
-  int nwords;
-  int i;
-
-  usb_dumpbuffer(">>>", buf, nbytes);
-
-  /* Convert the number of bytes to words */
-
-  nwords = (nbytes + 3) >> 2;
-
-  /* Get the TxFIFO for this endpoint (same as the endpoint number) */
-
-  regaddr = STM32L4_OTGFS_DFIFO_DEP(privep->epphy);
-
-  /* Then transfer each word to the TxFIFO */
-
-  for (i = 0; i < nwords; i++)
-    {
-      /* Read four bytes from the source buffer (to avoid unaligned accesses)
-       * and pack these into one 32-bit word (little endian).
-       */
-
-      regval  = (uint32_t) * buf++;
-      regval |= ((uint32_t) * buf++) << 8;
-      regval |= ((uint32_t) * buf++) << 16;
-      regval |= ((uint32_t) * buf++) << 24;
-
-      /* Then write the packet data to the TxFIFO */
-
-      stm32l4_putreg(regval, regaddr);
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_epin_transfer
- *
- * Description:
- *   Start the Tx data transfer
- *
- ****************************************************************************/
-
-static void stm32l4_epin_transfer(FAR struct stm32l4_ep_s *privep,
-                                  FAR uint8_t *buf, int nbytes)
-{
-  uint32_t pktcnt;
-  uint32_t regval;
-
-  /* Read the DIEPSIZx register */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_DIEPTSIZ(privep->epphy));
-
-  /* Clear the XFRSIZ, PKTCNT, and MCNT field of the DIEPSIZx register */
-
-  regval &= ~(OTGFS_DIEPTSIZ_XFRSIZ_MASK | OTGFS_DIEPTSIZ_PKTCNT_MASK |
-              OTGFS_DIEPTSIZ_MCNT_MASK);
-
-  /* Are we sending a zero length packet (ZLP) */
-
-  if (nbytes == 0)
-    {
-      /* Yes.. leave the transfer size at zero and set the packet count to 1 */
-
-      pktcnt = 1;
-    }
-  else
-    {
-      /* No.. Program the transfer size and packet count .  First calculate:
-       *
-       * xfrsize = The total number of bytes to be sent.
-       * pktcnt  = the number of packets (of maxpacket bytes) required to
-       *   perform the transfer.
-       */
-
-      pktcnt  = ((uint32_t)nbytes + (privep->ep.maxpacket - 1)) / privep->ep.maxpacket;
-    }
-
-  /* Set the XFRSIZ and PKTCNT */
-
-  regval |= (pktcnt << OTGFS_DIEPTSIZ_PKTCNT_SHIFT);
-  regval |= ((uint32_t)nbytes << OTGFS_DIEPTSIZ_XFRSIZ_SHIFT);
-
-  /* If this is an isochronous endpoint, then set the multi-count field to
-   * the PKTCNT as well.
-   */
-
-  if (privep->eptype == USB_EP_ATTR_XFER_ISOC)
-    {
-      regval |= (pktcnt << OTGFS_DIEPTSIZ_MCNT_SHIFT);
-    }
-
-  /* Save DIEPSIZx register value */
-
-  stm32l4_putreg(regval, STM32L4_OTGFS_DIEPTSIZ(privep->epphy));
-
-  /* Read the DIEPCTLx register */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_DIEPCTL(privep->epphy));
-
-  /* If this is an isochronous endpoint, then set the even/odd frame bit
-   * the DIEPCTLx register.
-   */
-
-  if (privep->eptype == USB_EP_ATTR_XFER_ISOC)
-    {
-      /* Check bit 0 of the frame number of the received SOF and set the
-       * even/odd frame to match.
-       */
-
-      uint32_t status = stm32l4_getreg(STM32L4_OTGFS_DSTS);
-      if ((status & OTGFS_DSTS_SOFFN0) == OTGFS_DSTS_SOFFN_EVEN)
-        {
-          regval |= OTGFS_DIEPCTL_SEVNFRM;
-        }
-      else
-        {
-          regval |= OTGFS_DIEPCTL_SODDFRM;
-        }
-    }
-
-  /* EP enable, IN data in FIFO */
-
-  regval &= ~OTGFS_DIEPCTL_EPDIS;
-  regval |= (OTGFS_DIEPCTL_CNAK | OTGFS_DIEPCTL_EPENA);
-  stm32l4_putreg(regval, STM32L4_OTGFS_DIEPCTL(privep->epphy));
-
-  /* Transfer the data to the TxFIFO.  At this point, the caller has already
-   * assured that there is sufficient space in the TxFIFO to hold the transfer
-   * we can just blindly continue.
-   */
-
-  stm32l4_txfifo_write(privep, buf, nbytes);
-}
-
-/****************************************************************************
- * Name: stm32l4_epin_request
- *
- * Description:
- *   Begin or continue write request processing.
- *
- ****************************************************************************/
-
-static void stm32l4_epin_request(FAR struct stm32l4_usbdev_s *priv,
-                                 FAR struct stm32l4_ep_s *privep)
-{
-  struct stm32l4_req_s *privreq;
-  uint32_t regaddr;
-  uint32_t regval;
-  uint8_t *buf;
-  int nbytes;
-  int nwords;
-  int bytesleft;
-
-  /* We get here in one of four possible ways.  From three interrupting
-   * events:
-   *
-   * 1. From stm32l4_epin as part of the transfer complete interrupt processing
-   *    This interrupt indicates that the last transfer has completed.
-   * 2. As part of the ITTXFE interrupt processing.  That interrupt indicates
-   *    that an IN token was received when the associated TxFIFO was empty.
-   * 3. From stm32l4_epin_txfifoempty as part of the TXFE interrupt processing.
-   *    The TXFE interrupt is only enabled when the TxFIFO is full and the
-   *    software must wait for space to become available in the TxFIFO.
-   *
-   * And this function may be called immediately when the write request is
-   * queue to start up the next transaction.
-   *
-   * 4. From stm32l4_ep_submit when a new write request is received WHILE the
-   *    endpoint is not active (privep->active == false).
-   */
-
-  /* Check the request from the head of the endpoint request queue */
-
-  privreq = stm32l4_rqpeek(privep);
-  if (!privreq)
-    {
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_EPINREQEMPTY), privep->epphy);
-
-      /* There is no TX transfer in progress and no new pending TX
-       * requests to send.  To stop transmitting any data on a particular
-       * IN endpoint, the application must set the IN NAK bit. To set this
-       * bit, the following field must be programmed.
-       */
-
-      regaddr = STM32L4_OTGFS_DIEPCTL(privep->epphy);
-      regval  = stm32l4_getreg(regaddr);
-      regval |= OTGFS_DIEPCTL_SNAK;
-      stm32l4_putreg(regval, regaddr);
-
-      /* The endpoint is no longer active */
-
-      privep->active = false;
-      return;
-    }
-
-  uinfo("EP%d req=%p: len=%d xfrd=%d zlp=%d\n",
-        privep->epphy, privreq, privreq->req.len,
-        privreq->req.xfrd, privep->zlp);
-
-  /* Check for a special case:  If we are just starting a request (xfrd==0) and
-   * the class driver is trying to send a zero-length packet (len==0).  Then set
-   * the ZLP flag so that the packet will be sent.
-   */
-
-  if (privreq->req.len == 0)
-    {
-      /* The ZLP flag is set TRUE whenever we want to force the driver to
-       * send a zero-length-packet on the next pass through the loop (below).
-       * The flag is cleared whenever a packet is sent in the loop below.
-       */
-
-      privep->zlp = true;
-    }
-
-  /* Add one more packet to the TxFIFO.  We will wait for the transfer
-   * complete event before we add the next packet (or part of a packet
-   * to the TxFIFO).
-   *
-   * The documentation says that we can can multiple packets to the TxFIFO,
-   * but it seems that we need to get the transfer complete event before
-   * we can add the next (or maybe I have got something wrong?)
-   */
-
-#if 0
-  while (privreq->req.xfrd < privreq->req.len || privep->zlp)
-#else
-  if (privreq->req.xfrd < privreq->req.len || privep->zlp)
-#endif
-    {
-      /* Get the number of bytes left to be sent in the request */
-
-      bytesleft = privreq->req.len - privreq->req.xfrd;
-      nbytes    = bytesleft;
-
-      /* Assume no zero-length-packet on the next pass through this loop */
-
-      privep->zlp = false;
-
-      /* Limit the size of the transfer to one full packet and handle
-       * zero-length packets (ZLPs).
-       */
-
-      if (nbytes > 0)
-        {
-          /* Either send the maxpacketsize or all of the remaining data in
-           * the request.
-           */
-
-          if (nbytes >= privep->ep.maxpacket)
-            {
-              nbytes =  privep->ep.maxpacket;
-
-              /* Handle the case where this packet is exactly the
-               * maxpacketsize.  Do we need to send a zero-length packet
-               * in this case?
-               */
-
-              if (bytesleft ==  privep->ep.maxpacket &&
-                  (privreq->req.flags & USBDEV_REQFLAGS_NULLPKT) != 0)
-                {
-                  /* The ZLP flag is set TRUE whenever we want to force
-                   * the driver to send a zero-length-packet on the next
-                   * pass through this loop. The flag is cleared (above)
-                   * whenever we are committed to sending any packet and
-                   * set here when we want to force one more pass through
-                   * the loop.
-                   */
-
-                  privep->zlp = true;
-                }
-            }
-        }
-
-      /* Get the transfer size in 32-bit words */
-
-      nwords = (nbytes + 3) >> 2;
-
-      /* Get the number of 32-bit words available in the TxFIFO. The
-       * DXTFSTS indicates the amount of free space available in the
-       * endpoint TxFIFO. Values are in terms of 32-bit words:
-       *
-       *   0: Endpoint TxFIFO is full
-       *   1: 1 word available
-       *   2: 2 words available
-       *   n: n words available
-       */
-
-      regaddr = STM32L4_OTGFS_DTXFSTS(privep->epphy);
-
-      /* Check for space in the TxFIFO.  If space in the TxFIFO is not
-       * available, then set up an interrupt to resume the transfer when
-       * the TxFIFO is empty.
-       */
-
-      regval = stm32l4_getreg(regaddr);
-      if ((int)(regval & OTGFS_DTXFSTS_MASK) < nwords)
-        {
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_EPIN_EMPWAIT), (uint16_t)regval);
-
-          /* There is insufficient space in the TxFIFO.  Wait for a TxFIFO
-           * empty interrupt and try again.
-           */
-
-          uint32_t empmsk = stm32l4_getreg(STM32L4_OTGFS_DIEPEMPMSK);
-          empmsk |= OTGFS_DIEPEMPMSK(privep->epphy);
-          stm32l4_putreg(empmsk, STM32L4_OTGFS_DIEPEMPMSK);
-
-          /* Terminate the transfer.  We will try again when the TxFIFO empty
-           * interrupt is received.
-           */
-
-          return;
-        }
-
-      /* Transfer data to the TxFIFO */
-
-      buf = privreq->req.buf + privreq->req.xfrd;
-      stm32l4_epin_transfer(privep, buf, nbytes);
-
-      /* If it was not before, the OUT endpoint is now actively transferring
-       * data.
-       */
-
-      privep->active = true;
-
-      /* EP0 is a special case */
-
-      if (privep->epphy == EP0)
-        {
-          priv->ep0state = EP0STATE_DATA_IN;
-        }
-
-      /* Update for the next time through the loop */
-
-      privreq->req.xfrd += nbytes;
-    }
-
-  /* Note that the ZLP, if any, must be sent as a separate transfer.  The need
-   * for a ZLP is indicated by privep->zlp.  If all of the bytes were sent
-   * (including any final null packet) then we are finished with the transfer
-   */
-
-  if (privreq->req.xfrd >= privreq->req.len && !privep->zlp)
-    {
-      usbtrace(TRACE_COMPLETE(privep->epphy), privreq->req.xfrd);
-
-      /* We are finished with the request (although the transfer has not
-       * yet completed).
-       */
-
-      stm32l4_req_complete(privep, OK);
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_rxfifo_read
- *
- * Description:
- *   Read packet from the RxFIFO into a read request.
- *
- ****************************************************************************/
-
-static void stm32l4_rxfifo_read(FAR struct stm32l4_ep_s *privep,
-                                FAR uint8_t *dest, uint16_t len)
-{
-  uint32_t regaddr;
-  int i;
-
-  /* Get the address of the RxFIFO.  Note:  there is only one RxFIFO so
-   * we might as well use the address associated with EP0.
-   */
-
-  regaddr = STM32L4_OTGFS_DFIFO_DEP(EP0);
-
-  /* Read 32-bits and write 4 x 8-bits at time (to avoid unaligned accesses) */
-
-  for (i = 0; i < len; i += 4)
-    {
-      union
-      {
-        uint32_t w;
-        uint8_t  b[4];
-      } data;
-
-      /* Read 1 x 32-bits of EP0 packet data */
-
-      data.w = stm32l4_getreg(regaddr);
-
-      /* Write 4 x 8-bits of EP0 packet data */
-
-      *dest++ = data.b[0];
-      *dest++ = data.b[1];
-      *dest++ = data.b[2];
-      *dest++ = data.b[3];
-    }
-
-  usb_dumpbuffer("<<<", dest - len, len);
-}
-
-/****************************************************************************
- * Name: stm32l4_rxfifo_discard
- *
- * Description:
- *   Discard packet data from the RxFIFO.
- *
- ****************************************************************************/
-
-static void stm32l4_rxfifo_discard(FAR struct stm32l4_ep_s *privep, int len)
-{
-  if (len > 0)
-    {
-      uint32_t regaddr;
-      int i;
-
-      /* Get the address of the RxFIFO  Note:  there is only one RxFIFO so
-       * we might as well use the address associated with EP0.
-       */
-
-      regaddr = STM32L4_OTGFS_DFIFO_DEP(EP0);
-
-      /* Read 32-bits at time */
-
-      for (i = 0; i < len; i += 4)
-        {
-          volatile uint32_t data = stm32l4_getreg(regaddr);
-          (void)data;
-        }
-
-      uinfo("<<< discarding %d\n", len);
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_epout_complete
- *
- * Description:
- *   This function is called when an OUT transfer complete interrupt is
- *   received.  It completes the read request at the head of the endpoint's
- *   request queue.
- *
- ****************************************************************************/
-
-static void stm32l4_epout_complete(FAR struct stm32l4_usbdev_s *priv,
-                                   FAR struct stm32l4_ep_s *privep)
-{
-  struct stm32l4_req_s *privreq;
-
-  /* Since a transfer just completed, there must be a read request at the head of
-   * the endpoint request queue.
-   */
-
-  privreq = stm32l4_rqpeek(privep);
-  DEBUGASSERT(privreq);
-
-  if (!privreq)
-    {
-      /* An OUT transfer completed, but no packet to receive the data.  This
-       * should not happen.
-       */
-
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_EPOUTQEMPTY), privep->epphy);
-      privep->active = false;
-      return;
-    }
-
-  uinfo("EP%d: len=%d xfrd=%d\n",
-        privep->epphy, privreq->req.len, privreq->req.xfrd);
-
-  /* Return the completed read request to the class driver and mark the state
-   * IDLE.
-   */
-
-  usbtrace(TRACE_COMPLETE(privep->epphy), privreq->req.xfrd);
-  stm32l4_req_complete(privep, OK);
-  privep->active = false;
-
-  /* Now set up the next read request (if any) */
-
-  stm32l4_epout_request(priv, privep);
-}
-
-/****************************************************************************
- * Name: stm32l4_ep0out_receive
- *
- * Description:
- *   This function is called from the RXFLVL interrupt handler when new incoming
- *   data is available in the endpoint's RxFIFO.  This function will simply
- *   copy the incoming data into pending request's data buffer.
- *
- ****************************************************************************/
-
-static inline void stm32l4_ep0out_receive(FAR struct stm32l4_ep_s *privep,
-                                          int bcnt)
-{
-  FAR struct stm32l4_usbdev_s *priv;
-
-  /* Sanity Checking */
-
-  DEBUGASSERT(privep && privep->ep.priv);
-  priv = (FAR struct stm32l4_usbdev_s *)privep->ep.priv;
-
-  uinfo("EP0: bcnt=%d\n", bcnt);
-  usbtrace(TRACE_READ(EP0), bcnt);
-
-  /* Verify that an OUT SETUP request as received before this data was
-   * received in the RxFIFO.
-   */
-
-  if (priv->ep0state == EP0STATE_SETUP_OUT)
-    {
-      /* Read the data into our special buffer for SETUP data */
-
-      int readlen = MIN(CONFIG_USBDEV_SETUP_MAXDATASIZE, bcnt);
-      stm32l4_rxfifo_read(privep, priv->ep0data, readlen);
-
-      /* Do we have to discard any excess bytes? */
-
-      stm32l4_rxfifo_discard(privep,  bcnt - readlen);
-
-      /* Now we can process the setup command */
-
-      privep->active  = false;
-      priv->ep0state  = EP0STATE_SETUP_READY;
-      priv->ep0datlen = readlen;
-
-      stm32l4_ep0out_setup(priv);
-    }
-  else
-    {
-      /* This is an error.  We don't have any idea what to do with the EP0
-       * data in this case.  Just read and discard it so that the RxFIFO
-       * does not become constipated.
-       */
-
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_NOOUTSETUP), priv->ep0state);
-      stm32l4_rxfifo_discard(privep, bcnt);
-      privep->active = false;
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_epout_receive
- *
- * Description:
- *   This function is called from the RXFLVL interrupt handler when new incoming
- *   data is available in the endpoint's RxFIFO.  This function will simply
- *   copy the incoming data into pending request's data buffer.
- *
- ****************************************************************************/
-
-static inline void stm32l4_epout_receive(FAR struct stm32l4_ep_s *privep,
-                                         int bcnt)
-{
-  struct stm32l4_req_s *privreq;
-  uint8_t *dest;
-  int buflen;
-  int readlen;
-
-  /* Get a reference to the request at the head of the endpoint's request
-   * queue.
-   */
-
-  privreq = stm32l4_rqpeek(privep);
-  if (!privreq)
-    {
-      /* Incoming data is available in the RxFIFO, but there is no read setup
-       * to receive the receive the data.  This should not happen for data
-       * endpoints; those endpoints should have been NAKing any OUT data tokens.
-       *
-       * We should get here normally on OUT data phase following an OUT
-       * SETUP command.  EP0 data will still receive data in this case and it
-       * should not be NAKing.
-       */
-
-      if (privep->epphy == 0)
-        {
-          stm32l4_ep0out_receive(privep, bcnt);
-        }
-      else
-        {
-          /* Otherwise, the data is lost. This really should not happen if
-           * NAKing is working as expected.
-           */
-
-          usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_EPOUTQEMPTY), privep->epphy);
-
-          /* Discard the data in the RxFIFO */
-
-          stm32l4_rxfifo_discard(privep, bcnt);
-        }
-
-      privep->active = false;
-      return;
-    }
-
-  uinfo("EP%d: len=%d xfrd=%d\n", privep->epphy, privreq->req.len, privreq->req.xfrd);
-  usbtrace(TRACE_READ(privep->epphy), bcnt);
-
-  /* Get the number of bytes to transfer from the RxFIFO */
-
-  buflen  = privreq->req.len - privreq->req.xfrd;
-  DEBUGASSERT(buflen > 0 && buflen >= bcnt);
-  readlen = MIN(buflen, bcnt);
-
-  /* Get the destination of the data transfer */
-
-  dest = privreq->req.buf + privreq->req.xfrd;
-
-  /* Transfer the data from the RxFIFO to the request's data buffer */
-
-  stm32l4_rxfifo_read(privep, dest, readlen);
-
-  /* If there were more bytes in the RxFIFO than could be held in the read
-   * request, then we will have to discard those.
-   */
-
-  stm32l4_rxfifo_discard(privep, bcnt - readlen);
-
-  /* Update the number of bytes transferred */
-
-  privreq->req.xfrd += readlen;
-}
-
-/****************************************************************************
- * Name: stm32l4_epout_request
- *
- * Description:
- *   This function is called when either (1) new read request is received, or
- *   (2) a pending receive request completes.  If there is no read in pending,
- *   then this function will initiate the next OUT (read) operation.
- *
- ****************************************************************************/
-
-static void stm32l4_epout_request(FAR struct stm32l4_usbdev_s *priv,
-                                  FAR struct stm32l4_ep_s *privep)
-{
-  struct stm32l4_req_s *privreq;
-  uint32_t regaddr;
-  uint32_t regval;
-  uint32_t xfrsize;
-  uint32_t pktcnt;
-
-  /* Make sure that there is not already a pending request request.  If there is,
-   * just return, leaving the newly received request in the request queue.
-   */
-
-  if (!privep->active)
-    {
-      /* Loop until a valid request is found (or the request queue is empty).
-       * The loop is only need to look at the request queue again is an invalid
-       * read request is encountered.
-       */
-
-      for (; ; )
-        {
-          /* Get a reference to the request at the head of the endpoint's request queue */
-
-          privreq = stm32l4_rqpeek(privep);
-          if (!privreq)
-            {
-              usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_EPOUTQEMPTY), privep->epphy);
-
-              /* There are no read requests to be setup.  Configure the hardware to
-               * NAK any incoming packets.  (This should already be the case.  I
-               * think that the hardware will automatically NAK after a transfer is
-               * completed until SNAK is cleared).
-               */
-
-              regaddr = STM32L4_OTGFS_DOEPCTL(privep->epphy);
-              regval  = stm32l4_getreg(regaddr);
-              regval |= OTGFS_DOEPCTL_SNAK;
-              stm32l4_putreg(regval, regaddr);
-
-              /* This endpoint is no longer actively transferring */
-
-              privep->active = false;
-              return;
-            }
-
-          uinfo("EP%d: len=%d\n", privep->epphy, privreq->req.len);
-
-          /* Ignore any attempt to receive a zero length packet (this really
-           * should not happen.
-           */
-
-          if (privreq->req.len <= 0)
-            {
-              usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_EPOUTNULLPACKET), 0);
-              stm32l4_req_complete(privep, OK);
-            }
-
-          /* Otherwise, we have a usable read request... break out of the loop */
-
-          else
-            {
-              break;
-            }
-        }
-
-      /* Setup the pending read into the request buffer.  First calculate:
-       *
-       * pktcnt  = the number of packets (of maxpacket bytes) required to
-       *   perform the transfer.
-       * xfrsize = The total number of bytes required (in units of
-       *   maxpacket bytes).
-       */
-
-      pktcnt  = (privreq->req.len + (privep->ep.maxpacket - 1)) / privep->ep.maxpacket;
-      xfrsize = pktcnt * privep->ep.maxpacket;
-
-      /* Then setup the hardware to perform this transfer */
-
-      regaddr = STM32L4_OTGFS_DOEPTSIZ(privep->epphy);
-      regval  = stm32l4_getreg(regaddr);
-      regval &= ~(OTGFS_DOEPTSIZ_XFRSIZ_MASK | OTGFS_DOEPTSIZ_PKTCNT_MASK);
-      regval |= (xfrsize << OTGFS_DOEPTSIZ_XFRSIZ_SHIFT);
-      regval |= (pktcnt  << OTGFS_DOEPTSIZ_PKTCNT_SHIFT);
-      stm32l4_putreg(regval, regaddr);
-
-      /* Then enable the transfer */
-
-      regaddr = STM32L4_OTGFS_DOEPCTL(privep->epphy);
-      regval  = stm32l4_getreg(regaddr);
-
-      /* When an isochronous transfer is enabled the Even/Odd frame bit must
-       * also be set appropriately.
-       */
-
-#ifdef CONFIG_USBDEV_ISOCHRONOUS
-      if (privep->eptype == USB_EP_ATTR_XFER_ISOC)
-        {
-          if (privep->odd)
-            {
-              regval |= OTGFS_DOEPCTL_SODDFRM;
-            }
-          else
-            {
-              regval |= OTGFS_DOEPCTL_SEVNFRM;
-            }
-        }
-#endif
-
-      /* Clearing NAKing and enable the transfer. */
-
-      regval |= (OTGFS_DOEPCTL_CNAK | OTGFS_DOEPCTL_EPENA);
-      stm32l4_putreg(regval, regaddr);
-
-      /* A transfer is now active on this endpoint */
-
-      privep->active = true;
-
-      /* EP0 is a special case.  We need to know when to switch back to
-       * normal SETUP processing.
-       */
-
-      if (privep->epphy == EP0)
-        {
-          priv->ep0state = EP0STATE_DATA_OUT;
-        }
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_ep_flush
- *
- * Description:
- *   Flush any primed descriptors from this ep
- *
- ****************************************************************************/
-
-static void stm32l4_ep_flush(struct stm32l4_ep_s *privep)
-{
-  if (privep->isin)
-    {
-      stm32l4_txfifo_flush(OTGFS_GRSTCTL_TXFNUM_D(privep->epphy));
-    }
-  else
-    {
-      stm32l4_rxfifo_flush();
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_req_complete
- *
- * Description:
- *   Handle termination of the request at the head of the endpoint request queue.
- *
- ****************************************************************************/
-
-static void stm32l4_req_complete(struct stm32l4_ep_s *privep, int16_t result)
-{
-  FAR struct stm32l4_req_s *privreq;
-
-  /* Remove the request at the head of the request list */
-
-  privreq = stm32l4_req_remfirst(privep);
-  DEBUGASSERT(privreq != NULL);
-
-  /* If endpoint 0, temporarily reflect the state of protocol stalled
-   * in the callback.
-   */
-
-  bool stalled = privep->stalled;
-  if (privep->epphy == EP0)
-    {
-      privep->stalled = privep->dev->stalled;
-    }
-
-  /* Save the result in the request structure */
-
-  privreq->req.result = result;
-
-  /* Callback to the request completion handler */
-
-  privreq->req.callback(&privep->ep, &privreq->req);
-
-  /* Restore the stalled indication */
-
-  privep->stalled = stalled;
-}
-
-/****************************************************************************
- * Name: stm32l4_req_cancel
- *
- * Description:
- *   Cancel all pending requests for an endpoint
- *
- ****************************************************************************/
-
-static void stm32l4_req_cancel(struct stm32l4_ep_s *privep, int16_t status)
-{
-  if (!stm32l4_rqempty(privep))
-    {
-      stm32l4_ep_flush(privep);
-    }
-
-  while (!stm32l4_rqempty(privep))
-    {
-      usbtrace(TRACE_COMPLETE(privep->epphy),
-               (stm32l4_rqpeek(privep))->req.xfrd);
-      stm32l4_req_complete(privep, status);
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_ep_findbyaddr
- *
- * Description:
- *   Find the physical endpoint structure corresponding to a logic endpoint
- *   address
- *
- ****************************************************************************/
-
-static struct stm32l4_ep_s *stm32l4_ep_findbyaddr(struct stm32l4_usbdev_s *priv,
-                                                  uint16_t eplog)
-{
-  struct stm32l4_ep_s *privep;
-  uint8_t epphy = USB_EPNO(eplog);
-
-  if (epphy >= STM32L4_NENDPOINTS)
-    {
-      return NULL;
-    }
-
-  /* Is this an IN or an OUT endpoint? */
-
-  if (USB_ISEPIN(eplog))
-    {
-      privep = &priv->epin[epphy];
-    }
-  else
-    {
-      privep = &priv->epout[epphy];
-    }
-
-  /* Return endpoint reference */
-
-  DEBUGASSERT(privep->epphy == epphy);
-  return privep;
-}
-
-/****************************************************************************
- * Name: stm32l4_req_dispatch
- *
- * Description:
- *   Provide unhandled setup actions to the class driver. This is logically part
- *   of the USB interrupt handler.
- *
- ****************************************************************************/
-
-static int stm32l4_req_dispatch(struct stm32l4_usbdev_s *priv,
-                                const struct usb_ctrlreq_s *ctrl)
-{
-  int ret = -EIO;
-
-  usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_DISPATCH), 0);
-  if (priv->driver)
-    {
-      /* Forward to the control request to the class driver implementation */
-
-      ret = CLASS_SETUP(priv->driver, &priv->usbdev, ctrl,
-                        priv->ep0data, priv->ep0datlen);
-    }
-
-  if (ret < 0)
-    {
-      /* Stall on failure */
-
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_DISPATCHSTALL), 0);
-      priv->stalled = true;
-    }
-
-  return ret;
-}
-
-/****************************************************************************
- * Name: stm32l4_usbreset
- *
- * Description:
- *   Reset Usb engine
- *
- ****************************************************************************/
-
-static void stm32l4_usbreset(struct stm32l4_usbdev_s *priv)
-{
-  FAR struct stm32l4_ep_s *privep;
-  uint32_t regval;
-  int i;
-
-  /* Clear the Remote Wake-up Signaling */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_DCTL);
-  regval &= ~OTGFS_DCTL_RWUSIG;
-  stm32l4_putreg(regval, STM32L4_OTGFS_DCTL);
-
-  /* Flush the EP0 Tx FIFO */
-
-  stm32l4_txfifo_flush(OTGFS_GRSTCTL_TXFNUM_D(EP0));
-
-  /* Tell the class driver that we are disconnected. The class
-   * driver should then accept any new configurations.
-   */
-
-  if (priv->driver)
-    {
-      CLASS_DISCONNECT(priv->driver, &priv->usbdev);
-    }
-
-  /* Mark all endpoints as available */
-
-  priv->epavail[0] = STM32L4_EP_AVAILABLE;
-  priv->epavail[1] = STM32L4_EP_AVAILABLE;
-
-  /* Disable all end point interrupts */
-
-  for (i = 0; i < STM32L4_NENDPOINTS ; i++)
-    {
-      /* Disable endpoint interrupts */
-
-      stm32l4_putreg(0xff, STM32L4_OTGFS_DIEPINT(i));
-      stm32l4_putreg(0xff, STM32L4_OTGFS_DOEPINT(i));
-
-      /* Return write requests to the class implementation */
-
-      privep = &priv->epin[i];
-      stm32l4_req_cancel(privep, -ESHUTDOWN);
-
-      /* Reset IN endpoint status */
-
-      privep->stalled = false;
-
-      /* Return read requests to the class implementation */
-
-      privep = &priv->epout[i];
-      stm32l4_req_cancel(privep, -ESHUTDOWN);
-
-      /* Reset endpoint status */
-
-      privep->stalled = false;
-    }
-
-  stm32l4_putreg(0xffffffff, STM32L4_OTGFS_DAINT);
-
-  /* Mask all device endpoint interrupts except EP0 */
-
-  regval = (OTGFS_DAINT_IEP(EP0) | OTGFS_DAINT_OEP(EP0));
-  stm32l4_putreg(regval, STM32L4_OTGFS_DAINTMSK);
-
-  /* Unmask OUT interrupts */
-
-  regval = (OTGFS_DOEPMSK_XFRCM | OTGFS_DOEPMSK_STUPM | OTGFS_DOEPMSK_EPDM);
-  stm32l4_putreg(regval, STM32L4_OTGFS_DOEPMSK);
-
-  /* Unmask IN interrupts */
-
-  regval = (OTGFS_DIEPMSK_XFRCM | OTGFS_DIEPMSK_EPDM | OTGFS_DIEPMSK_TOM);
-  stm32l4_putreg(regval, STM32L4_OTGFS_DIEPMSK);
-
-  /* Reset device address to 0 */
-
-  stm32l4_setaddress(priv, 0);
-  priv->devstate = DEVSTATE_DEFAULT;
-  priv->usbdev.speed = USB_SPEED_FULL;
-
-  /* Re-configure EP0 */
-
-  stm32l4_ep0_configure(priv);
-
-  /* Setup EP0 to receive SETUP packets */
-
-  stm32l4_ep0out_ctrlsetup(priv);
-}
-
-/****************************************************************************
- * Name: stm32l4_ep0out_testmode
- *
- * Description:
- *   Select test mode
- *
- ****************************************************************************/
-
-static inline void stm32l4_ep0out_testmode(FAR struct stm32l4_usbdev_s *priv,
-                                           uint16_t index)
-{
-  uint8_t testmode;
-
-  testmode = index >> 8;
-  switch (testmode)
-    {
-      case 1:
-        priv->testmode = OTGFS_TESTMODE_J;
-        break;
-
-      case 2:
-        priv->testmode = OTGFS_TESTMODE_K;
-        break;
-
-      case 3:
-        priv->testmode = OTGFS_TESTMODE_SE0_NAK;
-        break;
-
-      case 4:
-        priv->testmode = OTGFS_TESTMODE_PACKET;
-        break;
-
-      case 5:
-        priv->testmode = OTGFS_TESTMODE_FORCE;
-        break;
-
-      default:
-        usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_BADTESTMODE), testmode);
-        priv->dotest   = false;
-        priv->testmode = OTGFS_TESTMODE_DISABLED;
-        priv->stalled  = true;
-    }
-
-  priv->dotest = true;
-  stm32l4_ep0in_transmitzlp(priv);
-}
-
-/****************************************************************************
- * Name: stm32l4_ep0out_stdrequest
- *
- * Description:
- *   Handle a standard request on EP0.  Pick off the things of interest to the
- *   USB device controller driver; pass what is left to the class driver.
- *
- ****************************************************************************/
-
-static inline void stm32l4_ep0out_stdrequest(struct stm32l4_usbdev_s *priv,
-                                             FAR struct stm32l4_ctrlreq_s *ctrlreq)
-{
-  FAR struct stm32l4_ep_s *privep;
-
-  /* Handle standard request */
-
-  switch (ctrlreq->req)
-    {
-      case USB_REQ_GETSTATUS:
-        {
-          /* type:  device-to-host; recipient = device, interface, endpoint
-           * value: 0
-           * index: zero interface endpoint
-           * len:   2; data = status
-           */
-
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_GETSTATUS), 0);
-          if (!priv->addressed ||
-              ctrlreq->len != 2 ||
-              USB_REQ_ISOUT(ctrlreq->type) ||
-              ctrlreq->value != 0)
-            {
-              priv->stalled = true;
-            }
-          else
-            {
-              switch (ctrlreq->type & USB_REQ_RECIPIENT_MASK)
-                {
-                  case USB_REQ_RECIPIENT_ENDPOINT:
-                    {
-                      usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_EPGETSTATUS), 0);
-                      privep = stm32l4_ep_findbyaddr(priv, ctrlreq->index);
-                      if (!privep)
-                        {
-                          usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_BADEPGETSTATUS), 0);
-                          priv->stalled = true;
-                        }
-                      else
-                        {
-                          if (privep->stalled)
-                            {
-                              priv->ep0data[0] = (1 << USB_FEATURE_ENDPOINTHALT);
-                            }
-                          else
-                            {
-                              priv->ep0data[0] = 0; /* Not stalled */
-                            }
-
-                          priv->ep0data[1] = 0;
-                          stm32l4_ep0in_setupresponse(priv, priv->ep0data, 2);
-                        }
-                    }
-                    break;
-
-                  case USB_REQ_RECIPIENT_DEVICE:
-                    {
-                      if (ctrlreq->index == 0)
-                        {
-                          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_DEVGETSTATUS), 0);
-
-                          /* Features:  Remote Wakeup and self-powered */
-
-                          priv->ep0data[0]  = (priv->selfpowered << USB_FEATURE_SELFPOWERED);
-                          priv->ep0data[0] |= (priv->wakeup      << USB_FEATURE_REMOTEWAKEUP);
-                          priv->ep0data[1]  = 0;
-
-                          stm32l4_ep0in_setupresponse(priv, priv->ep0data, 2);
-                        }
-                      else
-                        {
-                          usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_BADDEVGETSTATUS), 0);
-                          priv->stalled = true;
-                        }
-                    }
-                    break;
-
-                  case USB_REQ_RECIPIENT_INTERFACE:
-                    {
-                      usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_IFGETSTATUS), 0);
-                      priv->ep0data[0] = 0;
-                      priv->ep0data[1] = 0;
-
-                      stm32l4_ep0in_setupresponse(priv, priv->ep0data, 2);
-                    }
-                    break;
-
-                  default:
-                    {
-                      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_BADGETSTATUS), 0);
-                      priv->stalled = true;
-                    }
-                    break;
-                }
-            }
-        }
-        break;
-
-      case USB_REQ_CLEARFEATURE:
-        {
-          /* type:  host-to-device; recipient = device, interface or endpoint
-           * value: feature selector
-           * index: zero interface endpoint;
-           * len:   zero, data = none
-           */
-
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_CLEARFEATURE), 0);
-          if (priv->addressed != 0 && ctrlreq->len == 0)
-            {
-              uint8_t recipient = ctrlreq->type & USB_REQ_RECIPIENT_MASK;
-              if (recipient == USB_REQ_RECIPIENT_ENDPOINT &&
-                  ctrlreq->value == USB_FEATURE_ENDPOINTHALT &&
-                  (privep = stm32l4_ep_findbyaddr(priv, ctrlreq->index)) != NULL)
-                {
-                  stm32l4_ep_clrstall(privep);
-                  stm32l4_ep0in_transmitzlp(priv);
-                }
-              else if (recipient == USB_REQ_RECIPIENT_DEVICE &&
-                       ctrlreq->value == USB_FEATURE_REMOTEWAKEUP)
-                {
-                  priv->wakeup = 0;
-                  stm32l4_ep0in_transmitzlp(priv);
-                }
-              else
-                {
-                  /* Actually, I think we could just stall here. */
-
-                  (void)stm32l4_req_dispatch(priv, &priv->ctrlreq);
-                }
-            }
-          else
-            {
-              usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_BADCLEARFEATURE), 0);
-              priv->stalled = true;
-            }
-        }
-        break;
-
-      case USB_REQ_SETFEATURE:
-        {
-          /* type:  host-to-device; recipient = device, interface, endpoint
-           * value: feature selector
-           * index: zero interface endpoint;
-           * len:   0; data = none
-           */
-
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_SETFEATURE), 0);
-          if (priv->addressed != 0 && ctrlreq->len == 0)
-            {
-              uint8_t recipient = ctrlreq->type & USB_REQ_RECIPIENT_MASK;
-              if (recipient == USB_REQ_RECIPIENT_ENDPOINT &&
-                  ctrlreq->value == USB_FEATURE_ENDPOINTHALT &&
-                  (privep = stm32l4_ep_findbyaddr(priv, ctrlreq->index)) != NULL)
-                {
-                  stm32l4_ep_setstall(privep);
-                  stm32l4_ep0in_transmitzlp(priv);
-                }
-              else if (recipient == USB_REQ_RECIPIENT_DEVICE &&
-                       ctrlreq->value == USB_FEATURE_REMOTEWAKEUP)
-                {
-                  priv->wakeup = 1;
-                  stm32l4_ep0in_transmitzlp(priv);
-                }
-              else if (recipient == USB_REQ_RECIPIENT_DEVICE &&
-                       ctrlreq->value == USB_FEATURE_TESTMODE &&
-                       ((ctrlreq->index & 0xff) == 0))
-                {
-                  stm32l4_ep0out_testmode(priv, ctrlreq->index);
-                }
-              else if (priv->configured)
-                {
-                  /* Actually, I think we could just stall here. */
-
-                  (void)stm32l4_req_dispatch(priv, &priv->ctrlreq);
-                }
-              else
-                {
-                  usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_BADSETFEATURE), 0);
-                  priv->stalled = true;
-                }
-            }
-          else
-            {
-              usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_BADSETFEATURE), 0);
-              priv->stalled = true;
-            }
-        }
-        break;
-
-      case USB_REQ_SETADDRESS:
-        {
-          /* type:  host-to-device; recipient = device
-           * value: device address
-           * index: 0
-           * len:   0; data = none
-           */
-
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_SETADDRESS), ctrlreq->value);
-          if ((ctrlreq->type & USB_REQ_RECIPIENT_MASK) == USB_REQ_RECIPIENT_DEVICE &&
-              ctrlreq->index  == 0 &&
-              ctrlreq->len == 0 &&
-              ctrlreq->value < 128 &&
-              priv->devstate != DEVSTATE_CONFIGURED)
-            {
-              /* Save the address.  We cannot actually change to the next address until
-               * the completion of the status phase.
-               */
-
-              stm32l4_setaddress(priv, (uint16_t)priv->ctrlreq.value[0]);
-              stm32l4_ep0in_transmitzlp(priv);
-            }
-          else
-            {
-              usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_BADSETADDRESS), 0);
-              priv->stalled = true;
-            }
-        }
-        break;
-
-      case USB_REQ_GETDESCRIPTOR:
-      /* type:  device-to-host; recipient = device
-       * value: descriptor type and index
-       * index: 0 or language ID;
-       * len:   descriptor len; data = descriptor
-       */
-
-      case USB_REQ_SETDESCRIPTOR:
-        /* type:  host-to-device; recipient = device
-         * value: descriptor type and index
-         * index: 0 or language ID;
-         * len:   descriptor len; data = descriptor
-         */
-
-        {
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_GETSETDESC), 0);
-          if ((ctrlreq->type & USB_REQ_RECIPIENT_MASK) == USB_REQ_RECIPIENT_DEVICE)
-            {
-              (void)stm32l4_req_dispatch(priv, &priv->ctrlreq);
-            }
-          else
-            {
-              usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_BADGETSETDESC), 0);
-              priv->stalled = true;
-            }
-        }
-        break;
-
-      case USB_REQ_GETCONFIGURATION:
-        /* type:  device-to-host; recipient = device
-         * value: 0;
-         * index: 0;
-         * len:   1; data = configuration value
-         */
-
-        {
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_GETCONFIG), 0);
-          if (priv->addressed &&
-              (ctrlreq->type & USB_REQ_RECIPIENT_MASK) == USB_REQ_RECIPIENT_DEVICE &&
-              ctrlreq->value == 0 &&
-              ctrlreq->index == 0 &&
-              ctrlreq->len == 1)
-            {
-              (void)stm32l4_req_dispatch(priv, &priv->ctrlreq);
-            }
-          else
-            {
-              usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_BADGETCONFIG), 0);
-              priv->stalled = true;
-            }
-        }
-        break;
-
-      case USB_REQ_SETCONFIGURATION:
-        /* type:  host-to-device; recipient = device
-         * value: configuration value
-         * index: 0;
-         * len:   0; data = none
-         */
-
-        {
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_SETCONFIG), 0);
-          if (priv->addressed &&
-              (ctrlreq->type & USB_REQ_RECIPIENT_MASK) == USB_REQ_RECIPIENT_DEVICE &&
-              ctrlreq->index == 0 &&
-              ctrlreq->len == 0)
-            {
-              /* Give the configuration to the class driver */
-
-              int ret = stm32l4_req_dispatch(priv, &priv->ctrlreq);
-
-              /* If the class driver accepted the configuration, then mark the
-               * device state as configured (or not, depending on the
-               * configuration).
-               */
-
-              if (ret == OK)
-                {
-                  uint8_t cfg = (uint8_t)ctrlreq->value;
-                  if (cfg != 0)
-                    {
-                      priv->devstate   = DEVSTATE_CONFIGURED;
-                      priv->configured = true;
-                    }
-                  else
-                    {
-                      priv->devstate   = DEVSTATE_ADDRESSED;
-                      priv->configured = false;
-                    }
-                }
-            }
-          else
-            {
-              usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_BADSETCONFIG), 0);
-              priv->stalled = true;
-            }
-        }
-        break;
-
-      case USB_REQ_GETINTERFACE:
-      /* type:  device-to-host; recipient = interface
-       * value: 0
-       * index: interface;
-       * len:   1; data = alt interface
-       */
-
-      case USB_REQ_SETINTERFACE:
-        /* type:  host-to-device; recipient = interface
-         * value: alternate setting
-         * index: interface;
-         * len:   0; data = none
-         */
-
-        {
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_GETSETIF), 0);
-          (void)stm32l4_req_dispatch(priv, &priv->ctrlreq);
-        }
-        break;
-
-      case USB_REQ_SYNCHFRAME:
-        /* type:  device-to-host; recipient = endpoint
-         * value: 0
-         * index: endpoint;
-         * len:   2; data = frame number
-         */
-
-        {
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_SYNCHFRAME), 0);
-        }
-        break;
-
-      default:
-        {
-          usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_INVALIDCTRLREQ), 0);
-          priv->stalled = true;
-        }
-        break;
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_ep0out_setup
- *
- * Description:
- *   USB Ctrl EP Setup Event. This is logically part of the USB interrupt
- *   handler.  This event occurs when a setup packet is receive on EP0 OUT.
- *
- ****************************************************************************/
-
-static inline void stm32l4_ep0out_setup(struct stm32l4_usbdev_s *priv)
-{
-  struct stm32l4_ctrlreq_s ctrlreq;
-
-  /* Verify that a SETUP was received */
-
-  if (priv->ep0state != EP0STATE_SETUP_READY)
-    {
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_EP0NOSETUP), priv->ep0state);
-      return;
-    }
-
-  /* Terminate any pending requests */
-
-  stm32l4_req_cancel(&priv->epout[EP0], -EPROTO);
-  stm32l4_req_cancel(&priv->epin[EP0],  -EPROTO);
-
-  /* Assume NOT stalled */
-
-  priv->epout[EP0].stalled = false;
-  priv->epin[EP0].stalled = false;
-  priv->stalled = false;
-
-  /* Starting to process a control request - update state */
-
-  priv->ep0state = EP0STATE_SETUP_PROCESS;
-
-  /* And extract the little-endian 16-bit values to host order */
-
-  ctrlreq.type  = priv->ctrlreq.type;
-  ctrlreq.req   = priv->ctrlreq.req;
-  ctrlreq.value = GETUINT16(priv->ctrlreq.value);
-  ctrlreq.index = GETUINT16(priv->ctrlreq.index);
-  ctrlreq.len   = GETUINT16(priv->ctrlreq.len);
-
-  uinfo("type=%02x req=%02x value=%04x index=%04x len=%04x\n",
-        ctrlreq.type, ctrlreq.req, ctrlreq.value, ctrlreq.index, ctrlreq.len);
-
-  /* Check for a standard request */
-
-  if ((ctrlreq.type & USB_REQ_TYPE_MASK) != USB_REQ_TYPE_STANDARD)
-    {
-      /* Dispatch any non-standard requests */
-
-      (void)stm32l4_req_dispatch(priv, &priv->ctrlreq);
-    }
-  else
-    {
-      /* Handle standard requests. */
-
-      stm32l4_ep0out_stdrequest(priv, &ctrlreq);
-    }
-
-  /* Check if the setup processing resulted in a STALL */
-
-  if (priv->stalled)
-    {
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_EP0SETUPSTALLED), priv->ep0state);
-      stm32l4_ep0_stall(priv);
-    }
-
-  /* Reset state/data associated with thie SETUP request */
-
-  priv->ep0datlen = 0;
-}
-
-/****************************************************************************
- * Name: stm32l4_epout
- *
- * Description:
- *   This is part of the OUT endpoint interrupt processing.  This function
- *   handles the OUT event for a single endpoint.
- *
- ****************************************************************************/
-
-static inline void stm32l4_epout(FAR struct stm32l4_usbdev_s *priv,
-                                 uint8_t epno)
-{
-  FAR struct stm32l4_ep_s *privep;
-
-  /* Endpoint 0 is a special case. */
-
-  if (epno == 0)
-    {
-      privep = &priv->epout[EP0];
-
-      /* In the EP0STATE_DATA_OUT state, we are receiving data into the
-       * request buffer.  In that case, we must continue the request
-       * processing.
-       */
-
-      if (priv->ep0state == EP0STATE_DATA_OUT)
-        {
-          /* Continue processing data from the EP0 OUT request queue */
-
-          stm32l4_epout_complete(priv, privep);
-
-          /* If we are not actively processing an OUT request, then we
-           * need to setup to receive the next control request.
-           */
-
-          if (!privep->active)
-            {
-              stm32l4_ep0out_ctrlsetup(priv);
-              priv->ep0state = EP0STATE_IDLE;
-            }
-        }
-    }
-
-  /* For other endpoints, the only possibility is that we are continuing
-   * or finishing an OUT request.
-   */
-
-  else if (priv->devstate == DEVSTATE_CONFIGURED)
-    {
-      stm32l4_epout_complete(priv, &priv->epout[epno]);
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_epout_interrupt
- *
- * Description:
- *   USB OUT endpoint interrupt handler.  The core generates this interrupt when
- *   there is an interrupt is pending on one of the OUT endpoints of the core.
- *   The driver must read the OTGFS DAINT register to determine the exact number
- *   of the OUT endpoint on which the interrupt occurred, and then read the
- *   corresponding OTGFS DOEPINTx register to determine the exact cause of the
- *   interrupt.
- *
- ****************************************************************************/
-
-static inline void stm32l4_epout_interrupt(FAR struct stm32l4_usbdev_s *priv)
-{
-  uint32_t daint;
-  uint32_t regval;
-  uint32_t doepint;
-  int epno;
-
-  /* Get the pending, enabled interrupts for the OUT endpoint from the endpoint
-   * interrupt status register.
-   */
-
-  regval  = stm32l4_getreg(STM32L4_OTGFS_DAINT);
-  regval &= stm32l4_getreg(STM32L4_OTGFS_DAINTMSK);
-  daint   = (regval & OTGFS_DAINT_OEP_MASK) >> OTGFS_DAINT_OEP_SHIFT;
-
-  if (daint == 0)
-    {
-      /* We got an interrupt, but there is no unmasked endpoint that caused
-       * it ?!  When this happens, the interrupt flag never gets cleared and
-       * we are stuck in infinite interrupt loop.
-       *
-       * This shouldn't happen if we are diligent about handling timing
-       * issues when masking endpoint interrupts. However, this workaround
-       * avoids infinite loop and allows operation to continue normally.  It
-       * works by clearing each endpoint flags, masked or not.
-       */
-
-      regval  = stm32l4_getreg(STM32L4_OTGFS_DAINT);
-      daint   = (regval & OTGFS_DAINT_OEP_MASK) >> OTGFS_DAINT_OEP_SHIFT;
-
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_EPOUTUNEXPECTED),
-               (uint16_t)regval);
-
-      epno = 0;
-      while (daint)
-        {
-          if ((daint & 1) != 0)
-            {
-              regval = stm32l4_getreg(STM32L4_OTGFS_DOEPINT(epno));
-              uinfo("DOEPINT(%d) = %08x\n", epno, regval);
-              stm32l4_putreg(0xFF, STM32L4_OTGFS_DOEPINT(epno));
-            }
-
-          epno++;
-          daint >>= 1;
-        }
-
-      return;
-    }
-
-  /* Process each pending IN endpoint interrupt */
-
-  epno = 0;
-  while (daint)
-    {
-      /* Is an OUT interrupt pending for this endpoint? */
-
-      if ((daint & 1) != 0)
-        {
-          /* Yes.. get the OUT endpoint interrupt status */
-
-          doepint  = stm32l4_getreg(STM32L4_OTGFS_DOEPINT(epno));
-          doepint &= stm32l4_getreg(STM32L4_OTGFS_DOEPMSK);
-
-          /* Transfer completed interrupt.  This interrupt is trigged when
-           * stm32l4_rxinterrupt() removes the last packet data from the RxFIFO.
-           * In this case, core internally sets the NAK bit for this endpoint to
-           * prevent it from receiving any more packets.
-           */
-
-          if ((doepint & OTGFS_DOEPINT_XFRC) != 0)
-            {
-              usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_EPOUT_XFRC),
-                       (uint16_t)doepint);
-
-              /* Clear the bit in DOEPINTn for this interrupt */
-
-              stm32l4_putreg(OTGFS_DOEPINT_XFRC, STM32L4_OTGFS_DOEPINT(epno));
-
-              /* Handle the RX transfer data ready event */
-
-              stm32l4_epout(priv, epno);
-            }
-
-          /* Endpoint disabled interrupt (ignored because this interrupt is
-           * used in polled mode by the endpoint disable logic).
-           */
-#if 1
-          /* REVISIT: */
-          if ((doepint & OTGFS_DOEPINT_EPDISD) != 0)
-            {
-              usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_EPOUT_EPDISD),
-                       (uint16_t)doepint);
-
-              /* Clear the bit in DOEPINTn for this interrupt */
-
-              stm32l4_putreg(OTGFS_DOEPINT_EPDISD, STM32L4_OTGFS_DOEPINT(epno));
-            }
-#endif
-          /* Setup Phase Done (control EPs) */
-
-          if ((doepint & OTGFS_DOEPINT_SETUP) != 0)
-            {
-              usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_EPOUT_SETUP),
-                       priv->ep0state);
-
-              /* Handle the receipt of the IN SETUP packets now (OUT setup
-               * packet processing may be delayed until the accompanying
-               * OUT DATA is received)
-               */
-
-              if (priv->ep0state == EP0STATE_SETUP_READY)
-                {
-                  stm32l4_ep0out_setup(priv);
-                }
-
-              stm32l4_putreg(OTGFS_DOEPINT_SETUP, STM32L4_OTGFS_DOEPINT(epno));
-            }
-        }
-
-      epno++;
-      daint >>= 1;
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_epin_runtestmode
- *
- * Description:
- *   Execute the test mode setup by the SET FEATURE request
- *
- ****************************************************************************/
-
-static inline void stm32l4_epin_runtestmode(FAR struct stm32l4_usbdev_s *priv)
-{
-  uint32_t regval = stm32l4_getreg(STM32L4_OTGFS_DCTL);
-  regval &= OTGFS_DCTL_TCTL_MASK;
-  regval |= (uint32_t)priv->testmode << OTGFS_DCTL_TCTL_SHIFT;
-  stm32l4_putreg(regval, STM32L4_OTGFS_DCTL);
-
-  priv->dotest = 0;
-  priv->testmode = OTGFS_TESTMODE_DISABLED;
-}
-
-/****************************************************************************
- * Name: stm32l4_epin
- *
- * Description:
- *   This is part of the IN endpoint interrupt processing.  This function
- *   handles the IN event for a single endpoint.
- *
- ****************************************************************************/
-
-static inline void stm32l4_epin(FAR struct stm32l4_usbdev_s *priv,
-                                uint8_t epno)
-{
-  FAR struct stm32l4_ep_s *privep = &priv->epin[epno];
-
-  /* Endpoint 0 is a special case. */
-
-  if (epno == 0)
-    {
-      /* In the EP0STATE_DATA_IN state, we are sending data from request
-       * buffer.  In that case, we must continue the request processing.
-       */
-
-      if (priv->ep0state == EP0STATE_DATA_IN)
-        {
-          /* Continue processing data from the EP0 OUT request queue */
-
-          stm32l4_epin_request(priv, privep);
-
-          /* If we are not actively processing an OUT request, then we
-           * need to setup to receive the next control request.
-           */
-
-          if (!privep->active)
-            {
-              stm32l4_ep0out_ctrlsetup(priv);
-              priv->ep0state = EP0STATE_IDLE;
-            }
-        }
-
-      /* Test mode is another special case */
-
-      if (priv->dotest)
-        {
-          stm32l4_epin_runtestmode(priv);
-        }
-    }
-
-  /* For other endpoints, the only possibility is that we are continuing
-   * or finishing an IN request.
-   */
-
-  else if (priv->devstate == DEVSTATE_CONFIGURED)
-    {
-      /* Continue processing data from the endpoint write request queue */
-
-      stm32l4_epin_request(priv, privep);
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_epin_txfifoempty
- *
- * Description:
- *   TxFIFO empty interrupt handling
- *
- ****************************************************************************/
-
-static inline void stm32l4_epin_txfifoempty(FAR struct stm32l4_usbdev_s *priv,
-                                            int epno)
-{
-  FAR struct stm32l4_ep_s *privep = &priv->epin[epno];
-
-  /* Continue processing the write request queue.  This may mean sending
-   * more data from the existing request or terminating the current requests
-   * and (perhaps) starting the IN transfer from the next write request.
-   */
-
-  stm32l4_epin_request(priv, privep);
-}
-
-/****************************************************************************
- * Name: stm32l4_epin_interrupt
- *
- * Description:
- *   USB IN endpoint interrupt handler.  The core generates this interrupt when
- *   an interrupt is pending on one of the IN endpoints of the core. The driver
- *   must read the OTGFS DAINT register to determine the exact number of the IN
- *   endpoint on which the interrupt occurred, and then read the corresponding
- *   OTGFS DIEPINTx register to determine the exact cause of the interrupt.
- *
- ****************************************************************************/
-
-static inline void stm32l4_epin_interrupt(FAR struct stm32l4_usbdev_s *priv)
-{
-  uint32_t diepint;
-  uint32_t daint;
-  uint32_t mask;
-  uint32_t empty;
-  int epno;
-
-  /* Get the pending, enabled interrupts for the IN endpoint from the endpoint
-   * interrupt status register.
-   */
-
-  daint  = stm32l4_getreg(STM32L4_OTGFS_DAINT);
-  daint &= stm32l4_getreg(STM32L4_OTGFS_DAINTMSK);
-  daint &= OTGFS_DAINT_IEP_MASK;
-
-  if (daint == 0)
-    {
-      /* We got an interrupt, but there is no unmasked endpoint that caused
-       * it ?!  When this happens, the interrupt flag never gets cleared and
-       * we are stuck in infinite interrupt loop.
-       *
-       * This shouldn't happen if we are diligent about handling timing
-       * issues when masking endpoint interrupts. However, this workaround
-       * avoids infinite loop and allows operation to continue normally.  It
-       * works by clearing each endpoint flags, masked or not.
-       */
-
-      daint  = stm32l4_getreg(STM32L4_OTGFS_DAINT);
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_EPINUNEXPECTED),
-               (uint16_t)daint);
-
-      daint &= OTGFS_DAINT_IEP_MASK;
-      epno = 0;
-
-      while (daint)
-        {
-          if ((daint & 1) != 0)
-            {
-              uerr("DIEPINT(%d) = %08x\n",
-                   epno, stm32l4_getreg(STM32L4_OTGFS_DIEPINT(epno)));
-              stm32l4_putreg(0xFF, STM32L4_OTGFS_DIEPINT(epno));
-            }
-
-          epno++;
-          daint >>= 1;
-        }
-
-      return;
-    }
-
-  /* Process each pending IN endpoint interrupt */
-
-  epno = 0;
-  while (daint)
-    {
-      /* Is an IN interrupt pending for this endpoint? */
-
-      if ((daint & 1) != 0)
-        {
-          /* Get IN interrupt mask register.  Bits 0-6 correspond to enabled
-           * interrupts as will be found in the DIEPINT interrupt status
-           * register.
-           */
-
-          mask = stm32l4_getreg(STM32L4_OTGFS_DIEPMSK);
-
-          /* Check if the TxFIFO not empty interrupt is enabled for this
-           * endpoint in the DIEPMSK register.  Bits n corresponds to
-           * endpoint n in the register. That condition corresponds to
-           * bit 7 of the DIEPINT interrupt status register.  There is
-           * no TXFE bit in the mask register, so we fake one here.
-           */
-
-          empty = stm32l4_getreg(STM32L4_OTGFS_DIEPEMPMSK);
-          if ((empty & OTGFS_DIEPEMPMSK(epno)) != 0)
-            {
-              mask |= OTGFS_DIEPINT_TXFE;
-            }
-
-          /* Now, read the interrupt status and mask out all disabled
-           * interrupts.
-           */
-
-          diepint = stm32l4_getreg(STM32L4_OTGFS_DIEPINT(epno)) & mask;
-
-          /* Decode and process the enabled, pending interrupts */
-          /* Transfer completed interrupt */
-
-          if ((diepint & OTGFS_DIEPINT_XFRC) != 0)
-            {
-              usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_EPIN_XFRC),
-                       (uint16_t)diepint);
-
-              /* It is possible that logic may be waiting for a the
-               * TxFIFO to become empty.  We disable the TxFIFO empty
-               * interrupt here; it will be re-enabled if there is still
-               * insufficient space in the TxFIFO.
-               */
-
-              empty &= ~OTGFS_DIEPEMPMSK(epno);
-              stm32l4_putreg(empty, STM32L4_OTGFS_DIEPEMPMSK);
-              stm32l4_putreg(OTGFS_DIEPINT_XFRC, STM32L4_OTGFS_DIEPINT(epno));
-
-              /* IN transfer complete */
-
-              stm32l4_epin(priv, epno);
-            }
-
-          /* Timeout condition */
-
-          if ((diepint & OTGFS_DIEPINT_TOC) != 0)
-            {
-              usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_EPIN_TOC), (uint16_t)diepint);
-              stm32l4_putreg(OTGFS_DIEPINT_TOC, STM32L4_OTGFS_DIEPINT(epno));
-            }
-
-          /* IN token received when TxFIFO is empty.  Applies to non-periodic IN
-           * endpoints only.  This interrupt indicates that an IN token was received
-           * when the associated TxFIFO (periodic/non-periodic) was empty. This
-           * interrupt is asserted on the endpoint for which the IN token was
-           * received.
-           */
-
-          if ((diepint & OTGFS_DIEPINT_ITTXFE) != 0)
-            {
-              usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_EPIN_ITTXFE), (uint16_t)diepint);
-              stm32l4_epin_request(priv, &priv->epin[epno]);
-              stm32l4_putreg(OTGFS_DIEPINT_ITTXFE, STM32L4_OTGFS_DIEPINT(epno));
-            }
-
-          /* IN endpoint NAK effective (ignored as this used only in polled
-           * mode)
-           */
-#if 0
-          if ((diepint & OTGFS_DIEPINT_INEPNE) != 0)
-            {
-              usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_EPIN_INEPNE), (uint16_t)diepint);
-              stm32l4_putreg(OTGFS_DIEPINT_INEPNE, STM32L4_OTGFS_DIEPINT(epno));
-            }
-#endif
-          /* Endpoint disabled interrupt (ignored as this used only in polled
-           * mode)
-           */
-#if 0
-          if ((diepint & OTGFS_DIEPINT_EPDISD) != 0)
-            {
-              usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_EPIN_EPDISD), (uint16_t)diepint);
-              stm32l4_putreg(OTGFS_DIEPINT_EPDISD, STM32L4_OTGFS_DIEPINT(epno));
-            }
-#endif
-          /* Transmit FIFO empty */
-
-          if ((diepint & OTGFS_DIEPINT_TXFE) != 0)
-            {
-              usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_EPIN_TXFE), (uint16_t)diepint);
-
-              /* If we were waiting for TxFIFO to become empty, the we might have both
-               * XFRC and TXFE interrupts pending.  Since we do the same thing for both
-               * cases, ignore the TXFE if we have already processed the XFRC.
-               */
-
-              if ((diepint & OTGFS_DIEPINT_XFRC) == 0)
-                {
-                  /* Mask further FIFO empty interrupts.  This will be re-enabled
-                   * whenever we need to wait for a FIFO event.
-                   */
-
-                  empty &= ~OTGFS_DIEPEMPMSK(epno);
-                  stm32l4_putreg(empty, STM32L4_OTGFS_DIEPEMPMSK);
-
-                  /* Handle TxFIFO empty */
-
-                  stm32l4_epin_txfifoempty(priv, epno);
-                }
-
-              /* Clear the pending TxFIFO empty interrupt */
-
-              stm32l4_putreg(OTGFS_DIEPINT_TXFE, STM32L4_OTGFS_DIEPINT(epno));
-            }
-        }
-
-      epno++;
-      daint >>= 1;
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_resumeinterrupt
- *
- * Description:
- *   Resume/remote wakeup detected interrupt
- *
- ****************************************************************************/
-
-static inline void stm32l4_resumeinterrupt(FAR struct stm32l4_usbdev_s *priv)
-{
-  uint32_t regval;
-
-  /* Restart the PHY clock and un-gate USB core clock (HCLK) */
-
-#ifdef CONFIG_USBDEV_LOWPOWER
-  regval = stm32l4_getreg(STM32L4_OTGFS_PCGCCTL);
-  regval &= ~(OTGFS_PCGCCTL_STPPCLK | OTGFS_PCGCCTL_GATEHCLK);
-  stm32l4_putreg(regval, STM32L4_OTGFS_PCGCCTL);
-#endif
-
-  /* Clear remote wake-up signaling */
-
-  regval  = stm32l4_getreg(STM32L4_OTGFS_DCTL);
-  regval &= ~OTGFS_DCTL_RWUSIG;
-  stm32l4_putreg(regval, STM32L4_OTGFS_DCTL);
-
-  /* Restore full power -- whatever that means for this particular board */
-
-  stm32l4_usbsuspend((struct usbdev_s *)priv, true);
-
-  /* Notify the class driver of the resume event */
-
-  if (priv->driver)
-    {
-      CLASS_RESUME(priv->driver, &priv->usbdev);
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_suspendinterrupt
- *
- * Description:
- *   USB suspend interrupt
- *
- ****************************************************************************/
-
-static inline void stm32l4_suspendinterrupt(FAR struct stm32l4_usbdev_s *priv)
-{
-#ifdef CONFIG_USBDEV_LOWPOWER
-  uint32_t regval;
-#endif
-
-  /* Notify the class driver of the suspend event */
-
-  if (priv->driver)
-    {
-      CLASS_SUSPEND(priv->driver, &priv->usbdev);
-    }
-
-#ifdef CONFIG_USBDEV_LOWPOWER
-  /* OTGFS_DSTS_SUSPSTS is set as long as the suspend condition is detected
-   * on USB.  Check if we are still have the suspend condition, that we are
-   * connected to the host, and that we have been configured.
-   */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_DSTS);
-
-  if ((regval & OTGFS_DSTS_SUSPSTS) != 0 && devstate == DEVSTATE_CONFIGURED)
-    {
-      /* Switch off OTG FS clocking.  Setting OTGFS_PCGCCTL_STPPCLK stops the
-       * PHY clock.
-       */
-
-      regval = stm32l4_getreg(STM32L4_OTGFS_PCGCCTL);
-      regval |= OTGFS_PCGCCTL_STPPCLK;
-      stm32l4_putreg(regval, STM32L4_OTGFS_PCGCCTL);
-
-      /* Setting OTGFS_PCGCCTL_GATEHCLK gate HCLK to modules other than
-       * the AHB Slave and Master and wakeup logic.
-       */
-
-      regval |= OTGFS_PCGCCTL_GATEHCLK;
-      stm32l4_putreg(regval, STM32L4_OTGFS_PCGCCTL);
-    }
-#endif
-
-  /* Let the board-specific logic know that we have entered the suspend
-   * state
-   */
-
-  stm32l4_usbsuspend((FAR struct usbdev_s *)priv, false);
-}
-
-/****************************************************************************
- * Name: stm32l4_rxinterrupt
- *
- * Description:
- *   RxFIFO non-empty interrupt.  This interrupt indicates that there is at
- *   least one packet pending to be read from the RxFIFO.
- *
- ****************************************************************************/
-
-static inline void stm32l4_rxinterrupt(FAR struct stm32l4_usbdev_s *priv)
-{
-  FAR struct stm32l4_ep_s *privep;
-  uint32_t regval;
-  int bcnt;
-  int epphy;
-
-  while (0 != (stm32l4_getreg(STM32L4_OTGFS_GINTSTS) & OTGFS_GINT_RXFLVL))
-    {
-
-      /* Get the status from the top of the FIFO */
-
-      regval = stm32l4_getreg(STM32L4_OTGFS_GRXSTSP);
-
-      /* Decode status fields */
-
-      epphy  = (regval & OTGFS_GRXSTSD_EPNUM_MASK) >> OTGFS_GRXSTSD_EPNUM_SHIFT;
-
-      /* Workaround for bad values read from the STM32L4_OTGFS_GRXSTSP register
-       * happens regval is 0xb4e48168 or 0xa80c9367 or 267E781c
-       * All of which provide out of range indexes for  epout[epphy]
-       */
-
-      if (epphy < STM32L4_NENDPOINTS)
-        {
-          privep = &priv->epout[epphy];
-
-          /* Handle the RX event according to the packet status field */
-
-          switch (regval & OTGFS_GRXSTSD_PKTSTS_MASK)
-            {
-              /* Global OUT NAK.  This indicate that the global OUT NAK bit has taken
-               * effect.
-               *
-               * PKTSTS = Global OUT NAK, BCNT = 0, EPNUM = Don't Care, DPID = Don't
-               * Care.
-               */
-
-              case OTGFS_GRXSTSD_PKTSTS_OUTNAK:
-                {
-                  usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_OUTNAK), 0);
-                }
-                break;
-
-              /* OUT data packet received.
-               *
-               * PKTSTS = DataOUT, BCNT = size of the received data OUT packet,
-               * EPNUM = EPNUM on which the packet was received, DPID = Actual Data PID.
-               */
-
-              case OTGFS_GRXSTSD_PKTSTS_OUTRECVD:
-                {
-                  usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_OUTRECVD), epphy);
-                  bcnt = (regval & OTGFS_GRXSTSD_BCNT_MASK) >> OTGFS_GRXSTSD_BCNT_SHIFT;
-                  if (bcnt > 0)
-                    {
-                      stm32l4_epout_receive(privep, bcnt);
-                    }
-                }
-                break;
-
-              /* OUT transfer completed.  This indicates that an OUT data transfer for
-               * the specified OUT endpoint has completed. After this entry is popped
-               * from the receive FIFO, the core asserts a Transfer Completed interrupt
-               * on the specified OUT endpoint.
-               *
-               * PKTSTS = Data OUT Transfer Done, BCNT = 0, EPNUM = OUT EP Num on
-               * which the data transfer is complete, DPID = Don't Care.
-               */
-
-              case OTGFS_GRXSTSD_PKTSTS_OUTDONE:
-                {
-                  usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_OUTDONE), epphy);
-                }
-                break;
-
-              /* SETUP transaction completed. This indicates that the Setup stage for
-               * the specified endpoint has completed and the Data stage has started.
-               * After this entry is popped from the receive FIFO, the core asserts a
-               * Setup interrupt on the specified control OUT endpoint (triggers an
-               * interrupt).
-               *
-               * PKTSTS = Setup Stage Done, BCNT = 0, EPNUM = Control EP Num,
-               * DPID = Don't Care.
-               */
-
-              case OTGFS_GRXSTSD_PKTSTS_SETUPDONE:
-                {
-                  usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_SETUPDONE), epphy);
-
-                  /* On the L4 This event does not occur on the next SETUP
-                   * after a SETUP OUT.
-                   */
-
-                }
-                break;
-
-              /* SETUP data packet received.  This indicates that a SETUP packet for the
-               * specified endpoint is now available for reading from the receive FIFO.
-               *
-               * PKTSTS = SETUP, BCNT = 8, EPNUM = Control EP Num, DPID = D0.
-               */
-
-              case OTGFS_GRXSTSD_PKTSTS_SETUPRECVD:
-                {
-                  uint16_t datlen;
-
-                  usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_SETUPRECVD), epphy);
-
-                  /* Read EP0 setup data.  NOTE:  If multiple SETUP packets are received,
-                   * the last one overwrites the previous setup packets and only that
-                   * last SETUP packet will be processed.
-                   */
-
-                  stm32l4_rxfifo_read(&priv->epout[EP0], (FAR uint8_t *)&priv->ctrlreq,
-                                      USB_SIZEOF_CTRLREQ);
-
-                  /* Was this an IN or an OUT SETUP packet.  If it is an OUT SETUP,
-                   * then we need to wait for the completion of the data phase to
-                   * process the setup command.  If it is an IN SETUP packet, then
-                   * we must processing the command BEFORE we enter the DATA phase.
-                   *
-                   * If the data associated with the OUT SETUP packet is zero length,
-                   * then, of course, we don't need to wait.
-                   */
-
-                  datlen = GETUINT16(priv->ctrlreq.len);
-                  if (USB_REQ_ISOUT(priv->ctrlreq.type) && datlen > 0)
-                    {
-                      /* Reset the endpoint and Stop NAK-ing */
-
-                      stm32l4_ep0out_ctrlsetup(priv);
-
-                      /* Wait for the data phase. */
-
-                      priv->ep0state = EP0STATE_SETUP_OUT;
-                    }
-                  else
-                    {
-                      /* We can process the setup data Now no need to wait for SETUP done word
-                       * to be popped of the RxFIFO.
-                       */
-
-                      priv->ep0state = EP0STATE_SETUP_READY;
-                      stm32l4_ep0out_setup(priv);
-
-                    }
-                }
-                break;
-
-              default:
-                {
-                  usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_INVALIDPARMS),
-                           (regval & OTGFS_GRXSTSD_PKTSTS_MASK) >> OTGFS_GRXSTSD_PKTSTS_SHIFT);
-                }
-                break;
-            }
-        }
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_enuminterrupt
- *
- * Description:
- *   Enumeration done interrupt
- *
- ****************************************************************************/
-
-static inline void stm32l4_enuminterrupt(FAR struct stm32l4_usbdev_s *priv)
-{
-  uint32_t regval;
-
-  /* Activate EP0 */
-
-  stm32l4_ep0in_activate();
-
-  /* Set USB turn-around time for the full speed device with internal PHY interface. */
-
-  regval  = stm32l4_getreg(STM32L4_OTGFS_GUSBCFG);
-  regval &= ~OTGFS_GUSBCFG_TRDT_MASK;
-  regval |=  OTGFS_GUSBCFG_TRDT(6);
-  stm32l4_putreg(regval, STM32L4_OTGFS_GUSBCFG);
-}
-
-/****************************************************************************
- * Name: stm32l4_isocininterrupt
- *
- * Description:
- *   Incomplete isochronous IN transfer interrupt.  Assertion of the incomplete
- *   isochronous IN transfer interrupt indicates an incomplete isochronous IN
- *   transfer on at least one of the isochronous IN endpoints.
- *
- ****************************************************************************/
-
-#ifdef CONFIG_USBDEV_ISOCHRONOUS
-static inline void stm32l4_isocininterrupt(FAR struct stm32l4_usbdev_s *priv)
-{
-  int i;
-
-  /* The application must read the endpoint control register for all isochronous
-   * IN endpoints to detect endpoints with incomplete IN data transfers.
-   */
-
-  for (i = 0; i < STM32L4_NENDPOINTS; i++)
-    {
-      /* Is this an isochronous IN endpoint? */
-
-      privep = &priv->epin[i];
-      if (privep->eptype != USB_EP_ATTR_XFER_ISOC)
-        {
-          /* No... keep looking */
-
-          continue;
-        }
-
-      /* Is there an active read request on the isochronous OUT endpoint? */
-
-      if (!privep->active)
-        {
-          /* No.. the endpoint is not actively transmitting data */
-
-          continue;
-        }
-
-      /* Check if this is the endpoint that had the incomplete transfer */
-
-      regaddr = STM32L4_OTGFS_DIEPCTL(privep->epphy);
-      doepctl = stm32l4_getreg(regaddr);
-      dsts    = stm32l4_getreg(STM32L4_OTGFS_DSTS);
-
-      /* EONUM = 0:even frame, 1:odd frame
-       * SOFFN = Frame number of the received SOF
-       */
-
-      eonum = ((doepctl & OTGFS_DIEPCTL_EONUM) != 0);
-      soffn = ((dsts & OTGFS_DSTS_SOFFN0) != 0);
-
-      if (eonum != soffn)
-        {
-          /* Not this endpoint */
-
-          continue;
-        }
-
-      /* For isochronous IN endpoints with incomplete transfers,
-       * the application must discard the data in the memory and
-       * disable the endpoint.
-       */
-
-      stm32l4_req_complete(privep, -EIO);
-#warning "Will clear OTGFS_DIEPCTL_USBAEP too"
-      stm32l4_epin_disable(privep);
-      break;
-    }
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_isocoutinterrupt
- *
- * Description:
- *   Incomplete periodic transfer interrupt
- *
- ****************************************************************************/
-
-#ifdef CONFIG_USBDEV_ISOCHRONOUS
-static inline void stm32l4_isocoutinterrupt(FAR struct stm32l4_usbdev_s *priv)
-{
-  FAR struct stm32l4_ep_s *privep;
-  FAR struct stm32l4_req_s *privreq;
-  uint32_t regaddr;
-  uint32_t doepctl;
-  uint32_t dsts;
-  bool eonum;
-  bool soffn;
-
-  /* When it receives an IISOOXFR interrupt, the application must read the
-   * control registers of all isochronous OUT endpoints to determine which
-   * endpoints had an incomplete transfer in the current microframe. An
-   * endpoint transfer is incomplete if both the following conditions are true:
-   *
-   *   DOEPCTLx:EONUM = DSTS:SOFFN[0], and
-   *   DOEPCTLx:EPENA = 1
-   */
-
-  for (i = 0; i < STM32L4_NENDPOINTS; i++)
-    {
-      /* Is this an isochronous OUT endpoint? */
-
-      privep = &priv->epout[i];
-      if (privep->eptype != USB_EP_ATTR_XFER_ISOC)
-        {
-          /* No... keep looking */
-
-          continue;
-        }
-
-      /* Is there an active read request on the isochronous OUT endpoint? */
-
-      if (!privep->active)
-        {
-          /* No.. the endpoint is not actively transmitting data */
-
-          continue;
-        }
-
-      /* Check if this is the endpoint that had the incomplete transfer */
-
-      regaddr = STM32L4_OTGFS_DOEPCTL(privep->epphy);
-      doepctl = stm32l4_getreg(regaddr);
-      dsts    = stm32l4_getreg(STM32L4_OTGFS_DSTS);
-
-      /* EONUM = 0:even frame, 1:odd frame
-       * SOFFN = Frame number of the received SOF
-       */
-
-      eonum = ((doepctl & OTGFS_DOEPCTL_EONUM) != 0);
-      soffn = ((dsts & OTGFS_DSTS_SOFFN0) != 0);
-
-      if (eonum != soffn)
-        {
-          /* Not this endpoint */
-
-          continue;
-        }
-
-      /* For isochronous OUT endpoints with incomplete transfers,
-       * the application must discard the data in the memory and
-       * disable the endpoint.
-       */
-
-      stm32l4_req_complete(privep, -EIO);
-#warning "Will clear OTGFS_DOEPCTL_USBAEP too"
-      stm32l4_epout_disable(privep);
-      break;
-    }
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_sessioninterrupt
- *
- * Description:
- *   Session request/new session detected interrupt
- *
- ****************************************************************************/
-
-#ifdef CONFIG_USBDEV_VBUSSENSING
-static inline void stm32l4_sessioninterrupt(FAR struct stm32l4_usbdev_s *priv)
-{
-#warning "Missing logic"
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_otginterrupt
- *
- * Description:
- *   OTG interrupt
- *
- ****************************************************************************/
-
-#ifdef CONFIG_USBDEV_VBUSSENSING
-static inline void stm32l4_otginterrupt(FAR struct stm32l4_usbdev_s *priv)
-{
-  uint32_t regval;
-
-  /* Check for session end detected */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_GOTGINT);
-  if ((regval & OTGFS_GOTGINT_SEDET) != 0)
-    {
-#warning "Missing logic"
-    }
-
-  /* Clear OTG interrupt */
-
-  stm32l4_putreg(regval, STM32L4_OTGFS_GOTGINT);
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_usbinterrupt
- *
- * Description:
- *   USB interrupt handler
- *
- ****************************************************************************/
-
-static int stm32l4_usbinterrupt(int irq, FAR void *context, FAR void *arg)
-{
-  /* At present, there is only a single OTG FS device support. Hence it is
-   * pre-allocated as g_otgfsdev.  However, in most code, the private data
-   * structure will be referenced using the 'priv' pointer (rather than the
-   * global data) in order to simplify any future support for multiple devices.
-   */
-
-  FAR struct stm32l4_usbdev_s *priv = &g_otgfsdev;
-  uint32_t regval;
-  uint32_t reserved;
-
-  usbtrace(TRACE_INTENTRY(STM32L4_TRACEINTID_USB), priv->ep0state);
-
-  /* Assure that we are in device mode */
-
-  DEBUGASSERT((stm32l4_getreg(STM32L4_OTGFS_GINTSTS) & OTGFS_GINTSTS_CMOD) == OTGFS_GINTSTS_DEVMODE);
-
-  /* Get the state of all enabled interrupts.  We will do this repeatedly
-   * some interrupts (like RXFLVL) will generate additional interrupting
-   * events.
-   */
-  for (; ; )
-    {
-      /* Get the set of pending, un-masked interrupts */
-
-      regval  = stm32l4_getreg(STM32L4_OTGFS_GINTSTS);
-      reserved = (regval & OTGFS_GINT_RESERVED);
-      regval &= stm32l4_getreg(STM32L4_OTGFS_GINTMSK);
-
-      /* With out modifying the reserved bits, acknowledge all
-       * **Writable** pending irqs we will service below
-       */
-
-      stm32l4_putreg(((regval | reserved) & OTGFS_GINT_RC_W1), STM32L4_OTGFS_GINTSTS);
-
-
-      /* Break out of the loop when there are no further pending (and
-       * unmasked) interrupts to be processes.
-       */
-
-      if (regval == 0)
-        {
-          break;
-        }
-      usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_INTPENDING), (uint16_t)regval);
-
-      /* OUT endpoint interrupt. The core sets this bit to indicate that an
-       * interrupt is pending on one of the OUT endpoints of the core.
-       */
-
-      if ((regval & OTGFS_GINT_OEP) != 0)
-        {
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_EPOUT), (uint16_t)regval);
-          stm32l4_epout_interrupt(priv);
-        }
-
-      /* IN endpoint interrupt.  The core sets this bit to indicate that
-       * an interrupt is pending on one of the IN endpoints of the core.
-       */
-
-      if ((regval & OTGFS_GINT_IEP) != 0)
-        {
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_EPIN), (uint16_t)regval);
-          stm32l4_epin_interrupt(priv);
-        }
-
-      /* Host/device mode mismatch error interrupt */
-
-#ifdef CONFIG_DEBUG_FEATURES
-      if ((regval & OTGFS_GINT_MMIS) != 0)
-        {
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_MISMATCH), (uint16_t)regval);
-        }
-#endif
-
-      /* Resume/remote wakeup detected interrupt */
-
-      if ((regval & OTGFS_GINT_WKUP) != 0)
-        {
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_WAKEUP), (uint16_t)regval);
-          stm32l4_resumeinterrupt(priv);
-        }
-
-      /* USB suspend interrupt */
-
-      if ((regval & OTGFS_GINT_USBSUSP) != 0)
-        {
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_SUSPEND), (uint16_t)regval);
-          stm32l4_suspendinterrupt(priv);
-        }
-
-      /* Start of frame interrupt */
-
-#ifdef CONFIG_USBDEV_SOFINTERRUPT
-      if ((regval & OTGFS_GINT_SOF) != 0)
-        {
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_SOF), (uint16_t)regval);
-        }
-#endif
-
-      /* RxFIFO non-empty interrupt.  Indicates that there is at least one
-       * packet pending to be read from the RxFIFO.
-       */
-
-      if ((regval & OTGFS_GINT_RXFLVL) != 0)
-        {
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_RXFIFO), (uint16_t)regval);
-          stm32l4_rxinterrupt(priv);
-        }
-
-      /* USB reset interrupt */
-
-      if ((regval & (OTGFS_GINT_USBRST | OTGFS_GINT_RSTDET)) != 0)
-        {
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_DEVRESET), (uint16_t)regval);
-
-          /* Perform the device reset */
-
-          stm32l4_usbreset(priv);
-          usbtrace(TRACE_INTEXIT(STM32L4_TRACEINTID_USB), priv->ep0state);
-          return OK;
-        }
-
-      /* Enumeration done interrupt */
-
-      if ((regval & OTGFS_GINT_ENUMDNE) != 0)
-        {
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_ENUMDNE), (uint16_t)regval);
-          stm32l4_enuminterrupt(priv);
-        }
-
-      /* Incomplete isochronous IN transfer interrupt.  When the core finds
-       * non-empty any of the isochronous IN endpoint FIFOs scheduled for
-       * the current frame non-empty, the core generates an IISOIXFR
-       * interrupt.
-       */
-
-#ifdef CONFIG_USBDEV_ISOCHRONOUS
-      if ((regval & OTGFS_GINT_IISOIXFR) != 0)
-        {
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_IISOIXFR), (uint16_t)regval);
-          stm32l4_isocininterrupt(priv);
-        }
-
-      /* Incomplete isochronous OUT transfer.  For isochronous OUT
-       * endpoints, the XFRC interrupt may not always be asserted. If the
-       * core drops isochronous OUT data packets, the application could fail
-       * to detect the XFRC interrupt.  The incomplete Isochronous OUT data
-       * interrupt indicates that an XFRC interrupt was not asserted on at
-       * least one of the isochronous OUT endpoints. At this point, the
-       * endpoint with the incomplete transfer remains enabled, but no active
-       * transfers remain in progress on this endpoint on the USB.
-       */
-
-      if ((regval & OTGFS_GINT_IISOOXFR) != 0)
-        {
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_IISOOXFR), (uint16_t)regval);
-          stm32l4_isocoutinterrupt(priv);
-        }
-#endif
-
-      /* Session request/new session detected interrupt */
-
-#ifdef CONFIG_USBDEV_VBUSSENSING
-      if ((regval & OTGFS_GINT_SRQ) != 0)
-        {
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_SRQ), (uint16_t)regval);
-          stm32l4_sessioninterrupt(priv);
-        }
-
-      /* OTG interrupt */
-
-      if ((regval & OTGFS_GINT_OTG) != 0)
-        {
-          usbtrace(TRACE_INTDECODE(STM32L4_TRACEINTID_OTG), (uint16_t)regval);
-          stm32l4_otginterrupt(priv);
-        }
-#endif
-    }
-
-  usbtrace(TRACE_INTEXIT(STM32L4_TRACEINTID_USB), priv->ep0state);
-  return OK;
-}
-
-/****************************************************************************
- * Endpoint operations
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_enablegonak
- *
- * Description:
- *   Enable global OUT NAK mode
- *
- ****************************************************************************/
-
-static void stm32l4_enablegonak(FAR struct stm32l4_ep_s *privep)
-{
-  uint32_t regval;
-
-  /* First, make sure that there is no GNOAKEFF interrupt pending. */
-
-#if 0
-  stm32l4_putreg(OTGFS_GINT_GONAKEFF, STM32L4_OTGFS_GINTSTS);
-#endif
-
-  /* Enable Global OUT NAK mode in the core. */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_DCTL);
-  regval |= OTGFS_DCTL_SGONAK;
-  stm32l4_putreg(regval, STM32L4_OTGFS_DCTL);
-
-#if 0
-  /* Wait for the GONAKEFF interrupt that indicates that the OUT NAK
-   * mode is in effect.  When the interrupt handler pops the OUTNAK word
-   * from the RxFIFO, the core sets the GONAKEFF interrupt.
-   */
-
-  while ((stm32l4_getreg(STM32L4_OTGFS_GINTSTS) & OTGFS_GINT_GONAKEFF) == 0);
-  stm32l4_putreg(OTGFS_GINT_GONAKEFF, STM32L4_OTGFS_GINTSTS);
-
-#else
-  /* Since we are in the interrupt handler, we cannot wait inline for the
-   * GONAKEFF because it cannot occur until service the RXFLVL global interrupt
-   * and pop the OUTNAK word from the RxFIFO.
-   *
-   * Perhaps it is sufficient to wait for Global OUT NAK status to be reported
-   * in OTGFS DCTL register?
-   */
-
-  while ((stm32l4_getreg(STM32L4_OTGFS_DCTL) & OTGFS_DCTL_GONSTS) == 0);
-#endif
-}
-
-/****************************************************************************
- * Name: stm32l4_disablegonak
- *
- * Description:
- *   Disable global OUT NAK mode
- *
- ****************************************************************************/
-
-static void stm32l4_disablegonak(FAR struct stm32l4_ep_s *privep)
-{
-  uint32_t regval;
-
-  /* Set the "Clear the Global OUT NAK bit" to disable global OUT NAK mode */
-
-  regval  = stm32l4_getreg(STM32L4_OTGFS_DCTL);
-  regval |= OTGFS_DCTL_CGONAK;
-  stm32l4_putreg(regval, STM32L4_OTGFS_DCTL);
-}
-
-/****************************************************************************
- * Name: stm32l4_epout_configure
- *
- * Description:
- *   Configure an OUT endpoint, making it usable
- *
- * Input Parameters:
- *   privep    - a pointer to an internal endpoint structure
- *   eptype    - The type of the endpoint
- *   maxpacket - The max packet size of the endpoint
- *
- ****************************************************************************/
-
-static int stm32l4_epout_configure(FAR struct stm32l4_ep_s *privep,
-                                   uint8_t eptype, uint16_t maxpacket)
-{
-  uint32_t mpsiz;
-  uint32_t regaddr;
-  uint32_t regval;
-
-  usbtrace(TRACE_EPCONFIGURE, privep->epphy);
-
-  /* For EP0, the packet size is encoded */
-
-  if (privep->epphy == EP0)
-    {
-      DEBUGASSERT(eptype == USB_EP_ATTR_XFER_CONTROL);
-
-      /* Map the size in bytes to the encoded value in the register */
-
-      switch (maxpacket)
-        {
-          case 8:
-            mpsiz = OTGFS_DOEPCTL0_MPSIZ_8;
-            break;
-
-          case 16:
-            mpsiz = OTGFS_DOEPCTL0_MPSIZ_16;
-            break;
-
-          case 32:
-            mpsiz = OTGFS_DOEPCTL0_MPSIZ_32;
-            break;
-
-          case 64:
-            mpsiz = OTGFS_DOEPCTL0_MPSIZ_64;
-            break;
-
-          default:
-            uerr("Unsupported maxpacket: %d\n", maxpacket);
-            return -EINVAL;
-        }
-    }
-
-  /* For other endpoints, the packet size is in bytes */
-
-  else
-    {
-      mpsiz = (maxpacket << OTGFS_DOEPCTL_MPSIZ_SHIFT);
-    }
-
-  /* If the endpoint is already active don't change the endpoint control
-   * register.
-   */
-
-  regaddr = STM32L4_OTGFS_DOEPCTL(privep->epphy);
-  regval  = stm32l4_getreg(regaddr);
-  if ((regval & OTGFS_DOEPCTL_USBAEP) == 0)
-    {
-      if (regval & OTGFS_DOEPCTL_NAKSTS)
-        {
-          regval |= OTGFS_DOEPCTL_CNAK;
-        }
-
-      regval &= ~(OTGFS_DOEPCTL_MPSIZ_MASK | OTGFS_DOEPCTL_EPTYP_MASK);
-      regval |= mpsiz;
-      regval |= (eptype << OTGFS_DOEPCTL_EPTYP_SHIFT);
-      regval |= (OTGFS_DOEPCTL_SD0PID | OTGFS_DOEPCTL_USBAEP);
-      stm32l4_putreg(regval, regaddr);
-
-      /* Save the endpoint configuration */
-
-      privep->ep.maxpacket = maxpacket;
-      privep->eptype       = eptype;
-      privep->stalled      = false;
-    }
-
-  /* Enable the interrupt for this endpoint */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_DAINTMSK);
-  regval |= OTGFS_DAINT_OEP(privep->epphy);
-  stm32l4_putreg(regval, STM32L4_OTGFS_DAINTMSK);
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_epin_configure
- *
- * Description:
- *   Configure an IN endpoint, making it usable
- *
- * Input Parameters:
- *   privep    - a pointer to an internal endpoint structure
- *   eptype    - The type of the endpoint
- *   maxpacket - The max packet size of the endpoint
- *
- ****************************************************************************/
-
-static int stm32l4_epin_configure(FAR struct stm32l4_ep_s *privep, uint8_t eptype,
-                                  uint16_t maxpacket)
-{
-  uint32_t mpsiz;
-  uint32_t regaddr;
-  uint32_t regval;
-
-  usbtrace(TRACE_EPCONFIGURE, privep->epphy);
-
-  /* For EP0, the packet size is encoded */
-
-  if (privep->epphy == EP0)
-    {
-      DEBUGASSERT(eptype == USB_EP_ATTR_XFER_CONTROL);
-
-      /* Map the size in bytes to the encoded value in the register */
-
-      switch (maxpacket)
-        {
-          case 8:
-            mpsiz = OTGFS_DIEPCTL0_MPSIZ_8;
-            break;
-
-          case 16:
-            mpsiz = OTGFS_DIEPCTL0_MPSIZ_16;
-            break;
-
-          case 32:
-            mpsiz = OTGFS_DIEPCTL0_MPSIZ_32;
-            break;
-
-          case 64:
-            mpsiz = OTGFS_DIEPCTL0_MPSIZ_64;
-            break;
-
-          default:
-            uerr("Unsupported maxpacket: %d\n", maxpacket);
-            return -EINVAL;
-        }
-    }
-
-  /* For other endpoints, the packet size is in bytes */
-
-  else
-    {
-      mpsiz = (maxpacket << OTGFS_DIEPCTL_MPSIZ_SHIFT);
-    }
-
-
-  /* If the endpoint is already active don't change the endpoint control
-   * register.
-   */
-
-  regaddr = STM32L4_OTGFS_DIEPCTL(privep->epphy);
-  regval  = stm32l4_getreg(regaddr);
-  if ((regval & OTGFS_DIEPCTL_USBAEP) == 0)
-    {
-      if (regval & OTGFS_DIEPCTL_NAKSTS)
-        {
-          regval |= OTGFS_DIEPCTL_CNAK;
-        }
-
-      regval &= ~(OTGFS_DIEPCTL_MPSIZ_MASK | OTGFS_DIEPCTL_EPTYP_MASK | OTGFS_DIEPCTL_TXFNUM_MASK);
-      regval |= mpsiz;
-      regval |= (eptype << OTGFS_DIEPCTL_EPTYP_SHIFT);
-      regval |= (eptype << OTGFS_DIEPCTL_TXFNUM_SHIFT);
-      regval |= (OTGFS_DIEPCTL_SD0PID | OTGFS_DIEPCTL_USBAEP);
-      stm32l4_putreg(regval, regaddr);
-
-      /* Save the endpoint configuration */
-
-      privep->ep.maxpacket = maxpacket;
-      privep->eptype       = eptype;
-      privep->stalled      = false;
-    }
-
-  /* Enable the interrupt for this endpoint */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_DAINTMSK);
-  regval |= OTGFS_DAINT_IEP(privep->epphy);
-  stm32l4_putreg(regval, STM32L4_OTGFS_DAINTMSK);
-
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_ep_configure
- *
- * Description:
- *   Configure endpoint, making it usable
- *
- * Input Parameters:
- *   ep   - the struct usbdev_ep_s instance obtained from allocep()
- *   desc - A struct usb_epdesc_s instance describing the endpoint
- *   last - true if this this last endpoint to be configured.  Some hardware
- *          needs to take special action when all of the endpoints have been
- *          configured.
- *
- ****************************************************************************/
-
-static int stm32l4_ep_configure(FAR struct usbdev_ep_s *ep,
-                                FAR const struct usb_epdesc_s *desc,
-                                bool last)
-{
-  FAR struct stm32l4_ep_s *privep = (FAR struct stm32l4_ep_s *)ep;
-  uint16_t maxpacket;
-  uint8_t  eptype;
-  int ret;
-
-  usbtrace(TRACE_EPCONFIGURE, privep->epphy);
-  DEBUGASSERT(desc->addr == ep->eplog);
-
-  /* Initialize EP capabilities */
-
-  maxpacket = GETUINT16(desc->mxpacketsize);
-  eptype    = desc->attr & USB_EP_ATTR_XFERTYPE_MASK;
-
-  /* Setup Endpoint Control Register */
-
-  if (privep->isin)
-    {
-      ret = stm32l4_epin_configure(privep, eptype, maxpacket);
-    }
-  else
-    {
-      ret = stm32l4_epout_configure(privep, eptype, maxpacket);
-    }
-
-  return ret;
-}
-
-/****************************************************************************
- * Name: stm32l4_ep0_configure
- *
- * Description:
- *   Reset Usb engine
- *
- ****************************************************************************/
-
-static void stm32l4_ep0_configure(FAR struct stm32l4_usbdev_s *priv)
-{
-  /* Enable EP0 IN and OUT */
-
-  (void)stm32l4_epin_configure(&priv->epin[EP0], USB_EP_ATTR_XFER_CONTROL,
-                               CONFIG_USBDEV_EP0_MAXSIZE);
-  (void)stm32l4_epout_configure(&priv->epout[EP0], USB_EP_ATTR_XFER_CONTROL,
-                                CONFIG_USBDEV_EP0_MAXSIZE);
-}
-
-/****************************************************************************
- * Name: stm32l4_epout_disable
- *
- * Description:
- *   Diable an OUT endpoint will no longer be used
- *
- ****************************************************************************/
-
-static void stm32l4_epout_disable(FAR struct stm32l4_ep_s *privep)
-{
-  uint32_t regaddr;
-  uint32_t regval;
-  irqstate_t flags;
-
-  usbtrace(TRACE_EPDISABLE, privep->epphy);
-
-  /* Is this an IN or an OUT endpoint */
-
-  /* Before disabling any OUT endpoint, the application must enable
-   * Global OUT NAK mode in the core.
-   */
-
-  flags = enter_critical_section();
-  stm32l4_enablegonak(privep);
-
-  /* Disable the required OUT endpoint by setting the EPDIS and SNAK bits
-   * int DOECPTL register.
-   */
-
-  regaddr = STM32L4_OTGFS_DOEPCTL(privep->epphy);
-  regval  = stm32l4_getreg(regaddr);
-  regval &= ~OTGFS_DOEPCTL_USBAEP;
-  regval |= (OTGFS_DOEPCTL_EPDIS | OTGFS_DOEPCTL_SNAK);
-  stm32l4_putreg(regval, regaddr);
-
-  /* Wait for the EPDISD interrupt which indicates that the OUT
-   * endpoint is completely disabled.
-   */
-
-#if 0 /* Doesn't happen */
-  regaddr = STM32L4_OTGFS_DOEPINT(privep->epphy);
-  while ((stm32l4_getreg(regaddr) & OTGFS_DOEPINT_EPDISD) == 0);
-#else
-  /* REVISIT: */
-  up_udelay(10);
-#endif
-
-  /* Clear the EPDISD interrupt indication */
-
-  stm32l4_putreg(OTGFS_DOEPINT_EPDISD, STM32L4_OTGFS_DOEPINT(privep->epphy));
-
-  /* Then disable the Global OUT NAK mode to continue receiving data
-   * from other non-disabled OUT endpoints.
-   */
-
-  stm32l4_disablegonak(privep);
-
-  /* Disable endpoint interrupts */
-
-  regval  = stm32l4_getreg(STM32L4_OTGFS_DAINTMSK);
-  regval &= ~OTGFS_DAINT_OEP(privep->epphy);
-  stm32l4_putreg(regval, STM32L4_OTGFS_DAINTMSK);
-
-  /* Cancel any queued read requests */
-
-  stm32l4_req_cancel(privep, -ESHUTDOWN);
-
-  leave_critical_section(flags);
-}
-
-/****************************************************************************
- * Name: stm32l4_epin_disable
- *
- * Description:
- *   Disable an IN endpoint when it will no longer be used
- *
- ****************************************************************************/
-
-static void stm32l4_epin_disable(FAR struct stm32l4_ep_s *privep)
-{
-  uint32_t regaddr;
-  uint32_t regval;
-  irqstate_t flags;
-
-  usbtrace(TRACE_EPDISABLE, privep->epphy);
-
-  /* After USB reset, the endpoint will already be deactivated by the
-   * hardware. Trying to disable again will just hang in the wait.
-   */
-
-  regaddr = STM32L4_OTGFS_DIEPCTL(privep->epphy);
-  regval  = stm32l4_getreg(regaddr);
-  if ((regval & OTGFS_DIEPCTL_USBAEP) == 0)
-    {
-      return;
-    }
-
-  /* This INEPNE wait logic is suggested by reference manual, but seems
-   * to get stuck to infinite loop.
-   */
-
-#if 0
-  /* Make sure that there is no pending IPEPNE interrupt (because we are
-   * to poll this bit below).
-   */
-
-  stm32l4_putreg(OTGFS_DIEPINT_INEPNE, STM32L4_OTGFS_DIEPINT(privep->epphy));
-
-  /* Set the endpoint in NAK mode */
-
-  regaddr = STM32L4_OTGFS_DIEPCTL(privep->epphy);
-  regval  = stm32l4_getreg(regaddr);
-  regval &= ~OTGFS_DIEPCTL_USBAEP;
-  regval |= (OTGFS_DIEPCTL_EPDIS | OTGFS_DIEPCTL_SNAK);
-  stm32l4_putreg(regval, regaddr);
-
-  /* Wait for the INEPNE interrupt that indicates that we are now in NAK mode */
-
-  regaddr = STM32L4_OTGFS_DIEPINT(privep->epphy);
-  while ((stm32l4_getreg(regaddr) & OTGFS_DIEPINT_INEPNE) == 0);
-
-  /* Clear the INEPNE interrupt indication */
-
-  stm32l4_putreg(OTGFS_DIEPINT_INEPNE, regaddr);
-#endif
-
-  /* Deactivate and disable the endpoint by setting the EPDIS and SNAK bits
-   * the DIEPCTLx register.
-   */
-
-  flags = enter_critical_section();
-  regaddr = STM32L4_OTGFS_DIEPCTL(privep->epphy);
-  regval  = stm32l4_getreg(regaddr);
-  regval &= ~OTGFS_DIEPCTL_USBAEP;
-  regval |= (OTGFS_DIEPCTL_EPDIS | OTGFS_DIEPCTL_SNAK);
-  stm32l4_putreg(regval, regaddr);
-
-  /* Wait for the EPDISD interrupt which indicates that the IN
-   * endpoint is completely disabled.
-   */
-
-  regaddr = STM32L4_OTGFS_DIEPINT(privep->epphy);
-  while ((stm32l4_getreg(regaddr) & OTGFS_DIEPINT_EPDISD) == 0);
-
-  /* Clear the EPDISD interrupt indication */
-
-  stm32l4_putreg(OTGFS_DIEPINT_EPDISD, stm32l4_getreg(regaddr));
-
-  /* Flush any data remaining in the TxFIFO */
-
-  stm32l4_txfifo_flush(OTGFS_GRSTCTL_TXFNUM_D(privep->epphy));
-
-  /* Disable endpoint interrupts */
-
-  regval  = stm32l4_getreg(STM32L4_OTGFS_DAINTMSK);
-  regval &= ~OTGFS_DAINT_IEP(privep->epphy);
-  stm32l4_putreg(regval, STM32L4_OTGFS_DAINTMSK);
-
-  /* Cancel any queued write requests */
-
-  stm32l4_req_cancel(privep, -ESHUTDOWN);
-  leave_critical_section(flags);
-}
-
-/****************************************************************************
- * Name: stm32l4_ep_disable
- *
- * Description:
- *   The endpoint will no longer be used
- *
- ****************************************************************************/
-
-static int stm32l4_ep_disable(FAR struct usbdev_ep_s *ep)
-{
-  FAR struct stm32l4_ep_s *privep = (FAR struct stm32l4_ep_s *)ep;
-
-#ifdef CONFIG_DEBUG_FEATURES
-  if (!ep)
-    {
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_INVALIDPARMS), 0);
-      return -EINVAL;
-    }
-#endif
-
-  usbtrace(TRACE_EPDISABLE, privep->epphy);
-
-  /* Is this an IN or an OUT endpoint */
-
-  if (privep->isin)
-    {
-      /* Disable the IN endpoint */
-
-      stm32l4_epin_disable(privep);
-    }
-  else
-    {
-      /* Disable the OUT endpoint */
-
-      stm32l4_epout_disable(privep);
-    }
-
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_ep_allocreq
- *
- * Description:
- *   Allocate an I/O request
- *
- ****************************************************************************/
-
-static FAR struct usbdev_req_s *stm32l4_ep_allocreq(FAR struct usbdev_ep_s *ep)
-{
-  FAR struct stm32l4_req_s *privreq;
-
-#ifdef CONFIG_DEBUG_FEATURES
-  if (!ep)
-    {
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_INVALIDPARMS), 0);
-      return NULL;
-    }
-#endif
-
-  usbtrace(TRACE_EPALLOCREQ, ((FAR struct stm32l4_ep_s *)ep)->epphy);
-
-  privreq = (FAR struct stm32l4_req_s *)kmm_malloc(sizeof(struct stm32l4_req_s));
-  if (!privreq)
-    {
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_ALLOCFAIL), 0);
-      return NULL;
-    }
-
-  memset(privreq, 0, sizeof(struct stm32l4_req_s));
-  return &privreq->req;
-}
-
-/****************************************************************************
- * Name: stm32l4_ep_freereq
- *
- * Description:
- *   Free an I/O request
- *
- ****************************************************************************/
-
-static void stm32l4_ep_freereq(FAR struct usbdev_ep_s *ep, FAR struct usbdev_req_s *req)
-{
-  FAR struct stm32l4_req_s *privreq = (FAR struct stm32l4_req_s *)req;
-
-#ifdef CONFIG_DEBUG_FEATURES
-  if (!ep || !req)
-    {
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_INVALIDPARMS), 0);
-      return;
-    }
-#endif
-
-  usbtrace(TRACE_EPFREEREQ, ((FAR struct stm32l4_ep_s *)ep)->epphy);
-  kmm_free(privreq);
-}
-
-/****************************************************************************
- * Name: stm32l4_ep_allocbuffer
- *
- * Description:
- *   Allocate an I/O buffer
- *
- ****************************************************************************/
-
-#ifdef CONFIG_USBDEV_DMA
-static void *stm32l4_ep_allocbuffer(FAR struct usbdev_ep_s *ep, unsigned bytes)
-{
-  usbtrace(TRACE_EPALLOCBUFFER, privep->epphy);
-
-#ifdef CONFIG_USBDEV_DMAMEMORY
-  return usbdev_dma_alloc(bytes);
-#else
-  return kmm_malloc(bytes);
-#endif
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_ep_freebuffer
- *
- * Description:
- *   Free an I/O buffer
- *
- ****************************************************************************/
-
-#ifdef CONFIG_USBDEV_DMA
-static void stm32l4_ep_freebuffer(FAR struct usbdev_ep_s *ep, FAR void *buf)
-{
-  usbtrace(TRACE_EPFREEBUFFER, privep->epphy);
-
-#ifdef CONFIG_USBDEV_DMAMEMORY
-  usbdev_dma_free(buf);
-#else
-  kmm_free(buf);
-#endif
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_ep_submit
- *
- * Description:
- *   Submit an I/O request to the endpoint
- *
- ****************************************************************************/
-
-static int stm32l4_ep_submit(FAR struct usbdev_ep_s *ep,
-                             FAR struct usbdev_req_s *req)
-{
-  FAR struct stm32l4_req_s *privreq = (FAR struct stm32l4_req_s *)req;
-  FAR struct stm32l4_ep_s *privep = (FAR struct stm32l4_ep_s *)ep;
-  FAR struct stm32l4_usbdev_s *priv;
-  irqstate_t flags;
-  int ret = OK;
-
-  /* Some sanity checking */
-
-#ifdef CONFIG_DEBUG_FEATURES
-  if (!req || !req->callback || !req->buf || !ep)
-    {
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_INVALIDPARMS), 0);
-      uinfo("req=%p callback=%p buf=%p ep=%p\n", req, req->callback, req->buf, ep);
-      return -EINVAL;
-    }
-#endif
-
-  usbtrace(TRACE_EPSUBMIT, privep->epphy);
-  priv = privep->dev;
-
-#ifdef CONFIG_DEBUG_FEATURES
-  if (!priv->driver)
-    {
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_NOTCONFIGURED), priv->usbdev.speed);
-      return -ESHUTDOWN;
-    }
-#endif
-
-  /* Handle the request from the class driver */
-
-  req->result = -EINPROGRESS;
-  req->xfrd   = 0;
-
-  /* Disable Interrupts */
-
-  flags = enter_critical_section();
-
-  /* If we are stalled, then drop all requests on the floor */
-
-  if (privep->stalled)
-    {
-      ret = -EBUSY;
-    }
-  else
-    {
-      /* Add the new request to the request queue for the endpoint. */
-
-      if (stm32l4_req_addlast(privep, privreq) && !privep->active)
-        {
-          /* If a request was added to an IN endpoint, then attempt to send
-           * the request data buffer now.
-           */
-
-          if (privep->isin)
-            {
-              usbtrace(TRACE_INREQQUEUED(privep->epphy), privreq->req.len);
-
-              /* If the endpoint is not busy with another write request,
-               * then process the newly received write request now.
-               */
-
-              if (!privep->active)
-                {
-                  stm32l4_epin_request(priv, privep);
-                }
-            }
-
-          /* If the request was added to an OUT endpoint, then attempt to
-           * setup a read into the request data buffer now (this will, of
-           * course, fail if there is already a read in place).
-           */
-
-          else
-            {
-              usbtrace(TRACE_OUTREQQUEUED(privep->epphy), privreq->req.len);
-              stm32l4_epout_request(priv, privep);
-            }
-        }
-    }
-
-  leave_critical_section(flags);
-  return ret;
-}
-
-/****************************************************************************
- * Name: stm32l4_ep_cancel
- *
- * Description:
- *   Cancel an I/O request previously sent to an endpoint
- *
- ****************************************************************************/
-
-static int stm32l4_ep_cancel(FAR struct usbdev_ep_s *ep,
-                             FAR struct usbdev_req_s *req)
-{
-  FAR struct stm32l4_ep_s *privep = (FAR struct stm32l4_ep_s *)ep;
-  irqstate_t flags;
-
-#ifdef CONFIG_DEBUG_FEATURES
-  if (!ep || !req)
-    {
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_INVALIDPARMS), 0);
-      return -EINVAL;
-    }
-#endif
-
-  usbtrace(TRACE_EPCANCEL, privep->epphy);
-
-  flags = enter_critical_section();
-
-  /* FIXME: if the request is the first, then we need to flush the EP
-   *         otherwise just remove it from the list
-   *
-   *  but ... all other implementations cancel all requests ...
-   */
-
-  stm32l4_req_cancel(privep, -ESHUTDOWN);
-  leave_critical_section(flags);
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_epout_setstall
- *
- * Description:
- *   Stall an OUT endpoint
- *
- ****************************************************************************/
-
-static int stm32l4_epout_setstall(FAR struct stm32l4_ep_s *privep)
-{
-#if 1
-  /* This implementation follows the requirements from the STM32 F4 reference
-   * manual.
-   */
-
-  uint32_t regaddr;
-  uint32_t regval;
-
-  /* Put the core in the Global OUT NAK mode */
-
-  stm32l4_enablegonak(privep);
-
-  /* Disable and STALL the OUT endpoint by setting the EPDIS and STALL bits
-   * in the DOECPTL register.
-   */
-
-  regaddr = STM32L4_OTGFS_DOEPCTL(privep->epphy);
-  regval  = stm32l4_getreg(regaddr);
-  regval |= (OTGFS_DOEPCTL_EPDIS | OTGFS_DOEPCTL_STALL);
-  stm32l4_putreg(regval, regaddr);
-
-  /* Wait for the EPDISD interrupt which indicates that the OUT
-   * endpoint is completely disabled.
-   */
-
-#if 0 /* Doesn't happen */
-  regaddr = STM32L4_OTGFS_DOEPINT(privep->epphy);
-  while ((stm32l4_getreg(regaddr) & OTGFS_DOEPINT_EPDISD) == 0);
-#else
-  /* REVISIT: */
-  up_udelay(10);
-#endif
-
-  /* Disable Global OUT NAK mode */
-
-  stm32l4_disablegonak(privep);
-
-  /* The endpoint is now stalled */
-
-  privep->stalled = true;
-  return OK;
-#else
-  /* This implementation follows the STMicro code example. */
-  /* REVISIT: */
-
-  uint32_t regaddr;
-  uint32_t regval;
-
-  /* Stall the OUT endpoint by setting the STALL bit in the DOECPTL register. */
-
-  regaddr = STM32L4_OTGFS_DOEPCTL(privep->epphy);
-  regval  = stm32l4_getreg(regaddr);
-  regval |= OTGFS_DOEPCTL_STALL;
-  stm32l4_putreg(regval, regaddr);
-
-  /* The endpoint is now stalled */
-
-  privep->stalled = true;
-  return OK;
-#endif
-}
-
-/****************************************************************************
- * Name: stm32l4_epin_setstall
- *
- * Description:
- *   Stall an IN endpoint
- *
- ****************************************************************************/
-
-static int stm32l4_epin_setstall(FAR struct stm32l4_ep_s *privep)
-{
-  uint32_t regaddr;
-  uint32_t regval;
-
-  /* Get the IN endpoint device control register */
-
-  regaddr = STM32L4_OTGFS_DIEPCTL(privep->epphy);
-  regval  = stm32l4_getreg(regaddr);
-
-  /* Then stall the endpoint */
-
-  regval |= OTGFS_DIEPCTL_STALL;
-  stm32l4_putreg(regval, regaddr);
-
-  /* The endpoint is now stalled */
-
-  privep->stalled = true;
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_ep_setstall
- *
- * Description:
- *   Stall an endpoint
- *
- ****************************************************************************/
-
-static int stm32l4_ep_setstall(FAR struct stm32l4_ep_s *privep)
-{
-  usbtrace(TRACE_EPSTALL, privep->epphy);
-
-  /* Is this an IN endpoint? */
-
-  if (privep->isin == 1)
-    {
-      return stm32l4_epin_setstall(privep);
-    }
-  else
-    {
-      return stm32l4_epout_setstall(privep);
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_ep_clrstall
- *
- * Description:
- *   Resume a stalled endpoint
- *
- ****************************************************************************/
-
-static int stm32l4_ep_clrstall(FAR struct stm32l4_ep_s *privep)
-{
-  uint32_t regaddr;
-  uint32_t regval;
-  uint32_t stallbit;
-  uint32_t data0bit;
-
-  usbtrace(TRACE_EPRESUME, privep->epphy);
-
-  /* Is this an IN endpoint? */
-
-  if (privep->isin == 1)
-    {
-      /* Clear the stall bit in the IN endpoint device control register */
-
-      regaddr  = STM32L4_OTGFS_DIEPCTL(privep->epphy);
-      stallbit = OTGFS_DIEPCTL_STALL;
-      data0bit = OTGFS_DIEPCTL_SD0PID;
-    }
-  else
-    {
-      /* Clear the stall bit in the IN endpoint device control register */
-
-      regaddr  = STM32L4_OTGFS_DOEPCTL(privep->epphy);
-      stallbit = OTGFS_DOEPCTL_STALL;
-      data0bit = OTGFS_DOEPCTL_SD0PID;
-    }
-
-  /* Clear the stall bit */
-
-  regval  = stm32l4_getreg(regaddr);
-  regval &= ~stallbit;
-
-  /* Set the DATA0 pid for interrupt and bulk endpoints */
-
-  if (privep->eptype == USB_EP_ATTR_XFER_INT ||
-      privep->eptype == USB_EP_ATTR_XFER_BULK)
-    {
-      /* Writing this bit sets the DATA0 PID */
-
-      regval |= data0bit;
-    }
-
-  stm32l4_putreg(regval, regaddr);
-
-  /* The endpoint is no longer stalled */
-
-  privep->stalled = false;
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_ep_stall
- *
- * Description:
- *   Stall or resume an endpoint
- *
- ****************************************************************************/
-
-static int stm32l4_ep_stall(FAR struct usbdev_ep_s *ep, bool resume)
-{
-  FAR struct stm32l4_ep_s *privep = (FAR struct stm32l4_ep_s *)ep;
-  irqstate_t flags;
-  int ret;
-
-  /* Set or clear the stall condition as requested */
-
-  flags = enter_critical_section();
-  if (resume)
-    {
-      ret = stm32l4_ep_clrstall(privep);
-    }
-  else
-    {
-      ret = stm32l4_ep_setstall(privep);
-    }
-  leave_critical_section(flags);
-
-  return ret;
-}
-
-/****************************************************************************
- * Name: stm32l4_ep0_stall
- *
- * Description:
- *   Stall endpoint 0
- *
- ****************************************************************************/
-
-static void stm32l4_ep0_stall(FAR struct stm32l4_usbdev_s *priv)
-{
-  stm32l4_epin_setstall(&priv->epin[EP0]);
-  stm32l4_epout_setstall(&priv->epout[EP0]);
-  priv->stalled = true;
-  stm32l4_ep0out_ctrlsetup(priv);
-}
-
-/****************************************************************************
- * Device operations
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_ep_alloc
- *
- * Description:
- *   Allocate an endpoint matching the parameters.
- *
- * Input Parameters:
- *   eplog  - 7-bit logical endpoint number (direction bit ignored).  Zero means
- *            that any endpoint matching the other requirements will suffice.  The
- *            assigned endpoint can be found in the eplog field.
- *   in     - true: IN (device-to-host) endpoint requested
- *   eptype - Endpoint type.  One of {USB_EP_ATTR_XFER_ISOC, USB_EP_ATTR_XFER_BULK,
- *            USB_EP_ATTR_XFER_INT}
- *
- ****************************************************************************/
-
-static FAR struct usbdev_ep_s *stm32l4_ep_alloc(FAR struct usbdev_s *dev,
-                                                uint8_t eplog, bool in,
-                                                uint8_t eptype)
-{
-  FAR struct stm32l4_usbdev_s *priv = (FAR struct stm32l4_usbdev_s *)dev;
-  uint8_t epavail;
-  irqstate_t flags;
-  int epphy;
-  int epno = 0;
-
-  usbtrace(TRACE_DEVALLOCEP, (uint16_t)eplog);
-
-  /* Ignore any direction bits in the logical address */
-
-  epphy = USB_EPNO(eplog);
-
-  /* Get the set of available endpoints depending on the direction */
-
-  flags = enter_critical_section();
-  epavail = priv->epavail[in];
-
-  /* A physical address of 0 means that any endpoint will do */
-
-  if (epphy > 0)
-    {
-      /* Otherwise, we will return the endpoint structure only for the requested
-       * 'logical' endpoint.  All of the other checks will still be performed.
-       *
-       * First, verify that the logical endpoint is in the range supported by
-       * by the hardware.
-       */
-
-      if (epphy >= STM32L4_NENDPOINTS)
-        {
-          usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_BADEPNO), (uint16_t)epphy);
-          return NULL;
-        }
-
-      /* Remove all of the candidate endpoints from the bitset except for the
-       * this physical endpoint number.
-       */
-
-      epavail &= (1 << epphy);
-    }
-
-  /* Is there an available endpoint? */
-
-  if (epavail)
-    {
-      /* Yes.. Select the lowest numbered endpoint in the set of available
-       * endpoints.
-       */
-
-      for (epno = 1; epno < STM32L4_NENDPOINTS; epno++)
-        {
-          uint8_t bit = 1 << epno;
-          if ((epavail & bit) != 0)
-            {
-              /* Mark the endpoint no longer available */
-
-              priv->epavail[in] &= ~(1 << epno);
-
-              /* And return the pointer to the standard endpoint structure */
-
-              leave_critical_section(flags);
-              return in ? &priv->epin[epno].ep : &priv->epout[epno].ep;
-            }
-        }
-
-      /* We should not get here */
-    }
-
-  usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_NOEP), (uint16_t)eplog);
-  leave_critical_section(flags);
-  return NULL;
-}
-
-/****************************************************************************
- * Name: stm32l4_ep_free
- *
- * Description:
- *   Free the previously allocated endpoint
- *
- ****************************************************************************/
-
-static void stm32l4_ep_free(FAR struct usbdev_s *dev,
-                            FAR struct usbdev_ep_s *ep)
-{
-  FAR struct stm32l4_usbdev_s *priv = (FAR struct stm32l4_usbdev_s *)dev;
-  FAR struct stm32l4_ep_s *privep = (FAR struct stm32l4_ep_s *)ep;
-  irqstate_t flags;
-
-  usbtrace(TRACE_DEVFREEEP, (uint16_t)privep->epphy);
-
-  if (priv && privep)
-    {
-      /* Mark the endpoint as available */
-
-      flags = enter_critical_section();
-      priv->epavail[privep->isin] |= (1 << privep->epphy);
-      leave_critical_section(flags);
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_getframe
- *
- * Description:
- *   Returns the current frame number
- *
- ****************************************************************************/
-
-static int stm32l4_getframe(struct usbdev_s *dev)
-{
-  uint32_t regval;
-
-  usbtrace(TRACE_DEVGETFRAME, 0);
-
-  /* Return the last frame number of the last SOF detected by the hardware */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_DSTS);
-  return (int)((regval & OTGFS_DSTS_SOFFN_MASK) >> OTGFS_DSTS_SOFFN_SHIFT);
-}
-
-/****************************************************************************
- * Name: stm32l4_wakeup
- *
- * Description:
- *   Exit suspend mode.
- *
- ****************************************************************************/
-
-static int stm32l4_wakeup(struct usbdev_s *dev)
-{
-  FAR struct stm32l4_usbdev_s *priv = (FAR struct stm32l4_usbdev_s *)dev;
-  uint32_t regval;
-  irqstate_t flags;
-
-  usbtrace(TRACE_DEVWAKEUP, 0);
-
-  /* Is wakeup enabled? */
-
-  flags = enter_critical_section();
-  if (priv->wakeup)
-    {
-      /* Yes... is the core suspended? */
-
-      regval = stm32l4_getreg(STM32L4_OTGFS_DSTS);
-      if ((regval & OTGFS_DSTS_SUSPSTS) != 0)
-        {
-          /* Re-start the PHY clock and un-gate USB core clock (HCLK) */
-
-#ifdef CONFIG_USBDEV_LOWPOWER
-          regval = stm32l4_getreg(STM32L4_OTGFS_PCGCCTL);
-          regval &= ~(OTGFS_PCGCCTL_STPPCLK | OTGFS_PCGCCTL_GATEHCLK);
-          stm32l4_putreg(regval, STM32L4_OTGFS_PCGCCTL);
-#endif
-          /* Activate Remote wakeup signaling */
-
-          regval  = stm32l4_getreg(STM32L4_OTGFS_DCTL);
-          regval |= OTGFS_DCTL_RWUSIG;
-          stm32l4_putreg(regval, STM32L4_OTGFS_DCTL);
-          up_mdelay(5);
-          regval &= ~OTGFS_DCTL_RWUSIG;
-          stm32l4_putreg(regval, STM32L4_OTGFS_DCTL);
-        }
-    }
-
-  leave_critical_section(flags);
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_selfpowered
- *
- * Description:
- *   Sets/clears the device self-powered feature
- *
- ****************************************************************************/
-
-static int stm32l4_selfpowered(struct usbdev_s *dev, bool selfpowered)
-{
-  FAR struct stm32l4_usbdev_s *priv = (FAR struct stm32l4_usbdev_s *)dev;
-
-  usbtrace(TRACE_DEVSELFPOWERED, (uint16_t)selfpowered);
-
-#ifdef CONFIG_DEBUG_FEATURES
-  if (!dev)
-    {
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_INVALIDPARMS), 0);
-      return -ENODEV;
-    }
-#endif
-
-  priv->selfpowered = selfpowered;
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_pullup
- *
- * Description:
- *   Software-controlled connect to/disconnect from USB host
- *
- ****************************************************************************/
-
-static int stm32l4_pullup(struct usbdev_s *dev, bool enable)
-{
-  uint32_t regval;
-
-  usbtrace(TRACE_DEVPULLUP, (uint16_t)enable);
-
-  irqstate_t flags = enter_critical_section();
-  regval = stm32l4_getreg(STM32L4_OTGFS_DCTL);
-  if (enable)
-    {
-      /* Connect the device by clearing the soft disconnect bit in the DCTL
-       * register
-       */
-
-      regval &= ~OTGFS_DCTL_SDIS;
-    }
-  else
-    {
-      /* Disconnect the device by setting the soft disconnect bit in the DCTL
-       * register
-       */
-
-      regval |= OTGFS_DCTL_SDIS;
-    }
-
-  stm32l4_putreg(regval, STM32L4_OTGFS_DCTL);
-  leave_critical_section(flags);
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_setaddress
- *
- * Description:
- *   Set the devices USB address
- *
- ****************************************************************************/
-
-static void stm32l4_setaddress(struct stm32l4_usbdev_s *priv,
-                               uint16_t address)
-{
-  uint32_t regval;
-
-  /* Set the device address in the DCFG register */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_DCFG);
-  regval &= ~OTGFS_DCFG_DAD_MASK;
-  regval |= ((uint32_t)address << OTGFS_DCFG_DAD_SHIFT);
-  stm32l4_putreg(regval, STM32L4_OTGFS_DCFG);
-
-  /* Are we now addressed?  (i.e., do we have a non-NULL device
-   * address?)
-   */
-
-  if (address != 0)
-    {
-      priv->devstate  = DEVSTATE_ADDRESSED;
-      priv->addressed = true;
-    }
-  else
-    {
-      priv->devstate  = DEVSTATE_DEFAULT;
-      priv->addressed = false;
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_txfifo_flush
- *
- * Description:
- *   Flush the specific TX fifo.
- *
- ****************************************************************************/
-
-static int stm32l4_txfifo_flush(uint32_t txfnum)
-{
-  uint32_t regval;
-  uint32_t timeout;
-
-  /* Initiate the TX FIFO flush operation */
-
-  regval = OTGFS_GRSTCTL_TXFFLSH | txfnum;
-  stm32l4_putreg(regval, STM32L4_OTGFS_GRSTCTL);
-
-  /* Wait for the FLUSH to complete */
-
-  for (timeout = 0; timeout < STM32L4_FLUSH_DELAY; timeout++)
-    {
-      regval = stm32l4_getreg(STM32L4_OTGFS_GRSTCTL);
-      if ((regval & OTGFS_GRSTCTL_TXFFLSH) == 0)
-        {
-          break;
-        }
-    }
-
-  /* Wait for 3 PHY Clocks */
-
-  up_udelay(3);
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_rxfifo_flush
- *
- * Description:
- *   Flush the RX fifo.
- *
- ****************************************************************************/
-
-static int stm32l4_rxfifo_flush(void)
-{
-  uint32_t regval;
-  uint32_t timeout;
-
-  /* Initiate the RX FIFO flush operation */
-
-  stm32l4_putreg(OTGFS_GRSTCTL_RXFFLSH, STM32L4_OTGFS_GRSTCTL);
-
-  /* Wait for the FLUSH to complete */
-
-  for (timeout = 0; timeout < STM32L4_FLUSH_DELAY; timeout++)
-    {
-      regval = stm32l4_getreg(STM32L4_OTGFS_GRSTCTL);
-      if ((regval & OTGFS_GRSTCTL_RXFFLSH) == 0)
-        {
-          break;
-        }
-    }
-
-  /* Wait for 3 PHY Clocks */
-
-  up_udelay(3);
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_swinitialize
- *
- * Description:
- *   Initialize all driver data structures.
- *
- ****************************************************************************/
-
-static void stm32l4_swinitialize(FAR struct stm32l4_usbdev_s *priv)
-{
-  FAR struct stm32l4_ep_s *privep;
-  int i;
-
-  /* Initialize the device state structure */
-
-  memset(priv, 0, sizeof(struct stm32l4_usbdev_s));
-
-  priv->usbdev.ops = &g_devops;
-  priv->usbdev.ep0 = &priv->epin[EP0].ep;
-
-  priv->epavail[0] = STM32L4_EP_AVAILABLE;
-  priv->epavail[1] = STM32L4_EP_AVAILABLE;
-
-  priv->epin[EP0].ep.priv  = priv;
-  priv->epout[EP0].ep.priv = priv;
-
-  /* Initialize the IN endpoint list */
-
-  for (i = 0; i < STM32L4_NENDPOINTS; i++)
-    {
-      /* Set endpoint operations, reference to driver structure (not
-       * really necessary because there is only one controller), and
-       * the physical endpoint number (which is just the index to the
-       * endpoint).
-       */
-
-      privep           = &priv->epin[i];
-      privep->ep.ops   = &g_epops;
-      privep->dev      = priv;
-      privep->isin     = 1;
-
-      /* The index, i, is the physical endpoint address;  Map this
-       * to a logical endpoint address usable by the class driver.
-       */
-
-      privep->epphy    = i;
-      privep->ep.eplog = STM32L4_EPPHYIN2LOG(i);
-
-      /* Control until endpoint is activated */
-
-      privep->eptype       = USB_EP_ATTR_XFER_CONTROL;
-      privep->ep.maxpacket = CONFIG_USBDEV_EP0_MAXSIZE;
-    }
-
-  /* Initialize the OUT endpoint list */
-
-  for (i = 0; i < STM32L4_NENDPOINTS; i++)
-    {
-      /* Set endpoint operations, reference to driver structure (not
-       * really necessary because there is only one controller), and
-       * the physical endpoint number (which is just the index to the
-       * endpoint).
-       */
-
-      privep           = &priv->epout[i];
-      privep->ep.ops   = &g_epops;
-      privep->dev      = priv;
-
-      /* The index, i, is the physical endpoint address;  Map this
-       * to a logical endpoint address usable by the class driver.
-       */
-
-      privep->epphy    = i;
-      privep->ep.eplog = STM32L4_EPPHYOUT2LOG(i);
-
-      /* Control until endpoint is activated */
-
-      privep->eptype       = USB_EP_ATTR_XFER_CONTROL;
-      privep->ep.maxpacket = CONFIG_USBDEV_EP0_MAXSIZE;
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_hwinitialize
- *
- * Description:
- *   Configure the OTG FS core for operation.
- *
- ****************************************************************************/
-
-static void stm32l4_hwinitialize(FAR struct stm32l4_usbdev_s *priv)
-{
-  uint32_t regval;
-  uint32_t timeout;
-  uint32_t address;
-  int i;
-
-  /* Enable Vbus monitoring in the Power control */
-
-  stm32l4_pwr_enableusv(true);
-
-  /* At start-up the core is in FS mode. */
-
-  /* Disable global interrupts by clearing the GINTMASK bit in the GAHBCFG
-   * register; Set the TXFELVL bit in the GAHBCFG register so that TxFIFO
-   * interrupts will occur when the TxFIFO is truly empty (not just half full).
-   */
-
-  stm32l4_putreg(OTGFS_GAHBCFG_TXFELVL, STM32L4_OTGFS_GAHBCFG);
-
-  /* Common USB OTG core initialization */
-  /* Reset after a PHY select and set Host mode.  First, wait for AHB master
-   * IDLE state.
-   */
-
-  for (timeout = 0; timeout < STM32L4_READY_DELAY; timeout++)
-    {
-      up_udelay(3);
-      regval = stm32l4_getreg(STM32L4_OTGFS_GRSTCTL);
-      if ((regval & OTGFS_GRSTCTL_AHBIDL) != 0)
-        {
-          break;
-        }
-    }
-
-  /* Then perform the core soft reset. */
-
-  stm32l4_putreg(OTGFS_GRSTCTL_CSRST, STM32L4_OTGFS_GRSTCTL);
-  for (timeout = 0; timeout < STM32L4_READY_DELAY; timeout++)
-    {
-      regval = stm32l4_getreg(STM32L4_OTGFS_GRSTCTL);
-      if ((regval & OTGFS_GRSTCTL_CSRST) == 0)
-        {
-          break;
-        }
-    }
-
-  /* Wait for 3 PHY Clocks */
-
-  up_udelay(3);
-
-  /* Deactivate the power down */
-
-  regval  = OTGFS_GCCFG_PWRDWN;
-
-# ifdef CONFIG_USBDEV_VBUSSENSING
-  /* Enable Vbus sensing */
-
-  regval |= OTGFS_GCCFG_VBDEN;
-# endif
-
-  stm32l4_putreg(regval, STM32L4_OTGFS_GCCFG);
-  up_mdelay(20);
-
-  /* When VBUS sensing is not used we need to force the B session valid */
-
-# ifndef CONFIG_USBDEV_VBUSSENSING
-  regval  =  stm32l4_getreg(STM32L4_OTGFS_GOTGCTL);
-  regval |= (OTGFS_GOTGCTL_BVALOEN | OTGFS_GOTGCTL_BVALOVAL);
-  stm32l4_putreg(regval, STM32L4_OTGFS_GOTGCTL);
-# endif
-
-  /* Force Device Mode */
-
-  regval  = stm32l4_getreg(STM32L4_OTGFS_GUSBCFG);
-  regval &= ~OTGFS_GUSBCFG_FHMOD;
-  regval |= OTGFS_GUSBCFG_FDMOD;
-  stm32l4_putreg(regval, STM32L4_OTGFS_GUSBCFG);
-  up_mdelay(50);
-
-  /* Initialize device mode */
-  /* Restart the PHY Clock */
-
-  stm32l4_putreg(0, STM32L4_OTGFS_PCGCCTL);
-
-  /* Device configuration register */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_DCFG);
-  regval &= ~OTGFS_DCFG_PFIVL_MASK;
-  regval |= OTGFS_DCFG_PFIVL_80PCT;
-  stm32l4_putreg(regval, STM32L4_OTGFS_DCFG);
-
-  /* Set full speed PHY */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_DCFG);
-  regval &= ~OTGFS_DCFG_DSPD_MASK;
-  regval |= OTGFS_DCFG_DSPD_FS;
-  stm32l4_putreg(regval, STM32L4_OTGFS_DCFG);
-
-  /* Set Rx FIFO size */
-
-  stm32l4_putreg(STM32L4_RXFIFO_WORDS, STM32L4_OTGFS_GRXFSIZ);
-
-#if STM32L4_NENDPOINTS > 0
-  /* EP0 TX */
-
-  address = STM32L4_RXFIFO_WORDS;
-  regval  = (address << OTGFS_DIEPTXF0_TX0FD_SHIFT) |
-            (STM32L4_EP0_TXFIFO_WORDS << OTGFS_DIEPTXF0_TX0FSA_SHIFT);
-  stm32l4_putreg(regval, STM32L4_OTGFS_DIEPTXF(0));
-#endif
-
-#if STM32L4_NENDPOINTS > 1
-  /* EP1 TX */
-
-  address += STM32L4_EP0_TXFIFO_WORDS;
-  regval   = (address << OTGFS_DIEPTXF_INEPTXSA_SHIFT) |
-             (STM32L4_EP1_TXFIFO_WORDS << OTGFS_DIEPTXF_INEPTXFD_SHIFT);
-  stm32l4_putreg(regval, STM32L4_OTGFS_DIEPTXF(1));
-#endif
-
-#if STM32L4_NENDPOINTS > 2
-  /* EP2 TX */
-
-  address += STM32L4_EP1_TXFIFO_WORDS;
-  regval   = (address << OTGFS_DIEPTXF_INEPTXSA_SHIFT) |
-             (STM32L4_EP2_TXFIFO_WORDS << OTGFS_DIEPTXF_INEPTXFD_SHIFT);
-  stm32l4_putreg(regval, STM32L4_OTGFS_DIEPTXF(2));
-#endif
-
-#if STM32L4_NENDPOINTS > 3
-  /* EP3 TX */
-
-  address += STM32L4_EP2_TXFIFO_WORDS;
-  regval   = (address << OTGFS_DIEPTXF_INEPTXSA_SHIFT) |
-             (STM32L4_EP3_TXFIFO_WORDS << OTGFS_DIEPTXF_INEPTXFD_SHIFT);
-  stm32l4_putreg(regval, STM32L4_OTGFS_DIEPTXF(3));
-#endif
-
-#if STM32L4_NENDPOINTS > 4
-  /* EP4 TX */
-
-  address += STM32L4_EP3_TXFIFO_WORDS;
-  regval   = (address << OTGFS_DIEPTXF_INEPTXSA_SHIFT) |
-             (STM32L4_EP4_TXFIFO_WORDS << OTGFS_DIEPTXF_INEPTXFD_SHIFT);
-  stm32l4_putreg(regval, STM32L4_OTGFS_DIEPTXF(4));
-#endif
-
-#if STM32L4_NENDPOINTS > 5
-  /* EP5 TX */
-
-  address += STM32L4_EP4_TXFIFO_WORDS;
-  regval   = (address << OTGFS_DIEPTXF_INEPTXSA_SHIFT) |
-             (STM32L4_EP5_TXFIFO_WORDS << OTGFS_DIEPTXF_INEPTXFD_SHIFT);
-  stm32l4_putreg(regval, STM32L4_OTGFS_DIEPTXF(5));
-#endif
-
-
-  /* Flush the FIFOs */
-
-  stm32l4_txfifo_flush(OTGFS_GRSTCTL_TXFNUM_DALL);
-  stm32l4_rxfifo_flush();
-
-  /* Clear all pending Device Interrupts */
-
-  stm32l4_putreg(0, STM32L4_OTGFS_DIEPMSK);
-  stm32l4_putreg(0, STM32L4_OTGFS_DOEPMSK);
-  stm32l4_putreg(0, STM32L4_OTGFS_DIEPEMPMSK);
-  stm32l4_putreg(0xffffffff, STM32L4_OTGFS_DAINT);
-  stm32l4_putreg(0, STM32L4_OTGFS_DAINTMSK);
-
-  /* Configure all IN endpoints */
-
-  for (i = 0; i < STM32L4_NENDPOINTS; i++)
-    {
-      regval = stm32l4_getreg(STM32L4_OTGFS_DIEPCTL(i));
-      if ((regval & OTGFS_DIEPCTL_EPENA) != 0)
-        {
-          /* The endpoint is already enabled */
-
-          regval = OTGFS_DIEPCTL_EPENA | OTGFS_DIEPCTL_SNAK;
-        }
-      else
-        {
-          regval = 0;
-        }
-
-      stm32l4_putreg(regval, STM32L4_OTGFS_DIEPCTL(i));
-      stm32l4_putreg(0, STM32L4_OTGFS_DIEPTSIZ(i));
-      stm32l4_putreg(0xff, STM32L4_OTGFS_DIEPINT(i));
-    }
-
-  /* Configure all OUT endpoints */
-
-  for (i = 0; i < STM32L4_NENDPOINTS; i++)
-    {
-      regval = stm32l4_getreg(STM32L4_OTGFS_DOEPCTL(i));
-      if ((regval & OTGFS_DOEPCTL_EPENA) != 0)
-        {
-          /* The endpoint is already enabled */
-
-          regval = OTGFS_DOEPCTL_EPENA | OTGFS_DOEPCTL_SNAK;
-        }
-      else
-        {
-          regval = 0;
-        }
-
-      stm32l4_putreg(regval, STM32L4_OTGFS_DOEPCTL(i));
-      stm32l4_putreg(0, STM32L4_OTGFS_DOEPTSIZ(i));
-      stm32l4_putreg(0xff, STM32L4_OTGFS_DOEPINT(i));
-    }
-
-  /* Disable all interrupts. */
-
-  stm32l4_putreg(0, STM32L4_OTGFS_GINTMSK);
-
-  /* Clear any pending USB_OTG Interrupts */
-
-  stm32l4_putreg(0xffffffff, STM32L4_OTGFS_GOTGINT);
-
-  /* Clear any pending interrupts */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_GINTSTS);
-  regval &=  OTGFS_GINT_RESERVED;
-  stm32l4_putreg(regval | OTGFS_GINT_RC_W1, STM32L4_OTGFS_GINTSTS);
-
-  /* Enable the interrupts in the INTMSK */
-
-  regval = (OTGFS_GINT_RXFLVL | OTGFS_GINT_USBSUSP | OTGFS_GINT_ENUMDNE |
-            OTGFS_GINT_IEP | OTGFS_GINT_OEP | OTGFS_GINT_USBRST);
-
-#ifdef CONFIG_USBDEV_ISOCHRONOUS
-  regval |= (OTGFS_GINT_IISOIXFR | OTGFS_GINT_IISOOXFR);
-#endif
-
-#ifdef CONFIG_USBDEV_SOFINTERRUPT
-  regval |= OTGFS_GINT_SOF;
-#endif
-
-#ifdef CONFIG_USBDEV_VBUSSENSING
-  regval |= (OTGFS_GINT_OTG | OTGFS_GINT_SRQ);
-#endif
-
-#ifdef CONFIG_DEBUG_FEATURES
-  regval |= OTGFS_GINT_MMIS;
-#endif
-
-  stm32l4_putreg(regval, STM32L4_OTGFS_GINTMSK);
-
-  /* Enable the USB global interrupt by setting GINTMSK in the global OTG
-   * FS AHB configuration register; Set the TXFELVL bit in the GAHBCFG
-   * register so that TxFIFO interrupts will occur when the TxFIFO is truly
-   * empty (not just half full).
-   */
-
-  stm32l4_putreg(OTGFS_GAHBCFG_GINTMSK | OTGFS_GAHBCFG_TXFELVL,
-                 STM32L4_OTGFS_GAHBCFG);
-}
-
-/****************************************************************************
- * Public Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: up_usbinitialize
- *
- * Description:
- *   Initialize USB hardware.
- *
- * Assumptions:
- * - This function is called very early in the initialization sequence
- * - PLL and GIO pin initialization is not performed here but should been in
- *   the low-level  boot logic:  PLL1 must be configured for operation at 48MHz
- *   and P0.23 and PO.31 in PINSEL1 must be configured for Vbus and USB connect
- *   LED.
- *
- ****************************************************************************/
-
-void up_usbinitialize(void)
-{
-  /* At present, there is only a single OTG FS device support. Hence it is
-   * pre-allocated as g_otgfsdev.  However, in most code, the private data
-   * structure will be referenced using the 'priv' pointer (rather than the
-   * global data) in order to simplify any future support for multiple devices.
-   */
-
-  FAR struct stm32l4_usbdev_s *priv = &g_otgfsdev;
-  int ret;
-
-  usbtrace(TRACE_DEVINIT, 0);
-
-  /* Here we assume that:
-   *
-   * 1. GPIOA and OTG FS peripheral clocking has already been enabled as part
-   *    of the boot sequence.
-   * 2. Board-specific logic has already enabled other board specific GPIOs
-   *    for things like soft pull-up, VBUS sensing, power controls, and over-
-   *    current detection.
-   */
-
-  /* Configure OTG FS alternate function pins
-   *
-   * PIN* SIGNAL      DIRECTION
-   * ---- ----------- ----------
-   * PA8  OTG_FS_SOF  SOF clock output
-   * PA9  OTG_FS_VBUS VBUS input for device, Driven by external regulator by
-   *                  host (not an alternate function)
-   * PA10 OTG_FS_ID   OTG ID pin (only needed in Dual mode)
-   * PA11 OTG_FS_DM   D- I/O
-   * PA12 OTG_FS_DP   D+ I/O
-   *
-   * *Pins may vary from device-to-device.
-   */
-
-  stm32l4_configgpio(GPIO_OTGFS_DM);
-  stm32l4_configgpio(GPIO_OTGFS_DP);
-  stm32l4_configgpio(GPIO_OTGFS_ID);    /* Only needed for OTG */
-
-  /* SOF output pin configuration is configurable. */
-
-#ifdef CONFIG_STM32L4_OTGFS_SOFOUTPUT
-  stm32l4_configgpio(GPIO_OTGFS_SOF);
-#endif
-
-  /* Uninitialize the hardware so that we know that we are starting from a
-   * known state. */
-
-  up_usbuninitialize();
-
-  /* Initialize the driver data structure */
-
-  stm32l4_swinitialize(priv);
-
-  /* Attach the OTG FS interrupt handler */
-
-  ret = irq_attach(STM32L4_IRQ_OTGFS, stm32l4_usbinterrupt, NULL);
-  if (ret < 0)
-    {
-      uerr("irq_attach failed\n", ret);
-      goto errout;
-    }
-
-  /* Initialize the USB OTG core */
-
-  stm32l4_hwinitialize(priv);
-
-  /* Disconnect device */
-
-  stm32l4_pullup(&priv->usbdev, false);
-
-  /* Reset/Re-initialize the USB hardware */
-
-  stm32l4_usbreset(priv);
-
-  /* Enable USB controller interrupts at the NVIC */
-
-  up_enable_irq(STM32L4_IRQ_OTGFS);
-
-#ifdef CONFIG_ARCH_IRQPRIO
-  /* Set the interrupt priority */
-
-  up_prioritize_irq(STM32L4_IRQ_OTGFS, CONFIG_OTGFS_PRI);
-#endif
-  return;
-
-errout:
-  up_usbuninitialize();
-}
-
-/****************************************************************************
- * Name: up_usbuninitialize
- ****************************************************************************/
-
-void up_usbuninitialize(void)
-{
-  /* At present, there is only a single OTG FS device support. Hence it is
-   * pre-allocated as g_otgfsdev.  However, in most code, the private data
-   * structure will be referenced using the 'priv' pointer (rather than the
-   * global data) in order to simplify any future support for multiple devices.
-   */
-
-  FAR struct stm32l4_usbdev_s *priv = &g_otgfsdev;
-  irqstate_t flags;
-  int i;
-
-  usbtrace(TRACE_DEVUNINIT, 0);
-
-  if (priv->driver)
-    {
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_DRIVERREGISTERED), 0);
-      usbdev_unregister(priv->driver);
-    }
-
-  /* Disconnect device */
-
-  flags = enter_critical_section();
-  stm32l4_pullup(&priv->usbdev, false);
-  priv->usbdev.speed = USB_SPEED_UNKNOWN;
-
-  /* Disable and detach IRQs */
-
-  up_disable_irq(STM32L4_IRQ_OTGFS);
-  irq_detach(STM32L4_IRQ_OTGFS);
-
-  /* Disable all endpoint interrupts */
-
-  for (i = 0; i < STM32L4_NENDPOINTS; i++)
-    {
-      stm32l4_putreg(0xff, STM32L4_OTGFS_DIEPINT(i));
-      stm32l4_putreg(0xff, STM32L4_OTGFS_DOEPINT(i));
-    }
-
-  stm32l4_putreg(0, STM32L4_OTGFS_DIEPMSK);
-  stm32l4_putreg(0, STM32L4_OTGFS_DOEPMSK);
-  stm32l4_putreg(0, STM32L4_OTGFS_DIEPEMPMSK);
-  stm32l4_putreg(0, STM32L4_OTGFS_DAINTMSK);
-  stm32l4_putreg(0xffffffff, STM32L4_OTGFS_DAINT);
-
-  /* Flush the FIFOs */
-
-  stm32l4_txfifo_flush(OTGFS_GRSTCTL_TXFNUM_DALL);
-  stm32l4_rxfifo_flush();
-
-  /* TODO: Turn off USB power and clocking */
-
-  priv->devstate = DEVSTATE_DEFAULT;
-  leave_critical_section(flags);
-}
-
-/****************************************************************************
- * Name: usbdev_register
- *
- * Description:
- *   Register a USB device class driver. The class driver's bind() method will be
- *   called to bind it to a USB device driver.
- *
- ****************************************************************************/
-
-int usbdev_register(struct usbdevclass_driver_s *driver)
-{
-  /* At present, there is only a single OTG FS device support. Hence it is
-   * pre-allocated as g_otgfsdev.  However, in most code, the private data
-   * structure will be referenced using the 'priv' pointer (rather than the
-   * global data) in order to simplify any future support for multiple devices.
-   */
-
-  FAR struct stm32l4_usbdev_s *priv = &g_otgfsdev;
-  int ret;
-
-  usbtrace(TRACE_DEVREGISTER, 0);
-
-#ifdef CONFIG_DEBUG_FEATURES
-  if (!driver || !driver->ops->bind || !driver->ops->unbind ||
-      !driver->ops->disconnect || !driver->ops->setup)
-    {
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_INVALIDPARMS), 0);
-      return -EINVAL;
-    }
-
-  if (priv->driver)
-    {
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_DRIVER), 0);
-      return -EBUSY;
-    }
-#endif
-
-  /* First hook up the driver */
-
-  priv->driver = driver;
-
-  /* Then bind the class driver */
-
-  ret = CLASS_BIND(driver, &priv->usbdev);
-  if (ret)
-    {
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_BINDFAILED), (uint16_t) - ret);
-      priv->driver = NULL;
-    }
-  else
-    {
-      /* Enable USB controller interrupts */
-
-      up_enable_irq(STM32L4_IRQ_OTGFS);
-
-      /* FIXME: nothing seems to call DEV_CONNECT(), but we need to set
-       *        the RS bit to enable the controller.  It kind of makes sense
-       *        to do this after the class has bound to us...
-       * GEN:   This bug is really in the class driver.  It should make the
-       *        soft connect when it is ready to be enumerated.  I have added
-       *        that logic to the class drivers but left this logic here.
-       */
-
-      stm32l4_pullup(&priv->usbdev, true);
-      priv->usbdev.speed = USB_SPEED_FULL;
-    }
-
-  return ret;
-}
-
-/****************************************************************************
- * Name: usbdev_unregister
- *
- * Description:
- *   Un-register usbdev class driver.If the USB device is connected to a USB host,
- *   it will first disconnect().  The driver is also requested to unbind() and clean
- *   up any device state, before this procedure finally returns.
- *
- ****************************************************************************/
-
-int usbdev_unregister(struct usbdevclass_driver_s *driver)
-{
-  /* At present, there is only a single OTG FS device support. Hence it is
-   * pre-allocated as g_otgfsdev.  However, in most code, the private data
-   * structure will be referenced using the 'priv' pointer (rather than the
-   * global data) in order to simplify any future support for multiple devices.
-   */
-
-  FAR struct stm32l4_usbdev_s *priv = &g_otgfsdev;
-  irqstate_t flags;
-
-  usbtrace(TRACE_DEVUNREGISTER, 0);
-
-#ifdef CONFIG_DEBUG_FEATURES
-  if (driver != priv->driver)
-    {
-      usbtrace(TRACE_DEVERROR(STM32L4_TRACEERR_INVALIDPARMS), 0);
-      return -EINVAL;
-    }
-#endif
-
-  /* Reset the hardware and cancel all requests.  All requests must be
-   * canceled while the class driver is still bound.
-   */
-
-  flags = enter_critical_section();
-  stm32l4_usbreset(priv);
-  leave_critical_section(flags);
-
-  /* Unbind the class driver */
-
-  CLASS_UNBIND(driver, &priv->usbdev);
-
-  /* Disable USB controller interrupts */
-
-  flags = enter_critical_section();
-  up_disable_irq(STM32L4_IRQ_OTGFS);
-
-  /* Disconnect device */
-
-  stm32l4_pullup(&priv->usbdev, false);
-
-  /* Unhook the driver */
-
-  priv->driver = NULL;
-  leave_critical_section(flags);
-
-  return OK;
-}
-
-#endif /* CONFIG_USBDEV && CONFIG_STM32L4_OTGFSDEV */
diff --git a/arch/arm/src/nrf52/nrf52_otgfshost.c b/arch/arm/src/nrf52/nrf52_otgfshost.c
deleted file mode 100644
index 118b6cb6dc..0000000000
--- a/arch/arm/src/nrf52/nrf52_otgfshost.c
+++ /dev/null
@@ -1,5410 +0,0 @@
-/****************************************************************************
- * arch/arm/src/stm32l4/stm32l4_otgfshost.c
- *
- *   Copyright (C) 2012-2016 Gregory Nutt. All rights reserved.
- *   Authors: Gregory Nutt <gnutt@nuttx.org>
- *            dev@ziggurat29.com
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ****************************************************************************/
-
-/****************************************************************************
- * Included Files
- ****************************************************************************/
-
-#include <nuttx/config.h>
-
-#include <sys/types.h>
-#include <stdint.h>
-#include <stdbool.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <semaphore.h>
-#include <string.h>
-#include <errno.h>
-#include <debug.h>
-
-#include <nuttx/arch.h>
-#include <nuttx/kmalloc.h>
-#include <nuttx/clock.h>
-#include <nuttx/semaphore.h>
-#include <nuttx/usb/usb.h>
-#include <nuttx/usb/usbhost.h>
-#include <nuttx/usb/usbhost_devaddr.h>
-#include <nuttx/usb/usbhost_trace.h>
-
-#include <nuttx/irq.h>
-
-#include "chip.h"             /* Includes default GPIO settings */
-#include <arch/board/board.h> /* May redefine GPIO settings */
-
-#include "up_arch.h"
-#include "up_internal.h"
-
-#include "stm32l4_usbhost.h"
-
-#if defined(CONFIG_USBHOST) && defined(CONFIG_STM32L4_OTGFS)
-
-/****************************************************************************
- * Pre-processor Definitions
- ****************************************************************************/
-/* Configuration ***************************************************************/
-/* STM32 USB OTG FS Host Driver Support
- *
- * Pre-requisites
- *
- *  CONFIG_USBHOST      - Enable general USB host support
- *  CONFIG_STM32L4_OTGFS  - Enable the STM32 USB OTG FS block
- *  CONFIG_STM32L4_SYSCFG - Needed
- *
- * Options:
- *
- *  CONFIG_STM32L4_OTGFS_RXFIFO_SIZE - Size of the RX FIFO in 32-bit words.
- *    Default 128 (512 bytes)
- *  CONFIG_STM32L4_OTGFS_NPTXFIFO_SIZE - Size of the non-periodic Tx FIFO
- *    in 32-bit words.  Default 96 (384 bytes)
- *  CONFIG_STM32L4_OTGFS_PTXFIFO_SIZE - Size of the periodic Tx FIFO in 32-bit
- *    words.  Default 96 (384 bytes)
- *  CONFIG_STM32L4_OTGFS_DESCSIZE - Maximum size of a descriptor.  Default: 128
- *  CONFIG_STM32L4_OTGFS_SOFINTR - Enable SOF interrupts.  Why would you ever
- *    want to do that?
- *  CONFIG_STM32L4_USBHOST_REGDEBUG - Enable very low-level register access
- *    debug.  Depends on CONFIG_DEBUG.
- *  CONFIG_STM32L4_USBHOST_PKTDUMP - Dump all incoming and outgoing USB
- *    packets. Depends on CONFIG_DEBUG.
- */
-
-/* Pre-requisites (partial) */
-
-#ifndef CONFIG_STM32L4_SYSCFG
-#  error "CONFIG_STM32L4_SYSCFG is required"
-#endif
-
-/* Default RxFIFO size */
-
-#ifndef CONFIG_STM32L4_OTGFS_RXFIFO_SIZE
-#  define CONFIG_STM32L4_OTGFS_RXFIFO_SIZE 128
-#endif
-
-/* Default host non-periodic Tx FIFO size */
-
-#ifndef CONFIG_STM32L4_OTGFS_NPTXFIFO_SIZE
-#  define CONFIG_STM32L4_OTGFS_NPTXFIFO_SIZE 96
-#endif
-
-/* Default host periodic Tx fifo size register */
-
-#ifndef CONFIG_STM32L4_OTGFS_PTXFIFO_SIZE
-#  define CONFIG_STM32L4_OTGFS_PTXFIFO_SIZE 96
-#endif
-
-/* Maximum size of a descriptor */
-
-#ifndef CONFIG_STM32L4_OTGFS_DESCSIZE
-#  define CONFIG_STM32L4_OTGFS_DESCSIZE 128
-#endif
-
-/* Register/packet debug depends on CONFIG_DEBUG */
-
-#ifndef CONFIG_DEBUG
-#  undef CONFIG_STM32L4_USBHOST_REGDEBUG
-#  undef CONFIG_STM32L4_USBHOST_PKTDUMP
-#endif
-
-/* HCD Setup *******************************************************************/
-/* Hardware capabilities */
-//XXX I think this needs to be 12 for the 'L4
-#define STM32L4_NHOST_CHANNELS      8   /* Number of host channels */
-#define STM32L4_MAX_PACKET_SIZE     64  /* Full speed max packet size */
-#define STM32L4_EP0_DEF_PACKET_SIZE 8   /* EP0 default packet size */
-#define STM32L4_EP0_MAX_PACKET_SIZE 64  /* EP0 FS max packet size */
-#define STM32L4_MAX_TX_FIFOS        15  /* Max number of TX FIFOs */
-#define STM32L4_MAX_PKTCOUNT        256 /* Max packet count */
-#define STM32L4_RETRY_COUNT         3   /* Number of ctrl transfer retries */
-
-/* Delays **********************************************************************/
-
-#define STM32L4_READY_DELAY         200000 /* In loop counts */
-#define STM32L4_FLUSH_DELAY         200000 /* In loop counts */
-#define STM32L4_SETUP_DELAY         SEC2TICK(5) /* 5 seconds in system ticks */
-#define STM32L4_DATANAK_DELAY       SEC2TICK(5) /* 5 seconds in system ticks */
-
-/* Ever-present MIN/MAX macros */
-
-#ifndef MIN
-#  define  MIN(a, b) (((a) < (b)) ? (a) : (b))
-#endif
-
-#ifndef MAX
-#  define  MAX(a, b) (((a) > (b)) ? (a) : (b))
-#endif
-
-/****************************************************************************
- * Private Types
- ****************************************************************************/
-
-/* The following enumeration represents the various states of the USB host
- * state machine (for debug purposes only)
- */
-
-enum stm32l4_smstate_e
-{
-  SMSTATE_DETACHED = 0,  /* Not attached to a device */
-  SMSTATE_ATTACHED,      /* Attached to a device */
-  SMSTATE_ENUM,          /* Attached, enumerating */
-  SMSTATE_CLASS_BOUND,   /* Enumeration complete, class bound */
-};
-
-/* This enumeration provides the reason for the channel halt. */
-
-enum stm32l4_chreason_e
-{
-  CHREASON_IDLE = 0,     /* Inactive (initial state) */
-  CHREASON_FREED,        /* Channel is no longer in use */
-  CHREASON_XFRC,         /* Transfer complete */
-  CHREASON_NAK,          /* NAK received */
-  CHREASON_NYET,         /* NotYet received */
-  CHREASON_STALL,        /* Endpoint stalled */
-  CHREASON_TXERR,        /* Transfer error received */
-  CHREASON_DTERR,        /* Data toggle error received */
-  CHREASON_FRMOR,        /* Frame overrun */
-  CHREASON_CANCELLED     /* Transfer cancelled */
-};
-
-/* This structure retains the state of one host channel.  NOTE: Since there
- * is only one channel operation active at a time, some of the fields in
- * in the structure could be moved in struct stm32l4_ubhost_s to achieve
- * some memory savings.
- */
-
-struct stm32l4_chan_s
-{
-  sem_t             waitsem;   /* Channel wait semaphore */
-  volatile uint8_t  result;    /* The result of the transfer */
-  volatile uint8_t  chreason;  /* Channel halt reason. See enum stm32l4_chreason_e */
-  uint8_t           chidx;     /* Channel index */
-  uint8_t           epno;      /* Device endpoint number (0-127) */
-  uint8_t           eptype;    /* See OTGFS_EPTYPE_* definitions */
-  uint8_t           funcaddr;  /* Device function address */
-  uint8_t           speed;     /* Device speed */
-  uint8_t           interval;  /* Interrupt/isochronous EP polling interval */
-  uint8_t           pid;       /* Data PID */
-  uint8_t           npackets;  /* Number of packets (for data toggle) */
-  bool              inuse;     /* True: This channel is "in use" */
-  volatile bool     indata1;   /* IN data toggle. True: DATA01 (Bulk and INTR only) */
-  volatile bool     outdata1;  /* OUT data toggle.  True: DATA01 */
-  bool              in;        /* True: IN endpoint */
-  volatile bool     waiter;    /* True: Thread is waiting for a channel event */
-  uint16_t          maxpacket; /* Max packet size */
-  uint16_t          buflen;    /* Buffer length (at start of transfer) */
-  volatile uint16_t xfrd;      /* Bytes transferred (at end of transfer) */
-  volatile uint16_t inflight;  /* Number of Tx bytes "in-flight" */
-  FAR uint8_t      *buffer;    /* Transfer buffer pointer */
-#ifdef CONFIG_USBHOST_ASYNCH
-  usbhost_asynch_t  callback;  /* Transfer complete callback */
-  FAR void         *arg;       /* Argument that accompanies the callback */
-#endif
-};
-
-/* A channel represents on uni-directional endpoint.  So, in the case of the
- * bi-directional, control endpoint, there must be two channels to represent
- * the endpoint.
- */
-
-struct stm32l4_ctrlinfo_s
-{
-  uint8_t           inndx;     /* EP0 IN control channel index */
-  uint8_t           outndx;    /* EP0 OUT control channel index */
-};
-
-/* This structure retains the state of the USB host controller */
-
-struct stm32l4_usbhost_s
-{
-  /* Common device fields.  This must be the first thing defined in the
-   * structure so that it is possible to simply cast from struct usbhost_s
-   * to structstm32l4_usbhost_s.
-   */
-
-  struct usbhost_driver_s drvr;
-
-  /* This is the hub port description understood by class drivers */
-
-  struct usbhost_roothubport_s rhport;
-
-  /* Overall driver status */
-
-  volatile uint8_t  smstate;   /* The state of the USB host state machine */
-  uint8_t           chidx;     /* ID of channel waiting for space in Tx FIFO */
-  volatile bool     connected; /* Connected to device */
-  volatile bool     change;    /* Connection change */
-  volatile bool     pscwait;   /* True: Thread is waiting for a port event */
-  sem_t             exclsem;   /* Support mutually exclusive access */
-  sem_t             pscsem;    /* Semaphore to wait for a port event */
-  struct stm32l4_ctrlinfo_s ep0;  /* Root hub port EP0 description */
-
-#ifdef CONFIG_USBHOST_HUB
-  /* Used to pass external hub port events */
-
-  volatile struct usbhost_hubport_s *hport;
-#endif
-
-  /* The state of each host channel */
-
-  struct stm32l4_chan_s chan[STM32L4_MAX_TX_FIFOS];
-};
-
-/****************************************************************************
- * Private Function Prototypes
- ****************************************************************************/
-
-/* Register operations ********************************************************/
-
-#ifdef CONFIG_STM32L4_USBHOST_REGDEBUG
-static void stm32l4_printreg(uint32_t addr, uint32_t val, bool iswrite);
-static void stm32l4_checkreg(uint32_t addr, uint32_t val, bool iswrite);
-static uint32_t stm32l4_getreg(uint32_t addr);
-static void stm32l4_putreg(uint32_t addr, uint32_t value);
-#else
-# define stm32l4_getreg(addr)     getreg32(addr)
-# define stm32l4_putreg(addr,val) putreg32(val,addr)
-#endif
-
-static inline void stm32l4_modifyreg(uint32_t addr, uint32_t clrbits,
-                                     uint32_t setbits);
-
-#ifdef CONFIG_STM32L4_USBHOST_PKTDUMP
-#  define stm32l4_pktdump(m,b,n) lib_dumpbuffer(m,b,n)
-#else
-#  define stm32l4_pktdump(m,b,n)
-#endif
-
-/* Semaphores ******************************************************************/
-
-static void stm32l4_takesem(FAR sem_t *sem);
-#define stm32l4_givesem(s) sem_post(s);
-
-/* Byte stream access helper functions *****************************************/
-
-static inline uint16_t stm32l4_getle16(FAR const uint8_t *val);
-
-/* Channel management **********************************************************/
-
-static int stm32l4_chan_alloc(FAR struct stm32l4_usbhost_s *priv);
-static inline void stm32l4_chan_free(FAR struct stm32l4_usbhost_s *priv, int chidx);
-static inline void stm32l4_chan_freeall(FAR struct stm32l4_usbhost_s *priv);
-static void stm32l4_chan_configure(FAR struct stm32l4_usbhost_s *priv, int chidx);
-static void stm32l4_chan_halt(FAR struct stm32l4_usbhost_s *priv, int chidx,
-                              enum stm32l4_chreason_e chreason);
-static int stm32l4_chan_waitsetup(FAR struct stm32l4_usbhost_s *priv,
-                                  FAR struct stm32l4_chan_s *chan);
-#ifdef CONFIG_USBHOST_ASYNCH
-static int stm32l4_chan_asynchsetup(FAR struct stm32l4_usbhost_s *priv,
-                                    FAR struct stm32l4_chan_s *chan,
-                                    usbhost_asynch_t callback, FAR void *arg);
-#endif
-static int stm32l4_chan_wait(FAR struct stm32l4_usbhost_s *priv,
-                             FAR struct stm32l4_chan_s *chan);
-static void stm32l4_chan_wakeup(FAR struct stm32l4_usbhost_s *priv,
-                                FAR struct stm32l4_chan_s *chan);
-static int stm32l4_ctrlchan_alloc(FAR struct stm32l4_usbhost_s *priv,
-                                  uint8_t epno, uint8_t funcaddr, uint8_t speed,
-                                  FAR struct stm32l4_ctrlinfo_s *ctrlep);
-static int stm32l4_ctrlep_alloc(FAR struct stm32l4_usbhost_s *priv,
-                                FAR const struct usbhost_epdesc_s *epdesc,
-                                FAR usbhost_ep_t *ep);
-static int stm32l4_xfrep_alloc(FAR struct stm32l4_usbhost_s *priv,
-                               FAR const struct usbhost_epdesc_s *epdesc,
-                               FAR usbhost_ep_t *ep);
-
-/* Control/data transfer logic *************************************************/
-
-static void stm32l4_transfer_start(FAR struct stm32l4_usbhost_s *priv, int chidx);
-#if 0 /* Not used */
-static inline uint16_t stm32l4_getframe(void);
-#endif
-static int stm32l4_ctrl_sendsetup(FAR struct stm32l4_usbhost_s *priv,
-                                  FAR struct stm32l4_ctrlinfo_s *ep0,
-                                  FAR const struct usb_ctrlreq_s *req);
-static int stm32l4_ctrl_senddata(FAR struct stm32l4_usbhost_s *priv,
-                                 FAR struct stm32l4_ctrlinfo_s *ep0,
-                                 FAR uint8_t *buffer, unsigned int buflen);
-static int stm32l4_ctrl_recvdata(FAR struct stm32l4_usbhost_s *priv,
-                                 FAR struct stm32l4_ctrlinfo_s *ep0,
-                                 FAR uint8_t *buffer, unsigned int buflen);
-static int stm32l4_in_setup(FAR struct stm32l4_usbhost_s *priv, int chidx);
-static ssize_t stm32l4_in_transfer(FAR struct stm32l4_usbhost_s *priv, int chidx,
-                                   FAR uint8_t *buffer, size_t buflen);
-#ifdef CONFIG_USBHOST_ASYNCH
-static void stm32l4_in_next(FAR struct stm32l4_usbhost_s *priv,
-                            FAR struct stm32l4_chan_s *chan);
-static int stm32l4_in_asynch(FAR struct stm32l4_usbhost_s *priv, int chidx,
-                             FAR uint8_t *buffer, size_t buflen,
-                             usbhost_asynch_t callback, FAR void *arg);
-#endif
-static int stm32l4_out_setup(FAR struct stm32l4_usbhost_s *priv, int chidx);
-static ssize_t stm32l4_out_transfer(FAR struct stm32l4_usbhost_s *priv, int chidx,
-                                    FAR uint8_t *buffer, size_t buflen);
-#ifdef CONFIG_USBHOST_ASYNCH
-static void stm32l4_out_next(FAR struct stm32l4_usbhost_s *priv,
-                             FAR struct stm32l4_chan_s *chan);
-static int stm32l4_out_asynch(FAR struct stm32l4_usbhost_s *priv, int chidx,
-                              FAR uint8_t *buffer, size_t buflen,
-                              usbhost_asynch_t callback, FAR void *arg);
-#endif
-
-/* Interrupt handling **********************************************************/
-/* Lower level interrupt handlers */
-
-static void stm32l4_gint_wrpacket(FAR struct stm32l4_usbhost_s *priv,
-                                  FAR uint8_t *buffer, int chidx, int buflen);
-static inline void stm32l4_gint_hcinisr(FAR struct stm32l4_usbhost_s *priv,
-                                        int chidx);
-static inline void stm32l4_gint_hcoutisr(FAR struct stm32l4_usbhost_s *priv,
-                                         int chidx);
-static void stm32l4_gint_connected(FAR struct stm32l4_usbhost_s *priv);
-static void stm32l4_gint_disconnected(FAR struct stm32l4_usbhost_s *priv);
-
-/* Second level interrupt handlers */
-
-#ifdef CONFIG_STM32L4_OTGFS_SOFINTR
-static inline void stm32l4_gint_sofisr(FAR struct stm32l4_usbhost_s *priv);
-#endif
-static inline void stm32l4_gint_rxflvlisr(FAR struct stm32l4_usbhost_s *priv);
-static inline void stm32l4_gint_nptxfeisr(FAR struct stm32l4_usbhost_s *priv);
-static inline void stm32l4_gint_ptxfeisr(FAR struct stm32l4_usbhost_s *priv);
-static inline void stm32l4_gint_hcisr(FAR struct stm32l4_usbhost_s *priv);
-static inline void stm32l4_gint_hprtisr(FAR struct stm32l4_usbhost_s *priv);
-static inline void stm32l4_gint_discisr(FAR struct stm32l4_usbhost_s *priv);
-static inline void stm32l4_gint_ipxfrisr(FAR struct stm32l4_usbhost_s *priv);
-
-/* First level, global interrupt handler */
-
-static int stm32l4_gint_isr(int irq, FAR void *context, FAR void *arg);
-
-/* Interrupt controls */
-
-static void stm32l4_gint_enable(void);
-static void stm32l4_gint_disable(void);
-static inline void stm32l4_hostinit_enable(void);
-static void stm32l4_txfe_enable(FAR struct stm32l4_usbhost_s *priv, int chidx);
-
-/* USB host controller operations **********************************************/
-
-static int stm32l4_wait(FAR struct usbhost_connection_s *conn,
-                        FAR struct usbhost_hubport_s **hport);
-static int stm32l4_rh_enumerate(FAR struct stm32l4_usbhost_s *priv,
-                                FAR struct usbhost_connection_s *conn,
-                                FAR struct usbhost_hubport_s *hport);
-static int stm32l4_enumerate(FAR struct usbhost_connection_s *conn,
-                             FAR struct usbhost_hubport_s *hport);
-
-static int stm32l4_ep0configure(FAR struct usbhost_driver_s *drvr,
-                                usbhost_ep_t ep0, uint8_t funcaddr, uint8_t speed,
-                                uint16_t maxpacketsize);
-static int stm32l4_epalloc(FAR struct usbhost_driver_s *drvr,
-                           FAR const FAR struct usbhost_epdesc_s *epdesc,
-                           FAR usbhost_ep_t *ep);
-static int stm32l4_epfree(FAR struct usbhost_driver_s *drvr, usbhost_ep_t ep);
-static int stm32l4_alloc(FAR struct usbhost_driver_s *drvr,
-                         FAR uint8_t **buffer, FAR size_t *maxlen);
-static int stm32l4_free(FAR struct usbhost_driver_s *drvr, FAR uint8_t *buffer);
-static int stm32l4_ioalloc(FAR struct usbhost_driver_s *drvr,
-                           FAR uint8_t **buffer, size_t buflen);
-static int stm32l4_iofree(FAR struct usbhost_driver_s *drvr, FAR uint8_t *buffer);
-static int stm32l4_ctrlin(FAR struct usbhost_driver_s *drvr, usbhost_ep_t ep0,
-                          FAR const struct usb_ctrlreq_s *req,
-                          FAR uint8_t *buffer);
-static int stm32l4_ctrlout(FAR struct usbhost_driver_s *drvr, usbhost_ep_t ep0,
-                           FAR const struct usb_ctrlreq_s *req,
-                           FAR const uint8_t *buffer);
-static ssize_t stm32l4_transfer(FAR struct usbhost_driver_s *drvr, usbhost_ep_t ep,
-                                FAR uint8_t *buffer, size_t buflen);
-#ifdef CONFIG_USBHOST_ASYNCH
-static int stm32l4_asynch(FAR struct usbhost_driver_s *drvr, usbhost_ep_t ep,
-                          FAR uint8_t *buffer, size_t buflen,
-                          usbhost_asynch_t callback, FAR void *arg);
-#endif
-static int stm32l4_cancel(FAR struct usbhost_driver_s *drvr, usbhost_ep_t ep);
-#ifdef CONFIG_USBHOST_HUB
-static int stm32l4_connect(FAR struct usbhost_driver_s *drvr,
-                           FAR struct usbhost_hubport_s *hport,
-                           bool connected);
-#endif
-static void stm32l4_disconnect(FAR struct usbhost_driver_s *drvr,
-                               FAR struct usbhost_hubport_s *hport);
-
-/* Initialization **************************************************************/
-
-static void stm32l4_portreset(FAR struct stm32l4_usbhost_s *priv);
-static void stm32l4_flush_txfifos(uint32_t txfnum);
-static void stm32l4_flush_rxfifo(void);
-static void stm32l4_vbusdrive(FAR struct stm32l4_usbhost_s *priv, bool state);
-static void stm32l4_host_initialize(FAR struct stm32l4_usbhost_s *priv);
-
-static inline void stm32l4_sw_initialize(FAR struct stm32l4_usbhost_s *priv);
-static inline int stm32l4_hw_initialize(FAR struct stm32l4_usbhost_s *priv);
-
-/****************************************************************************
- * Private Data
- ****************************************************************************/
-
-/* In this driver implementation, support is provided for only a single a single
- * USB device.  All status information can be simply retained in a single global
- * instance.
- */
-
-static struct stm32l4_usbhost_s g_usbhost;
-
-/* This is the connection/enumeration interface */
-
-static struct usbhost_connection_s g_usbconn =
-{
-  .wait             = stm32l4_wait,
-  .enumerate        = stm32l4_enumerate,
-};
-
-/****************************************************************************
- * Public Data
- ****************************************************************************/
-
-/****************************************************************************
- * Private Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_printreg
- *
- * Description:
- *   Print the contents of an STM32xx register operation
- *
- ****************************************************************************/
-
-#ifdef CONFIG_STM32L4_USBHOST_REGDEBUG
-static void stm32l4_printreg(uint32_t addr, uint32_t val, bool iswrite)
-{
-  lldbg("%08x%s%08x\n", addr, iswrite ? "<-" : "->", val);
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_checkreg
- *
- * Description:
- *   Get the contents of an STM32 register
- *
- ****************************************************************************/
-
-#ifdef CONFIG_STM32L4_USBHOST_REGDEBUG
-static void stm32l4_checkreg(uint32_t addr, uint32_t val, bool iswrite)
-{
-  static uint32_t prevaddr = 0;
-  static uint32_t preval = 0;
-  static uint32_t count = 0;
-  static bool     prevwrite = false;
-
-  /* Is this the same value that we read from/wrote to the same register last time?
-   * Are we polling the register?  If so, suppress the output.
-   */
-
-  if (addr == prevaddr && val == preval && prevwrite == iswrite)
-    {
-      /* Yes.. Just increment the count */
-
-      count++;
-    }
-  else
-    {
-      /* No this is a new address or value or operation. Were there any
-       * duplicate accesses before this one?
-       */
-
-      if (count > 0)
-        {
-          /* Yes.. Just one? */
-
-          if (count == 1)
-            {
-              /* Yes.. Just one */
-
-              stm32l4_printreg(prevaddr, preval, prevwrite);
-            }
-          else
-            {
-              /* No.. More than one. */
-
-              lldbg("[repeats %d more times]\n", count);
-            }
-        }
-
-      /* Save the new address, value, count, and operation for next time */
-
-      prevaddr  = addr;
-      preval    = val;
-      count     = 0;
-      prevwrite = iswrite;
-
-      /* Show the new regisgter access */
-
-      stm32l4_printreg(addr, val, iswrite);
-    }
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_getreg
- *
- * Description:
- *   Get the contents of an STM32 register
- *
- ****************************************************************************/
-
-#ifdef CONFIG_STM32L4_USBHOST_REGDEBUG
-static uint32_t stm32l4_getreg(uint32_t addr)
-{
-  /* Read the value from the register */
-
-  uint32_t val = getreg32(addr);
-
-  /* Check if we need to print this value */
-
-  stm32l4_checkreg(addr, val, false);
-  return val;
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_putreg
- *
- * Description:
- *   Set the contents of an STM32 register to a value
- *
- ****************************************************************************/
-
-#ifdef CONFIG_STM32L4_USBHOST_REGDEBUG
-static void stm32l4_putreg(uint32_t addr, uint32_t val)
-{
-  /* Check if we need to print this value */
-
-  stm32l4_checkreg(addr, val, true);
-
-  /* Write the value */
-
-  putreg32(val, addr);
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_modifyreg
- *
- * Description:
- *   Modify selected bits of an STM32 register.
- *
- ****************************************************************************/
-
-static inline void stm32l4_modifyreg(uint32_t addr, uint32_t clrbits,
-                                     uint32_t setbits)
-{
-  stm32l4_putreg(addr, (((stm32l4_getreg(addr)) & ~clrbits) | setbits));
-}
-
-/****************************************************************************
- * Name: stm32l4_takesem
- *
- * Description:
- *   This is just a wrapper to handle the annoying behavior of semaphore
- *   waits that return due to the receipt of a signal.
- *
- ****************************************************************************/
-
-static void stm32l4_takesem(FAR sem_t *sem)
-{
-  /* Take the semaphore (perhaps waiting) */
-
-  while (sem_wait(sem) != 0)
-    {
-      /* The only case that an error should occr here is if the wait was
-       * awakened by a signal.
-       */
-
-      ASSERT(errno == EINTR);
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_getle16
- *
- * Description:
- *   Get a (possibly unaligned) 16-bit little endian value.
- *
- ****************************************************************************/
-
-static inline uint16_t stm32l4_getle16(FAR const uint8_t *val)
-{
-  return (uint16_t)val[1] << 8 | (uint16_t)val[0];
-}
-
-/****************************************************************************
- * Name: stm32l4_chan_alloc
- *
- * Description:
- *   Allocate a channel.
- *
- ****************************************************************************/
-
-static int stm32l4_chan_alloc(FAR struct stm32l4_usbhost_s *priv)
-{
-  int chidx;
-
-  /* Search the table of channels */
-
-  for (chidx = 0; chidx < STM32L4_NHOST_CHANNELS; chidx++)
-    {
-      /* Is this channel available? */
-
-      if (!priv->chan[chidx].inuse)
-        {
-          /* Yes... make it "in use" and return the index */
-
-          priv->chan[chidx].inuse = true;
-          return chidx;
-        }
-    }
-
-  /* All of the channels are "in-use" */
-
-  return -EBUSY;
-}
-
-/****************************************************************************
- * Name: stm32l4_chan_free
- *
- * Description:
- *   Free a previoiusly allocated channel.
- *
- ****************************************************************************/
-
-static void stm32l4_chan_free(FAR struct stm32l4_usbhost_s *priv, int chidx)
-{
-  DEBUGASSERT((unsigned)chidx < STM32L4_NHOST_CHANNELS);
-
-  /* Halt the channel */
-
-  stm32l4_chan_halt(priv, chidx, CHREASON_FREED);
-
-  /* Mark the channel available */
-
-  priv->chan[chidx].inuse = false;
-}
-
-/****************************************************************************
- * Name: stm32l4_chan_freeall
- *
- * Description:
- *   Free all channels.
- *
- ****************************************************************************/
-
-static inline void stm32l4_chan_freeall(FAR struct stm32l4_usbhost_s *priv)
-{
-  uint8_t chidx;
-
-  /* Free all host channels */
-
-  for (chidx = 2; chidx < STM32L4_NHOST_CHANNELS; chidx ++)
-    {
-      stm32l4_chan_free(priv, chidx);
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_chan_configure
- *
- * Description:
- *   Configure or re-configure a host channel.  Host channels are configured
- *   when endpoint is allocated and EP0 (only) is re-configured with the
- *   max packet size or device address changes.
- *
- ****************************************************************************/
-
-static void stm32l4_chan_configure(FAR struct stm32l4_usbhost_s *priv, int chidx)
-{
-  FAR struct stm32l4_chan_s *chan = &priv->chan[chidx];
-  uint32_t regval;
-
-  /* Clear any old pending interrupts for this host channel. */
-
-  stm32l4_putreg(STM32L4_OTGFS_HCINT(chidx), 0xffffffff);
-
-  /* Enable channel interrupts required for transfers on this channel. */
-
-  regval = 0;
-
-  switch (chan->eptype)
-    {
-      case OTGFS_EPTYPE_CTRL:
-      case OTGFS_EPTYPE_BULK:
-        {
-#ifdef HAVE_USBHOST_TRACE_VERBOSE
-          uint16_t intrace;
-          uint16_t outtrace;
-
-          /* Determine the definitive trace ID to use below */
-
-          if (chan->eptype == OTGFS_EPTYPE_CTRL)
-            {
-              intrace  = OTGFS_VTRACE2_CHANCONF_CTRL_IN;
-              outtrace = OTGFS_VTRACE2_CHANCONF_CTRL_OUT;
-            }
-          else
-            {
-              intrace  = OTGFS_VTRACE2_CHANCONF_BULK_IN;
-              outtrace = OTGFS_VTRACE2_CHANCONF_BULK_OUT;
-            }
-#endif
-
-          /* Interrupts required for CTRL and BULK endpoints */
-
-          regval |= (OTGFS_HCINT_XFRC  | OTGFS_HCINT_STALL | OTGFS_HCINT_NAK |
-                     OTGFS_HCINT_TXERR | OTGFS_HCINT_DTERR);
-
-          /* Additional setting for IN/OUT endpoints */
-
-          if (chan->in)
-            {
-              usbhost_vtrace2(intrace, chidx, chan->epno);
-              regval |= OTGFS_HCINT_BBERR;
-            }
-          else
-            {
-              usbhost_vtrace2(outtrace, chidx, chan->epno);
-              regval |= OTGFS_HCINT_NYET;
-            }
-        }
-        break;
-
-      case OTGFS_EPTYPE_INTR:
-        {
-          /* Interrupts required for INTR endpoints */
-
-          regval |= (OTGFS_HCINT_XFRC | OTGFS_HCINT_STALL | OTGFS_HCINT_NAK |
-                     OTGFS_HCINT_TXERR | OTGFS_HCINT_FRMOR | OTGFS_HCINT_DTERR);
-
-          /* Additional setting for IN endpoints */
-
-          if (chan->in)
-            {
-              usbhost_vtrace2(OTGFS_VTRACE2_CHANCONF_INTR_IN, chidx,
-                              chan->epno);
-              regval |= OTGFS_HCINT_BBERR;
-            }
-#ifdef HAVE_USBHOST_TRACE_VERBOSE
-          else
-            {
-              usbhost_vtrace2(OTGFS_VTRACE2_CHANCONF_INTR_OUT, chidx,
-                              chan->epno);
-            }
-#endif
-        }
-        break;
-
-      case OTGFS_EPTYPE_ISOC:
-        {
-          /* Interrupts required for ISOC endpoints */
-
-          regval |= (OTGFS_HCINT_XFRC | OTGFS_HCINT_ACK | OTGFS_HCINT_FRMOR);
-
-          /* Additional setting for IN endpoints */
-
-          if (chan->in)
-            {
-              usbhost_vtrace2(OTGFS_VTRACE2_CHANCONF_ISOC_IN, chidx,
-                              chan->epno);
-              regval |= (OTGFS_HCINT_TXERR | OTGFS_HCINT_BBERR);
-            }
-#ifdef HAVE_USBHOST_TRACE_VERBOSE
-          else
-            {
-              usbhost_vtrace2(OTGFS_VTRACE2_CHANCONF_ISOC_OUT, chidx,
-                              chan->epno);
-            }
-#endif
-        }
-        break;
-    }
-
-  stm32l4_putreg(STM32L4_OTGFS_HCINTMSK(chidx), regval);
-
-  /* Enable the top level host channel interrupt. */
-
-  stm32l4_modifyreg(STM32L4_OTGFS_HAINTMSK, 0, OTGFS_HAINT(chidx));
-
-  /* Make sure host channel interrupts are enabled. */
-
-  stm32l4_modifyreg(STM32L4_OTGFS_GINTMSK, 0, OTGFS_GINT_HC);
-
-  /* Program the HCCHAR register */
-
-  regval = ((uint32_t)chan->maxpacket << OTGFS_HCCHAR_MPSIZ_SHIFT) |
-           ((uint32_t)chan->epno      << OTGFS_HCCHAR_EPNUM_SHIFT) |
-           ((uint32_t)chan->eptype    << OTGFS_HCCHAR_EPTYP_SHIFT) |
-           ((uint32_t)chan->funcaddr  << OTGFS_HCCHAR_DAD_SHIFT);
-
-  /* Special case settings for low speed devices */
-
-  if (chan->speed == USB_SPEED_LOW)
-    {
-      regval |= OTGFS_HCCHAR_LSDEV;
-    }
-
-  /* Special case settings for IN endpoints */
-
-  if (chan->in)
-    {
-      regval |= OTGFS_HCCHAR_EPDIR_IN;
-    }
-
-  /* Special case settings for INTR endpoints */
-
-  if (chan->eptype == OTGFS_EPTYPE_INTR)
-    {
-      regval |= OTGFS_HCCHAR_ODDFRM;
-    }
-
-  /* Write the channel configuration */
-
-  stm32l4_putreg(STM32L4_OTGFS_HCCHAR(chidx), regval);
-}
-
-/****************************************************************************
- * Name: stm32l4_chan_halt
- *
- * Description:
- *   Halt the channel associated with 'chidx' by setting the CHannel DISable
- *   (CHDIS) bit in in the HCCHAR register.
- *
- ****************************************************************************/
-
-static void stm32l4_chan_halt(FAR struct stm32l4_usbhost_s *priv, int chidx,
-                              enum stm32l4_chreason_e chreason)
-{
-  uint32_t hcchar;
-  uint32_t intmsk;
-  uint32_t eptype;
-  unsigned int avail;
-
-  /* Save the reason for the halt.  We need this in the channel halt interrupt
-   * handling logic to know what to do next.
-   */
-
-  usbhost_vtrace2(OTGFS_VTRACE2_CHANHALT, chidx, chreason);
-
-  priv->chan[chidx].chreason = (uint8_t)chreason;
-
-  /* "The application can disable any channel by programming the OTG_FS_HCCHARx
-   *  register with the CHDIS and CHENA bits set to 1. This enables the OTG_FS
-   *  host to flush the posted requests (if any) and generates a channel halted
-   *  interrupt. The application must wait for the CHH interrupt in OTG_FS_HCINTx
-   *  before reallocating the channel for other transactions.  The OTG_FS host
-   *  does not interrupt the transaction that has already been started on the
-   *  USB."
-   */
-
-  hcchar  = stm32l4_getreg(STM32L4_OTGFS_HCCHAR(chidx));
-  hcchar |= (OTGFS_HCCHAR_CHDIS | OTGFS_HCCHAR_CHENA);
-
-  /* Get the endpoint type from the HCCHAR register */
-
-  eptype = hcchar & OTGFS_HCCHAR_EPTYP_MASK;
-
-  /* Check for space in the Tx FIFO to issue the halt.
-   *
-   * "Before disabling a channel, the application must ensure that there is at
-   *  least one free space available in the non-periodic request queue (when
-   *  disabling a non-periodic channel) or the periodic request queue (when
-   *  disabling a periodic channel). The application can simply flush the
-   *  posted requests when the Request queue is full (before disabling the
-   *  channel), by programming the OTG_FS_HCCHARx register with the CHDIS bit
-   *  set to 1, and the CHENA bit cleared to 0.
-   */
-
-  if (eptype == OTGFS_HCCHAR_EPTYP_CTRL || eptype == OTGFS_HCCHAR_EPTYP_BULK)
-    {
-      /* Get the number of words available in the non-periodic Tx FIFO. */
-
-      avail = stm32l4_getreg(STM32L4_OTGFS_HNPTXSTS) & OTGFS_HNPTXSTS_NPTXFSAV_MASK;
-    }
-  else /* if (eptype == OTGFS_HCCHAR_EPTYP_ISOC || eptype == OTGFS_HCCHAR_EPTYP_INTR) */
-    {
-      /* Get the number of words available in the non-periodic Tx FIFO. */
-
-      avail = stm32l4_getreg(STM32L4_OTGFS_HPTXSTS) & OTGFS_HPTXSTS_PTXFSAVL_MASK;
-    }
-
-  /* Check if there is any space available in the Tx FIFO. */
-
-  if (avail == 0)
-    {
-      /* The Tx FIFO is full... disable the channel to flush the requests */
-
-      hcchar &= ~OTGFS_HCCHAR_CHENA;
-    }
-
-  /* Unmask the CHannel Halted (CHH) interrupt */
-
-  intmsk  = stm32l4_getreg(STM32L4_OTGFS_HCINTMSK(chidx));
-  intmsk |= OTGFS_HCINT_CHH;
-  stm32l4_putreg(STM32L4_OTGFS_HCINTMSK(chidx), intmsk);
-
-  /* Halt the channel by setting CHDIS (and maybe CHENA) in the HCCHAR */
-
-  stm32l4_putreg(STM32L4_OTGFS_HCCHAR(chidx), hcchar);
-}
-
-/****************************************************************************
- * Name: stm32l4_chan_waitsetup
- *
- * Description:
- *   Set the request for the transfer complete event well BEFORE enabling the
- *   transfer (as soon as we are absolutely committed to the to avoid transfer).
- *   We do this to minimize race conditions.  This logic would have to be expanded
- *   if we want to have more than one packet in flight at a time!
- *
- * Assumptions:
- *   Called from a normal thread context BEFORE the transfer has been started.
- *
- ****************************************************************************/
-
-static int stm32l4_chan_waitsetup(FAR struct stm32l4_usbhost_s *priv,
-                                  FAR struct stm32l4_chan_s *chan)
-{
-  irqstate_t flags = enter_critical_section();
-  int        ret   = -ENODEV;
-
-  /* Is the device still connected? */
-
-  if (priv->connected)
-    {
-      /* Yes.. then set waiter to indicate that we expect to be informed when
-       * either (1) the device is disconnected, or (2) the transfer completed.
-       */
-
-      chan->waiter   = true;
-#ifdef CONFIG_USBHOST_ASYNCH
-      chan->callback = NULL;
-      chan->arg      = NULL;
-#endif
-      ret            = OK;
-    }
-
-  leave_critical_section(flags);
-  return ret;
-}
-
-/****************************************************************************
- * Name: stm32l4_chan_asynchsetup
- *
- * Description:
- *   Set the request for the transfer complete event well BEFORE enabling the
- *   transfer (as soon as we are absolutely committed to the to avoid transfer).
- *   We do this to minimize race conditions.  This logic would have to be expanded
- *   if we want to have more than one packet in flight at a time!
- *
- * Assumptions:
- *   Might be called from the level of an interrupt handler
- *
- ****************************************************************************/
-
-#ifdef CONFIG_USBHOST_ASYNCH
-static int stm32l4_chan_asynchsetup(FAR struct stm32l4_usbhost_s *priv,
-                                    FAR struct stm32l4_chan_s *chan,
-                                    usbhost_asynch_t callback, FAR void *arg)
-{
-  irqstate_t flags = enter_critical_section();
-  int        ret   = -ENODEV;
-
-  /* Is the device still connected? */
-
-  if (priv->connected)
-    {
-      /* Yes.. then set waiter to indicate that we expect to be informed when
-       * either (1) the device is disconnected, or (2) the transfer completed.
-       */
-
-      chan->waiter   = false;
-      chan->callback = callback;
-      chan->arg      = arg;
-      ret            = OK;
-    }
-
-  leave_critical_section(flags);
-  return ret;
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_chan_wait
- *
- * Description:
- *   Wait for a transfer on a channel to complete.
- *
- * Assumptions:
- *   Called from a normal thread context
- *
- ****************************************************************************/
-
-static int stm32l4_chan_wait(FAR struct stm32l4_usbhost_s *priv,
-                             FAR struct stm32l4_chan_s *chan)
-{
-  irqstate_t flags;
-  int ret;
-
-  /* Disable interrupts so that the following operations will be atomic.  On
-   * the OTG FS global interrupt needs to be disabled.  However, here we disable
-   * all interrupts to exploit that fact that interrupts will be re-enabled
-   * while we wait.
-   */
-
-  flags = enter_critical_section();
-
-  /* Loop, testing for an end of transfer condition.  The channel 'result'
-   * was set to EBUSY and 'waiter' was set to true before the transfer; 'waiter'
-   * will be set to false and 'result' will be set appropriately when the
-   * transfer is completed.
-   */
-
-  do
-    {
-      /* Wait for the transfer to complete.  NOTE the transfer may already
-       * completed before we get here or the transfer may complete while we
-       * wait here.
-       */
-
-      ret = sem_wait(&chan->waitsem);
-
-      /* sem_wait should succeed.  But it is possible that we could be
-       * awakened by a signal too.
-       */
-
-      DEBUGASSERT(ret == OK || get_errno() == EINTR);
-    }
-  while (chan->waiter);
-
-  /* The transfer is complete re-enable interrupts and return the result */
-
-  ret = -(int)chan->result;
-  leave_critical_section(flags);
-  return ret;
-}
-
-/****************************************************************************
- * Name: stm32l4_chan_wakeup
- *
- * Description:
- *   A channel transfer has completed... wakeup any threads waiting for the
- *   transfer to complete.
- *
- * Assumptions:
- *   This function is called from the transfer complete interrupt handler for
- *   the channel.  Interrupts are disabled.
- *
- ****************************************************************************/
-
-static void stm32l4_chan_wakeup(FAR struct stm32l4_usbhost_s *priv,
-                                FAR struct stm32l4_chan_s *chan)
-{
-  /* Is the transfer complete? */
-
-  if (chan->result != EBUSY)
-    {
-      /* Is there a thread waiting for this transfer to complete? */
-
-      if (chan->waiter)
-        {
-#ifdef CONFIG_USBHOST_ASYNCH
-          /* Yes.. there should not also be a callback scheduled */
-
-          DEBUGASSERT(chan->callback == NULL);
-#endif
-          /* Wake'em up! */
-
-          usbhost_vtrace2(chan->in ? OTGFS_VTRACE2_CHANWAKEUP_IN :
-                          OTGFS_VTRACE2_CHANWAKEUP_OUT,
-                          chan->epno, chan->result);
-
-          stm32l4_givesem(&chan->waitsem);
-          chan->waiter = false;
-        }
-
-#ifdef CONFIG_USBHOST_ASYNCH
-      /* No.. is an asynchronous callback expected when the transfer
-       * completes?
-       */
-
-      else if (chan->callback)
-        {
-          /* Handle continuation of IN/OUT pipes */
-
-          if (chan->in)
-            {
-              stm32l4_in_next(priv, chan);
-            }
-          else
-            {
-              stm32l4_out_next(priv, chan);
-            }
-        }
-#endif
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_ctrlchan_alloc
- *
- * Description:
- *   Allocate and configured channels for a control pipe.
- *
- ****************************************************************************/
-
-static int stm32l4_ctrlchan_alloc(FAR struct stm32l4_usbhost_s *priv,
-                                  uint8_t epno, uint8_t funcaddr, uint8_t speed,
-                                  FAR struct stm32l4_ctrlinfo_s *ctrlep)
-{
-  FAR struct stm32l4_chan_s *chan;
-  int inndx;
-  int outndx;
-
-  outndx = stm32l4_chan_alloc(priv);
-  if (outndx < 0)
-    {
-      return -ENOMEM;
-    }
-
-  ctrlep->outndx  = outndx;
-  chan            = &priv->chan[outndx];
-  chan->epno      = epno;
-  chan->in        = false;
-  chan->eptype    = OTGFS_EPTYPE_CTRL;
-  chan->funcaddr  = funcaddr;
-  chan->speed     = speed;
-  chan->interval  = 0;
-  chan->maxpacket = STM32L4_EP0_DEF_PACKET_SIZE;
-  chan->indata1   = false;
-  chan->outdata1  = false;
-
-  /* Configure control OUT channels */
-
-  stm32l4_chan_configure(priv, outndx);
-
-  /* Allocate and initialize the control IN channel */
-
-  inndx = stm32l4_chan_alloc(priv);
-  if (inndx < 0)
-    {
-      stm32l4_chan_free(priv, outndx);
-      return -ENOMEM;
-    }
-
-  ctrlep->inndx   = inndx;
-  chan            = &priv->chan[inndx];
-  chan->epno      = epno;
-  chan->in        = true;
-  chan->eptype    = OTGFS_EPTYPE_CTRL;
-  chan->funcaddr  = funcaddr;
-  chan->speed     = speed;
-  chan->interval  = 0;
-  chan->maxpacket = STM32L4_EP0_DEF_PACKET_SIZE;
-  chan->indata1   = false;
-  chan->outdata1  = false;
-
-  /* Configure control IN channels */
-
-  stm32l4_chan_configure(priv, inndx);
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_ctrlep_alloc
- *
- * Description:
- *   Allocate a container and channels for control pipe.
- *
- * Input Parameters:
- *   priv - The private USB host driver state.
- *   epdesc - Describes the endpoint to be allocated.
- *   ep - A memory location provided by the caller in which to receive the
- *      allocated endpoint descriptor.
- *
- * Returned Values:
- *   On success, zero (OK) is returned. On a failure, a negated errno value is
- *   returned indicating the nature of the failure
- *
- * Assumptions:
- *   This function will *not* be called from an interrupt handler.
- *
- ****************************************************************************/
-
-static int stm32l4_ctrlep_alloc(FAR struct stm32l4_usbhost_s *priv,
-                                FAR const struct usbhost_epdesc_s *epdesc,
-                                FAR usbhost_ep_t *ep)
-{
-  FAR struct usbhost_hubport_s *hport;
-  FAR struct stm32l4_ctrlinfo_s *ctrlep;
-  int ret;
-
-  /* Sanity check.  NOTE that this method should only be called if a device is
-   * connected (because we need a valid low speed indication).
-   */
-
-  DEBUGASSERT(epdesc->hport != NULL);
-  hport = epdesc->hport;
-
-  /* Allocate a container for the control endpoint */
-
-  ctrlep = (FAR struct stm32l4_ctrlinfo_s *)kmm_malloc(sizeof(struct stm32l4_ctrlinfo_s));
-  if (ctrlep == NULL)
-    {
-      uerr("ERROR: Failed to allocate control endpoint container\n");
-      return -ENOMEM;
-    }
-
-  /* Then allocate and configure the IN/OUT channnels  */
-
-  ret = stm32l4_ctrlchan_alloc(priv, epdesc->addr & USB_EPNO_MASK,
-                               hport->funcaddr, hport->speed, ctrlep);
-  if (ret < 0)
-    {
-      uerr("ERROR: stm32l4_ctrlchan_alloc failed: %d\n", ret);
-      kmm_free(ctrlep);
-      return ret;
-    }
-
-  /* Return a pointer to the control pipe container as the pipe "handle" */
-
-  *ep = (usbhost_ep_t)ctrlep;
-  return OK;
-}
-
-/************************************************************************************
- * Name: stm32l4_xfrep_alloc
- *
- * Description:
- *   Allocate and configure one unidirectional endpoint.
- *
- * Input Parameters:
- *   priv - The private USB host driver state.
- *   epdesc - Describes the endpoint to be allocated.
- *   ep - A memory location provided by the caller in which to receive the
- *      allocated endpoint descriptor.
- *
- * Returned Values:
- *   On success, zero (OK) is returned. On a failure, a negated errno value is
- *   returned indicating the nature of the failure
- *
- * Assumptions:
- *   This function will *not* be called from an interrupt handler.
- *
- ************************************************************************************/
-
-static int stm32l4_xfrep_alloc(FAR struct stm32l4_usbhost_s *priv,
-                               FAR const struct usbhost_epdesc_s *epdesc,
-                               FAR usbhost_ep_t *ep)
-{
-  struct usbhost_hubport_s *hport;
-  FAR struct stm32l4_chan_s *chan;
-  int chidx;
-
-  /* Sanity check.  NOTE that this method should only be called if a device is
-   * connected (because we need a valid low speed indication).
-   */
-
-  DEBUGASSERT(epdesc->hport != NULL);
-  hport = epdesc->hport;
-
-  /* Allocate a host channel for the endpoint */
-
-  chidx = stm32l4_chan_alloc(priv);
-  if (chidx < 0)
-    {
-      uerr("ERROR: Failed to allocate a host channel\n");
-      return -ENOMEM;
-    }
-
-  /* Decode the endpoint descriptor to initialize the channel data structures.
-   * Note:  Here we depend on the fact that the endpoint point type is
-   * encoded in the same way in the endpoint descriptor as it is in the OTG
-   * HS hardware.
-   */
-
-  chan            = &priv->chan[chidx];
-  chan->epno      = epdesc->addr & USB_EPNO_MASK;
-  chan->in        = epdesc->in;
-  chan->eptype    = epdesc->xfrtype;
-  chan->funcaddr  = hport->funcaddr;
-  chan->speed     = hport->speed;
-  chan->interval  = epdesc->interval;
-  chan->maxpacket = epdesc->mxpacketsize;
-  chan->indata1   = false;
-  chan->outdata1  = false;
-
-  /* Then configure the endpoint */
-
-  stm32l4_chan_configure(priv, chidx);
-
-  /* Return the index to the allocated channel as the endpoint "handle" */
-
-  *ep = (usbhost_ep_t)chidx;
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_transfer_start
- *
- * Description:
- *   Start at transfer on the select IN or OUT channel.
- *
- ****************************************************************************/
-
-static void stm32l4_transfer_start(FAR struct stm32l4_usbhost_s *priv,
-                                   int chidx)
-{
-  FAR struct stm32l4_chan_s *chan;
-  uint32_t regval;
-  unsigned int npackets;
-  unsigned int maxpacket;
-  unsigned int avail;
-  unsigned int wrsize;
-  unsigned int minsize;
-
-  /* Set up the initial state of the transfer */
-
-  chan           = &priv->chan[chidx];
-
-  usbhost_vtrace2(OTGFS_VTRACE2_STARTTRANSFER, chidx, chan->buflen);
-
-  chan->result   = EBUSY;
-  chan->inflight = 0;
-  chan->xfrd     = 0;
-  priv->chidx    = chidx;
-
-  /* Compute the expected number of packets associated to the transfer.
-   * If the transfer length is zero (or less than the size of one maximum
-   * size packet), then one packet is expected.
-   */
-
-  /* If the transfer size is greater than one packet, then calculate the
-   * number of packets that will be received/sent, including any partial
-   * final packet.
-   */
-
-  maxpacket = chan->maxpacket;
-
-  if (chan->buflen > maxpacket)
-    {
-      npackets = (chan->buflen + maxpacket - 1) / maxpacket;
-
-      /* Clip if the buffer length if it exceeds the maximum number of
-       * packets that can be transferred (this should not happen).
-       */
-
-      if (npackets > STM32L4_MAX_PKTCOUNT)
-        {
-          npackets = STM32L4_MAX_PKTCOUNT;
-          chan->buflen = STM32L4_MAX_PKTCOUNT * maxpacket;
-          usbhost_trace2(OTGFS_TRACE2_CLIP, chidx, chan->buflen);
-        }
-    }
-  else
-    {
-      /* One packet will be sent/received (might be a zero length packet) */
-
-      npackets = 1;
-    }
-
-  /* If it is an IN transfer, then adjust the size of the buffer UP to
-   * a full number of packets.  Hmmm... couldn't this cause an overrun
-   * into unallocated memory?
-   */
-
-#if 0 /* Think about this */
-  if (chan->in)
-    {
-      /* Force the buffer length to an even multiple of maxpacket */
-
-      chan->buflen = npackets * maxpacket;
-    }
-#endif
-
-  /* Save the number of packets in the transfer.  We will need this in
-   * order to set the next data toggle correctly when the transfer
-   * completes.
-   */
-
-  chan->npackets = (uint8_t)npackets;
-
-  /* Setup the HCTSIZn register */
-
-  regval = ((uint32_t)chan->buflen << OTGFS_HCTSIZ_XFRSIZ_SHIFT) |
-           ((uint32_t)npackets << OTGFS_HCTSIZ_PKTCNT_SHIFT) |
-           ((uint32_t)chan->pid << OTGFS_HCTSIZ_DPID_SHIFT);
-  stm32l4_putreg(STM32L4_OTGFS_HCTSIZ(chidx), regval);
-
-  /* Setup the HCCHAR register: Frame oddness and host channel enable */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_HCCHAR(chidx));
-
-  /* Set/clear the Odd Frame bit.  Check for an even frame; if so set Odd
-   * Frame. This field is applicable for only periodic (isochronous and
-   * interrupt) channels.
-   */
-
-  if ((stm32l4_getreg(STM32L4_OTGFS_HFNUM) & 1) == 0)
-    {
-      regval |= OTGFS_HCCHAR_ODDFRM;
-    }
-  else
-    {
-      regval &= ~OTGFS_HCCHAR_ODDFRM;
-    }
-
-  regval &= ~OTGFS_HCCHAR_CHDIS;
-  regval |= OTGFS_HCCHAR_CHENA;
-  stm32l4_putreg(STM32L4_OTGFS_HCCHAR(chidx), regval);
-
-  /* If this is an out transfer, then we need to do more.. we need to copy
-   * the outgoing data into the correct TxFIFO.
-   */
-
-  if (!chan->in && chan->buflen > 0)
-    {
-      /* Handle non-periodic (CTRL and BULK) OUT transfers differently than
-       * periodic (INTR and ISOC) OUT transfers.
-       */
-
-      minsize = MIN(chan->buflen, chan->maxpacket);
-
-      switch (chan->eptype)
-        {
-          case OTGFS_EPTYPE_CTRL: /* Non periodic transfer */
-          case OTGFS_EPTYPE_BULK:
-            {
-              /* Read the Non-periodic Tx FIFO status register */
-
-              regval = stm32l4_getreg(STM32L4_OTGFS_HNPTXSTS);
-              avail  = ((regval & OTGFS_HNPTXSTS_NPTXFSAV_MASK) >> OTGFS_HNPTXSTS_NPTXFSAV_SHIFT) << 2;
-            }
-            break;
-
-          /* Periodic transfer */
-
-          case OTGFS_EPTYPE_INTR:
-          case OTGFS_EPTYPE_ISOC:
-            {
-              /* Read the Non-periodic Tx FIFO status register */
-
-              regval = stm32l4_getreg(STM32L4_OTGFS_HPTXSTS);
-              avail  = ((regval & OTGFS_HPTXSTS_PTXFSAVL_MASK) >> OTGFS_HPTXSTS_PTXFSAVL_SHIFT) << 2;
-            }
-            break;
-
-          default:
-            DEBUGASSERT(false);
-            return;
-        }
-
-      /* Is there space in the TxFIFO to hold the minimum size packet? */
-
-      if (minsize <= avail)
-        {
-          /* Yes.. Get the size of the biggest thing that we can put in the Tx FIFO now */
-
-          wrsize = chan->buflen;
-          if (wrsize > avail)
-            {
-              /* Clip the write size to the number of full, max sized packets
-               * that will fit in the Tx FIFO.
-               */
-
-              unsigned int wrpackets = avail / chan->maxpacket;
-              wrsize = wrpackets * chan->maxpacket;
-            }
-
-          /* Write packet into the Tx FIFO. */
-
-          stm32l4_gint_wrpacket(priv, chan->buffer, chidx, wrsize);
-        }
-
-      /* Did we put the entire buffer into the Tx FIFO? */
-
-      if (chan->buflen > avail)
-        {
-          /* No, there was insufficient space to hold the entire transfer ...
-           * Enable the Tx FIFO interrupt to handle the transfer when the Tx
-           * FIFO becomes empty.
-           */
-
-          stm32l4_txfe_enable(priv, chidx);
-        }
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_getframe
- *
- * Description:
- *   Get the current frame number.  The frame number (FRNUM) field increments
- *   when a new SOF is transmitted on the USB, and is cleared to 0 when it
- *   reaches 0x3fff.
- *
- ****************************************************************************/
-
-#if 0 /* Not used */
-static inline uint16_t stm32l4_getframe(void)
-{
-  return (uint16_t)(stm32l4_getreg(STM32L4_OTGFS_HFNUM) & OTGFS_HFNUM_FRNUM_MASK);
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_ctrl_sendsetup
- *
- * Description:
- *   Send an IN/OUT SETUP packet.
- *
- ****************************************************************************/
-
-static int stm32l4_ctrl_sendsetup(FAR struct stm32l4_usbhost_s *priv,
-                                  FAR struct stm32l4_ctrlinfo_s *ep0,
-                                  FAR const struct usb_ctrlreq_s *req)
-{
-  FAR struct stm32l4_chan_s *chan;
-  systime_t start;
-  systime_t elapsed;
-  int ret;
-
-  /* Loop while the device reports NAK (and a timeout is not exceeded */
-
-  chan  = &priv->chan[ep0->outndx];
-  start = clock_systimer();
-
-  do
-    {
-      /* Send the  SETUP packet */
-
-      chan->pid    = OTGFS_PID_SETUP;
-      chan->buffer = (FAR uint8_t *)req;
-      chan->buflen = USB_SIZEOF_CTRLREQ;
-      chan->xfrd   = 0;
-
-      /* Set up for the wait BEFORE starting the transfer */
-
-      ret = stm32l4_chan_waitsetup(priv, chan);
-      if (ret < 0)
-        {
-          usbhost_trace1(OTGFS_TRACE1_DEVDISCONN, 0);
-          return ret;
-        }
-
-      /* Start the transfer */
-
-      stm32l4_transfer_start(priv, ep0->outndx);
-
-      /* Wait for the transfer to complete */
-
-      ret = stm32l4_chan_wait(priv, chan);
-
-      /* Return on success and for all failures other than EAGAIN.  EAGAIN
-       * means that the device NAKed the SETUP command and that we should
-       * try a few more times.
-       */
-
-      if (ret != -EAGAIN)
-        {
-          /* Output some debug information if the transfer failed */
-
-          if (ret < 0)
-            {
-              usbhost_trace1(OTGFS_TRACE1_TRNSFRFAILED, ret);
-            }
-
-          /* Return the result in any event */
-
-          return ret;
-        }
-
-      /* Get the elapsed time (in frames) */
-
-      elapsed = clock_systimer() - start;
-    }
-  while (elapsed < STM32L4_SETUP_DELAY);
-
-  return -ETIMEDOUT;
-}
-
-/****************************************************************************
- * Name: stm32l4_ctrl_senddata
- *
- * Description:
- *   Send data in the data phase of an OUT control transfer.  Or send status
- *   in the status phase of an IN control transfer
- *
- ****************************************************************************/
-
-static int stm32l4_ctrl_senddata(FAR struct stm32l4_usbhost_s *priv,
-                                 FAR struct stm32l4_ctrlinfo_s *ep0,
-                                 FAR uint8_t *buffer, unsigned int buflen)
-{
-  FAR struct stm32l4_chan_s *chan = &priv->chan[ep0->outndx];
-  int ret;
-
-  /* Save buffer information */
-
-  chan->buffer = buffer;
-  chan->buflen = buflen;
-  chan->xfrd   = 0;
-
-  /* Set the DATA PID */
-
-  if (buflen == 0)
-    {
-      /* For status OUT stage with buflen == 0, set PID DATA1 */
-
-      chan->outdata1 = true;
-    }
-
-  /* Set the Data PID as per the outdata1 boolean */
-
-  chan->pid = chan->outdata1 ? OTGFS_PID_DATA1 : OTGFS_PID_DATA0;
-
-  /* Set up for the wait BEFORE starting the transfer */
-
-  ret = stm32l4_chan_waitsetup(priv, chan);
-  if (ret < 0)
-    {
-      usbhost_trace1(OTGFS_TRACE1_DEVDISCONN, 0);
-      return ret;
-    }
-
-  /* Start the transfer */
-
-  stm32l4_transfer_start(priv, ep0->outndx);
-
-  /* Wait for the transfer to complete and return the result */
-
-  return stm32l4_chan_wait(priv, chan);
-}
-
-/****************************************************************************
- * Name: stm32l4_ctrl_recvdata
- *
- * Description:
- *   Receive data in the data phase of an IN control transfer.  Or receive status
- *   in the status phase of an OUT control transfer
- *
- ****************************************************************************/
-
-static int stm32l4_ctrl_recvdata(FAR struct stm32l4_usbhost_s *priv,
-                                 FAR struct stm32l4_ctrlinfo_s *ep0,
-                                 FAR uint8_t *buffer, unsigned int buflen)
-{
-  FAR struct stm32l4_chan_s *chan = &priv->chan[ep0->inndx];
-  int ret;
-
-  /* Save buffer information */
-
-  chan->pid    = OTGFS_PID_DATA1;
-  chan->buffer = buffer;
-  chan->buflen = buflen;
-  chan->xfrd   = 0;
-
-  /* Set up for the wait BEFORE starting the transfer */
-
-  ret = stm32l4_chan_waitsetup(priv, chan);
-  if (ret < 0)
-    {
-      usbhost_trace1(OTGFS_TRACE1_DEVDISCONN, 0);
-      return ret;
-    }
-
-  /* Start the transfer */
-
-  stm32l4_transfer_start(priv, ep0->inndx);
-
-  /* Wait for the transfer to complete and return the result */
-
-  return stm32l4_chan_wait(priv, chan);
-}
-
-/****************************************************************************
- * Name: stm32l4_in_setup
- *
- * Description:
- *   Initiate an IN transfer on an bulk, interrupt, or isochronous pipe.
- *
- ****************************************************************************/
-
-static int stm32l4_in_setup(FAR struct stm32l4_usbhost_s *priv, int chidx)
-{
-  FAR struct stm32l4_chan_s *chan;
-
-  /* Set up for the transfer based on the direction and the endpoint type */
-
-  chan = &priv->chan[chidx];
-  switch (chan->eptype)
-    {
-      default:
-      case OTGFS_EPTYPE_CTRL: /* Control */
-        {
-          /* This kind of transfer on control endpoints other than EP0 are not
-           * currently supported
-           */
-
-          return -ENOSYS;
-        }
-
-      case OTGFS_EPTYPE_ISOC: /* Isochronous */
-        {
-          /* Set up the IN data PID */
-
-          usbhost_vtrace2(OTGFS_VTRACE2_ISOCIN, chidx, chan->buflen);
-          chan->pid = OTGFS_PID_DATA0;
-        }
-        break;
-
-      case OTGFS_EPTYPE_BULK: /* Bulk */
-        {
-          /* Setup the IN data PID */
-
-          usbhost_vtrace2(OTGFS_VTRACE2_BULKIN, chidx, chan->buflen);
-          chan->pid = chan->indata1 ? OTGFS_PID_DATA1 : OTGFS_PID_DATA0;
-        }
-        break;
-
-      case OTGFS_EPTYPE_INTR: /* Interrupt */
-        {
-          /* Setup the IN data PID */
-
-          usbhost_vtrace2(OTGFS_VTRACE2_INTRIN, chidx, chan->buflen);
-          chan->pid = chan->indata1 ? OTGFS_PID_DATA1 : OTGFS_PID_DATA0;
-        }
-        break;
-    }
-
-  /* Start the transfer */
-
-  stm32l4_transfer_start(priv, chidx);
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_in_transfer
- *
- * Description:
- *   Transfer 'buflen' bytes into 'buffer' from an IN channel.
- *
- ****************************************************************************/
-
-static ssize_t stm32l4_in_transfer(FAR struct stm32l4_usbhost_s *priv,
-                                   int chidx, FAR uint8_t *buffer,
-                                   size_t buflen)
-{
-  FAR struct stm32l4_chan_s *chan;
-  systime_t start;
-  ssize_t xfrd;
-  int ret;
-
-  /* Loop until the transfer completes (i.e., buflen is decremented to zero)
-   * or a fatal error occurs any error other than a simple NAK.  NAK would
-   * simply indicate the end of the transfer (short-transfer).
-   */
-
-  chan         = &priv->chan[chidx];
-  chan->buffer = buffer;
-  chan->buflen = buflen;
-  chan->xfrd   = 0;
-  xfrd         = 0;
-
-  start = clock_systimer();
-  while (chan->xfrd < chan->buflen)
-    {
-      /* Set up for the wait BEFORE starting the transfer */
-
-      ret = stm32l4_chan_waitsetup(priv, chan);
-      if (ret < 0)
-        {
-          usbhost_trace1(OTGFS_TRACE1_DEVDISCONN, 0);
-          return (ssize_t)ret;
-        }
-
-      /* Set up for the transfer based on the direction and the endpoint type */
-
-      ret = stm32l4_in_setup(priv, chidx);
-      if (ret < 0)
-        {
-          uerr("ERROR: stm32l4_in_setup failed: %d\n", ret);
-          return (ssize_t)ret;
-        }
-
-      /* Wait for the transfer to complete and get the result */
-
-      ret = stm32l4_chan_wait(priv, chan);
-
-      /* EAGAIN indicates that the device NAKed the transfer. */
-
-      if (ret < 0)
-        {
-          /* The transfer failed.  If we received a NAK, return all data
-           * buffered so far (if any).
-           */
-
-          if (ret == -EAGAIN)
-            {
-              /* Was data buffered prior to the NAK? */
-
-              if (xfrd > 0)
-                {
-                  /* Yes, return the amount of data received.
-                   *
-                   * REVISIT: This behavior is clearly correct for CDC/ACM
-                   * bulk transfers and HID interrupt transfers.  But I am
-                   * not so certain for MSC bulk transfers which, I think,
-                   * could have NAKed packets in the middle of a transfer.
-                   */
-
-                  return xfrd;
-                }
-              else
-                {
-                  useconds_t delay;
-
-                  /* Get the elapsed time.  Has the timeout elapsed?
-                   * if not then try again.
-                   */
-
-                  systime_t elapsed = clock_systimer() - start;
-                  if (elapsed >= STM32L4_DATANAK_DELAY)
-                    {
-                      /* Timeout out... break out returning the NAK as
-                       * as a failure.
-                       */
-
-                      return (ssize_t)ret;
-                    }
-
-                  /* Wait a bit before retrying after a NAK. */
-
-                  if (chan->eptype == OTGFS_HCCHAR_EPTYP_INTR)
-                    {
-                      /* For interrupt (and isochronous) endpoints, the
-                       * polling rate is determined by the bInterval field
-                       * of the endpoint descriptor (in units of frames
-                       * which we treat as milliseconds here).
-                       */
-
-                      if (chan->interval > 0)
-                        {
-                          /* Convert the delay to units of microseconds */
-
-                          delay = (useconds_t)chan->interval * 1000;
-                        }
-                      else
-                        {
-                          /* Out of range! For interrupt endpoints, the valid
-                           * range is 1-255 frames.  Assume one frame.
-                           */
-
-                          delay = 1000;
-                        }
-                    }
-                  else
-                    {
-                      /* For Isochronous endpoints, bInterval must be 1.  Bulk
-                       * endpoints do not have a polling interval.  Rather,
-                       * the should wait until data is received.
-                       *
-                       * REVISIT:  For bulk endpoints this 1 msec delay is only
-                       * intended to give the CPU a break from the bulk EP tight
-                       * polling loop.  But are there performance issues?
-                       */
-
-                      delay = 1000;
-                    }
-
-                  /* Wait for the next polling interval.
-                   *
-                   * REVISIT:  This delay could require more resolution than
-                   * is provided by the system timer.  In that case, the
-                   * delay could be significantly longer than required.
-                   */
-
-                  usleep(delay);
-                }
-            }
-          else
-            {
-              /* Some unexpected, fatal error occurred. */
-
-              usbhost_trace1(OTGFS_TRACE1_TRNSFRFAILED, ret);
-
-              /* Break out and return the error */
-
-              uerr("ERROR: stm32l4_chan_wait failed: %d\n", ret);
-              return (ssize_t)ret;
-            }
-        }
-      else
-        {
-          /* Successfully received another chunk of data... add that to the
-           * runing total.  Then continue reading until we read 'buflen'
-           * bytes of data or until the the devices NAKs (implying a short
-           * packet).
-           */
-
-          xfrd += chan->xfrd;
-        }
-    }
-
-  return xfrd;
-}
-
-/****************************************************************************
- * Name: stm32l4_in_next
- *
- * Description:
- *   Initiate the next of a sequence of asynchronous transfers.
- *
- * Assumptions:
- *   This function is always called from an interrupt handler
- *
- ****************************************************************************/
-
-#ifdef CONFIG_USBHOST_ASYNCH
-static void stm32l4_in_next(FAR struct stm32l4_usbhost_s *priv,
-                            FAR struct stm32l4_chan_s *chan)
-{
-  usbhost_asynch_t callback;
-  FAR void *arg;
-  ssize_t nbytes;
-  int result;
-  int ret;
-
-  /* Is the full transfer complete? Did the last chunk transfer complete OK? */
-
-  result = -(int)chan->result;
-  if (chan->xfrd < chan->buflen && result == OK)
-    {
-      /* Yes.. Set up for the next transfer based on the direction and the
-       * endpoint type
-       */
-
-      ret = stm32l4_in_setup(priv, chan->chidx);
-      if (ret >= 0)
-        {
-          return;
-        }
-
-      uerr("ERROR: stm32l4_in_setup failed: %d\n", ret);
-      result = ret;
-    }
-
-  /* The transfer is complete, with or without an error */
-
-  uvdbg("Transfer complete:  %d\n", result);
-
-  /* Extract the callback information */
-
-  callback       = chan->callback;
-  arg            = chan->arg;
-  nbytes         = chan->xfrd;
-
-  chan->callback = NULL;
-  chan->arg      = NULL;
-  chan->xfrd     = 0;
-
-  /* Then perform the callback */
-
-  if (result < 0)
-    {
-      nbytes = (ssize_t)result;
-    }
-
-  callback(arg, nbytes);
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_in_asynch
- *
- * Description:
- *   Initiate the first of a sequence of asynchronous transfers.
- *
- * Assumptions:
- *   This function is never called from an interrupt handler
- *
- ****************************************************************************/
-
-#ifdef CONFIG_USBHOST_ASYNCH
-static int stm32l4_in_asynch(FAR struct stm32l4_usbhost_s *priv, int chidx,
-                             FAR uint8_t *buffer, size_t buflen,
-                             usbhost_asynch_t callback, FAR void *arg)
-{
-  FAR struct stm32l4_chan_s *chan;
-  int ret;
-
-  /* Set up for the transfer data and callback BEFORE starting the first transfer */
-
-  chan         = &priv->chan[chidx];
-  chan->buffer = buffer;
-  chan->buflen = buflen;
-  chan->xfrd   = 0;
-
-  ret = stm32l4_chan_asynchsetup(priv, chan, callback, arg);
-  if (ret < 0)
-    {
-      uerr("ERROR: stm32l4_chan_asynchsetup failed: %d\n", ret);
-      return ret;
-    }
-
-  /* Set up for the transfer based on the direction and the endpoint type */
-
-  ret = stm32l4_in_setup(priv, chidx);
-  if (ret < 0)
-    {
-      uerr("ERROR: stm32l4_in_setup failed: %d\n", ret);
-    }
-
-  /* And return with the transfer pending */
-
-  return ret;
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_out_setup
- *
- * Description:
- *   Initiate an OUT transfer on an bulk, interrupt, or isochronous pipe.
- *
- ****************************************************************************/
-
-static int stm32l4_out_setup(FAR struct stm32l4_usbhost_s *priv, int chidx)
-{
-  FAR struct stm32l4_chan_s *chan;
-
-  /* Set up for the transfer based on the direction and the endpoint type */
-
-  chan = &priv->chan[chidx];
-  switch (chan->eptype)
-    {
-      default:
-      case OTGFS_EPTYPE_CTRL: /* Control */
-        {
-          /* This kind of transfer on control endpoints other than EP0 are not
-           * currently supported
-           */
-
-          return -ENOSYS;
-        }
-
-      case OTGFS_EPTYPE_ISOC: /* Isochronous */
-        {
-          /* Set up the OUT data PID */
-
-          usbhost_vtrace2(OTGFS_VTRACE2_ISOCOUT, chidx, chan->buflen);
-          chan->pid = OTGFS_PID_DATA0;
-        }
-        break;
-
-      case OTGFS_EPTYPE_BULK: /* Bulk */
-        {
-          /* Setup the OUT data PID */
-
-          usbhost_vtrace2(OTGFS_VTRACE2_BULKOUT, chidx, chan->buflen);
-          chan->pid = chan->outdata1 ? OTGFS_PID_DATA1 : OTGFS_PID_DATA0;
-        }
-        break;
-
-      case OTGFS_EPTYPE_INTR: /* Interrupt */
-        {
-          /* Setup the OUT data PID */
-
-          usbhost_vtrace2(OTGFS_VTRACE2_INTROUT, chidx, chan->buflen);
-          chan->pid = chan->outdata1 ? OTGFS_PID_DATA1 : OTGFS_PID_DATA0;
-
-          /* Toggle the OUT data PID for the next transfer */
-
-          chan->outdata1 ^= true;
-        }
-        break;
-    }
-
-  /* Start the transfer */
-
-  stm32l4_transfer_start(priv, chidx);
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_out_transfer
- *
- * Description:
- *   Transfer the 'buflen' bytes in 'buffer' through an OUT channel.
- *
- ****************************************************************************/
-
-static ssize_t stm32l4_out_transfer(FAR struct stm32l4_usbhost_s *priv,
-                                    int chidx, FAR uint8_t *buffer,
-                                    size_t buflen)
-{
-  FAR struct stm32l4_chan_s *chan;
-  systime_t start;
-  systime_t elapsed;
-  size_t xfrlen;
-  ssize_t xfrd;
-  int ret;
-
-  /* Loop until the transfer completes (i.e., buflen is decremented to zero)
-   * or a fatal error occurs (any error other than a simple NAK)
-   */
-
-  chan  = &priv->chan[chidx];
-  start = clock_systimer();
-  xfrd  = 0;
-
-  while (buflen > 0)
-    {
-      /* Transfer one packet at a time.  The hardware is capable of queueing
-       * multiple OUT packets, but I just haven't figured out how to handle
-       * the case where a single OUT packet in the group is NAKed.
-       */
-
-      xfrlen       = MIN(chan->maxpacket, buflen);
-      chan->buffer = buffer;
-      chan->buflen = xfrlen;
-      chan->xfrd   = 0;
-
-      /* Set up for the wait BEFORE starting the transfer */
-
-      ret = stm32l4_chan_waitsetup(priv, chan);
-      if (ret < 0)
-        {
-          usbhost_trace1(OTGFS_TRACE1_DEVDISCONN, 0);
-          return (ssize_t)ret;
-        }
-
-      /* Set up for the transfer based on the direction and the endpoint type */
-
-      ret = stm32l4_out_setup(priv, chidx);
-      if (ret < 0)
-        {
-          uerr("ERROR: stm32l4_out_setup failed: %d\n", ret);
-          return (ssize_t)ret;
-        }
-
-      /* Wait for the transfer to complete and get the result */
-
-      ret = stm32l4_chan_wait(priv, chan);
-
-      /* Handle transfer failures */
-
-      if (ret < 0)
-        {
-          usbhost_trace1(OTGFS_TRACE1_TRNSFRFAILED, ret);
-
-          /* Check for a special case:  If (1) the transfer was NAKed and (2)
-           * no Tx FIFO empty or Rx FIFO not-empty event occurred, then we
-           * should be able to just flush the Rx and Tx FIFOs and try again.
-           * We can detect this latter case because the then the transfer
-           * buffer pointer and buffer size will be unaltered.
-           */
-
-          elapsed = clock_systimer() - start;
-          if (ret != -EAGAIN ||                  /* Not a NAK condition OR */
-              elapsed >= STM32L4_DATANAK_DELAY ||  /* Timeout has elapsed OR */
-              chan->xfrd > 0)                    /* Data has been partially transferred */
-            {
-              /* Break out and return the error */
-
-              uerr("ERROR: stm32l4_chan_wait failed: %d\n", ret);
-              return (ssize_t)ret;
-            }
-
-          /* Is this flush really necessary? What does the hardware do with the
-           * data in the FIFO when the NAK occurs?  Does it discard it?
-           */
-
-          stm32l4_flush_txfifos(OTGFS_GRSTCTL_TXFNUM_HALL);
-
-          /* Get the device a little time to catch up.  Then retry the transfer
-           * using the same buffer pointer and length.
-           */
-
-          usleep(20 * 1000);
-        }
-      else
-        {
-          /* Successfully transferred.  Update the buffer pointer and length */
-
-          buffer += xfrlen;
-          buflen -= xfrlen;
-          xfrd   += chan->xfrd;
-        }
-    }
-
-  return xfrd;
-}
-
-/****************************************************************************
- * Name: stm32l4_out_next
- *
- * Description:
- *   Initiate the next of a sequence of asynchronous transfers.
- *
- * Assumptions:
- *   This function is always called from an interrupt handler
- *
- ****************************************************************************/
-
-#ifdef CONFIG_USBHOST_ASYNCH
-static void stm32l4_out_next(FAR struct stm32l4_usbhost_s *priv,
-                             FAR struct stm32l4_chan_s *chan)
-{
-  usbhost_asynch_t callback;
-  FAR void *arg;
-  ssize_t nbytes;
-  int result;
-  int ret;
-
-  /* Is the full transfer complete? Did the last chunk transfer complete OK? */
-
-  result = -(int)chan->result;
-  if (chan->xfrd < chan->buflen && result == OK)
-    {
-      /* Yes.. Set up for the next transfer based on the direction and the
-       * endpoint type
-       */
-
-      ret = stm32l4_out_setup(priv, chan->chidx);
-      if (ret >= 0)
-        {
-          return;
-        }
-
-      uerr("ERROR: stm32l4_out_setup failed: %d\n", ret);
-      result = ret;
-    }
-
-  /* The transfer is complete, with or without an error */
-
-  uvdbg("Transfer complete:  %d\n", result);
-
-  /* Extract the callback information */
-
-  callback       = chan->callback;
-  arg            = chan->arg;
-  nbytes         = chan->xfrd;
-
-  chan->callback = NULL;
-  chan->arg      = NULL;
-  chan->xfrd     = 0;
-
-  /* Then perform the callback */
-
-  if (result < 0)
-    {
-      nbytes = (ssize_t)result;
-    }
-
-  callback(arg, nbytes);
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_out_asynch
- *
- * Description:
- *   Initiate the first of a sequence of asynchronous transfers.
- *
- * Assumptions:
- *   This function is never called from an interrupt handler
- *
- ****************************************************************************/
-
-#ifdef CONFIG_USBHOST_ASYNCH
-static int stm32l4_out_asynch(FAR struct stm32l4_usbhost_s *priv, int chidx,
-                              FAR uint8_t *buffer, size_t buflen,
-                              usbhost_asynch_t callback, FAR void *arg)
-{
-  FAR struct stm32l4_chan_s *chan;
-  int ret;
-
-  /* Set up for the transfer data and callback BEFORE starting the first transfer */
-
-  chan         = &priv->chan[chidx];
-  chan->buffer = buffer;
-  chan->buflen = buflen;
-  chan->xfrd   = 0;
-
-  ret = stm32l4_chan_asynchsetup(priv, chan, callback, arg);
-  if (ret < 0)
-    {
-      uerr("ERROR: stm32l4_chan_asynchsetup failed: %d\n", ret);
-      return ret;
-    }
-
-  /* Set up for the transfer based on the direction and the endpoint type */
-
-  ret = stm32l4_out_setup(priv, chidx);
-  if (ret < 0)
-    {
-      uerr("ERROR: stm32l4_out_setup failed: %d\n", ret);
-    }
-
-  /* And return with the transfer pending */
-
-  return ret;
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_gint_wrpacket
- *
- * Description:
- *   Transfer the 'buflen' bytes in 'buffer' to the Tx FIFO associated with
- *   'chidx' (non-DMA).
- *
- ****************************************************************************/
-
-static void stm32l4_gint_wrpacket(FAR struct stm32l4_usbhost_s *priv,
-                                  FAR uint8_t *buffer, int chidx, int buflen)
-{
-  FAR uint32_t *src;
-  uint32_t fifo;
-  int buflen32;
-
-  stm32l4_pktdump("Sending", buffer, buflen);
-
-  /* Get the number of 32-byte words associated with this byte size */
-
-  buflen32 = (buflen + 3) >> 2;
-
-  /* Get the address of the Tx FIFO associated with this channel */
-
-  fifo = STM32L4_OTGFS_DFIFO_HCH(chidx);
-
-  /* Transfer all of the data into the Tx FIFO */
-
-  src = (FAR uint32_t *)buffer;
-  for (; buflen32 > 0; buflen32--)
-    {
-      uint32_t data = *src++;
-      stm32l4_putreg(fifo, data);
-    }
-
-  /* Increment the count of bytes "in-flight" in the Tx FIFO */
-
-  priv->chan[chidx].inflight += buflen;
-}
-
-/****************************************************************************
- * Name: stm32l4_gint_hcinisr
- *
- * Description:
- *   USB OTG FS host IN channels interrupt handler
- *
- *   One the completion of the transfer, the channel result byte may be set as
- *   follows:
- *
- *     OK     - Transfer completed successfully
- *     EAGAIN - If devices NAKs the transfer or NYET occurs
- *     EPERM  - If the endpoint stalls
- *     EIO    - On a TX or data toggle error
- *     EPIPE  - Frame overrun
- *
- *   EBUSY in the result field indicates that the transfer has not completed.
- *
- ****************************************************************************/
-
-static inline void stm32l4_gint_hcinisr(FAR struct stm32l4_usbhost_s *priv,
-                                        int chidx)
-{
-  FAR struct stm32l4_chan_s *chan = &priv->chan[chidx];
-  uint32_t regval;
-  uint32_t pending;
-
-  /* Read the HCINT register to get the pending HC interrupts.  Read the
-   * HCINTMSK register to get the set of enabled HC interrupts.
-   */
-
-  pending = stm32l4_getreg(STM32L4_OTGFS_HCINT(chidx));
-  regval  = stm32l4_getreg(STM32L4_OTGFS_HCINTMSK(chidx));
-
-  /* AND the two to get the set of enabled, pending HC interrupts */
-
-  pending &= regval;
-  uinfo("HCINTMSK%d: %08x pending: %08x\n", chidx, regval, pending);
-
-  /* Check for a pending ACK response received/transmitted (ACK) interrupt */
-
-  if ((pending & OTGFS_HCINT_ACK) != 0)
-    {
-      /* Clear the pending the ACK response received/transmitted (ACK) interrupt */
-
-      stm32l4_putreg(STM32L4_OTGFS_HCINT(chidx), OTGFS_HCINT_ACK);
-    }
-
-  /* Check for a pending STALL response receive (STALL) interrupt */
-
-  else if ((pending & OTGFS_HCINT_STALL) != 0)
-    {
-      /* Clear the NAK and STALL Conditions. */
-
-      stm32l4_putreg(STM32L4_OTGFS_HCINT(chidx), (OTGFS_HCINT_NAK | OTGFS_HCINT_STALL));
-
-      /* Halt the channel when a STALL, TXERR, BBERR or DTERR interrupt is
-       * received on the channel.
-       */
-
-      stm32l4_chan_halt(priv, chidx, CHREASON_STALL);
-
-      /* When there is a STALL, clear any pending NAK so that it is not
-       * processed below.
-       */
-
-      pending &= ~OTGFS_HCINT_NAK;
-    }
-
-  /* Check for a pending Data Toggle ERRor (DTERR) interrupt */
-
-  else if ((pending & OTGFS_HCINT_DTERR) != 0)
-    {
-      /* Halt the channel when a STALL, TXERR, BBERR or DTERR interrupt is
-       * received on the channel.
-       */
-
-      stm32l4_chan_halt(priv, chidx, CHREASON_DTERR);
-
-      /* Clear the NAK and data toggle error conditions */
-
-      stm32l4_putreg(STM32L4_OTGFS_HCINT(chidx), (OTGFS_HCINT_NAK | OTGFS_HCINT_DTERR));
-    }
-
-  /* Check for a pending FRaMe OverRun (FRMOR) interrupt */
-
-  if ((pending & OTGFS_HCINT_FRMOR) != 0)
-    {
-      /* Halt the channel -- the CHH interrupt is expected next */
-
-      stm32l4_chan_halt(priv, chidx, CHREASON_FRMOR);
-
-      /* Clear the FRaMe OverRun (FRMOR) condition */
-
-      stm32l4_putreg(STM32L4_OTGFS_HCINT(chidx), OTGFS_HCINT_FRMOR);
-    }
-
-  /* Check for a pending TransFeR Completed (XFRC) interrupt */
-
-  else if ((pending & OTGFS_HCINT_XFRC) != 0)
-    {
-      /* Clear the TransFeR Completed (XFRC) condition */
-
-      stm32l4_putreg(STM32L4_OTGFS_HCINT(chidx), OTGFS_HCINT_XFRC);
-
-      /* Then handle the transfer completion event based on the endpoint type */
-
-      if (chan->eptype == OTGFS_EPTYPE_CTRL || chan->eptype == OTGFS_EPTYPE_BULK)
-        {
-          /* Halt the channel -- the CHH interrupt is expected next */
-
-          stm32l4_chan_halt(priv, chidx, CHREASON_XFRC);
-
-          /* Clear any pending NAK condition.  The 'indata1' data toggle
-           * should have been appropriately updated by the RxFIFO
-           * logic as each packet was received.
-           */
-
-          stm32l4_putreg(STM32L4_OTGFS_HCINT(chidx), OTGFS_HCINT_NAK);
-        }
-      else if (chan->eptype == OTGFS_EPTYPE_INTR)
-        {
-          /* Force the next transfer on an ODD frame */
-
-          regval = stm32l4_getreg(STM32L4_OTGFS_HCCHAR(chidx));
-          regval |= OTGFS_HCCHAR_ODDFRM;
-          stm32l4_putreg(STM32L4_OTGFS_HCCHAR(chidx), regval);
-
-          /* Set the request done state */
-
-          chan->result = OK;
-        }
-    }
-
-  /* Check for a pending CHannel Halted (CHH) interrupt */
-
-  else if ((pending & OTGFS_HCINT_CHH) != 0)
-    {
-      /* Mask the CHannel Halted (CHH) interrupt */
-
-      regval  = stm32l4_getreg(STM32L4_OTGFS_HCINTMSK(chidx));
-      regval &= ~OTGFS_HCINT_CHH;
-      stm32l4_putreg(STM32L4_OTGFS_HCINTMSK(chidx), regval);
-
-      /* Update the request state based on the host state machine state */
-
-      if (chan->chreason == CHREASON_XFRC)
-        {
-          /* Set the request done result */
-
-          chan->result = OK;
-        }
-      else if (chan->chreason == CHREASON_STALL)
-        {
-          /* Set the request stall result */
-
-          chan->result = EPERM;
-        }
-      else if ((chan->chreason == CHREASON_TXERR) ||
-               (chan->chreason == CHREASON_DTERR))
-        {
-          /* Set the request I/O error result */
-
-          chan->result = EIO;
-        }
-      else if (chan->chreason == CHREASON_NAK)
-        {
-          /* Set the NAK error result */
-
-          chan->result = EAGAIN;
-        }
-      else /* if (chan->chreason == CHREASON_FRMOR) */
-        {
-          /* Set the frame overrun error result */
-
-          chan->result = EPIPE;
-        }
-
-      /* Clear the CHannel Halted (CHH) condition */
-
-      stm32l4_putreg(STM32L4_OTGFS_HCINT(chidx), OTGFS_HCINT_CHH);
-    }
-
-  /* Check for a pending Transaction ERror (TXERR) interrupt */
-
-  else if ((pending & OTGFS_HCINT_TXERR) != 0)
-    {
-      /* Halt the channel when a STALL, TXERR, BBERR or DTERR interrupt is
-       * received on the channel.
-       */
-
-      stm32l4_chan_halt(priv, chidx, CHREASON_TXERR);
-
-      /* Clear the Transaction ERror (TXERR) condition */
-
-      stm32l4_putreg(STM32L4_OTGFS_HCINT(chidx), OTGFS_HCINT_TXERR);
-    }
-
-  /* Check for a pending NAK response received (NAK) interrupt */
-
-  else if ((pending & OTGFS_HCINT_NAK) != 0)
-    {
-      /* For a BULK transfer, the hardware is capable of retrying
-       * automatically on a NAK.  However, this is not always
-       * what we need to do.  So we always halt the transfer and
-       * return control to high level logic in the event of a NAK.
-       */
-
-#if 1
-      /* Halt the interrupt channel */
-
-      if (chan->eptype == OTGFS_EPTYPE_INTR ||
-          chan->eptype == OTGFS_EPTYPE_BULK)
-        {
-          /* Halt the channel -- the CHH interrupt is expected next */
-
-          stm32l4_chan_halt(priv, chidx, CHREASON_NAK);
-        }
-
-      /* Re-activate CTRL and BULK channels.
-       * REVISIT: This can cause a lot of interrupts!
-       */
-
-      else if (chan->eptype == OTGFS_EPTYPE_CTRL /*||
-               chan->eptype == OTGFS_EPTYPE_BULK*/)
-        {
-          /* Re-activate the channel by clearing CHDIS and assuring that
-           * CHENA is set
-           *
-           * TODO: set channel reason to NACK?
-           */
-
-          regval  = stm32l4_getreg(STM32L4_OTGFS_HCCHAR(chidx));
-          regval |= OTGFS_HCCHAR_CHENA;
-          regval &= ~OTGFS_HCCHAR_CHDIS;
-          stm32l4_putreg(STM32L4_OTGFS_HCCHAR(chidx), regval);
-        }
-
-#else
-      /* Halt all transfers on the NAK -- the CHH interrupt is expected next */
-
-      stm32l4_chan_halt(priv, chidx, CHREASON_NAK);
-#endif
-
-      /* Clear the NAK condition */
-
-      stm32l4_putreg(STM32L4_OTGFS_HCINT(chidx), OTGFS_HCINT_NAK);
-    }
-
-  /* Check for a transfer complete event */
-
-  stm32l4_chan_wakeup(priv, chan);
-}
-
-/****************************************************************************
- * Name: stm32l4_gint_hcoutisr
- *
- * Description:
- *   USB OTG FS host OUT channels interrupt handler
- *
- *   One the completion of the transfer, the channel result byte may be set as
- *   follows:
- *
- *     OK     - Transfer completed successfully
- *     EAGAIN - If devices NAKs the transfer or NYET occurs
- *     EPERM  - If the endpoint stalls
- *     EIO    - On a TX or data toggle error
- *     EPIPE  - Frame overrun
- *
- *   EBUSY in the result field indicates that the transfer has not completed.
- *
- ****************************************************************************/
-
-static inline void stm32l4_gint_hcoutisr(FAR struct stm32l4_usbhost_s *priv,
-                                         int chidx)
-{
-  FAR struct stm32l4_chan_s *chan = &priv->chan[chidx];
-  uint32_t regval;
-  uint32_t pending;
-
-  /* Read the HCINT register to get the pending HC interrupts.  Read the
-   * HCINTMSK register to get the set of enabled HC interrupts.
-   */
-
-  pending = stm32l4_getreg(STM32L4_OTGFS_HCINT(chidx));
-  regval  = stm32l4_getreg(STM32L4_OTGFS_HCINTMSK(chidx));
-
-  /* AND the two to get the set of enabled, pending HC interrupts */
-
-  pending &= regval;
-  uinfo("HCINTMSK%d: %08x pending: %08x\n", chidx, regval, pending);
-
-  /* Check for a pending ACK response received/transmitted (ACK) interrupt */
-
-  if ((pending & OTGFS_HCINT_ACK) != 0)
-    {
-      /* Clear the pending the ACK response received/transmitted (ACK) interrupt */
-
-      stm32l4_putreg(STM32L4_OTGFS_HCINT(chidx), OTGFS_HCINT_ACK);
-    }
-
-  /* Check for a pending FRaMe OverRun (FRMOR) interrupt */
-
-  else if ((pending & OTGFS_HCINT_FRMOR) != 0)
-    {
-      /* Halt the channel (probably not necessary for FRMOR) */
-
-      stm32l4_chan_halt(priv, chidx, CHREASON_FRMOR);
-
-      /* Clear the pending the FRaMe OverRun (FRMOR) interrupt */
-
-      stm32l4_putreg(STM32L4_OTGFS_HCINT(chidx), OTGFS_HCINT_FRMOR);
-    }
-
-  /* Check for a pending TransFeR Completed (XFRC) interrupt */
-
-  else if ((pending & OTGFS_HCINT_XFRC) != 0)
-    {
-      /* Decrement the number of bytes remaining by the number of
-       * bytes that were "in-flight".
-       */
-
-      priv->chan[chidx].buffer  += priv->chan[chidx].inflight;
-      priv->chan[chidx].xfrd    += priv->chan[chidx].inflight;
-      priv->chan[chidx].inflight = 0;
-
-      /* Halt the channel -- the CHH interrupt is expected next */
-
-      stm32l4_chan_halt(priv, chidx, CHREASON_XFRC);
-
-      /* Clear the pending the TransFeR Completed (XFRC) interrupt */
-
-      stm32l4_putreg(STM32L4_OTGFS_HCINT(chidx), OTGFS_HCINT_XFRC);
-    }
-
-  /* Check for a pending STALL response receive (STALL) interrupt */
-
-  else if ((pending & OTGFS_HCINT_STALL) != 0)
-    {
-      /* Clear the pending the STALL response receiv (STALL) interrupt */
-
-      stm32l4_putreg(STM32L4_OTGFS_HCINT(chidx), OTGFS_HCINT_STALL);
-
-      /* Halt the channel when a STALL, TXERR, BBERR or DTERR interrupt is
-       * received on the channel.
-       */
-
-      stm32l4_chan_halt(priv, chidx, CHREASON_STALL);
-    }
-
-  /* Check for a pending NAK response received (NAK) interrupt */
-
-  else if ((pending & OTGFS_HCINT_NAK) != 0)
-    {
-      /* Halt the channel  -- the CHH interrupt is expected next */
-
-      stm32l4_chan_halt(priv, chidx, CHREASON_NAK);
-
-      /* Clear the pending the NAK response received (NAK) interrupt */
-
-      stm32l4_putreg(STM32L4_OTGFS_HCINT(chidx), OTGFS_HCINT_NAK);
-    }
-
-  /* Check for a pending Transaction ERror (TXERR) interrupt */
-
-  else if ((pending & OTGFS_HCINT_TXERR) != 0)
-    {
-      /* Halt the channel when a STALL, TXERR, BBERR or DTERR interrupt is
-       * received on the channel.
-       */
-
-      stm32l4_chan_halt(priv, chidx, CHREASON_TXERR);
-
-      /* Clear the pending the Transaction ERror (TXERR) interrupt */
-
-      stm32l4_putreg(STM32L4_OTGFS_HCINT(chidx), OTGFS_HCINT_TXERR);
-    }
-
-  /* Check for a NYET interrupt */
-
-#if 0 /* NYET is a reserved bit in the HCINT register */
-  else if ((pending & OTGFS_HCINT_NYET) != 0)
-    {
-      /* Halt the channel */
-
-      stm32l4_chan_halt(priv, chidx, CHREASON_NYET);
-
-      /* Clear the pending the NYET interrupt */
-
-      stm32l4_putreg(STM32L4_OTGFS_HCINT(chidx), OTGFS_HCINT_NYET);
-    }
-#endif
-
-  /* Check for a pending Data Toggle ERRor (DTERR) interrupt */
-
-  else if (pending & OTGFS_HCINT_DTERR)
-    {
-      /* Halt the channel when a STALL, TXERR, BBERR or DTERR interrupt is
-       * received on the channel.
-       */
-
-      stm32l4_chan_halt(priv, chidx, CHREASON_DTERR);
-
-      /* Clear the pending the Data Toggle ERRor (DTERR) and NAK interrupts */
-
-      stm32l4_putreg(STM32L4_OTGFS_HCINT(chidx), (OTGFS_HCINT_DTERR | OTGFS_HCINT_NAK));
-    }
-
-  /* Check for a pending CHannel Halted (CHH) interrupt */
-
-  else if ((pending & OTGFS_HCINT_CHH) != 0)
-    {
-      /* Mask the CHannel Halted (CHH) interrupt */
-
-      regval  = stm32l4_getreg(STM32L4_OTGFS_HCINTMSK(chidx));
-      regval &= ~OTGFS_HCINT_CHH;
-      stm32l4_putreg(STM32L4_OTGFS_HCINTMSK(chidx), regval);
-
-      if (chan->chreason == CHREASON_XFRC)
-        {
-          /* Set the request done result */
-
-          chan->result = OK;
-
-          /* Read the HCCHAR register to get the HCCHAR register to get
-           * the endpoint type.
-           */
-
-          regval = stm32l4_getreg(STM32L4_OTGFS_HCCHAR(chidx));
-
-          /* Is it a bulk endpoint?  Were an odd number of packets
-           * transferred?
-           */
-
-          if ((regval & OTGFS_HCCHAR_EPTYP_MASK) == OTGFS_HCCHAR_EPTYP_BULK &&
-              (chan->npackets & 1) != 0)
-            {
-              /* Yes to both... toggle the data out PID */
-
-              chan->outdata1 ^= true;
-            }
-        }
-      else if (chan->chreason == CHREASON_NAK ||
-               chan->chreason == CHREASON_NYET)
-        {
-          /* Set the try again later result */
-
-          chan->result = EAGAIN;
-        }
-      else if (chan->chreason == CHREASON_STALL)
-        {
-          /* Set the request stall result */
-
-          chan->result = EPERM;
-        }
-      else if ((chan->chreason == CHREASON_TXERR) ||
-               (chan->chreason == CHREASON_DTERR))
-        {
-          /* Set the I/O failure result */
-
-          chan->result = EIO;
-        }
-      else /* if (chan->chreason == CHREASON_FRMOR) */
-        {
-          /* Set the frame error result */
-
-          chan->result = EPIPE;
-        }
-
-      /* Clear the pending the CHannel Halted (CHH) interrupt */
-
-      stm32l4_putreg(STM32L4_OTGFS_HCINT(chidx), OTGFS_HCINT_CHH);
-    }
-
-  /* Check for a transfer complete event */
-
-  stm32l4_chan_wakeup(priv, chan);
-}
-
-/****************************************************************************
- * Name: stm32l4_gint_connected
- *
- * Description:
- *   Handle a connection event.
- *
- ****************************************************************************/
-
-static void stm32l4_gint_connected(FAR struct stm32l4_usbhost_s *priv)
-{
-  /* We we previously disconnected? */
-
-  if (!priv->connected)
-    {
-      /* Yes.. then now we are connected */
-
-      usbhost_vtrace1(OTGFS_VTRACE1_CONNECTED, 0);
-      priv->connected = true;
-      priv->change    = true;
-      DEBUGASSERT(priv->smstate == SMSTATE_DETACHED);
-
-      /* Notify any waiters */
-
-      priv->smstate = SMSTATE_ATTACHED;
-      if (priv->pscwait)
-        {
-          stm32l4_givesem(&priv->pscsem);
-          priv->pscwait = false;
-        }
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_gint_disconnected
- *
- * Description:
- *   Handle a disconnection event.
- *
- ****************************************************************************/
-
-static void stm32l4_gint_disconnected(FAR struct stm32l4_usbhost_s *priv)
-{
-  /* Were we previously connected? */
-
-  if (priv->connected)
-    {
-      /* Yes.. then we no longer connected */
-
-      usbhost_vtrace1(OTGFS_VTRACE1_DISCONNECTED, 0);
-
-      /* Are we bound to a class driver? */
-
-      if (priv->rhport.hport.devclass)
-        {
-          /* Yes.. Disconnect the class driver */
-
-          CLASS_DISCONNECTED(priv->rhport.hport.devclass);
-          priv->rhport.hport.devclass = NULL;
-        }
-
-      /* Re-Initialize Host for new Enumeration */
-
-      priv->smstate   = SMSTATE_DETACHED;
-      priv->connected = false;
-      priv->change    = true;
-      stm32l4_chan_freeall(priv);
-
-      priv->rhport.hport.speed = USB_SPEED_FULL;
-      priv->rhport.hport.funcaddr = 0;
-
-      /* Notify any waiters that there is a change in the connection state */
-
-      if (priv->pscwait)
-        {
-          stm32l4_givesem(&priv->pscsem);
-          priv->pscwait = false;
-        }
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_gint_sofisr
- *
- * Description:
- *   USB OTG FS start-of-frame interrupt handler
- *
- ****************************************************************************/
-
-#ifdef CONFIG_STM32L4_OTGFS_SOFINTR
-static inline void stm32l4_gint_sofisr(FAR struct stm32l4_usbhost_s *priv)
-{
-  /* Handle SOF interrupt */
-#warning "Do what?"
-
-  /* Clear pending SOF interrupt */
-
-  stm32l4_putreg(STM32L4_OTGFS_GINTSTS, OTGFS_GINT_SOF);
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_gint_rxflvlisr
- *
- * Description:
- *   USB OTG FS RxFIFO non-empty interrupt handler
- *
- ****************************************************************************/
-
-static inline void stm32l4_gint_rxflvlisr(FAR struct stm32l4_usbhost_s *priv)
-{
-  FAR uint32_t *dest;
-  uint32_t grxsts;
-  uint32_t intmsk;
-  uint32_t hcchar;
-  uint32_t hctsiz;
-  uint32_t fifo;
-  int bcnt;
-  int bcnt32;
-  int chidx;
-  int i;
-
-  /* Disable the RxFIFO non-empty interrupt */
-
-  intmsk  = stm32l4_getreg(STM32L4_OTGFS_GINTMSK);
-  intmsk &= ~OTGFS_GINT_RXFLVL;
-  stm32l4_putreg(STM32L4_OTGFS_GINTMSK, intmsk);
-
-  /* Read and pop the next status from the Rx FIFO */
-
-  grxsts = stm32l4_getreg(STM32L4_OTGFS_GRXSTSP);
-  uinfo("GRXSTS: %08x\n", grxsts);
-
-  /* Isolate the channel number/index in the status word */
-
-  chidx = (grxsts & OTGFS_GRXSTSH_CHNUM_MASK) >> OTGFS_GRXSTSH_CHNUM_SHIFT;
-
-  /* Get the host channel characteristics register (HCCHAR) for this channel */
-
-  hcchar = stm32l4_getreg(STM32L4_OTGFS_HCCHAR(chidx));
-
-  /* Then process the interrupt according to the packet status */
-
-  switch (grxsts & OTGFS_GRXSTSH_PKTSTS_MASK)
-    {
-      case OTGFS_GRXSTSH_PKTSTS_INRECVD: /* IN data packet received */
-        {
-          /* Read the data into the host buffer. */
-
-          bcnt = (grxsts & OTGFS_GRXSTSH_BCNT_MASK) >> OTGFS_GRXSTSH_BCNT_SHIFT;
-          if (bcnt > 0 && priv->chan[chidx].buffer != NULL)
-            {
-              /* Transfer the packet from the Rx FIFO into the user buffer */
-
-              dest   = (FAR uint32_t *)priv->chan[chidx].buffer;
-              fifo   = STM32L4_OTGFS_DFIFO_HCH(0);
-              bcnt32 = (bcnt + 3) >> 2;
-
-              for (i = 0; i < bcnt32; i++)
-                {
-                  *dest++ = stm32l4_getreg(fifo);
-                }
-
-              stm32l4_pktdump("Received", priv->chan[chidx].buffer, bcnt);
-
-              /* Toggle the IN data pid (Used by Bulk and INTR only) */
-
-              priv->chan[chidx].indata1 ^= true;
-
-              /* Manage multiple packet transfers */
-
-              priv->chan[chidx].buffer += bcnt;
-              priv->chan[chidx].xfrd   += bcnt;
-
-              /* Check if more packets are expected */
-
-              hctsiz = stm32l4_getreg(STM32L4_OTGFS_HCTSIZ(chidx));
-              if ((hctsiz & OTGFS_HCTSIZ_PKTCNT_MASK) != 0)
-                {
-                  /* Re-activate the channel when more packets are expected */
-
-                  hcchar |= OTGFS_HCCHAR_CHENA;
-                  hcchar &= ~OTGFS_HCCHAR_CHDIS;
-                  stm32l4_putreg(STM32L4_OTGFS_HCCHAR(chidx), hcchar);
-                }
-            }
-        }
-        break;
-
-      case OTGFS_GRXSTSH_PKTSTS_INDONE:  /* IN transfer completed */
-      case OTGFS_GRXSTSH_PKTSTS_DTOGERR: /* Data toggle error */
-      case OTGFS_GRXSTSH_PKTSTS_HALTED:  /* Channel halted */
-      default:
-        break;
-    }
-
-  /* Re-enable the RxFIFO non-empty interrupt */
-
-  intmsk |= OTGFS_GINT_RXFLVL;
-  stm32l4_putreg(STM32L4_OTGFS_GINTMSK, intmsk);
-}
-
-/****************************************************************************
- * Name: stm32l4_gint_nptxfeisr
- *
- * Description:
- *   USB OTG FS non-periodic TxFIFO empty interrupt handler
- *
- ****************************************************************************/
-
-static inline void stm32l4_gint_nptxfeisr(FAR struct stm32l4_usbhost_s *priv)
-{
-  FAR struct stm32l4_chan_s *chan;
-  uint32_t     regval;
-  unsigned int wrsize;
-  unsigned int avail;
-  unsigned int chidx;
-
-  /* Recover the index of the channel that is waiting for space in the Tx
-   * FIFO.
-   */
-
-  chidx = priv->chidx;
-  chan  = &priv->chan[chidx];
-
-  /* Reduce the buffer size by the number of bytes that were previously placed
-   * in the Tx FIFO.
-   */
-
-  chan->buffer  += chan->inflight;
-  chan->xfrd    += chan->inflight;
-  chan->inflight = 0;
-
-  /* If we have now transferred the entire buffer, then this transfer is
-   * complete (this case really should never happen because we disable
-   * the NPTXFE interrupt on the final packet).
-   */
-
-  if (chan->xfrd >= chan->buflen)
-    {
-      /* Disable further Tx FIFO empty interrupts and bail. */
-
-      stm32l4_modifyreg(STM32L4_OTGFS_GINTMSK, OTGFS_GINT_NPTXFE, 0);
-      return;
-    }
-
-  /* Read the status from the top of the non-periodic TxFIFO */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_HNPTXSTS);
-
-  /* Extract the number of bytes available in the non-periodic Tx FIFO. */
-
-  avail = ((regval & OTGFS_HNPTXSTS_NPTXFSAV_MASK) >> OTGFS_HNPTXSTS_NPTXFSAV_SHIFT) << 2;
-
-  /* Get the size to put in the Tx FIFO now */
-
-  wrsize = chan->buflen - chan->xfrd;
-
-  /* Get minimal size packet that can be sent.  Something is seriously
-   * configured wrong if one packet will not fit into the empty Tx FIFO.
-   */
-
-  DEBUGASSERT(wrsize > 0 && avail >= MIN(wrsize, chan->maxpacket));
-  if (wrsize > avail)
-    {
-      /* Clip the write size to the number of full, max sized packets
-       * that will fit in the Tx FIFO.
-       */
-
-      unsigned int wrpackets = avail / chan->maxpacket;
-      wrsize = wrpackets * chan->maxpacket;
-    }
-
-  /* Otherwise, this will be the last packet to be sent in this transaction.
-   * We now need to disable further NPTXFE interrupts.
-   */
-
-  else
-    {
-      stm32l4_modifyreg(STM32L4_OTGFS_GINTMSK, OTGFS_GINT_NPTXFE, 0);
-    }
-
-  /* Write the next group of packets into the Tx FIFO */
-
-  uinfo("HNPTXSTS: %08x chidx: %d avail: %d buflen: %d xfrd: %d wrsize: %d\n",
-        regval, chidx, avail, chan->buflen, chan->xfrd, wrsize);
-
-  stm32l4_gint_wrpacket(priv, chan->buffer, chidx, wrsize);
-}
-
-/****************************************************************************
- * Name: stm32l4_gint_ptxfeisr
- *
- * Description:
- *   USB OTG FS periodic TxFIFO empty interrupt handler
- *
- ****************************************************************************/
-
-static inline void stm32l4_gint_ptxfeisr(FAR struct stm32l4_usbhost_s *priv)
-{
-  FAR struct stm32l4_chan_s *chan;
-  uint32_t     regval;
-  unsigned int wrsize;
-  unsigned int avail;
-  unsigned int chidx;
-
-  /* Recover the index of the channel that is waiting for space in the Tx
-   * FIFO.
-   */
-
-  chidx = priv->chidx;
-  chan  = &priv->chan[chidx];
-
-  /* Reduce the buffer size by the number of bytes that were previously placed
-   * in the Tx FIFO.
-   */
-
-  chan->buffer  += chan->inflight;
-  chan->xfrd    += chan->inflight;
-  chan->inflight = 0;
-
-  /* If we have now transfered the entire buffer, then this transfer is
-   * complete (this case really should never happen because we disable
-   * the PTXFE interrupt on the final packet).
-   */
-
-  if (chan->xfrd >= chan->buflen)
-    {
-      /* Disable further Tx FIFO empty interrupts and bail. */
-
-      stm32l4_modifyreg(STM32L4_OTGFS_GINTMSK, OTGFS_GINT_PTXFE, 0);
-      return;
-    }
-
-  /* Read the status from the top of the periodic TxFIFO */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_HPTXSTS);
-
-  /* Extract the number of bytes available in the periodic Tx FIFO. */
-
-  avail = ((regval & OTGFS_HPTXSTS_PTXFSAVL_MASK) >> OTGFS_HPTXSTS_PTXFSAVL_SHIFT) << 2;
-
-  /* Get the size to put in the Tx FIFO now */
-
-  wrsize = chan->buflen - chan->xfrd;
-
-  /* Get minimal size packet that can be sent.  Something is seriously
-   * configured wrong if one packet will not fit into the empty Tx FIFO.
-   */
-
-  DEBUGASSERT(wrsize && avail >= MIN(wrsize, chan->maxpacket));
-  if (wrsize > avail)
-    {
-      /* Clip the write size to the number of full, max sized packets
-       * that will fit in the Tx FIFO.
-       */
-
-      unsigned int wrpackets = avail / chan->maxpacket;
-      wrsize = wrpackets * chan->maxpacket;
-    }
-
-  /* Otherwise, this will be the last packet to be sent in this transaction.
-   * We now need to disable further PTXFE interrupts.
-   */
-
-  else
-    {
-      stm32l4_modifyreg(STM32L4_OTGFS_GINTMSK, OTGFS_GINT_PTXFE, 0);
-    }
-
-  /* Write the next group of packets into the Tx FIFO */
-
-  uinfo("HPTXSTS: %08x chidx: %d avail: %d buflen: %d xfrd: %d wrsize: %d\n",
-        regval, chidx, avail, chan->buflen, chan->xfrd, wrsize);
-
-  stm32l4_gint_wrpacket(priv, chan->buffer, chidx, wrsize);
-}
-
-/****************************************************************************
- * Name: stm32l4_gint_hcisr
- *
- * Description:
- *   USB OTG FS host channels interrupt handler
- *
- ****************************************************************************/
-
-static inline void stm32l4_gint_hcisr(FAR struct stm32l4_usbhost_s *priv)
-{
-  uint32_t haint;
-  uint32_t hcchar;
-  int i = 0;
-
-  /* Read the Host all channels interrupt register and test each bit in the
-   * register. Each bit i, i=0...(STM32L4_NHOST_CHANNELS-1), corresponds to
-   * a pending interrupt on channel i.
-   */
-
-  haint = stm32l4_getreg(STM32L4_OTGFS_HAINT);
-  for (i = 0; i < STM32L4_NHOST_CHANNELS; i++)
-    {
-      /* Is an interrupt pending on this channel? */
-
-      if ((haint & OTGFS_HAINT(i)) != 0)
-        {
-          /* Yes... read the HCCHAR register to get the direction bit */
-
-          hcchar = stm32l4_getreg(STM32L4_OTGFS_HCCHAR(i));
-
-          /* Was this an interrupt on an IN or an OUT channel? */
-
-          if ((hcchar & OTGFS_HCCHAR_EPDIR) != 0)
-            {
-              /* Handle the HC IN channel interrupt */
-
-              stm32l4_gint_hcinisr(priv, i);
-            }
-          else
-            {
-              /* Handle the HC OUT channel interrupt */
-
-              stm32l4_gint_hcoutisr(priv, i);
-            }
-        }
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_gint_hprtisr
- *
- * Description:
- *   USB OTG FS host port interrupt handler
- *
- ****************************************************************************/
-
-static inline void stm32l4_gint_hprtisr(FAR struct stm32l4_usbhost_s *priv)
-{
-  uint32_t hprt;
-  uint32_t newhprt;
-  uint32_t hcfg;
-
-  usbhost_vtrace1(OTGFS_VTRACE1_GINT_HPRT, 0);
-  /* Read the port status and control register (HPRT) */
-
-  hprt = stm32l4_getreg(STM32L4_OTGFS_HPRT);
-
-  /* Setup to clear the interrupt bits in GINTSTS by setting the corresponding
-   * bits in the HPRT.  The HCINT interrupt bit is cleared when the appropriate
-   * status bits in the HPRT register are cleared.
-   */
-
-  newhprt = hprt & ~(OTGFS_HPRT_PENA    | OTGFS_HPRT_PCDET  |
-                     OTGFS_HPRT_PENCHNG | OTGFS_HPRT_POCCHNG);
-
-  /* Check for Port Overcurrent CHaNGe (POCCHNG) */
-
-  if ((hprt & OTGFS_HPRT_POCCHNG) != 0)
-    {
-      /* Set up to clear the POCCHNG status in the new HPRT contents. */
-
-      usbhost_vtrace1(OTGFS_VTRACE1_GINT_HPRT_POCCHNG, 0);
-      newhprt |= OTGFS_HPRT_POCCHNG;
-    }
-
-  /* Check for Port Connect DETected (PCDET).  The core sets this bit when a
-   * device connection is detected.
-   */
-
-  if ((hprt & OTGFS_HPRT_PCDET) != 0)
-    {
-      /* Set up to clear the PCDET status in the new HPRT contents. Then
-       * process the new connection event.
-       */
-
-      usbhost_vtrace1(OTGFS_VTRACE1_GINT_HPRT_PCDET, 0);
-      newhprt |= OTGFS_HPRT_PCDET;
-      stm32l4_portreset(priv);
-      stm32l4_gint_connected(priv);
-    }
-
-  /* Check for Port Enable CHaNGed (PENCHNG) */
-
-  if ((hprt & OTGFS_HPRT_PENCHNG) != 0)
-    {
-      /* Set up to clear the PENCHNG status in the new HPRT contents. */
-
-      usbhost_vtrace1(OTGFS_VTRACE1_GINT_HPRT_PENCHNG, 0);
-      newhprt |= OTGFS_HPRT_PENCHNG;
-
-      /* Was the port enabled? */
-
-      if ((hprt & OTGFS_HPRT_PENA) != 0)
-        {
-          /* Yes.. handle the new connection event */
-
-          stm32l4_gint_connected(priv);
-
-          /* Check the Host ConFiGuration register (HCFG) */
-
-          hcfg = stm32l4_getreg(STM32L4_OTGFS_HCFG);
-
-          /* Is this a low speed or full speed connection (OTG FS does not
-           * support high speed)
-           */
-
-          if ((hprt & OTGFS_HPRT_PSPD_MASK) == OTGFS_HPRT_PSPD_LS)
-            {
-              /* Set the Host Frame Interval Register for the 6KHz speed */
-
-              usbhost_vtrace1(OTGFS_VTRACE1_GINT_HPRT_LSDEV, 0);
-              stm32l4_putreg(STM32L4_OTGFS_HFIR, 6000);
-
-              /* Are we switching from FS to LS? */
-
-              if ((hcfg & OTGFS_HCFG_FSLSPCS_MASK) != OTGFS_HCFG_FSLSPCS_LS6MHz)
-                {
-                  usbhost_vtrace1(OTGFS_VTRACE1_GINT_HPRT_FSLSSW, 0);
-
-                  /* Yes... configure for LS */
-
-                  hcfg &= ~OTGFS_HCFG_FSLSPCS_MASK;
-                  hcfg |= OTGFS_HCFG_FSLSPCS_LS6MHz;
-                  stm32l4_putreg(STM32L4_OTGFS_HCFG, hcfg);
-
-                  /* And reset the port */
-
-                  stm32l4_portreset(priv);
-                }
-            }
-          else /* if ((hprt & OTGFS_HPRT_PSPD_MASK) == OTGFS_HPRT_PSPD_FS) */
-            {
-
-              usbhost_vtrace1(OTGFS_VTRACE1_GINT_HPRT_FSDEV, 0);
-              stm32l4_putreg(STM32L4_OTGFS_HFIR, 48000);
-
-              /* Are we switching from LS to FS? */
-
-              if ((hcfg & OTGFS_HCFG_FSLSPCS_MASK) != OTGFS_HCFG_FSLSPCS_FS48MHz)
-                {
-
-                  usbhost_vtrace1(OTGFS_VTRACE1_GINT_HPRT_LSFSSW, 0);
-                  /* Yes... configure for FS */
-
-                  hcfg &= ~OTGFS_HCFG_FSLSPCS_MASK;
-                  hcfg |= OTGFS_HCFG_FSLSPCS_FS48MHz;
-                  stm32l4_putreg(STM32L4_OTGFS_HCFG, hcfg);
-
-                  /* And reset the port */
-
-                  stm32l4_portreset(priv);
-                }
-            }
-        }
-    }
-
-  /* Clear port interrupts by setting bits in the HPRT */
-
-  stm32l4_putreg(STM32L4_OTGFS_HPRT, newhprt);
-}
-
-/****************************************************************************
- * Name: stm32l4_gint_discisr
- *
- * Description:
- *   USB OTG FS disconnect detected interrupt handler
- *
- ****************************************************************************/
-
-static inline void stm32l4_gint_discisr(FAR struct stm32l4_usbhost_s *priv)
-{
-  /* Handle the disconnection event */
-
-  stm32l4_gint_disconnected(priv);
-
-  /* Clear the dicsonnect interrupt */
-
-  stm32l4_putreg(STM32L4_OTGFS_GINTSTS, OTGFS_GINT_DISC);
-}
-
-/****************************************************************************
- * Name: stm32l4_gint_ipxfrisr
- *
- * Description:
- *   USB OTG FS incomplete periodic interrupt handler
- *
- ****************************************************************************/
-
-static inline void stm32l4_gint_ipxfrisr(FAR struct stm32l4_usbhost_s *priv)
-{
-  uint32_t regval;
-
-  /* CHENA : Set to enable the channel
-   * CHDIS : Set to stop transmitting/receiving data on a channel
-   */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_HCCHAR(0));
-  regval |= (OTGFS_HCCHAR_CHDIS | OTGFS_HCCHAR_CHENA);
-  stm32l4_putreg(STM32L4_OTGFS_HCCHAR(0), regval);
-
-  /* Clear the incomplete isochronous OUT interrupt */
-
-  stm32l4_putreg(STM32L4_OTGFS_GINTSTS, OTGFS_GINT_IPXFR);
-}
-
-/****************************************************************************
- * Name: stm32l4_gint_isr
- *
- * Description:
- *   USB OTG FS global interrupt handler
- *
- ****************************************************************************/
-
-static int stm32l4_gint_isr(int irq, FAR void *context, FAR void *arg)
-{
-  /* At present, there is only support for a single OTG FS host. Hence it is
-   * pre-allocated as g_usbhost.  However, in most code, the private data
-   * structure will be referenced using the 'priv' pointer (rather than the
-   * global data) in order to simplify any future support for multiple devices.
-   */
-
-  FAR struct stm32l4_usbhost_s *priv = &g_usbhost;
-  uint32_t pending;
-
-  /* If OTG were supported, we would need to check if we are in host or
-   * device mode when the global interrupt occurs.  Here we support only
-   * host mode
-   */
-
-  /* Loop while there are pending interrupts to process.  This loop may save a
-   * little interrupt handling overhead.
-   */
-
-  for (; ; )
-    {
-      /* Get the unmasked bits in the GINT status */
-
-      pending  = stm32l4_getreg(STM32L4_OTGFS_GINTSTS);
-      pending &= stm32l4_getreg(STM32L4_OTGFS_GINTMSK);
-
-      /* Return from the interrupt when there are no further pending
-       * interrupts.
-       */
-
-      if (pending == 0)
-        {
-          return OK;
-        }
-
-      /* Otherwise, process each pending, unmasked GINT interrupts */
-
-      /* Handle the start of frame interrupt */
-
-#ifdef CONFIG_STM32L4_OTGFS_SOFINTR
-      if ((pending & OTGFS_GINT_SOF) != 0)
-        {
-          usbhost_vtrace1(OTGFS_VTRACE1_GINT_SOF, 0);
-          stm32l4_gint_sofisr(priv);
-        }
-#endif
-
-      /* Handle the RxFIFO non-empty interrupt */
-
-      if ((pending & OTGFS_GINT_RXFLVL) != 0)
-        {
-          usbhost_vtrace1(OTGFS_VTRACE1_GINT_RXFLVL, 0);
-          stm32l4_gint_rxflvlisr(priv);
-        }
-
-      /* Handle the non-periodic TxFIFO empty interrupt */
-
-      if ((pending & OTGFS_GINT_NPTXFE) != 0)
-        {
-          usbhost_vtrace1(OTGFS_VTRACE1_GINT_NPTXFE, 0);
-          stm32l4_gint_nptxfeisr(priv);
-        }
-
-      /* Handle the periodic TxFIFO empty interrupt */
-
-      if ((pending & OTGFS_GINT_PTXFE) != 0)
-        {
-          usbhost_vtrace1(OTGFS_VTRACE1_GINT_PTXFE, 0);
-          stm32l4_gint_ptxfeisr(priv);
-        }
-
-      /* Handle the host channels interrupt */
-
-      if ((pending & OTGFS_GINT_HC) != 0)
-        {
-          usbhost_vtrace1(OTGFS_VTRACE1_GINT_HC, 0);
-          stm32l4_gint_hcisr(priv);
-        }
-
-      /* Handle the host port interrupt */
-
-      if ((pending & OTGFS_GINT_HPRT) != 0)
-        {
-          stm32l4_gint_hprtisr(priv);
-        }
-
-      /* Handle the disconnect detected interrupt */
-
-      if ((pending & OTGFS_GINT_DISC) != 0)
-        {
-          usbhost_vtrace1(OTGFS_VTRACE1_GINT_DISC, 0);
-          stm32l4_gint_discisr(priv);
-        }
-
-      /* Handle the incomplete periodic transfer */
-
-      if ((pending & OTGFS_GINT_IPXFR) != 0)
-        {
-          usbhost_vtrace1(OTGFS_VTRACE1_GINT_IPXFR, 0);
-          stm32l4_gint_ipxfrisr(priv);
-        }
-    }
-
-  /* We won't get here */
-
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_gint_enable and stm32l4_gint_disable
- *
- * Description:
- *   Respectively enable or disable the global OTG FS interrupt.
- *
- * Input Parameters:
- *   None
- *
- * Returned Value:
- *   None
- *
- ****************************************************************************/
-
-static void stm32l4_gint_enable(void)
-{
-  uint32_t regval;
-
-  /* Set the GINTMSK bit to unmask the interrupt */
-
-  regval  = stm32l4_getreg(STM32L4_OTGFS_GAHBCFG);
-  regval |= OTGFS_GAHBCFG_GINTMSK;
-  stm32l4_putreg(STM32L4_OTGFS_GAHBCFG, regval);
-}
-
-static void stm32l4_gint_disable(void)
-{
-  uint32_t regval;
-
-  /* Clear the GINTMSK bit to mask the interrupt */
-
-  regval  = stm32l4_getreg(STM32L4_OTGFS_GAHBCFG);
-  regval &= ~OTGFS_GAHBCFG_GINTMSK;
-  stm32l4_putreg(STM32L4_OTGFS_GAHBCFG, regval);
-}
-
-/****************************************************************************
- * Name: stm32l4_hostinit_enable
- *
- * Description:
- *   Enable host interrupts.
- *
- * Input Parameters:
- *   None
- *
- * Returned Value:
- *   None
- *
- ****************************************************************************/
-
-static inline void stm32l4_hostinit_enable(void)
-{
-  uint32_t regval;
-
-  /* Disable all interrupts. */
-
-  stm32l4_putreg(STM32L4_OTGFS_GINTMSK, 0);
-
-  /* Clear any pending interrupts. */
-
-  stm32l4_putreg(STM32L4_OTGFS_GINTSTS, 0xffffffff);
-
-  /* Clear any pending USB OTG Interrupts (should be done elsewhere if OTG is supported) */
-
-  stm32l4_putreg(STM32L4_OTGFS_GOTGINT, 0xffffffff);
-
-  /* Clear any pending USB OTG interrupts */
-
-  stm32l4_putreg(STM32L4_OTGFS_GINTSTS, 0xbfffffff);
-
-  /* Enable the host interrupts */
-  /* Common interrupts:
-   *
-   *   OTGFS_GINT_WKUP     : Resume/remote wakeup detected interrupt
-   *   OTGFS_GINT_USBSUSP  : USB suspend
-   */
-
-  regval = (OTGFS_GINT_WKUP | OTGFS_GINT_USBSUSP);
-
-  /* If OTG were supported, we would need to enable the following as well:
-   *
-   *   OTGFS_GINT_OTG      : OTG interrupt
-   *   OTGFS_GINT_SRQ      : Session request/new session detected interrupt
-   *   OTGFS_GINT_CIDSCHG  : Connector ID status change
-   */
-
-  /* Host-specific interrupts
-   *
-   *   OTGFS_GINT_SOF      : Start of frame
-   *   OTGFS_GINT_RXFLVL   : RxFIFO non-empty
-   *   OTGFS_GINT_IISOOXFR : Incomplete isochronous OUT transfer
-   *   OTGFS_GINT_HPRT     : Host port interrupt
-   *   OTGFS_GINT_HC       : Host channels interrupt
-   *   OTGFS_GINT_DISC     : Disconnect detected interrupt
-   */
-
-#ifdef CONFIG_STM32L4_OTGFS_SOFINTR
-  regval |= (OTGFS_GINT_SOF    | OTGFS_GINT_RXFLVL   | OTGFS_GINT_IISOOXFR |
-             OTGFS_GINT_HPRT   | OTGFS_GINT_HC       | OTGFS_GINT_DISC);
-#else
-  regval |= (OTGFS_GINT_RXFLVL | OTGFS_GINT_IPXFR    | OTGFS_GINT_HPRT     |
-             OTGFS_GINT_HC     | OTGFS_GINT_DISC);
-#endif
-  stm32l4_putreg(STM32L4_OTGFS_GINTMSK, regval);
-}
-
-/****************************************************************************
- * Name: stm32l4_txfe_enable
- *
- * Description:
- *   Enable Tx FIFO empty interrupts.  This is necessary when the entire
- *   transfer will not fit into Tx FIFO.  The transfer will then be completed
- *   when the Tx FIFO is empty.  NOTE:  The Tx FIFO interrupt is disabled
- *   the fifo empty interrupt handler when the transfer is complete.
- *
- * Input Parameters:
- *   priv - Driver state structure reference
- *   chidx - The channel that requires the Tx FIFO empty interrupt
- *
- * Returned Value:
- *   None
- *
- * Assumptions:
- *   Called from user task context.  Interrupts must be disabled to assure
- *   exclusive access to the GINTMSK register.
- *
- ****************************************************************************/
-
-static void stm32l4_txfe_enable(FAR struct stm32l4_usbhost_s *priv, int chidx)
-{
-  FAR struct stm32l4_chan_s *chan = &priv->chan[chidx];
-  irqstate_t flags;
-  uint32_t regval;
-
-  /* Disable all interrupts so that we have exclusive access to the GINTMSK
-   * (it would be sufficent just to disable the GINT interrupt).
-   */
-
-  flags = enter_critical_section();
-
-  /* Should we enable the periodic or non-peridic Tx FIFO empty interrupts */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_GINTMSK);
-  switch (chan->eptype)
-    {
-      default:
-      case OTGFS_EPTYPE_CTRL: /* Non periodic transfer */
-      case OTGFS_EPTYPE_BULK:
-        regval |= OTGFS_GINT_NPTXFE;
-        break;
-
-      case OTGFS_EPTYPE_INTR: /* Periodic transfer */
-      case OTGFS_EPTYPE_ISOC:
-        regval |= OTGFS_GINT_PTXFE;
-        break;
-    }
-
-  /* Enable interrupts */
-
-  stm32l4_putreg(STM32L4_OTGFS_GINTMSK, regval);
-  leave_critical_section(flags);
-}
-
-/****************************************************************************
- * USB Host Controller Operations
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_wait
- *
- * Description:
- *   Wait for a device to be connected or disconnected to/from a hub port.
- *
- * Input Parameters:
- *   conn - The USB host connection instance obtained as a parameter from the call to
- *      the USB driver initialization logic.
- *   hport - The location to return the hub port descriptor that detected the
- *      connection related event.
- *
- * Returned Values:
- *   Zero (OK) is returned on success when a device in connected or
- *   disconnected. This function will not return until either (1) a device is
- *   connected or disconnect to/from any hub port or until (2) some failure
- *   occurs.  On a failure, a negated errno value is returned indicating the
- *   nature of the failure
- *
- * Assumptions:
- *   - Called from a single thread so no mutual exclusion is required.
- *   - Never called from an interrupt handler.
- *
- ****************************************************************************/
-
-static int stm32l4_wait(FAR struct usbhost_connection_s *conn,
-                        FAR struct usbhost_hubport_s **hport)
-{
-  FAR struct stm32l4_usbhost_s *priv = &g_usbhost;
-  struct usbhost_hubport_s *connport;
-  irqstate_t flags;
-
-  /* Loop until a change in connection state is detected */
-
-  flags = enter_critical_section();
-  for (; ; )
-    {
-      /* Is there a change in the connection state of the single root hub
-       * port?
-       */
-
-      if (priv->change)
-        {
-          connport = &priv->rhport.hport;
-
-          /* Yes. Remember the new state */
-
-          connport->connected = priv->connected;
-          priv->change = false;
-
-          /* And return the root hub port */
-
-          *hport = connport;
-          leave_critical_section(flags);
-
-          uvdbg("RHport Connected: %s\n", connport->connected ? "YES" : "NO");
-          return OK;
-        }
-
-#ifdef CONFIG_USBHOST_HUB
-      /* Is a device connected to an external hub? */
-
-      if (priv->hport)
-        {
-          /* Yes.. return the external hub port */
-
-          connport = (struct usbhost_hubport_s *)priv->hport;
-          priv->hport = NULL;
-
-          *hport = connport;
-          leave_critical_section(flags);
-
-          uvdbg("Hub port Connected: %s\n", connport->connected ? "YES" : "NO");
-          return OK;
-        }
-#endif
-
-      /* Wait for the next connection event */
-
-      priv->pscwait = true;
-      stm32l4_takesem(&priv->pscsem);
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_enumerate
- *
- * Description:
- *   Enumerate the connected device.  As part of this enumeration process,
- *   the driver will (1) get the device's configuration descriptor, (2)
- *   extract the class ID info from the configuration descriptor, (3) call
- *   usbhost_findclass() to find the class that supports this device, (4)
- *   call the create() method on the struct usbhost_registry_s interface
- *   to get a class instance, and finally (5) call the connect() method
- *   of the struct usbhost_class_s interface.  After that, the class is in
- *   charge of the sequence of operations.
- *
- * Input Parameters:
- *   conn - The USB host connection instance obtained as a parameter from
- *      the call to the USB driver initialization logic.
- *   hport - The descriptor of the hub port that has the newly connected
- *      device.
- *
- * Returned Values:
- *   On success, zero (OK) is returned. On a failure, a negated errno value is
- *   returned indicating the nature of the failure
- *
- * Assumptions:
- *   This function will *not* be called from an interrupt handler.
- *
- ****************************************************************************/
-
-static int stm32l4_rh_enumerate(FAR struct stm32l4_usbhost_s *priv,
-                                FAR struct usbhost_connection_s *conn,
-                                FAR struct usbhost_hubport_s *hport)
-{
-  uint32_t regval;
-  int ret;
-
-  DEBUGASSERT(conn != NULL && hport != NULL && hport->port == 0);
-
-  /* Are we connected to a device?  The caller should have called the wait()
-   * method first to be assured that a device is connected.
-   */
-
-  while (!priv->connected)
-    {
-      /* No, return an error */
-
-      usbhost_trace1(OTGFS_TRACE1_DEVDISCONN, 0);
-      return -ENODEV;
-    }
-
-  DEBUGASSERT(priv->smstate == SMSTATE_ATTACHED);
-
-  /* USB 2.0 spec says at least 50ms delay before port reset.  We wait 100ms. */
-
-  usleep(100 * 1000);
-
-  /* Reset the host port */
-
-  stm32l4_portreset(priv);
-
-  /* Get the current device speed */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_HPRT);
-  if ((regval & OTGFS_HPRT_PSPD_MASK) == OTGFS_HPRT_PSPD_LS)
-    {
-      priv->rhport.hport.speed = USB_SPEED_LOW;
-    }
-  else
-    {
-      priv->rhport.hport.speed = USB_SPEED_FULL;
-    }
-
-  /* Allocate and initialize the root hub port EP0 channels */
-
-  ret = stm32l4_ctrlchan_alloc(priv, 0, 0, priv->rhport.hport.speed, &priv->ep0);
-  if (ret < 0)
-    {
-      uerr("ERROR: Failed to allocate a control endpoint: %d\n", ret);
-    }
-
-  return ret;
-}
-
-static int stm32l4_enumerate(FAR struct usbhost_connection_s *conn,
-                             FAR struct usbhost_hubport_s *hport)
-{
-  FAR struct stm32l4_usbhost_s *priv = &g_usbhost;
-  int ret;
-
-  DEBUGASSERT(hport);
-
-  /* If this is a connection on the root hub, then we need to go to
-   * little more effort to get the device speed.  If it is a connection
-   * on an external hub, then we already have that information.
-   */
-
-#ifdef CONFIG_USBHOST_HUB
-  if (ROOTHUB(hport))
-#endif
-    {
-      ret = stm32l4_rh_enumerate(priv, conn, hport);
-      if (ret < 0)
-        {
-          return ret;
-        }
-    }
-
-  /* Then let the common usbhost_enumerate do the real enumeration. */
-
-  uvdbg("Enumerate the device\n");
-  priv->smstate = SMSTATE_ENUM;
-  ret = usbhost_enumerate(hport, &hport->devclass);
-
-  /* The enumeration may fail either because of some HCD interfaces failure
-   * or because the device class is not supported.  In either case, we just
-   * need to perform the disconnection operation and make ready for a new
-   * enumeration.
-   */
-
-  if (ret < 0)
-    {
-      /* Return to the disconnected state */
-
-      uerr("ERROR: Enumeration failed: %d\n", ret);
-      stm32l4_gint_disconnected(priv);
-    }
-
-  return ret;
-}
-
-/************************************************************************************
- * Name: stm32l4_ep0configure
- *
- * Description:
- *   Configure endpoint 0.  This method is normally used internally by the
- *   enumerate() method but is made available at the interface to support an
- *   external implementation of the enumeration logic.
- *
- * Input Parameters:
- *   drvr - The USB host driver instance obtained as a parameter from the call to
- *      the class create() method.
- *   ep0 - The (opaque) EP0 endpoint instance
- *   funcaddr - The USB address of the function containing the endpoint that EP0
- *     controls
- *   speed - The speed of the port USB_SPEED_LOW, _FULL, or _HIGH
- *   maxpacketsize - The maximum number of bytes that can be sent to or
- *    received from the endpoint in a single data packet
- *
- * Returned Values:
- *   On success, zero (OK) is returned. On a failure, a negated errno value is
- *   returned indicating the nature of the failure
- *
- * Assumptions:
- *   This function will *not* be called from an interrupt handler.
- *
- ************************************************************************************/
-
-static int stm32l4_ep0configure(FAR struct usbhost_driver_s *drvr,
-                                usbhost_ep_t ep0, uint8_t funcaddr,
-                                uint8_t speed, uint16_t maxpacketsize)
-{
-  FAR struct stm32l4_usbhost_s *priv = (FAR struct stm32l4_usbhost_s *)drvr;
-  FAR struct stm32l4_ctrlinfo_s *ep0info = (FAR struct stm32l4_ctrlinfo_s *)ep0;
-  FAR struct stm32l4_chan_s *chan;
-
-  DEBUGASSERT(drvr != NULL && ep0info != NULL && funcaddr < 128 &&
-              maxpacketsize <= 64);
-
-  /* We must have exclusive access to the USB host hardware and state structures */
-
-  stm32l4_takesem(&priv->exclsem);
-
-  /* Configure the EP0 OUT channel */
-
-  chan            = &priv->chan[ep0info->outndx];
-  chan->funcaddr  = funcaddr;
-  chan->speed     = speed;
-  chan->maxpacket = maxpacketsize;
-
-  stm32l4_chan_configure(priv, ep0info->outndx);
-
-  /* Configure the EP0 IN channel */
-
-  chan            = &priv->chan[ep0info->inndx];
-  chan->funcaddr  = funcaddr;
-  chan->speed     = speed;
-  chan->maxpacket = maxpacketsize;
-
-  stm32l4_chan_configure(priv, ep0info->inndx);
-
-  stm32l4_givesem(&priv->exclsem);
-  return OK;
-}
-
-/************************************************************************************
- * Name: stm32l4_epalloc
- *
- * Description:
- *   Allocate and configure one endpoint.
- *
- * Input Parameters:
- *   drvr - The USB host driver instance obtained as a parameter from the call to
- *      the class create() method.
- *   epdesc - Describes the endpoint to be allocated.
- *   ep - A memory location provided by the caller in which to receive the
- *      allocated endpoint descriptor.
- *
- * Returned Values:
- *   On success, zero (OK) is returned. On a failure, a negated errno value is
- *   returned indicating the nature of the failure
- *
- * Assumptions:
- *   This function will *not* be called from an interrupt handler.
- *
- ************************************************************************************/
-
-static int stm32l4_epalloc(FAR struct usbhost_driver_s *drvr,
-                           FAR const struct usbhost_epdesc_s *epdesc,
-                           FAR usbhost_ep_t *ep)
-{
-  FAR struct stm32l4_usbhost_s *priv = (FAR struct stm32l4_usbhost_s *)drvr;
-  int ret;
-
-  /* Sanity check.  NOTE that this method should only be called if a device is
-   * connected (because we need a valid low speed indication).
-   */
-
-  DEBUGASSERT(drvr != 0 && epdesc != NULL && ep != NULL);
-
-  /* We must have exclusive access to the USB host hardware and state structures */
-
-  stm32l4_takesem(&priv->exclsem);
-
-  /* Handler control pipes differently from other endpoint types.  This is
-   * because the normal, "transfer" endpoints are unidirectional an require
-   * only a single channel.  Control endpoints, however, are bi-diretional
-   * and require two channels, one for the IN and one for the OUT direction.
-   */
-
-  if (epdesc->xfrtype == OTGFS_EPTYPE_CTRL)
-    {
-      ret = stm32l4_ctrlep_alloc(priv, epdesc, ep);
-    }
-  else
-    {
-      ret = stm32l4_xfrep_alloc(priv, epdesc, ep);
-    }
-
-  stm32l4_givesem(&priv->exclsem);
-  return ret;
-}
-
-/************************************************************************************
- * Name: stm32l4_epfree
- *
- * Description:
- *   Free and endpoint previously allocated by DRVR_EPALLOC.
- *
- * Input Parameters:
- *   drvr - The USB host driver instance obtained as a parameter from the call to
- *      the class create() method.
- *   ep - The endpoint to be freed.
- *
- * Returned Values:
- *   On success, zero (OK) is returned. On a failure, a negated errno value is
- *   returned indicating the nature of the failure
- *
- * Assumptions:
- *   This function will *not* be called from an interrupt handler.
- *
- ************************************************************************************/
-
-static int stm32l4_epfree(FAR struct usbhost_driver_s *drvr, usbhost_ep_t ep)
-{
-  FAR struct stm32l4_usbhost_s *priv = (FAR struct stm32l4_usbhost_s *)drvr;
-
-  DEBUGASSERT(priv);
-
-  /* We must have exclusive access to the USB host hardware and state structures */
-
-  stm32l4_takesem(&priv->exclsem);
-
-  /* A single channel is represent by an index in the range of 0 to STM32L4_MAX_TX_FIFOS.
-   * Otherwise, the ep must be a pointer to an allocated control endpoint structure.
-   */
-
-  if ((uintptr_t)ep < STM32L4_MAX_TX_FIFOS)
-    {
-      /* Halt the channel and mark the channel available */
-
-      stm32l4_chan_free(priv, (int)ep);
-    }
-  else
-    {
-      /* Halt both control channel and mark the channels available */
-
-      FAR struct stm32l4_ctrlinfo_s *ctrlep = (FAR struct stm32l4_ctrlinfo_s *)ep;
-      stm32l4_chan_free(priv, ctrlep->inndx);
-      stm32l4_chan_free(priv, ctrlep->outndx);
-
-      /* And free the control endpoint container */
-
-      kmm_free(ctrlep);
-    }
-
-  stm32l4_givesem(&priv->exclsem);
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_alloc
- *
- * Description:
- *   Some hardware supports special memory in which request and descriptor data can
- *   be accessed more efficiently.  This method provides a mechanism to allocate
- *   the request/descriptor memory.  If the underlying hardware does not support
- *   such "special" memory, this functions may simply map to kmm_malloc.
- *
- *   This interface was optimized under a particular assumption.  It was assumed
- *   that the driver maintains a pool of small, pre-allocated buffers for descriptor
- *   traffic.  NOTE that size is not an input, but an output:  The size of the
- *   pre-allocated buffer is returned.
- *
- * Input Parameters:
- *   drvr - The USB host driver instance obtained as a parameter from the call to
- *      the class create() method.
- *   buffer - The address of a memory location provided by the caller in which to
- *     return the allocated buffer memory address.
- *   maxlen - The address of a memory location provided by the caller in which to
- *     return the maximum size of the allocated buffer memory.
- *
- * Returned Values:
- *   On success, zero (OK) is returned. On a failure, a negated errno value is
- *   returned indicating the nature of the failure
- *
- * Assumptions:
- *   - Called from a single thread so no mutual exclusion is required.
- *   - Never called from an interrupt handler.
- *
- ****************************************************************************/
-#warning this function name is too generic
-static int stm32l4_alloc(FAR struct usbhost_driver_s *drvr,
-                         FAR uint8_t **buffer, FAR size_t *maxlen)
-{
-  FAR uint8_t *alloc;
-
-  DEBUGASSERT(drvr && buffer && maxlen);
-
-  /* There is no special memory requirement for the STM32. */
-
-  alloc = (FAR uint8_t *)kmm_malloc(CONFIG_STM32L4_OTGFS_DESCSIZE);
-  if (!alloc)
-    {
-      return -ENOMEM;
-    }
-
-  /* Return the allocated address and size of the descriptor buffer */
-
-  *buffer = alloc;
-  *maxlen = CONFIG_STM32L4_OTGFS_DESCSIZE;
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_free
- *
- * Description:
- *   Some hardware supports special memory in which request and descriptor data can
- *   be accessed more efficiently.  This method provides a mechanism to free that
- *   request/descriptor memory.  If the underlying hardware does not support
- *   such "special" memory, this functions may simply map to kmm_free().
- *
- * Input Parameters:
- *   drvr - The USB host driver instance obtained as a parameter from the call to
- *      the class create() method.
- *   buffer - The address of the allocated buffer memory to be freed.
- *
- * Returned Values:
- *   On success, zero (OK) is returned. On a failure, a negated errno value is
- *   returned indicating the nature of the failure
- *
- * Assumptions:
- *   - Never called from an interrupt handler.
- *
- ****************************************************************************/
-#warning this function name is too generic
-static int stm32l4_free(FAR struct usbhost_driver_s *drvr, FAR uint8_t *buffer)
-{
-  /* There is no special memory requirement */
-
-  DEBUGASSERT(drvr && buffer);
-  kmm_free(buffer);
-  return OK;
-}
-
-/************************************************************************************
- * Name: stm32l4_ioalloc
- *
- * Description:
- *   Some hardware supports special memory in which larger IO buffers can
- *   be accessed more efficiently.  This method provides a mechanism to allocate
- *   the request/descriptor memory.  If the underlying hardware does not support
- *   such "special" memory, this functions may simply map to kmm_malloc.
- *
- *   This interface differs from DRVR_ALLOC in that the buffers are variable-sized.
- *
- * Input Parameters:
- *   drvr - The USB host driver instance obtained as a parameter from the call to
- *      the class create() method.
- *   buffer - The address of a memory location provided by the caller in which to
- *     return the allocated buffer memory address.
- *   buflen - The size of the buffer required.
- *
- * Returned Values:
- *   On success, zero (OK) is returned. On a failure, a negated errno value is
- *   returned indicating the nature of the failure
- *
- * Assumptions:
- *   This function will *not* be called from an interrupt handler.
- *
- ************************************************************************************/
-#warning this function name is too generic
-static int stm32l4_ioalloc(FAR struct usbhost_driver_s *drvr,
-                           FAR uint8_t **buffer, size_t buflen)
-{
-  FAR uint8_t *alloc;
-
-  DEBUGASSERT(drvr && buffer && buflen > 0);
-
-  /* There is no special memory requirement */
-
-  alloc = (FAR uint8_t *)kmm_malloc(buflen);
-  if (!alloc)
-    {
-      return -ENOMEM;
-    }
-
-  /* Return the allocated buffer */
-
-  *buffer = alloc;
-  return OK;
-}
-
-/************************************************************************************
- * Name: stm32l4_iofree
- *
- * Description:
- *   Some hardware supports special memory in which IO data can  be accessed more
- *   efficiently.  This method provides a mechanism to free that IO buffer
- *   memory.  If the underlying hardware does not support such "special" memory,
- *   this functions may simply map to kmm_free().
- *
- * Input Parameters:
- *   drvr - The USB host driver instance obtained as a parameter from the call to
- *      the class create() method.
- *   buffer - The address of the allocated buffer memory to be freed.
- *
- * Returned Values:
- *   On success, zero (OK) is returned. On a failure, a negated errno value is
- *   returned indicating the nature of the failure
- *
- * Assumptions:
- *   This function will *not* be called from an interrupt handler.
- *
- ************************************************************************************/
-#warning this function name is too generic
-static int stm32l4_iofree(FAR struct usbhost_driver_s *drvr, FAR uint8_t *buffer)
-{
-  /* There is no special memory requirement */
-
-  DEBUGASSERT(drvr && buffer);
-  kmm_free(buffer);
-  return OK;
-}
-
-/****************************************************************************
- * Name: stm32l4_ctrlin and stm32l4_ctrlout
- *
- * Description:
- *   Process a IN or OUT request on the control endpoint.  These methods
- *   will enqueue the request and wait for it to complete.  Only one transfer may be
- *   queued; Neither these methods nor the transfer() method can be called again
- *   until the control transfer functions returns.
- *
- *   These are blocking methods; these functions will not return until the
- *   control transfer has completed.
- *
- * Input Parameters:
- *   drvr - The USB host driver instance obtained as a parameter from the call to
- *      the class create() method.
- *   ep0 - The control endpoint to send/receive the control request.
- *   req - Describes the request to be sent.  This request must lie in memory
- *      created by DRVR_ALLOC.
- *   buffer - A buffer used for sending the request and for returning any
- *     responses.  This buffer must be large enough to hold the length value
- *     in the request description. buffer must have been allocated using DRVR_ALLOC.
- *
- *   NOTE: On an IN transaction, req and buffer may refer to the same allocated
- *   memory.
- *
- * Returned Values:
- *   On success, zero (OK) is returned. On a failure, a negated errno value is
- *   returned indicating the nature of the failure
- *
- * Assumptions:
- *   - Called from a single thread so no mutual exclusion is required.
- *   - Never called from an interrupt handler.
- *
- ****************************************************************************/
-
-static int stm32l4_ctrlin(FAR struct usbhost_driver_s *drvr, usbhost_ep_t ep0,
-                          FAR const struct usb_ctrlreq_s *req,
-                          FAR uint8_t *buffer)
-{
-  FAR struct stm32l4_usbhost_s *priv = (FAR struct stm32l4_usbhost_s *)drvr;
-  FAR struct stm32l4_ctrlinfo_s *ep0info = (FAR struct stm32l4_ctrlinfo_s *)ep0;
-  uint16_t buflen;
-  systime_t start;
-  systime_t elapsed;
-  int retries;
-  int ret;
-
-  DEBUGASSERT(priv != NULL && ep0info != NULL && req != NULL);
-  usbhost_vtrace2(OTGFS_VTRACE2_CTRLIN, req->type, req->req);
-  uvdbg("type:%02x req:%02x value:%02x%02x index:%02x%02x len:%02x%02x\n",
-        req->type, req->req, req->value[1], req->value[0],
-        req->index[1], req->index[0], req->len[1], req->len[0]);
-
-  /* Extract values from the request */
-
-  buflen = stm32l4_getle16(req->len);
-
-  /* We must have exclusive access to the USB host hardware and state structures */
-
-  stm32l4_takesem(&priv->exclsem);
-
-  /* Loop, retrying until the retry time expires */
-
-  for (retries = 0; retries < STM32L4_RETRY_COUNT; retries++)
-    {
-      /* Send the SETUP request */
-
-      ret = stm32l4_ctrl_sendsetup(priv, ep0info, req);
-      if (ret < 0)
-        {
-          usbhost_trace1(OTGFS_TRACE1_SENDSETUP, -ret);
-          continue;
-        }
-
-      /* Get the start time.  Loop again until the timeout expires */
-
-      start = clock_systimer();
-      do
-        {
-          /* Handle the IN data phase (if any) */
-
-          if (buflen > 0)
-            {
-              ret = stm32l4_ctrl_recvdata(priv, ep0info, buffer, buflen);
-              if (ret < 0)
-                {
-                  usbhost_trace1(OTGFS_TRACE1_RECVDATA, -ret);
-                }
-            }
-
-          /* Handle the status OUT phase */
-
-          if (ret == OK)
-            {
-              priv->chan[ep0info->outndx].outdata1 ^= true;
-              ret = stm32l4_ctrl_senddata(priv, ep0info, NULL, 0);
-              if (ret == OK)
-                {
-                  /* All success transactions exit here */
-
-                  stm32l4_givesem(&priv->exclsem);
-                  return OK;
-                }
-
-              usbhost_trace1(OTGFS_TRACE1_SENDDATA, ret < 0 ? -ret : ret);
-            }
-
-          /* Get the elapsed time (in frames) */
-
-          elapsed = clock_systimer() - start;
-        }
-      while (elapsed < STM32L4_DATANAK_DELAY);
-    }
-
-  /* All failures exit here after all retries and timeouts have been exhausted */
-
-  stm32l4_givesem(&priv->exclsem);
-  return -ETIMEDOUT;
-}
-
-static int stm32l4_ctrlout(FAR struct usbhost_driver_s *drvr, usbhost_ep_t ep0,
-                           FAR const struct usb_ctrlreq_s *req,
-                           FAR const uint8_t *buffer)
-{
-  FAR struct stm32l4_usbhost_s *priv = (FAR struct stm32l4_usbhost_s *)drvr;
-  FAR struct stm32l4_ctrlinfo_s *ep0info = (FAR struct stm32l4_ctrlinfo_s *)ep0;
-  uint16_t buflen;
-  systime_t start;
-  systime_t elapsed;
-  int retries;
-  int ret;
-
-  DEBUGASSERT(priv != NULL && ep0info != NULL && req != NULL);
-  usbhost_vtrace2(OTGFS_VTRACE2_CTRLOUT, req->type, req->req);
-  uvdbg("type:%02x req:%02x value:%02x%02x index:%02x%02x len:%02x%02x\n",
-        req->type, req->req, req->value[1], req->value[0],
-        req->index[1], req->index[0], req->len[1], req->len[0]);
-
-  /* Extract values from the request */
-
-  buflen = stm32l4_getle16(req->len);
-
-  /* We must have exclusive access to the USB host hardware and state structures */
-
-  stm32l4_takesem(&priv->exclsem);
-
-  /* Loop, retrying until the retry time expires */
-
-  for (retries = 0; retries < STM32L4_RETRY_COUNT; retries++)
-    {
-      /* Send the SETUP request */
-
-      ret = stm32l4_ctrl_sendsetup(priv, ep0info, req);
-      if (ret < 0)
-        {
-          usbhost_trace1(OTGFS_TRACE1_SENDSETUP, -ret);
-          continue;
-        }
-
-      /* Get the start time.  Loop again until the timeout expires */
-
-      start = clock_systimer();
-      do
-        {
-          /* Handle the data OUT phase (if any) */
-
-          if (buflen > 0)
-            {
-              /* Start DATA out transfer (only one DATA packet) */
-
-              priv->chan[ep0info->outndx].outdata1 = true;
-              ret = stm32l4_ctrl_senddata(priv, ep0info, NULL, 0);
-              if (ret < 0)
-                {
-                  usbhost_trace1(OTGFS_TRACE1_SENDDATA, -ret);
-                }
-            }
-
-          /* Handle the status IN phase */
-
-          if (ret == OK)
-            {
-              ret = stm32l4_ctrl_recvdata(priv, ep0info, NULL, 0);
-              if (ret == OK)
-                {
-                  /* All success transactins exit here */
-
-                  stm32l4_givesem(&priv->exclsem);
-                  return OK;
-                }
-
-              usbhost_trace1(OTGFS_TRACE1_RECVDATA, ret < 0 ? -ret : ret);
-            }
-
-          /* Get the elapsed time (in frames) */
-
-          elapsed = clock_systimer() - start;
-        }
-      while (elapsed < STM32L4_DATANAK_DELAY);
-    }
-
-  /* All failures exit here after all retries and timeouts have been exhausted */
-
-  stm32l4_givesem(&priv->exclsem);
-  return -ETIMEDOUT;
-}
-
-/****************************************************************************
- * Name: stm32l4_transfer
- *
- * Description:
- *   Process a request to handle a transfer descriptor.  This method will
- *   enqueue the transfer request, blocking until the transfer completes. Only
- *   one transfer may be  queued; Neither this method nor the ctrlin or
- *   ctrlout methods can be called again until this function returns.
- *
- *   This is a blocking method; this functions will not return until the
- *   transfer has completed.
- *
- * Input Parameters:
- *   drvr - The USB host driver instance obtained as a parameter from the call to
- *      the class create() method.
- *   ep - The IN or OUT endpoint descriptor for the device endpoint on which to
- *      perform the transfer.
- *   buffer - A buffer containing the data to be sent (OUT endpoint) or received
- *     (IN endpoint).  buffer must have been allocated using DRVR_ALLOC
- *   buflen - The length of the data to be sent or received.
- *
- * Returned Values:
- *   On success, a non-negative value is returned that indicates the number
- *   of bytes successfully transferred.  On a failure, a negated errno value is
- *   returned that indicates the nature of the failure:
- *
- *     EAGAIN - If devices NAKs the transfer (or NYET or other error where
- *              it may be appropriate to restart the entire transaction).
- *     EPERM  - If the endpoint stalls
- *     EIO    - On a TX or data toggle error
- *     EPIPE  - Overrun errors
- *
- * Assumptions:
- *   - Called from a single thread so no mutual exclusion is required.
- *   - Never called from an interrupt handler.
- *
- ****************************************************************************/
-
-static ssize_t stm32l4_transfer(FAR struct usbhost_driver_s *drvr, usbhost_ep_t ep,
-                                FAR uint8_t *buffer, size_t buflen)
-{
-  FAR struct stm32l4_usbhost_s *priv  = (FAR struct stm32l4_usbhost_s *)drvr;
-  unsigned int chidx = (unsigned int)ep;
-  ssize_t nbytes;
-
-  uvdbg("chidx: %d buflen: %d\n",  (unsigned int)ep, buflen);
-
-  DEBUGASSERT(priv && buffer && chidx < STM32L4_MAX_TX_FIFOS && buflen > 0);
-
-  /* We must have exclusive access to the USB host hardware and state structures */
-
-  stm32l4_takesem(&priv->exclsem);
-
-  /* Handle IN and OUT transfer slightly differently */
-
-  if (priv->chan[chidx].in)
-    {
-      nbytes = stm32l4_in_transfer(priv, chidx, buffer, buflen);
-    }
-  else
-    {
-      nbytes = stm32l4_out_transfer(priv, chidx, buffer, buflen);
-    }
-
-  stm32l4_givesem(&priv->exclsem);
-  return nbytes;
-}
-
-/****************************************************************************
- * Name: stm32l4_asynch
- *
- * Description:
- *   Process a request to handle a transfer descriptor.  This method will
- *   enqueue the transfer request and return immediately.  When the transfer
- *   completes, the the callback will be invoked with the provided transfer.
- *   This method is useful for receiving interrupt transfers which may come
- *   infrequently.
- *
- *   Only one transfer may be queued; Neither this method nor the ctrlin or
- *   ctrlout methods can be called again until the transfer completes.
- *
- * Input Parameters:
- *   drvr - The USB host driver instance obtained as a parameter from the call to
- *      the class create() method.
- *   ep - The IN or OUT endpoint descriptor for the device endpoint on which to
- *      perform the transfer.
- *   buffer - A buffer containing the data to be sent (OUT endpoint) or received
- *     (IN endpoint).  buffer must have been allocated using DRVR_ALLOC
- *   buflen - The length of the data to be sent or received.
- *   callback - This function will be called when the transfer completes.
- *   arg - The arbitrary parameter that will be passed to the callback function
- *     when the transfer completes.
- *
- * Returned Values:
- *   On success, zero (OK) is returned. On a failure, a negated errno value is
- *   returned indicating the nature of the failure
- *
- * Assumptions:
- *   - Called from a single thread so no mutual exclusion is required.
- *   - Never called from an interrupt handler.
- *
- ****************************************************************************/
-
-#ifdef CONFIG_USBHOST_ASYNCH
-static int stm32l4_asynch(FAR struct usbhost_driver_s *drvr, usbhost_ep_t ep,
-                          FAR uint8_t *buffer, size_t buflen,
-                          usbhost_asynch_t callback, FAR void *arg)
-{
-  FAR struct stm32l4_usbhost_s *priv  = (FAR struct stm32l4_usbhost_s *)drvr;
-  unsigned int chidx = (unsigned int)ep;
-  int ret;
-
-  uvdbg("chidx: %d buflen: %d\n",  (unsigned int)ep, buflen);
-
-  DEBUGASSERT(priv && buffer && chidx < STM32L4_MAX_TX_FIFOS && buflen > 0);
-
-  /* We must have exclusive access to the USB host hardware and state structures */
-
-  stm32l4_takesem(&priv->exclsem);
-
-  /* Handle IN and OUT transfer slightly differently */
-
-  if (priv->chan[chidx].in)
-    {
-      ret = stm32l4_in_asynch(priv, chidx, buffer, buflen, callback, arg);
-    }
-  else
-    {
-      ret = stm32l4_out_asynch(priv, chidx, buffer, buflen, callback, arg);
-    }
-
-  stm32l4_givesem(&priv->exclsem);
-  return ret;
-}
-#endif /* CONFIG_USBHOST_ASYNCH */
-
-/************************************************************************************
- * Name: stm32l4_cancel
- *
- * Description:
- *   Cancel a pending transfer on an endpoint.  Cancelled synchronous or
- *   asynchronous transfer will complete normally with the error -ESHUTDOWN.
- *
- * Input Parameters:
- *   drvr - The USB host driver instance obtained as a parameter from the call to
- *      the class create() method.
- *   ep - The IN or OUT endpoint descriptor for the device endpoint on which an
- *      asynchronous transfer should be transferred.
- *
- * Returned Values:
- *   On success, zero (OK) is returned. On a failure, a negated errno value is
- *   returned indicating the nature of the failure.
- *
- ************************************************************************************/
-
-static int stm32l4_cancel(FAR struct usbhost_driver_s *drvr, usbhost_ep_t ep)
-{
-  FAR struct stm32l4_usbhost_s *priv  = (FAR struct stm32l4_usbhost_s *)drvr;
-  FAR struct stm32l4_chan_s *chan;
-  unsigned int chidx = (unsigned int)ep;
-  irqstate_t flags;
-
-  uvdbg("chidx: %u: %d\n",  chidx);
-
-  DEBUGASSERT(priv && chidx < STM32L4_MAX_TX_FIFOS);
-  chan = &priv->chan[chidx];
-
-  /* We need to disable interrupts to avoid race conditions with the asynchronous
-   * completion of the transfer being cancelled.
-   */
-
-  flags = enter_critical_section();
-
-  /* Halt the channel */
-
-  stm32l4_chan_halt(priv, chidx, CHREASON_CANCELLED);
-  chan->result = -ESHUTDOWN;
-
-  /* Is there a thread waiting for this transfer to complete? */
-
-  if (chan->waiter)
-    {
-#ifdef CONFIG_USBHOST_ASYNCH
-      /* Yes.. there should not also be a callback scheduled */
-
-      DEBUGASSERT(chan->callback == NULL);
-#endif
-
-      /* Wake'em up! */
-
-      stm32l4_givesem(&chan->waitsem);
-      chan->waiter = false;
-    }
-
-#ifdef CONFIG_USBHOST_ASYNCH
-  /* No.. is an asynchronous callback expected when the transfer
-   * completes?
-   */
-
-  else if (chan->callback)
-    {
-      usbhost_asynch_t callback;
-      FAR void *arg;
-
-      /* Extract the callback information */
-
-      callback       = chan->callback;
-      arg            = chan->arg;
-
-      chan->callback = NULL;
-      chan->arg      = NULL;
-      chan->xfrd     = 0;
-
-      /* Then perform the callback */
-
-      callback(arg, -ESHUTDOWN);
-    }
-#endif
-
-  leave_critical_section(flags);
-  return OK;
-}
-
-/************************************************************************************
- * Name: stm32l4_connect
- *
- * Description:
- *   New connections may be detected by an attached hub.  This method is the
- *   mechanism that is used by the hub class to introduce a new connection
- *   and port description to the system.
- *
- * Input Parameters:
- *   drvr - The USB host driver instance obtained as a parameter from the call to
- *      the class create() method.
- *   hport - The descriptor of the hub port that detected the connection
- *      related event
- *   connected - True: device connected; false: device disconnected
- *
- * Returned Values:
- *   On success, zero (OK) is returned. On a failure, a negated errno value is
- *   returned indicating the nature of the failure.
- *
- ************************************************************************************/
-
-#ifdef CONFIG_USBHOST_HUB
-static int stm32l4_connect(FAR struct usbhost_driver_s *drvr,
-                           FAR struct usbhost_hubport_s *hport,
-                           bool connected)
-{
-  FAR struct stm32l4_usbhost_s *priv = (FAR struct stm32l4_usbhost_s *)drvr;
-  irqstate_t flags;
-
-  DEBUGASSERT(priv != NULL && hport != NULL);
-
-  /* Set the connected/disconnected flag */
-
-  hport->connected = connected;
-  uinfo("Hub port %d connected: %s\n", hport->port, connected ? "YES" : "NO");
-
-  /* Report the connection event */
-
-  flags = enter_critical_section();
-  priv->hport = hport;
-  if (priv->pscwait)
-    {
-      priv->pscwait = false;
-      stm32l4_givesem(&priv->pscsem);
-    }
-
-  leave_critical_section(flags);
-  return OK;
-}
-#endif
-
-/****************************************************************************
- * Name: stm32l4_disconnect
- *
- * Description:
- *   Called by the class when an error occurs and driver has been disconnected.
- *   The USB host driver should discard the handle to the class instance (it is
- *   stale) and not attempt any further interaction with the class driver instance
- *   (until a new instance is received from the create() method).  The driver
- *   should not called the class' disconnected() method.
- *
- * Input Parameters:
- *   drvr - The USB host driver instance obtained as a parameter from the call to
- *      the class create() method.
- *   hport - The port from which the device is being disconnected.  Might be a port
- *      on a hub.
- *
- * Returned Values:
- *   None
- *
- * Assumptions:
- *   - Only a single class bound to a single device is supported.
- *   - Never called from an interrupt handler.
- *
- ****************************************************************************/
-
-static void stm32l4_disconnect(FAR struct usbhost_driver_s *drvr,
-                               FAR struct usbhost_hubport_s *hport)
-{
-  DEBUGASSERT(hport != NULL);
-  hport->devclass = NULL;
-}
-
-/****************************************************************************
- * Initialization
- ****************************************************************************/
-/****************************************************************************
- * Name: stm32l4_portreset
- *
- * Description:
- *   Reset the USB host port.
- *
- *   NOTE: "Before starting to drive a USB reset, the application waits for the
- *   OTG interrupt triggered by the debounce done bit (DBCDNE bit in
- *   OTG_FS_GOTGINT), which indicates that the bus is stable again after the
- *   electrical debounce caused by the attachment of a pull-up resistor on DP
- *   (FS) or DM (LS).
- *
- * Input Parameters:
- *   priv -- USB host driver private data structure.
- *
- * Returned Value:
- *   None
- *
- ****************************************************************************/
-
-static void stm32l4_portreset(FAR struct stm32l4_usbhost_s *priv)
-{
-  uint32_t regval;
-
-  regval  = stm32l4_getreg(STM32L4_OTGFS_HPRT);
-  regval &= ~(OTGFS_HPRT_PENA | OTGFS_HPRT_PCDET | OTGFS_HPRT_PENCHNG |
-              OTGFS_HPRT_POCCHNG);
-  regval |= OTGFS_HPRT_PRST;
-  stm32l4_putreg(STM32L4_OTGFS_HPRT, regval);
-
-  up_mdelay(20);
-
-  regval &= ~OTGFS_HPRT_PRST;
-  stm32l4_putreg(STM32L4_OTGFS_HPRT, regval);
-
-  up_mdelay(20);
-}
-
-/****************************************************************************
- * Name: stm32l4_flush_txfifos
- *
- * Description:
- *   Flush the selected Tx FIFO.
- *
- * Input Parameters:
- *   txfnum -- USB host driver private data structure.
- *
- * Returned Value:
- *   None.
- *
- ****************************************************************************/
-
-static void stm32l4_flush_txfifos(uint32_t txfnum)
-{
-  uint32_t regval;
-  uint32_t timeout;
-
-  /* Initiate the TX FIFO flush operation */
-
-  regval = OTGFS_GRSTCTL_TXFFLSH | txfnum;
-  stm32l4_putreg(STM32L4_OTGFS_GRSTCTL, regval);
-
-  /* Wait for the FLUSH to complete */
-
-  for (timeout = 0; timeout < STM32L4_FLUSH_DELAY; timeout++)
-    {
-      regval = stm32l4_getreg(STM32L4_OTGFS_GRSTCTL);
-      if ((regval & OTGFS_GRSTCTL_TXFFLSH) == 0)
-        {
-          break;
-        }
-    }
-
-  /* Wait for 3 PHY Clocks */
-
-  up_udelay(3);
-}
-
-/****************************************************************************
- * Name: stm32l4_flush_rxfifo
- *
- * Description:
- *   Flush the Rx FIFO.
- *
- * Input Parameters:
- *   priv -- USB host driver private data structure.
- *
- * Returned Value:
- *   None.
- *
- ****************************************************************************/
-
-static void stm32l4_flush_rxfifo(void)
-{
-  uint32_t regval;
-  uint32_t timeout;
-
-  /* Initiate the RX FIFO flush operation */
-
-  stm32l4_putreg(STM32L4_OTGFS_GRSTCTL, OTGFS_GRSTCTL_RXFFLSH);
-
-  /* Wait for the FLUSH to complete */
-
-  for (timeout = 0; timeout < STM32L4_FLUSH_DELAY; timeout++)
-    {
-      regval = stm32l4_getreg(STM32L4_OTGFS_GRSTCTL);
-      if ((regval & OTGFS_GRSTCTL_RXFFLSH) == 0)
-        {
-          break;
-        }
-    }
-
-  /* Wait for 3 PHY Clocks */
-
-  up_udelay(3);
-}
-
-/****************************************************************************
- * Name: stm32l4_vbusdrive
- *
- * Description:
- *   Drive the Vbus +5V.
- *
- * Input Parameters:
- *   priv  - USB host driver private data structure.
- *   state - True: Drive, False: Don't drive
- *
- * Returned Value:
- *   None.
- *
- ****************************************************************************/
-
-static void stm32l4_vbusdrive(FAR struct stm32l4_usbhost_s *priv, bool state)
-{
-  uint32_t regval;
-
-  /* Enable/disable the external charge pump */
-
-  stm32l4_usbhost_vbusdrive(0, state);
-
-  /* Turn on the Host port power. */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_HPRT);
-  regval &= ~(OTGFS_HPRT_PENA | OTGFS_HPRT_PCDET | OTGFS_HPRT_PENCHNG |
-              OTGFS_HPRT_POCCHNG);
-
-  if (((regval & OTGFS_HPRT_PPWR) == 0) && state)
-    {
-      regval |= OTGFS_HPRT_PPWR;
-      stm32l4_putreg(STM32L4_OTGFS_HPRT, regval);
-    }
-
-  if (((regval & OTGFS_HPRT_PPWR) != 0) && !state)
-    {
-      regval &= ~OTGFS_HPRT_PPWR;
-      stm32l4_putreg(STM32L4_OTGFS_HPRT, regval);
-    }
-
-  up_mdelay(200);
-}
-
-/****************************************************************************
- * Name: stm32l4_host_initialize
- *
- * Description:
- *   Initialize/re-initialize hardware for host mode operation.  At present,
- *   this function is called only from stm32l4_hw_initialize().  But if OTG mode
- *   were supported, this function would also be called to swtich between
- *   host and device modes on a connector ID change interrupt.
- *
- * Input Parameters:
- *   priv -- USB host driver private data structure.
- *
- * Returned Value:
- *   None.
- *
- ****************************************************************************/
-
-static void stm32l4_host_initialize(FAR struct stm32l4_usbhost_s *priv)
-{
-  uint32_t regval;
-  uint32_t offset;
-  int i;
-
-  /* Restart the PHY Clock */
-
-  stm32l4_putreg(STM32L4_OTGFS_PCGCCTL, 0);
-
-  /* Initialize Host Configuration (HCFG) register */
-
-  regval  = stm32l4_getreg(STM32L4_OTGFS_HCFG);
-  regval &= ~OTGFS_HCFG_FSLSPCS_MASK;
-  regval |= OTGFS_HCFG_FSLSPCS_FS48MHz;
-  stm32l4_putreg(STM32L4_OTGFS_HCFG, regval);
-
-  /* Reset the host port */
-
-  stm32l4_portreset(priv);
-
-  /* Clear the FS-/LS-only support bit in the HCFG register */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_HCFG);
-  regval &= ~OTGFS_HCFG_FSLSS;
-  stm32l4_putreg(STM32L4_OTGFS_HCFG, regval);
-
-  /* Carve up FIFO memory for the Rx FIFO and the periodic and non-periodic Tx FIFOs */
-  /* Configure Rx FIFO size (GRXFSIZ) */
-
-  stm32l4_putreg(STM32L4_OTGFS_GRXFSIZ, CONFIG_STM32L4_OTGFS_RXFIFO_SIZE);
-  offset = CONFIG_STM32L4_OTGFS_RXFIFO_SIZE;
-
-  /* Setup the host non-periodic Tx FIFO size (HNPTXFSIZ) */
-
-  regval = (offset | (CONFIG_STM32L4_OTGFS_NPTXFIFO_SIZE << OTGFS_HNPTXFSIZ_NPTXFD_SHIFT));
-  stm32l4_putreg(STM32L4_OTGFS_HNPTXFSIZ, regval);
-  offset += CONFIG_STM32L4_OTGFS_NPTXFIFO_SIZE;
-
-  /* Set up the host periodic Tx fifo size register (HPTXFSIZ) */
-
-  regval = (offset | (CONFIG_STM32L4_OTGFS_PTXFIFO_SIZE << OTGFS_HPTXFSIZ_PTXFD_SHIFT));
-  stm32l4_putreg(STM32L4_OTGFS_HPTXFSIZ, regval);
-
-  /* If OTG were supported, we sould need to clear HNP enable bit in the
-   * USB_OTG control register about here.
-   */
-
-  /* Flush all FIFOs */
-
-  stm32l4_flush_txfifos(OTGFS_GRSTCTL_TXFNUM_HALL);
-  stm32l4_flush_rxfifo();
-
-  /* Clear all pending HC Interrupts */
-
-  for (i = 0; i < STM32L4_NHOST_CHANNELS; i++)
-    {
-      stm32l4_putreg(STM32L4_OTGFS_HCINT(i), 0xffffffff);
-      stm32l4_putreg(STM32L4_OTGFS_HCINTMSK(i), 0);
-    }
-
-  /* Driver Vbus +5V (the smoke test).  Should be done elsewhere in OTG
-   * mode.
-   */
-
-  stm32l4_vbusdrive(priv, true);
-
-  /* Enable host interrupts */
-
-  stm32l4_hostinit_enable();
-}
-
-/****************************************************************************
- * Name: stm32l4_sw_initialize
- *
- * Description:
- *   One-time setup of the host driver state structure.
- *
- * Input Parameters:
- *   priv -- USB host driver private data structure.
- *
- * Returned Value:
- *   None.
- *
- ****************************************************************************/
-
-static inline void stm32l4_sw_initialize(FAR struct stm32l4_usbhost_s *priv)
-{
-  FAR struct usbhost_driver_s *drvr;
-  FAR struct usbhost_hubport_s *hport;
-  int i;
-
-  /* Initialize the device operations */
-
-  drvr                 = &priv->drvr;
-  drvr->ep0configure   = stm32l4_ep0configure;
-  drvr->epalloc        = stm32l4_epalloc;
-  drvr->epfree         = stm32l4_epfree;
-  drvr->alloc          = stm32l4_alloc;
-  drvr->free           = stm32l4_free;
-  drvr->ioalloc        = stm32l4_ioalloc;
-  drvr->iofree         = stm32l4_iofree;
-  drvr->ctrlin         = stm32l4_ctrlin;
-  drvr->ctrlout        = stm32l4_ctrlout;
-  drvr->transfer       = stm32l4_transfer;
-#ifdef CONFIG_USBHOST_ASYNCH
-  drvr->asynch         = stm32l4_asynch;
-#endif
-  drvr->cancel         = stm32l4_cancel;
-#ifdef CONFIG_USBHOST_HUB
-  drvr->connect        = stm32l4_connect;
-#endif
-  drvr->disconnect     = stm32l4_disconnect;
-
-  /* Initialize the public port representation */
-
-  hport                = &priv->rhport.hport;
-  hport->drvr          = drvr;
-#ifdef CONFIG_USBHOST_HUB
-  hport->parent        = NULL;
-#endif
-  hport->ep0           = (usbhost_ep_t)&priv->ep0;
-  hport->speed         = USB_SPEED_FULL;
-
-  /* Initialize function address generation logic */
-
-  usbhost_devaddr_initialize(&priv->rhport);
-
-  /* Initialize semaphores */
-
-  sem_init(&priv->pscsem,  0, 0);
-  sem_init(&priv->exclsem, 0, 1);
-
-  /* The pscsem semaphore is used for signaling and, hence, should not have
-   * priority inheritance enabled.
-   */
-
-  sem_setprotocol(&priv->pscsem, SEM_PRIO_NONE);
-
-  /* Initialize the driver state data */
-
-  priv->smstate   = SMSTATE_DETACHED;
-  priv->connected = false;
-  priv->change    = false;
-
-  /* Put all of the channels back in their initial, allocated state */
-
-  memset(priv->chan, 0, STM32L4_MAX_TX_FIFOS * sizeof(struct stm32l4_chan_s));
-
-  /* Initialize each channel */
-
-  for (i = 0; i < STM32L4_MAX_TX_FIFOS; i++)
-    {
-      FAR struct stm32l4_chan_s *chan = &priv->chan[i];
-
-      chan->chidx = i;
-
-      /* The waitsem semaphore is used for signaling and, hence, should not
-       * have priority inheritance enabled.
-       */
-
-      sem_init(&chan->waitsem,  0, 0);
-      sem_setprotocol(&chan->waitsem, SEM_PRIO_NONE);
-    }
-}
-
-/****************************************************************************
- * Name: stm32l4_hw_initialize
- *
- * Description:
- *   One-time setup of the host controller harware for normal operations.
- *
- * Input Parameters:
- *   priv -- USB host driver private data structure.
- *
- * Returned Value:
- *   Zero on success; a negated errno value on failure.
- *
- ****************************************************************************/
-
-static inline int stm32l4_hw_initialize(FAR struct stm32l4_usbhost_s *priv)
-{
-  uint32_t regval;
-  unsigned long timeout;
-
-  /* Set the PHYSEL bit in the GUSBCFG register to select the OTG FS serial
-   * transceiver: "This bit is always 1 with write-only access"
-   */
-
-  regval = stm32l4_getreg(STM32L4_OTGFS_GUSBCFG);
-  regval |= OTGFS_GUSBCFG_PHYSEL;
-  stm32l4_putreg(STM32L4_OTGFS_GUSBCFG, regval);
-
-  /* Reset after a PHY select and set Host mode.  First, wait for AHB master
-   * IDLE state.
-   */
-
-  for (timeout = 0; timeout < STM32L4_READY_DELAY; timeout++)
-    {
-      up_udelay(3);
-      regval = stm32l4_getreg(STM32L4_OTGFS_GRSTCTL);
-      if ((regval & OTGFS_GRSTCTL_AHBIDL) != 0)
-        {
-          break;
-        }
-    }
-
-  /* Then perform the core soft reset. */
-
-  stm32l4_putreg(STM32L4_OTGFS_GRSTCTL, OTGFS_GRSTCTL_CSRST);
-  for (timeout = 0; timeout < STM32L4_READY_DELAY; timeout++)
-    {
-      regval = stm32l4_getreg(STM32L4_OTGFS_GRSTCTL);
-      if ((regval & OTGFS_GRSTCTL_CSRST) == 0)
-        {
-          break;
-        }
-    }
-
-  /* Wait for 3 PHY Clocks */
-
-  up_udelay(3);
-
-  /* Deactivate the power down */
-
-  regval  = (OTGFS_GCCFG_PWRDWN | OTGFS_GCCFG_VBUSASEN | OTGFS_GCCFG_VBUSBSEN);
-#ifndef CONFIG_USBDEV_VBUSSENSING
-  regval |= OTGFS_GCCFG_NOVBUSSENS;
-#endif
-#ifdef CONFIG_STM32L4_OTGFS_SOFOUTPUT
-  regval |= OTGFS_GCCFG_SOFOUTEN;
-#endif
-  stm32l4_putreg(STM32L4_OTGFS_GCCFG, regval);
-  up_mdelay(20);
-
-  /* Initialize OTG features:  In order to support OTP, the HNPCAP and SRPCAP
-   * bits would need to be set in the GUSBCFG register about here.
-   */
-
-  /* Force Host Mode */
-
-  regval  = stm32l4_getreg(STM32L4_OTGFS_GUSBCFG);
-  regval &= ~OTGFS_GUSBCFG_FDMOD;
-  regval |= OTGFS_GUSBCFG_FHMOD;
-  stm32l4_putreg(STM32L4_OTGFS_GUSBCFG, regval);
-  up_mdelay(50);
-
-  /* Initialize host mode and return success */
-
-  stm32l4_host_initialize(priv);
-  return OK;
-}
-
-/****************************************************************************
- * Public Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_otgfshost_initialize
- *
- * Description:
- *   Initialize USB host device controller hardware.
- *
- * Input Parameters:
- *   controller -- If the device supports more than USB host controller, then
- *     this identifies which controller is being initialized.  Normally, this
- *     is just zero.
- *
- * Returned Value:
- *   And instance of the USB host interface.  The controlling task should
- *   use this interface to (1) call the wait() method to wait for a device
- *   to be connected, and (2) call the enumerate() method to bind the device
- *   to a class driver.
- *
- * Assumptions:
- * - This function should called in the initialization sequence in order
- *   to initialize the USB device functionality.
- * - Class drivers should be initialized prior to calling this function.
- *   Otherwise, there is a race condition if the device is already connected.
- *
- ****************************************************************************/
-
-FAR struct usbhost_connection_s *stm32l4_otgfshost_initialize(int controller)
-{
-  /* At present, there is only support for a single OTG FS host. Hence it is
-   * pre-allocated as g_usbhost.  However, in most code, the private data
-   * structure will be referenced using the 'priv' pointer (rather than the
-   * global data) in order to simplify any future support for multiple devices.
-   */
-
-  FAR struct stm32l4_usbhost_s *priv = &g_usbhost;
-
-  /* Sanity checks */
-
-  DEBUGASSERT(controller == 0);
-
-  /* Make sure that interrupts from the OTG FS core are disabled */
-
-  stm32l4_gint_disable();
-
-  /* Reset the state of the host driver */
-
-  stm32l4_sw_initialize(priv);
-
-  /* Alternate function pin configuration.  Here we assume that:
-   *
-   * 1. GPIOA, SYSCFG, and OTG FS peripheral clocking have already been\
-   *    enabled as part of the boot sequence.
-   * 2. Board-specific logic has already enabled other board specific GPIOs
-   *    for things like soft pull-up, VBUS sensing, power controls, and over-
-   *    current detection.
-   */
-
-  /* Configure OTG FS alternate function pins for DM, DP, ID, and SOF.
-   *
-   * PIN* SIGNAL      DIRECTION
-   * ---- ----------- ----------
-   * PA8  OTG_FS_SOF  SOF clock output
-   * PA9  OTG_FS_VBUS VBUS input for device, Driven by external regulator by
-   *                  host (not an alternate function)
-   * PA10 OTG_FS_ID   OTG ID pin (only needed in Dual mode)
-   * PA11 OTG_FS_DM   D- I/O
-   * PA12 OTG_FS_DP   D+ I/O
-   *
-   * *Pins may vary from device-to-device.
-   */
-
-  stm32l4_configgpio(GPIO_OTGFS_DM);
-  stm32l4_configgpio(GPIO_OTGFS_DP);
-  stm32l4_configgpio(GPIO_OTGFS_ID);    /* Only needed for OTG */
-
-  /* SOF output pin configuration is configurable */
-
-#ifdef CONFIG_STM32L4_OTGFS_SOFOUTPUT
-  stm32l4_configgpio(GPIO_OTGFS_SOF);
-#endif
-
-  /* Initialize the USB OTG FS core */
-
-  stm32l4_hw_initialize(priv);
-
-  /* Attach USB host controller interrupt handler */
-
-  if (irq_attach(STM32L4_IRQ_OTGFS, stm32l4_gint_isr, NULL) != 0)
-    {
-      usbhost_trace1(OTGFS_TRACE1_IRQATTACH, 0);
-      return NULL;
-    }
-
-  /* Enable USB OTG FS global interrupts */
-
-  stm32l4_gint_enable();
-
-  /* Enable interrupts at the interrupt controller */
-
-  up_enable_irq(STM32L4_IRQ_OTGFS);
-  return &g_usbconn;
-}
-
-#endif /* CONFIG_USBHOST && CONFIG_STM32L4_OTGFS */
diff --git a/arch/arm/src/nrf52/nrf52_qencoder.c b/arch/arm/src/nrf52/nrf52_qencoder.c
deleted file mode 100644
index b19f5653bd..0000000000
--- a/arch/arm/src/nrf52/nrf52_qencoder.c
+++ /dev/null
@@ -1,1157 +0,0 @@
-/************************************************************************************
- * arch/arm/src/stm32l4/stm32;4_qencoder.c
- *
- *   Copyright (C) 2012 Gregory Nutt. All rights reserved.
- *   Authors: Gregory Nutt <gnutt@nuttx.org>
- *            Diego Sanchez <dsanchez@nx-engineering.com>
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ************************************************************************************/
-
-/************************************************************************************
- * Included Files
- ************************************************************************************/
-
-#include <nuttx/config.h>
-
-#include <stdint.h>
-#include <assert.h>
-#include <errno.h>
-#include <debug.h>
-
-#include <nuttx/arch.h>
-#include <nuttx/irq.h>
-#include <nuttx/sensors/qencoder.h>
-
-#include <arch/board/board.h>
-
-#include "chip.h"
-#include "up_internal.h"
-#include "up_arch.h"
-
-#include "stm32l4.h"
-#include "stm32l4_gpio.h"
-#include "stm32l4_tim.h"
-#include "stm32l4_qencoder.h"
-
-#ifdef CONFIG_QENCODER
-
-/************************************************************************************
- * Pre-processor Definitions
- ************************************************************************************/
-/* Clocking *************************************************************************/
-
-/* Timers ***************************************************************************/
-
-#undef HAVE_32BIT_TIMERS
-#undef HAVE_16BIT_TIMERS
-
-/* On the L4 series, TIM2 and TIM5 are 32-bit.  All of the rest are 16-bit */
-
-/* If TIM2 or TIM5 are enabled, then we have 32-bit timers */
-
-#if defined(CONFIG_STM32L4_TIM2_QE) || defined(CONFIG_STM32L4_TIM5_QE)
-#  define HAVE_32BIT_TIMERS   1
-#endif
-
-/* If TIM1,3,4, or 8 are enabled, then we have 16-bit timers */
-
-#if defined(CONFIG_STM32L4_TIM1_QE) || defined(CONFIG_STM32L4_TIM3_QE) || \
-    defined(CONFIG_STM32L4_TIM4_QE) || defined(CONFIG_STM32L4_TIM8_QE)
-#  define HAVE_16BIT_TIMERS   1
-#endif
-
-/* The width in bits of each timer */
-
-#define TIM1_BITWIDTH         16
-#define TIM2_BITWIDTH         32
-#define TIM3_BITWIDTH         16
-#define TIM4_BITWIDTH         16
-#define TIM5_BITWIDTH         32
-#define TIM8_BITWIDTH         16
-
-/* Do we need to support mixed 16- and 32-bit timers */
-
-#undef HAVE_MIXEDWIDTH_TIMERS
-#if defined(HAVE_16BIT_TIMERS) && defined(HAVE_32BIT_TIMERS)
-#  define HAVE_MIXEDWIDTH_TIMERS 1
-#endif
-
-/* Input filter *********************************************************************/
-
-#ifdef CONFIG_STM32L4_QENCODER_FILTER
-#  if defined(CONFIG_STM32L4_QENCODER_SAMPLE_FDTS)
-#    if defined(CONFIG_STM32L4_QENCODER_SAMPLE_EVENT_1)
-#      define STM32L4_QENCODER_ICF GTIM_CCMR_ICF_NOFILT
-#    endif
-#  elif defined(CONFIG_STM32L4_QENCODER_SAMPLE_CKINT)
-#    if defined(CONFIG_STM32L4_QENCODER_SAMPLE_EVENT_2)
-#      define STM32L4_QENCODER_ICF GTIM_CCMR_ICF_FCKINT2
-#    elif defined(CONFIG_STM32L4_QENCODER_SAMPLE_EVENT_4)
-#      define STM32L4_QENCODER_ICF GTIM_CCMR_ICF_FCKINT4
-#    elif defined(CONFIG_STM32L4_QENCODER_SAMPLE_EVENT_8)
-#      define STM32L4_QENCODER_ICF GTIM_CCMR_ICF_FCKINT8
-#    endif
-#  elif defined(CONFIG_STM32L4_QENCODER_SAMPLE_FDTS_2)
-#    if defined(CONFIG_STM32L4_QENCODER_SAMPLE_EVENT_6)
-#      define STM32L4_QENCODER_ICF GTIM_CCMR_ICF_FDTSd26
-#    elif defined(CONFIG_STM32L4_QENCODER_SAMPLE_EVENT_8)
-#      define STM32L4_QENCODER_ICF GTIM_CCMR_ICF_FDTSd28
-#    endif
-#  elif defined(CONFIG_STM32L4_QENCODER_SAMPLE_FDTS_4)
-#    if defined(CONFIG_STM32L4_QENCODER_SAMPLE_EVENT_6)
-#      define STM32L4_QENCODER_ICF GTIM_CCMR_ICF_FDTSd46
-#    elif defined(CONFIG_STM32L4_QENCODER_SAMPLE_EVENT_8)
-#      define STM32L4_QENCODER_ICF GTIM_CCMR_ICF_FDTSd48
-#    endif
-#  elif defined(CONFIG_STM32L4_QENCODER_SAMPLE_FDTS_8)
-#    if defined(CONFIG_STM32L4_QENCODER_SAMPLE_EVENT_6)
-#      define STM32L4_QENCODER_ICF GTIM_CCMR_ICF_FDTSd86
-#    elif defined(CONFIG_STM32L4_QENCODER_SAMPLE_EVENT_8)
-#      define STM32L4_QENCODER_ICF GTIM_CCMR_ICF_FDTSd88
-#    endif
-#  elif defined(CONFIG_STM32L4_QENCODER_SAMPLE_FDTS_16)
-#    if defined(CONFIG_STM32L4_QENCODER_SAMPLE_EVENT_5)
-#      define STM32L4_QENCODER_ICF GTIM_CCMR_ICF_FDTSd165
-#    elif defined(CONFIG_STM32L4_QENCODER_SAMPLE_EVENT_6)
-#      define STM32L4_QENCODER_ICF GTIM_CCMR_ICF_FDTSd166
-#    elif defined(CONFIG_STM32L4_QENCODER_SAMPLE_EVENT_8)
-#      define STM32L4_QENCODER_ICF GTIM_CCMR_ICF_FDTSd168
-#    endif
-#  elif defined(CONFIG_STM32L4_QENCODER_SAMPLE_FDTS_32)
-#    if defined(CONFIG_STM32L4_QENCODER_SAMPLE_EVENT_5)
-#      define STM32L4_QENCODER_ICF GTIM_CCMR_ICF_FDTSd325
-#    elif defined(CONFIG_STM32L4_QENCODER_SAMPLE_EVENT_6)
-#      define STM32L4_QENCODER_ICF GTIM_CCMR_ICF_FDTSd326
-#    elif defined(CONFIG_STM32L4_QENCODER_SAMPLE_EVENT_8)
-#      define STM32L4_QENCODER_ICF GTIM_CCMR_ICF_FDTSd328
-#    endif
-#  endif
-
-#  ifndef STM32L4_QENCODER_ICF
-#    warning "Invalid encoder filter combination, filter disabled"
-#  endif
-#endif
-
-#ifndef STM32L4_QENCODER_ICF
-#  define STM32L4_QENCODER_ICF GTIM_CCMR_ICF_NOFILT
-#endif
-
-#define STM32L4_GPIO_INPUT_FLOAT (GPIO_INPUT | GPIO_FLOAT)
-
-/* Debug ****************************************************************************/
-/* Non-standard debug that may be enabled just for testing the quadrature encoder */
-
-#ifndef CONFIG_DEBUG_FEATURES
-#  undef CONFIG_DEBUG_SENSORS
-#endif
-
-#ifdef CONFIG_DEBUG_SENSORS
-#  ifdef CONFIG_DEBUG_INFO
-#    define qe_dumpgpio(p,m)    stm32l4_dumpgpio(p,m)
-#  else
-#    define qe_dumpgpio(p,m)
-#  endif
-#else
-#  define qe_dumpgpio(p,m)
-#endif
-
-/************************************************************************************
- * Private Types
- ************************************************************************************/
-
-/* Constant configuration structure that is retained in FLASH */
-
-struct stm32l4_qeconfig_s
-{
-  uint8_t  timid;   /* Timer ID {1,2,3,4,5,8} */
-  uint8_t  irq;     /* Timer update IRQ */
-#ifdef HAVE_MIXEDWIDTH_TIMERS
-  uint8_t  width;   /* Timer width (16- or 32-bits) */
-#endif
-  uint32_t ti1cfg;  /* TI1 input pin configuration (20-bit encoding) */
-  uint32_t ti2cfg;  /* TI2 input pin configuration (20-bit encoding) */
-  uint32_t base;    /* Register base address */
-  uint32_t psc;     /* Encoder pulses prescaler */
-};
-
-/* Overall, RAM-based state structure */
-
-struct stm32l4_lowerhalf_s
-{
-  /* The first field of this state structure must be a pointer to the lower-
-   * half callback structure:
-   */
-
-  FAR const struct qe_ops_s *ops;  /* Lower half callback structure */
-
-  /* STM32 driver-specific fields: */
-
-  FAR const struct stm32l4_qeconfig_s *config; /* static onfiguration */
-
-  bool             inuse;    /* True: The lower-half driver is in-use */
-
-#ifdef HAVE_16BIT_TIMERS
-  volatile int32_t position; /* The current position offset */
-#endif
-};
-
-/************************************************************************************
- * Private Function Prototypes
- ************************************************************************************/
-/* Helper functions */
-
-static uint16_t stm32l4_getreg16(FAR struct stm32l4_lowerhalf_s *priv, int offset);
-static void stm32l4_putreg16(FAR struct stm32l4_lowerhalf_s *priv, int offset, uint16_t value);
-static uint32_t stm32l4_getreg32(FAR struct stm32l4_lowerhalf_s *priv, int offset);
-static void stm32l4_putreg32(FAR struct stm32l4_lowerhalf_s *priv, int offset, uint32_t value);
-
-#if defined(CONFIG_DEBUG_SENSORS) && defined(CONFIG_DEBUG_INFO)
-static void stm32l4_dumpregs(FAR struct stm32l4_lowerhalf_s *priv, FAR const char *msg);
-#else
-#  define stm32l4_dumpregs(priv,msg)
-#endif
-
-static FAR struct stm32l4_lowerhalf_s *stm32l4_tim2lower(int tim);
-
-/* Interrupt handling */
-
-#ifdef HAVE_16BIT_TIMERS
-static int stm32l4_interrupt(int irq, FAR void *context, FAR void *arg);
-#endif
-
-/* Lower-half Quadrature Encoder Driver Methods */
-
-static int stm32l4_setup(FAR struct qe_lowerhalf_s *lower);
-static int stm32l4_shutdown(FAR struct qe_lowerhalf_s *lower);
-static int stm32l4_position(FAR struct qe_lowerhalf_s *lower, FAR int32_t *pos);
-static int stm32l4_reset(FAR struct qe_lowerhalf_s *lower);
-static int stm32l4_ioctl(FAR struct qe_lowerhalf_s *lower, int cmd, unsigned long arg);
-
-/************************************************************************************
- * Private Data
- ************************************************************************************/
-/* The lower half callback structure */
-
-static const struct qe_ops_s g_qecallbacks =
-{
-  .setup    = stm32l4_setup,
-  .shutdown = stm32l4_shutdown,
-  .position = stm32l4_position,
-  .reset    = stm32l4_reset,
-  .ioctl    = stm32l4_ioctl,
-};
-
-/* Per-timer state structures */
-
-#ifdef CONFIG_STM32L4_TIM1_QE
-static const struct stm32l4_qeconfig_s g_tim1config =
-{
-  .timid    = 1,
-  .irq      = STM32L4_IRQ_TIM1UP,
-#ifdef HAVE_MIXEDWIDTH_TIMERS
-  .width    = TIM1_BITWIDTH,
-#endif
-  .base     = STM32L4_TIM1_BASE,
-  .psc      = CONFIG_STM32L4_TIM1_QEPSC,
-  .ti1cfg   = GPIO_TIM1_CH1IN,
-  .ti2cfg   = GPIO_TIM1_CH2IN,
-};
-
-static struct stm32l4_lowerhalf_s g_tim1lower =
-{
-  .ops      = &g_qecallbacks,
-  .config   = &g_tim1config,
-  .inuse    = false,
-};
-
-#endif
-
-#ifdef CONFIG_STM32L4_TIM2_QE
-static const struct stm32l4_qeconfig_s g_tim2config =
-{
-  .timid    = 2,
-  .irq      = STM32L4_IRQ_TIM2,
-#ifdef HAVE_MIXEDWIDTH_TIMERS
-  .width    = TIM2_BITWIDTH,
-#endif
-  .base     = STM32L4_TIM2_BASE,
-  .psc      = CONFIG_STM32L4_TIM2_QEPSC,
-  .ti1cfg   = GPIO_TIM2_CH1IN,
-  .ti2cfg   = GPIO_TIM2_CH2IN,
-};
-
-static struct stm32l4_lowerhalf_s g_tim2lower =
-{
-  .ops      = &g_qecallbacks,
-  .config   = &g_tim2config,
-  .inuse    = false,
-};
-
-#endif
-
-#ifdef CONFIG_STM32L4_TIM3_QE
-static const struct stm32l4_qeconfig_s g_tim3config =
-{
-  .timid    = 3,
-  .irq      = STM32L4_IRQ_TIM3,
-#ifdef HAVE_MIXEDWIDTH_TIMERS
-  .width    = TIM3_BITWIDTH,
-#endif
-  .base     = STM32L4_TIM3_BASE,
-  .psc      = CONFIG_STM32L4_TIM3_QEPSC,
-  .ti1cfg   = GPIO_TIM3_CH1IN,
-  .ti2cfg   = GPIO_TIM3_CH2IN,
-};
-
-static struct stm32l4_lowerhalf_s g_tim3lower =
-{
-  .ops      = &g_qecallbacks,
-  .config   = &g_tim3config,
-  .inuse    = false,
-};
-
-#endif
-
-#ifdef CONFIG_STM32L4_TIM4_QE
-static const struct stm32l4_qeconfig_s g_tim4config =
-{
-  .timid    = 4,
-  .irq      = STM32L4_IRQ_TIM4,
-#ifdef HAVE_MIXEDWIDTH_TIMERS
-  .width    = TIM4_BITWIDTH,
-#endif
-  .base     = STM32L4_TIM4_BASE,
-  .psc      = CONFIG_STM32L4_TIM4_QEPSC,
-  .ti1cfg   = GPIO_TIM4_CH1IN,
-  .ti2cfg   = GPIO_TIM4_CH2IN,
-};
-
-static struct stm32l4_lowerhalf_s g_tim4lower =
-{
-  .ops      = &g_qecallbacks,
-  .config   = &g_tim4config,
-  .inuse    = false,
-};
-
-#endif
-
-#ifdef CONFIG_STM32L4_TIM5_QE
-static const struct stm32l4_qeconfig_s g_tim5config =
-{
-  .timid    = 5,
-  .irq      = STM32L4_IRQ_TIM5,
-#ifdef HAVE_MIXEDWIDTH_TIMERS
-  .width    = TIM5_BITWIDTH,
-#endif
-  .base     = STM32L4_TIM5_BASE,
-  .psc      = CONFIG_STM32L4_TIM5_QEPSC,
-  .ti1cfg   = GPIO_TIM5_CH1IN,
-  .ti2cfg   = GPIO_TIM5_CH2IN,
-};
-
-static struct stm32l4_lowerhalf_s g_tim5lower =
-{
-  .ops      = &g_qecallbacks,
-  .config   = &g_tim5config,
-  .inuse    = false,
-};
-
-#endif
-
-#ifdef CONFIG_STM32L4_TIM8_QE
-static const struct stm32l4_qeconfig_s g_tim8config =
-{
-  .timid    = 8,
-  .irq      = STM32L4_IRQ_TIM8UP,
-#ifdef HAVE_MIXEDWIDTH_TIMERS
-  .width    = TIM8_BITWIDTH,
-#endif
-  .base     = STM32L4_TIM8_BASE,
-  .psc      = CONFIG_STM32L4_TIM8_QEPSC,
-  .ti1cfg   = GPIO_TIM8_CH1IN,
-  .ti2cfg   = GPIO_TIM8_CH2IN,
-};
-
-static struct stm32l4_lowerhalf_s g_tim8lower =
-{
-  .ops      = &g_qecallbacks,
-  .config   = &g_tim8config,
-  .inuse    = false,
-};
-
-#endif
-
-/************************************************************************************
- * Private Functions
- ************************************************************************************/
-
-/************************************************************************************
- * Name: stm32l4_getreg16
- *
- * Description:
- *   Read the value of a 16-bit timer register.
- *
- * Input Parameters:
- *   priv - A reference to the lower half status
- *   offset - The offset to the register to read
- *
- * Returned Value:
- *   The current contents of the specified register
- *
- ************************************************************************************/
-
-static uint16_t stm32l4_getreg16(struct stm32l4_lowerhalf_s *priv, int offset)
-{
-  return getreg16(priv->config->base + offset);
-}
-
-/************************************************************************************
- * Name: stm32l4_putreg16
- *
- * Description:
- *   Write a value to a 16-bit timer register.
- *
- * Input Parameters:
- *   priv - A reference to the lower half status
- *   offset - The offset to the register to read
- *
- * Returned Value:
- *   None
- *
- ************************************************************************************/
-
-static void stm32l4_putreg16(FAR struct stm32l4_lowerhalf_s *priv, int offset,
-                             uint16_t value)
-{
-  putreg16(value, priv->config->base + offset);
-}
-
-/************************************************************************************
- * Name: stm32l4_getreg32
- *
- * Description:
- *   Read the value of a 32-bit timer register.  This applies only for the STM32 F4
- *   32-bit registers (CNT, ARR, CRR1-4) in the 32-bit timers TIM2-5 (but works OK
- *   with the 16-bit TIM1,8 and F1 registers as well).
- *
- * Input Parameters:
- *   priv - A reference to the lower half status
- *   offset - The offset to the register to read
- *
- * Returned Value:
- *   The current contents of the specified register
- *
- ************************************************************************************/
-
-static uint32_t stm32l4_getreg32(FAR struct stm32l4_lowerhalf_s *priv, int offset)
-{
-  return getreg32(priv->config->base + offset);
-}
-
-/************************************************************************************
- * Name: stm32l4_putreg16
- *
- * Description:
- *   Write a value to a 32-bit timer register.  This applies only for the STM32 F4
- *   32-bit registers (CNT, ARR, CRR1-4) in the 32-bit timers TIM2-5 (but works OK
- *   with the 16-bit TIM1,8 and F1 registers).
- *
- * Input Parameters:
- *   priv - A reference to the lower half status
- *   offset - The offset to the register to read
- *
- * Returned Value:
- *   None
- *
- ************************************************************************************/
-
-static void stm32l4_putreg32(FAR struct stm32l4_lowerhalf_s *priv, int offset,
-                             uint32_t value)
-{
-  putreg32(value, priv->config->base + offset);
-}
-
-/****************************************************************************
- * Name: stm32l4_dumpregs
- *
- * Description:
- *   Dump all timer registers.
- *
- * Input parameters:
- *   priv - A reference to the QENCODER block status
- *
- * Returned Value:
- *   None
- *
- ****************************************************************************/
-
-#if defined(CONFIG_DEBUG_SENSORS) && defined(CONFIG_DEBUG_INFO)
-static void stm32l4_dumpregs(FAR struct stm32l4_lowerhalf_s *priv,
-                             FAR const char *msg)
-{
-  sninfo("%s:\n", msg);
-  sninfo("  CR1: %04x CR2:  %04x SMCR:  %08x DIER:  %04x\n",
-         stm32l4_getreg16(priv, STM32L4_GTIM_CR1_OFFSET),
-         stm32l4_getreg16(priv, STM32L4_GTIM_CR2_OFFSET),
-         stm32l4_getreg32(priv, STM32L4_GTIM_SMCR_OFFSET),
-         stm32l4_getreg16(priv, STM32L4_GTIM_DIER_OFFSET));
-  sninfo("   SR: %04x EGR:  %04x CCMR1: %08x CCMR2: %08x\n",
-         stm32l4_getreg16(priv, STM32L4_GTIM_SR_OFFSET),
-         stm32l4_getreg16(priv, STM32L4_GTIM_EGR_OFFSET),
-         stm32l4_getreg32(priv, STM32L4_GTIM_CCMR1_OFFSET),
-         stm32l4_getreg32(priv, STM32L4_GTIM_CCMR2_OFFSET));
-  sninfo(" CCER: %04x CNT:  %08x PSC:   %04x ARR:   %08x\n",
-         stm32l4_getreg16(priv, STM32L4_GTIM_CCER_OFFSET),
-         stm32l4_getreg32(priv, STM32L4_GTIM_CNT_OFFSET),
-         stm32l4_getreg16(priv, STM32L4_GTIM_PSC_OFFSET),
-         stm32l4_getreg32(priv, STM32L4_GTIM_ARR_OFFSET));
-  sninfo(" CCR1: %08x CCR2: %08x\n",
-         stm32l4_getreg32(priv, STM32L4_GTIM_CCR1_OFFSET),
-         stm32l4_getreg32(priv, STM32L4_GTIM_CCR2_OFFSET));
-  sninfo(" CCR3: %08x CCR4: %08x\n",
-         stm32l4_getreg32(priv, STM32L4_GTIM_CCR3_OFFSET),
-         stm32l4_getreg32(priv, STM32L4_GTIM_CCR4_OFFSET));
-#if defined(CONFIG_STM32L4_TIM1_QE) || defined(CONFIG_STM32L4_TIM8_QE)
-  if (priv->config->timid == 1 || priv->config->timid == 8)
-    {
-      sninfo("  RCR: %04x BDTR: %04x DCR:   %04x DMAR:  %04x\n",
-             stm32l4_getreg16(priv, STM32L4_ATIM_RCR_OFFSET),
-             stm32l4_getreg16(priv, STM32L4_ATIM_BDTR_OFFSET),
-             stm32l4_getreg16(priv, STM32L4_ATIM_DCR_OFFSET),
-             stm32l4_getreg16(priv, STM32L4_ATIM_DMAR_OFFSET));
-    }
-  else
-#endif
-    {
-      sninfo("  DCR: %04x DMAR: %04x\n",
-             stm32l4_getreg16(priv, STM32L4_GTIM_DCR_OFFSET),
-             stm32l4_getreg16(priv, STM32L4_GTIM_DMAR_OFFSET));
-    }
-}
-#endif
-
-/************************************************************************************
- * Name: stm32l4_tim2lower
- *
- * Description:
- *   Map a timer number to a device structure
- *
- ************************************************************************************/
-
-static FAR struct stm32l4_lowerhalf_s *stm32l4_tim2lower(int tim)
-{
-  switch (tim)
-    {
-#ifdef CONFIG_STM32L4_TIM1_QE
-      case 1:
-        return &g_tim1lower;
-#endif
-#ifdef CONFIG_STM32L4_TIM2_QE
-      case 2:
-        return &g_tim2lower;
-#endif
-#ifdef CONFIG_STM32L4_TIM3_QE
-      case 3:
-        return &g_tim3lower;
-#endif
-#ifdef CONFIG_STM32L4_TIM4_QE
-      case 4:
-        return &g_tim4lower;
-#endif
-#ifdef CONFIG_STM32L4_TIM5_QE
-      case 5:
-        return &g_tim5lower;
-#endif
-#ifdef CONFIG_STM32L4_TIM8_QE
-      case 8:
-        return &g_tim8lower;
-#endif
-      default:
-        return NULL;
-    }
-}
-
-/************************************************************************************
- * Name: stm32l4_interrupt
- *
- * Description:
- *   Common timer interrupt handling.  NOTE: Only 16-bit timers require timer
- *   interrupts.
- *
- ************************************************************************************/
-
-#ifdef HAVE_16BIT_TIMERS
-static int stm32l4_interrupt(int irq, FAR void *context, FAR void *arg)
-{
-  FAR struct stm32l4_lowerhalf_s *priv = (FAR struct stm32l4_lowerhalf_s *)arg;
-  uint16_t regval;
-
-  DEBUGASSERT(priv != NULL);
-
-  /* Verify that this is an update interrupt.  Nothing else is expected. */
-
-  regval = stm32l4_getreg16(priv, STM32L4_GTIM_SR_OFFSET);
-  DEBUGASSERT((regval & ATIM_SR_UIF) != 0);
-
-  /* Clear the UIF interrupt bit */
-
-  stm32l4_putreg16(priv, STM32L4_GTIM_SR_OFFSET, regval & ~GTIM_SR_UIF);
-
-  /* Check the direction bit in the CR1 register and add or subtract the
-   * maximum value, as appropriate.
-   */
-
-  regval = stm32l4_getreg16(priv, STM32L4_GTIM_CR1_OFFSET);
-  if ((regval & ATIM_CR1_DIR) != 0)
-    {
-      priv->position -= (int32_t)0x0000ffff;
-    }
-  else
-    {
-      priv->position += (int32_t)0x0000ffff;
-    }
-
-  return OK;
-}
-#endif
-
-/************************************************************************************
- * Name: stm32l4_setup
- *
- * Description:
- *   This method is called when the driver is opened.  The lower half driver
- *   should configure and initialize the device so that it is ready for use.
- *   The initial position value should be zero. *
- *
- ************************************************************************************/
-
-static int stm32l4_setup(FAR struct qe_lowerhalf_s *lower)
-{
-  FAR struct stm32l4_lowerhalf_s *priv = (FAR struct stm32l4_lowerhalf_s *)lower;
-  uint16_t dier;
-  uint32_t smcr;
-  uint32_t ccmr1;
-  uint16_t ccer;
-  uint16_t cr1;
-#ifdef HAVE_16BIT_TIMERS
-  uint16_t regval;
-  int ret;
-#endif
-
-  /* NOTE: Clocking should have been enabled in the low-level RCC logic at boot-up */
-
-  /* Timer base configuration */
-
-  cr1 = stm32l4_getreg16(priv, STM32L4_GTIM_CR1_OFFSET);
-
-  /* Clear the direction bit (0=count up) and select the Counter Mode (0=Edge aligned)
-   * (Timers 2-5 and 1-8 only)
-   */
-
-  cr1 &= ~(GTIM_CR1_DIR | GTIM_CR1_CMS_MASK);
-  stm32l4_putreg16(priv, STM32L4_GTIM_CR1_OFFSET, cr1);
-
-  /* Set the Autoreload value */
-
-#if defined(HAVE_MIXEDWIDTH_TIMERS)
-  if (priv->config->width == 32)
-    {
-      stm32l4_putreg32(priv, STM32L4_GTIM_ARR_OFFSET, 0xffffffff);
-    }
-  else
-    {
-      stm32l4_putreg16(priv, STM32L4_GTIM_ARR_OFFSET, 0xffff);
-    }
-#elif defined(HAVE_32BIT_TIMERS)
-  stm32l4_putreg32(priv, STM32L4_GTIM_ARR_OFFSET, 0xffffffff);
-#else
-  stm32l4_putreg16(priv, STM32L4_GTIM_ARR_OFFSET, 0xffff);
-#endif
-
-  /* Set the timer prescaler value.
-   *
-   * Previously, and still in the stm32fx driver, the clock input value (CLKIN)
-   * was based on the peripheral clock (PCLK) and a multiplier.
-   * These CLKIN values are provided in the board.h file.
-   * The prescaler value is then that CLKIN value divided by the configured
-   * CLKOUT value (minus one).
-   *
-   * It was determined that this configuration makes no sense for a qencoder.
-   * If we are doing precise shaft positioning, each qe pulse is important.
-   * So the STM32L4 has direct config control on the pulse count prescaler,
-   * instead of deriving this value from an obscure "output" setting AND the
-   * timer input clock. This input clock just limits the incoming pulse rate,
-   * which should be lower than the peripheral clock due to resynchronization,
-   * but it is the responsibility of the system designer to decide the
-   * correct prescaler value, because it has a direct influence on the
-   * encoder resolution.
-   */
-
-  stm32l4_putreg16(priv, STM32L4_GTIM_PSC_OFFSET, (uint16_t)priv->config->psc);
-
-#if defined(CONFIG_STM32L4_TIM1_QE) || defined(CONFIG_STM32L4_TIM8_QE)
-  if (priv->config->timid == 1 || priv->config->timid == 8)
-    {
-      /* Clear the Repetition Counter value */
-
-      stm32l4_putreg16(priv, STM32L4_ATIM_RCR_OFFSET, 0);
-    }
-#endif
-
-  /* Generate an update event to reload the Prescaler
-   * and the repetition counter (only for TIM1 and TIM8) value immediately
-   */
-
-  stm32l4_putreg16(priv, STM32L4_GTIM_EGR_OFFSET, GTIM_EGR_UG);
-
-  /* GPIO pin configuration */
-
-  stm32l4_configgpio(priv->config->ti1cfg);
-  stm32l4_configgpio(priv->config->ti2cfg);
-
-  /* Set the encoder Mode 3 */
-
-  smcr = stm32l4_getreg32(priv, STM32L4_GTIM_SMCR_OFFSET);
-  smcr &= ~GTIM_SMCR_SMS_MASK;
-  smcr |= GTIM_SMCR_ENCMD3;
-  stm32l4_putreg32(priv, STM32L4_GTIM_SMCR_OFFSET, smcr);
-
-  /* TI1 Channel Configuration */
-  /* Disable the Channel 1: Reset the CC1E Bit */
-
-  ccer  = stm32l4_getreg16(priv, STM32L4_GTIM_CCER_OFFSET);
-  ccer &= ~GTIM_CCER_CC1E;
-  stm32l4_putreg16(priv, STM32L4_GTIM_CCER_OFFSET, ccer);
-
-  ccmr1 = stm32l4_getreg32(priv, STM32L4_GTIM_CCMR1_OFFSET);
-  ccer = stm32l4_getreg16(priv, STM32L4_GTIM_CCER_OFFSET);
-
-  /* Select the Input IC1=TI1 and set the filter fSAMPLING=fDTS/4, N=6 */
-
-  ccmr1 &= ~(GTIM_CCMR1_CC1S_MASK | GTIM_CCMR1_IC1F_MASK);
-  ccmr1 |= GTIM_CCMR_CCS_CCIN1 << GTIM_CCMR1_CC1S_SHIFT;
-  ccmr1 |= STM32L4_QENCODER_ICF << GTIM_CCMR1_IC1F_SHIFT;
-
-  /* Select the Polarity=rising and set the CC1E Bit */
-
-  ccer &= ~(GTIM_CCER_CC1P | GTIM_CCER_CC1NP);
-  ccer |= GTIM_CCER_CC1E;
-
-  /* Write to TIM CCMR1 and CCER registers */
-
-  stm32l4_putreg32(priv, STM32L4_GTIM_CCMR1_OFFSET, ccmr1);
-  stm32l4_putreg16(priv, STM32L4_GTIM_CCER_OFFSET, ccer);
-
-  /* Set the Input Capture Prescaler value: Capture performed each time an
-   * edge is detected on the capture input.
-   */
-
-  ccmr1  = stm32l4_getreg32(priv, STM32L4_GTIM_CCMR1_OFFSET);
-  ccmr1 &= ~GTIM_CCMR1_IC1PSC_MASK;
-  ccmr1 |= (GTIM_CCMR_ICPSC_NOPSC << GTIM_CCMR1_IC1PSC_SHIFT);
-  stm32l4_putreg32(priv, STM32L4_GTIM_CCMR1_OFFSET, ccmr1);
-
-  /* TI2 Channel Configuration */
-  /* Disable the Channel 2: Reset the CC2E Bit */
-
-  ccer  = stm32l4_getreg16(priv, STM32L4_GTIM_CCER_OFFSET);
-  ccer &= ~GTIM_CCER_CC2E;
-  stm32l4_putreg16(priv, STM32L4_GTIM_CCER_OFFSET, ccer);
-
-  ccmr1 = stm32l4_getreg32(priv, STM32L4_GTIM_CCMR1_OFFSET);
-  ccer  = stm32l4_getreg16(priv, STM32L4_GTIM_CCER_OFFSET);
-
-  /* Select the Input IC2=TI2 and set the filter fSAMPLING=fDTS/4, N=6 */
-
-  ccmr1 &= ~(GTIM_CCMR1_CC2S_MASK | GTIM_CCMR1_IC2F_MASK);
-  ccmr1 |= GTIM_CCMR_CCS_CCIN1 << GTIM_CCMR1_CC2S_SHIFT;
-  ccmr1 |= STM32L4_QENCODER_ICF << GTIM_CCMR1_IC2F_SHIFT;
-
-  /* Select the Polarity=rising and set the CC2E Bit */
-
-  ccer &= ~(GTIM_CCER_CC2P | GTIM_CCER_CC2NP);
-  ccer |= GTIM_CCER_CC2E;
-
-  /* Write to TIM CCMR1 and CCER registers */
-
-  stm32l4_putreg32(priv, STM32L4_GTIM_CCMR1_OFFSET, ccmr1);
-  stm32l4_putreg16(priv, STM32L4_GTIM_CCER_OFFSET, ccer);
-
-  /* Set the Input Capture Prescaler value: Capture performed each time an
-   * edge is detected on the capture input.
-   */
-
-  ccmr1  = stm32l4_getreg32(priv, STM32L4_GTIM_CCMR1_OFFSET);
-  ccmr1 &= ~GTIM_CCMR1_IC2PSC_MASK;
-  ccmr1 |= (GTIM_CCMR_ICPSC_NOPSC << GTIM_CCMR1_IC2PSC_SHIFT);
-  stm32l4_putreg32(priv, STM32L4_GTIM_CCMR1_OFFSET, ccmr1);
-
-  /* Disable the update interrupt */
-
-  dier = stm32l4_getreg16(priv, STM32L4_GTIM_DIER_OFFSET);
-  dier &= ~GTIM_DIER_UIE;
-  stm32l4_putreg16(priv, STM32L4_GTIM_DIER_OFFSET, dier);
-
-  /* There is no need for interrupts with 32-bit timers */
-
-#ifdef HAVE_16BIT_TIMERS
-#ifdef HAVE_MIXEDWIDTH_TIMERS
-  if (priv->config->width != 32)
-#endif
-    {
-      /* Attach the interrupt handler */
-
-      ret = irq_attach(priv->config->irq, stm32l4_interrupt, priv);
-      if (ret < 0)
-        {
-          stm32l4_shutdown(lower);
-          return ret;
-        }
-
-      /* Enable the update/global interrupt at the NVIC */
-
-      up_enable_irq(priv->config->irq);
-    }
-#endif
-
-  /* Reset the Update Disable Bit */
-
-  cr1 = stm32l4_getreg16(priv, STM32L4_GTIM_CR1_OFFSET);
-  cr1 &= ~GTIM_CR1_UDIS;
-  stm32l4_putreg16(priv, STM32L4_GTIM_CR1_OFFSET, cr1);
-
-  /* Reset the URS Bit */
-
-  cr1 &= ~GTIM_CR1_URS;
-  stm32l4_putreg16(priv, STM32L4_GTIM_CR1_OFFSET, cr1);
-
-  /* There is no need for interrupts with 32-bit timers */
-
-#ifdef HAVE_16BIT_TIMERS
-#ifdef HAVE_MIXEDWIDTH_TIMERS
-  if (priv->config->width != 32)
-#endif
-    {
-      /* Clear any pending update interrupts */
-
-      regval = stm32l4_getreg16(priv, STM32L4_GTIM_SR_OFFSET);
-      stm32l4_putreg16(priv, STM32L4_GTIM_SR_OFFSET, regval & ~GTIM_SR_UIF);
-
-      /* Then enable the update interrupt */
-
-      dier = stm32l4_getreg16(priv, STM32L4_GTIM_DIER_OFFSET);
-      dier |= GTIM_DIER_UIE;
-      stm32l4_putreg16(priv, STM32L4_GTIM_DIER_OFFSET, dier);
-    }
-#endif
-
-  /* Enable the TIM Counter */
-
-  cr1 = stm32l4_getreg16(priv, STM32L4_GTIM_CR1_OFFSET);
-  cr1 |= GTIM_CR1_CEN;
-  stm32l4_putreg16(priv, STM32L4_GTIM_CR1_OFFSET, cr1);
-
-  stm32l4_dumpregs(priv, "After setup");
-
-  return OK;
-}
-
-/************************************************************************************
- * Name: stm32l4_shutdown
- *
- * Description:
- *   This method is called when the driver is closed.  The lower half driver
- *   should stop data collection, free any resources, disable timer hardware, and
- *   put the system into the lowest possible power usage state *
- *
- ************************************************************************************/
-
-static int stm32l4_shutdown(FAR struct qe_lowerhalf_s *lower)
-{
-  FAR struct stm32l4_lowerhalf_s *priv = (FAR struct stm32l4_lowerhalf_s *)lower;
-  irqstate_t flags;
-  uint32_t regaddr;
-  uint32_t regval;
-  uint32_t resetbit;
-  uint32_t pincfg;
-
-  /* Disable the update/global interrupt at the NVIC */
-
-  flags = enter_critical_section();
-  up_disable_irq(priv->config->irq);
-
-  /* Detach the interrupt handler */
-
-  (void)irq_detach(priv->config->irq);
-
-  /* Disable interrupts momentary to stop any ongoing timer processing and
-   * to prevent any concurrent access to the reset register.
-   */
-
-  /* Disable further interrupts and stop the timer */
-
-  stm32l4_putreg16(priv, STM32L4_GTIM_DIER_OFFSET, 0);
-  stm32l4_putreg16(priv, STM32L4_GTIM_SR_OFFSET, 0);
-
-  /* Determine which timer to reset */
-
-  switch (priv->config->timid)
-    {
-#ifdef CONFIG_STM32L4_TIM1_QE
-      case 1:
-        regaddr  = STM32L4_RCC_APB2RSTR;
-        resetbit = RCC_APB2RSTR_TIM1RST;
-        break;
-#endif
-#ifdef CONFIG_STM32L4_TIM2_QE
-      case 2:
-        regaddr  = STM32L4_RCC_APB1RSTR1;
-        resetbit = RCC_APB1RSTR1_TIM2RST;
-        break;
-#endif
-#ifdef CONFIG_STM32L4_TIM3_QE
-      case 3:
-        regaddr  = STM32L4_RCC_APB1RSTR1;
-        resetbit = RCC_APB1RSTR1_TIM3RST;
-        break;
-#endif
-#ifdef CONFIG_STM32L4_TIM4_QE
-      case 4:
-        regaddr  = STM32L4_RCC_APB1RSTR1;
-        resetbit = RCC_APB1RSTR1_TIM4RST;
-        break;
-#endif
-#ifdef CONFIG_STM32L4_TIM5_QE
-      case 5:
-        regaddr  = STM32L4_RCC_APB1RSTR1;
-        resetbit = RCC_APB1RSTR1_TIM5RST;
-        break;
-#endif
-#ifdef CONFIG_STM32L4_TIM8_QE
-      case 8:
-        regaddr  = STM32L4_RCC_APB2RSTR;
-        resetbit = RCC_APB2RSTR_TIM8RST;
-        break;
-#endif
-      default:
-        return -EINVAL;
-    }
-
-  /* Reset the timer - stopping the output and putting the timer back
-   * into a state where stm32l4_start() can be called.
-   */
-
-  regval  = getreg32(regaddr);
-  regval |= resetbit;
-  putreg32(regval, regaddr);
-
-  regval &= ~resetbit;
-  putreg32(regval, regaddr);
-  leave_critical_section(flags);
-
-  sninfo("regaddr: %08x resetbit: %08x\n", regaddr, resetbit);
-  stm32l4_dumpregs(priv, "After stop");
-
-  /* Put the TI1 GPIO pin back to its default state */
-
-  pincfg  = priv->config->ti1cfg & (GPIO_PORT_MASK | GPIO_PIN_MASK);
-  pincfg |= STM32L4_GPIO_INPUT_FLOAT;
-
-  stm32l4_configgpio(pincfg);
-
-  /* Put the TI2 GPIO pin back to its default state */
-
-  pincfg  = priv->config->ti2cfg & (GPIO_PORT_MASK | GPIO_PIN_MASK);
-  pincfg |= STM32L4_GPIO_INPUT_FLOAT;
-
-  stm32l4_configgpio(pincfg);
-  return OK;
-}
-
-/************************************************************************************
- * Name: stm32l4_position
- *
- * Description:
- *   Return the current position measurement.
- *
- ************************************************************************************/
-
-static int stm32l4_position(FAR struct qe_lowerhalf_s *lower, FAR int32_t *pos)
-{
-  FAR struct stm32l4_lowerhalf_s *priv = (FAR struct stm32l4_lowerhalf_s *)lower;
-#ifdef HAVE_16BIT_TIMERS
-  int32_t position;
-  int32_t verify;
-  uint32_t count;
-
-  DEBUGASSERT(lower && priv->inuse);
-
-  /* Loop until we are certain that no interrupt occurred between samples */
-
-  do
-    {
-      /* Don't let another task pre-empt us until we get the measurement.  The timer
-       * interrupt may still be processed
-       */
-
-      sched_lock();
-      position = priv->position;
-      count    = stm32l4_getreg32(priv, STM32L4_GTIM_CNT_OFFSET);
-      verify   = priv->position;
-      sched_unlock();
-    }
-  while (position != verify);
-
-  /* Return the position measurement */
-
-  *pos = position + (int32_t)count;
-#else
-  /* Return the counter value */
-
-  *pos = (int32_t)stm32l4_getreg32(priv, STM32L4_GTIM_CNT_OFFSET);
-#endif
-  return OK;
-}
-
-/************************************************************************************
- * Name: stm32l4_reset
- *
- * Description:
- *   Reset the position measurement to zero.
- *
- ************************************************************************************/
-
-static int stm32l4_reset(FAR struct qe_lowerhalf_s *lower)
-{
-  FAR struct stm32l4_lowerhalf_s *priv = (FAR struct stm32l4_lowerhalf_s *)lower;
-#ifdef HAVE_16BIT_TIMERS
-  irqstate_t flags;
-
-  sninfo("Resetting position to zero\n");
-  DEBUGASSERT(lower && priv->inuse);
-
-  /* Reset the timer and the counter.  Interrupts are disabled to make this atomic
-   * (if possible)
-   */
-
-  flags = enter_critical_section();
-  stm32l4_putreg32(priv, STM32L4_GTIM_CNT_OFFSET, 0);
-  priv->position = 0;
-  leave_critical_section(flags);
-#else
-  sninfo("Resetting position to zero\n");
-  DEBUGASSERT(lower && priv->inuse);
-
-  /* Reset the counter to zero */
-
-  stm32l4_putreg32(priv, STM32L4_GTIM_CNT_OFFSET, 0);
-#endif
-  return OK;
-}
-
-/************************************************************************************
- * Name: stm32l4_ioctl
- *
- * Description:
- *   Lower-half logic may support platform-specific ioctl commands
- *
- ************************************************************************************/
-
-static int stm32l4_ioctl(FAR struct qe_lowerhalf_s *lower, int cmd, unsigned long arg)
-{
-  /* No ioctl commands supported */
-
-  /* TODO add an IOCTL to control the encoder pulse count prescaler */
-
-  return -ENOTTY;
-}
-
-/************************************************************************************
- * Public Functions
- ************************************************************************************/
-
-/************************************************************************************
- * Name: stm32l4_qeinitialize
- *
- * Description:
- *   Initialize a quadrature encoder interface.  This function must be called from
- *   board-specific logic.
- *
- * Input Parameters:
- *   devpath - The full path to the driver to register. E.g., "/dev/qe0"
- *   tim     - The timer number to used.  'tim' must be an element of {1,2,3,4,5,8}
- *
- * Returned Values:
- *   Zero on success; A negated errno value is returned on failure.
- *
- ************************************************************************************/
-
-int stm32l4_qeinitialize(FAR const char *devpath, int tim)
-{
-  FAR struct stm32l4_lowerhalf_s *priv;
-  int ret;
-
-  /* Find the pre-allocated timer state structure corresponding to this timer */
-
-  priv = stm32l4_tim2lower(tim);
-  if (!priv)
-    {
-      snerr("ERROR: TIM%d support not configured\n", tim);
-      return -ENXIO;
-    }
-
-  /* Make sure that it is available */
-
-  if (priv->inuse)
-    {
-      snerr("ERROR: TIM%d is in-use\n", tim);
-      return -EBUSY;
-    }
-
-  /* Register the priv-half driver */
-
-  ret = qe_register(devpath, (FAR struct qe_lowerhalf_s *)priv);
-  if (ret < 0)
-    {
-      snerr("ERROR: qe_register failed: %d\n", ret);
-      return ret;
-    }
-
-  /* Make sure that the timer is in the shutdown state */
-
-  stm32l4_shutdown((FAR struct qe_lowerhalf_s *)priv);
-
-  /* The driver is now in-use */
-
-  priv->inuse = true;
-  return OK;
-}
-
-#endif /* CONFIG_QENCODER */
diff --git a/arch/arm/src/nrf52/nrf52_qencoder.h b/arch/arm/src/nrf52/nrf52_qencoder.h
deleted file mode 100644
index fca0b88b8b..0000000000
--- a/arch/arm/src/nrf52/nrf52_qencoder.h
+++ /dev/null
@@ -1,141 +0,0 @@
-/************************************************************************************
- * arch/arm/src/stm32l4/stm32l4_qencoder.h
- *
- *   Copyright (C) 2012 Gregory Nutt. All rights reserved.
- *   Author: Gregory Nutt <gnutt@nuttx.org>
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ************************************************************************************/
-
-#ifndef __ARCH_ARM_SRC_STM32L4_STM32L4_QENCODER_H
-#define __ARCH_ARM_SRC_STM32L4_STM32L4_QENCODER_H
-
-/************************************************************************************
- * Included Files
- ************************************************************************************/
-
-#include <nuttx/config.h>
-
-#include "chip.h"
-
-#ifdef CONFIG_QENCODER
-
-/************************************************************************************
- * Included Files
- ************************************************************************************/
-/* Timer devices may be used for different purposes.  One special purpose is as
- * a quadrature encoder input device.  If CONFIG_STM32L4_TIMn is defined then the
- * CONFIG_STM32L4_TIMn_QE must also be defined to indicate that timer "n" is intended
- * to be used for as a quadrature encoder.
- */
-
-#ifndef CONFIG_STM32L4_TIM1
-#  undef CONFIG_STM32L4_TIM1_QE
-#endif
-#ifndef CONFIG_STM32L4_TIM2
-#  undef CONFIG_STM32L4_TIM2_QE
-#endif
-#ifndef CONFIG_STM32L4_TIM3
-#  undef CONFIG_STM32L4_TIM3_QE
-#endif
-#ifndef CONFIG_STM32L4_TIM4
-#  undef CONFIG_STM32L4_TIM4_QE
-#endif
-#ifndef CONFIG_STM32L4_TIM5
-#  undef CONFIG_STM32L4_TIM5_QE
-#endif
-#ifndef CONFIG_STM32L4_TIM8
-#  undef CONFIG_STM32L4_TIM8_QE
-#endif
-
-/* Only timers 2-5, and 1 & 8 can be used as a quadrature encoder
- */
-
-#undef CONFIG_STM32L4_TIM6_QE
-#undef CONFIG_STM32L4_TIM7_QE
-#undef CONFIG_STM32L4_TIM9_QE
-#undef CONFIG_STM32L4_TIM10_QE
-#undef CONFIG_STM32L4_TIM11_QE
-#undef CONFIG_STM32L4_TIM12_QE
-#undef CONFIG_STM32L4_TIM13_QE
-#undef CONFIG_STM32L4_TIM14_QE
-
-/* Clock out frequency.  This value is used to calculation the timer CLKIN in
- * prescaler value.
- */
-
-#ifndef CONFIG_STM32L4_TIM1_QECLKOUT
-#  define CONFIG_STM32L4_TIM1_QECLKOUT 28000000
-#endif
-
-#ifndef CONFIG_STM32L4_TIM2_QECLKOUT
-#  define CONFIG_STM32L4_TIM2_QECLKOUT 28000000
-#endif
-
-#ifndef CONFIG_STM32L4_TIM3_QECLKOUT
-#  define CONFIG_STM32L4_TIM3_QECLKOUT 28000000
-#endif
-
-#ifndef CONFIG_STM32L4_TIM4_QECLKOUT
-#  define CONFIG_STM32L4_TIM4_QECLKOUT 28000000
-#endif
-
-#ifndef CONFIG_STM32L4_TIM5_QECLKOUT
-#  define CONFIG_STM32L4_TIM5_QECLKOUT 28000000
-#endif
-
-#ifndef CONFIG_STM32L4_TIM8_QECLKOUT
-#  define CONFIG_STM32L4_TIM8_QECLKOUT 28000000
-#endif
-
-/************************************************************************************
- * Included Files
- ************************************************************************************/
-
-/************************************************************************************
- * Name: stm32l4_qeinitialize
- *
- * Description:
- *   Initialize a quadrature encoder interface.  This function must be called from
- *   board-specific logic..
- *
- * Input Parameters:
- *   devpath - The full path to the driver to register. E.g., "/dev/qe0"
- *   tim     - The timer number to used.  'tim' must be an element of {1,2,3,4,5,8}
- *
- * Returned Values:
- *   Zero on success; A negated errno value is returned on failure.
- *
- ************************************************************************************/
-
-int stm32l4_qeinitialize(FAR const char *devpath, int tim);
-
-#endif /* CONFIG_QENCODER */
-#endif /* __ARCH_ARM_SRC_STM32L4_STM32L4_QENCODER_H */
-
diff --git a/arch/arm/src/nrf52/nrf52_rcc.c b/arch/arm/src/nrf52/nrf52_rcc.c
deleted file mode 100644
index 60d0b11b32..0000000000
--- a/arch/arm/src/nrf52/nrf52_rcc.c
+++ /dev/null
@@ -1,906 +0,0 @@
-/****************************************************************************
- * arch/arm/src/stm32l4/stm32l4x6xx_rcc.c
- *
- *   Copyright (C) 2011-2012, 2014-2015 Gregory Nutt. All rights reserved.
- *   Copyright (C) 2016 Sebastien Lorquet. All rights reserved.
- *   Author: Gregory Nutt <gnutt@nuttx.org>
- *           Sebastien Lorquet <sebastien@lorquet.fr>
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ****************************************************************************/
-
-/****************************************************************************
- * Included Files
- ****************************************************************************/
-
-#include <nuttx/config.h>
-#include <arch/stm32l4/chip.h>
-
-#include "stm32l4_pwr.h"
-#include "stm32l4_flash.h"
-
-/****************************************************************************
- * Pre-processor Definitions
- ****************************************************************************/
-
-/* Allow up to 100 milliseconds for the high speed clock to become ready.
- * that is a very long delay, but if the clock does not become ready we are
- * hosed anyway.  Normally this is very fast, but I have seen at least one
- * board that required this long, long timeout for the HSE to be ready.
- */
-
-#define HSERDY_TIMEOUT (100 * CONFIG_BOARD_LOOPSPERMSEC)
-
-/* Same for HSI and MSI */
-
-#define HSIRDY_TIMEOUT HSERDY_TIMEOUT
-#define MSIRDY_TIMEOUT HSERDY_TIMEOUT
-
-/* HSE divisor to yield ~1MHz RTC clock */
-
-#define HSE_DIVISOR (STM32L4_HSE_FREQUENCY + 500000) / 1000000
-
-/****************************************************************************
- * Private Data
- ****************************************************************************/
-
-/****************************************************************************
- * Private Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: rcc_reset
- *
- * Description:
- *   Reset the RCC clock configuration to the default reset state
- *
- ****************************************************************************/
-
-static inline void rcc_reset(void)
-{
-  uint32_t regval;
-
-  /* Enable the Internal High Speed clock (HSI) */
-
-  regval = getreg32(STM32L4_RCC_CR);
-  regval |= RCC_CR_HSION;
-  putreg32(regval, STM32L4_RCC_CR);
-
-  /* Reset CFGR register */
-
-  putreg32(0x00000000, STM32L4_RCC_CFGR);
-
-  /* Reset HSION, HSEON, CSSON and PLLON bits */
-
-  regval  = getreg32(STM32L4_RCC_CR);
-  regval &= ~(RCC_CR_HSION | RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLLON);
-  putreg32(regval, STM32L4_RCC_CR);
-
-  /* Reset PLLCFGR register to reset default */
-
-  putreg32(RCC_PLLCFG_RESET, STM32L4_RCC_PLLCFG);
-
-  /* Reset HSEBYP bit */
-
-  regval  = getreg32(STM32L4_RCC_CR);
-  regval &= ~RCC_CR_HSEBYP;
-  putreg32(regval, STM32L4_RCC_CR);
-
-  /* Disable all interrupts */
-
-  putreg32(0x00000000, STM32L4_RCC_CIER);
-}
-
-/****************************************************************************
- * Name: rcc_enableahb1
- *
- * Description:
- *   Enable selected AHB1 peripherals
- *
- ****************************************************************************/
-
-static inline void rcc_enableahb1(void)
-{
-  uint32_t regval;
-
-  /* Set the appropriate bits in the AHB1ENR register to enabled the
-   * selected AHB1 peripherals.
-   */
-
-  regval = getreg32(STM32L4_RCC_AHB1ENR);
-
-#ifdef CONFIG_STM32L4_DMA1
-  /* DMA 1 clock enable */
-
-  regval |= RCC_AHB1ENR_DMA1EN;
-#endif
-
-#ifdef CONFIG_STM32L4_DMA2
-  /* DMA 2 clock enable */
-
-  regval |= RCC_AHB1ENR_DMA2EN;
-#endif
-
-#ifdef CONFIG_STM32L4_CRC
-  /* CRC clock enable */
-
-  regval |= RCC_AHB1ENR_CRCEN;
-#endif
-
-#ifdef CONFIG_STM32L4_TSC
-  /* TSC clock enable */
-
-  regval |= RCC_AHB1ENR_TSCEN;
-#endif
-
-  putreg32(regval, STM32L4_RCC_AHB1ENR);   /* Enable peripherals */
-}
-
-/****************************************************************************
- * Name: rcc_enableahb2
- *
- * Description:
- *   Enable selected AHB2 peripherals
- *
- ****************************************************************************/
-
-static inline void rcc_enableahb2(void)
-{
-  uint32_t regval;
-
-  /* Set the appropriate bits in the AHB2ENR register to enabled the
-   * selected AHB2 peripherals.
-   */
-
-  regval = getreg32(STM32L4_RCC_AHB2ENR);
-
-  /* Enable GPIOA, GPIOB, .... GPIOI */
-
-#if STM32L4_NPORTS > 0
-  regval |= (RCC_AHB2ENR_GPIOAEN
-#if STM32L4_NPORTS > 1
-             | RCC_AHB2ENR_GPIOBEN
-#endif
-#if STM32L4_NPORTS > 2
-             | RCC_AHB2ENR_GPIOCEN
-#endif
-#if STM32L4_NPORTS > 3
-             | RCC_AHB2ENR_GPIODEN
-#endif
-#if STM32L4_NPORTS > 4
-             | RCC_AHB2ENR_GPIOEEN
-#endif
-#if STM32L4_NPORTS > 5
-             | RCC_AHB2ENR_GPIOFEN
-#endif
-#if STM32L4_NPORTS > 6
-             | RCC_AHB2ENR_GPIOGEN
-#endif
-#if STM32L4_NPORTS > 7
-             | RCC_AHB2ENR_GPIOHEN
-#endif
-            );
-#endif
-
-#ifdef CONFIG_STM32L4_OTGFS
-  /* USB OTG FS clock enable */
-
-  regval |= RCC_AHB2ENR_OTGFSEN;
-#endif
-
-#if defined(CONFIG_STM32L4_ADC1) || defined(CONFIG_STM32L4_ADC2) || defined(CONFIG_STM32L4_ADC3)
-  /* ADC clock enable */
-
-  regval |= RCC_AHB2ENR_ADCEN;
-#endif
-
-#ifdef CONFIG_STM32L4_AES
-  /* Cryptographic modules clock enable */
-
-  regval |= RCC_AHB2ENR_AESEN;
-#endif
-
-#ifdef CONFIG_STM32L4_RNG
-  /* Random number generator clock enable */
-
-  regval |= RCC_AHB2ENR_RNGEN;
-#endif
-
-  putreg32(regval, STM32L4_RCC_AHB2ENR);   /* Enable peripherals */
-}
-
-/****************************************************************************
- * Name: rcc_enableahb3
- *
- * Description:
- *   Enable selected AHB3 peripherals
- *
- ****************************************************************************/
-
-static inline void rcc_enableahb3(void)
-{
-  uint32_t regval;
-
-  /* Set the appropriate bits in the AHB3ENR register to enabled the
-   * selected AHB3 peripherals.
-   */
-
-  regval = getreg32(STM32L4_RCC_AHB3ENR);
-
-#ifdef CONFIG_STM32L4_FSMC
-  /* Flexible static memory controller module clock enable */
-
-  regval |= RCC_AHB3ENR_FMCEN;
-#endif
-
-
-#ifdef CONFIG_STM32L4_QSPI
-  /* QuadSPI module clock enable */
-
-  regval |= RCC_AHB3ENR_QSPIEN;
-#endif
-
-  putreg32(regval, STM32L4_RCC_AHB3ENR);   /* Enable peripherals */
-}
-
-/****************************************************************************
- * Name: rcc_enableapb1
- *
- * Description:
- *   Enable selected APB1 peripherals
- *
- ****************************************************************************/
-
-static inline void rcc_enableapb1(void)
-{
-  uint32_t regval;
-
-  /* Set the appropriate bits in the APB1ENR register to enabled the
-   * selected APB1 peripherals.
-   */
-
-  regval = getreg32(STM32L4_RCC_APB1ENR1);
-
-#ifdef CONFIG_STM32L4_TIM2
-  /* TIM2 clock enable */
-
-  regval |= RCC_APB1ENR1_TIM2EN;
-#endif
-
-#ifdef CONFIG_STM32L4_TIM3
-  /* TIM3 clock enable */
-
-  regval |= RCC_APB1ENR1_TIM3EN;
-#endif
-
-#ifdef CONFIG_STM32L4_TIM4
-  /* TIM4 clock enable */
-
-  regval |= RCC_APB1ENR1_TIM4EN;
-#endif
-
-#ifdef CONFIG_STM32L4_TIM5
-  /* TIM5 clock enable */
-
-  regval |= RCC_APB1ENR1_TIM5EN;
-#endif
-
-#ifdef CONFIG_STM32L4_TIM6
-  /* TIM6 clock enable */
-
-  regval |= RCC_APB1ENR1_TIM6EN;
-#endif
-
-#ifdef CONFIG_STM32L4_TIM7
-  /* TIM7 clock enable */
-
-  regval |= RCC_APB1ENR1_TIM7EN;
-#endif
-
-#ifdef CONFIG_STM32L4_LCD
-  /* LCD clock enable */
-
-  regval |= RCC_APB1ENR1_LCDEN;
-#endif
-
-#ifdef CONFIG_STM32L4_SPI2
-  /* SPI2 clock enable */
-
-  regval |= RCC_APB1ENR1_SPI2EN;
-#endif
-
-#ifdef CONFIG_STM32L4_SPI3
-  /* SPI3 clock enable */
-
-  regval |= RCC_APB1ENR1_SPI3EN;
-#endif
-
-#ifdef CONFIG_STM32L4_USART2
-  /* USART 2 clock enable */
-
-  regval |= RCC_APB1ENR1_USART2EN;
-#endif
-
-#ifdef CONFIG_STM32L4_USART3
-  /* USART3 clock enable */
-
-  regval |= RCC_APB1ENR1_USART3EN;
-#endif
-
-#ifdef CONFIG_STM32L4_UART4
-  /* UART4 clock enable */
-
-  regval |= RCC_APB1ENR1_UART4EN;
-#endif
-
-#ifdef CONFIG_STM32L4_UART5
-  /* UART5 clock enable */
-
-  regval |= RCC_APB1ENR1_UART5EN;
-#endif
-
-#ifdef CONFIG_STM32L4_I2C1
-  /* I2C1 clock enable */
-
-  regval |= RCC_APB1ENR1_I2C1EN;
-#endif
-
-#ifdef CONFIG_STM32L4_I2C2
-  /* I2C2 clock enable */
-
-  regval |= RCC_APB1ENR1_I2C2EN;
-#endif
-
-#ifdef CONFIG_STM32L4_I2C3
-  /* I2C3 clock enable */
-
-  regval |= RCC_APB1ENR1_I2C3EN;
-#endif
-
-#ifdef CONFIG_STM32L4_CAN1
-  /* CAN 1 clock enable */
-
-  regval |= RCC_APB1ENR1_CAN1EN;
-#endif
-
-  /* Power interface clock enable.  The PWR block is always enabled so that
-   * we can set the internal voltage regulator as required.
-   */
-
-  regval |= RCC_APB1ENR1_PWREN;
-
-#if defined (CONFIG_STM32L4_DAC1) || defined(CONFIG_STM32L4_DAC2)
-  /* DAC interface clock enable */
-
-  regval |= RCC_APB1ENR1_DACEN;
-#endif
-
-#ifdef CONFIG_STM32L4_OPAMP
-  /* OPAMP clock enable */
-
-  regval |= RCC_APB1ENR1_OPAMPEN;
-#endif
-
-#ifdef CONFIG_STM32L4_LPTIM1
-  /* Low power timer 1 clock enable */
-
-  regval |= RCC_APB1ENR1_LPTIM1EN;
-#endif
-
-  putreg32(regval, STM32L4_RCC_APB1ENR1);   /* Enable peripherals */
-
-  /* Second APB1 register */
-
-  regval = getreg32(STM32L4_RCC_APB1ENR2);
-
-#ifdef CONFIG_STM32L4_LPUART1
-  /* Low power uart clock enable */
-
-  regval |= RCC_APB1ENR2_LPUART1EN;
-#endif
-
-#ifdef CONFIG_STM32L4_SWPMI
-  /* Single-wire protocol master clock enable */
-
-  regval |= RCC_APB1ENR2_SWPMI1EN;
-#endif
-
-#ifdef CONFIG_STM32L4_LPTIM2
-  /* Low power timer 2 clock enable */
-
-  regval |= RCC_APB1ENR2_LPTIM2EN;
-#endif
-
-  putreg32(regval, STM32L4_RCC_APB1ENR2);   /* Enable peripherals */
-}
-
-/****************************************************************************
- * Name: rcc_enableapb2
- *
- * Description:
- *   Enable selected APB2 peripherals
- *
- ****************************************************************************/
-
-static inline void rcc_enableapb2(void)
-{
-  uint32_t regval;
-
-  /* Set the appropriate bits in the APB2ENR register to enabled the
-   * selected APB2 peripherals.
-   */
-
-  regval = getreg32(STM32L4_RCC_APB2ENR);
-
-#ifdef CONFIG_STM32L4_SYSCFG
-  /* System configuration controller clock enable */
-
-  regval |= RCC_APB2ENR_SYSCFGEN;
-#endif
-
-#ifdef CONFIG_STM32L4_FIREWALL
-  /* Firewall clock enable */
-
-  regval |= RCC_APB2ENR_FWEN;
-#endif
-
-#ifdef CONFIG_STM32L4_SDMMC
-  /* SDMMC clock enable */
-
-  regval |= RCC_APB2ENR_SDMMCEN;
-#endif
-
-#ifdef CONFIG_STM32L4_TIM1
-  /* TIM1 clock enable */
-
-  regval |= RCC_APB2ENR_TIM1EN;
-#endif
-
-#ifdef CONFIG_STM32L4_SPI1
-  /* SPI1 clock enable */
-
-  regval |= RCC_APB2ENR_SPI1EN;
-#endif
-
-#ifdef CONFIG_STM32L4_TIM8
-  /* TIM8 clock enable */
-
-  regval |= RCC_APB2ENR_TIM8EN;
-#endif
-
-#ifdef CONFIG_STM32L4_USART1
-  /* USART1 clock enable */
-
-  regval |= RCC_APB2ENR_USART1EN;
-#endif
-
-#ifdef CONFIG_STM32L4_TIM15
-  /* TIM15 clock enable */
-
-  regval |= RCC_APB2ENR_TIM15EN;
-#endif
-
-#ifdef CONFIG_STM32L4_TIM16
-  /* TIM16 clock enable */
-
-  regval |= RCC_APB2ENR_TIM16EN;
-#endif
-
-#ifdef CONFIG_STM32L4_TIM17
-  /* TIM17 clock enable */
-
-  regval |= RCC_APB2ENR_TIM17EN;
-#endif
-
-#ifdef CONFIG_STM32L4_SAI1
-  /* SAI1 clock enable */
-
-  regval |= RCC_APB2ENR_SAI1EN;
-#endif
-
-#ifdef CONFIG_STM32L4_SAI2
-  /* SAI2 clock enable */
-
-  regval |= RCC_APB2ENR_SAI2EN;
-#endif
-
-#ifdef CONFIG_STM32L4_DFSDM
-  /* DFSDM clock enable */
-
-  regval |= RCC_APB2ENR_DFSDMEN;
-#endif
-
-  putreg32(regval, STM32L4_RCC_APB2ENR);   /* Enable peripherals */
-}
-
-/****************************************************************************
- * Name: stm32l4_stdclockconfig
- *
- * Description:
- *   Called to change to new clock based on settings in board.h
- *
- *   NOTE:  This logic would need to be extended if you need to select low-
- *   power clocking modes!
- ****************************************************************************/
-
-#ifndef CONFIG_ARCH_BOARD_STM32L4_CUSTOM_CLOCKCONFIG
-static void stm32l4_stdclockconfig(void)
-{
-  uint32_t regval;
-  volatile int32_t timeout;
-
-#ifdef STM32L4_BOARD_USEHSI
-  /* Enable Internal High-Speed Clock (HSI) */
-
-  regval  = getreg32(STM32L4_RCC_CR);
-  regval |= RCC_CR_HSION;           /* Enable HSI */
-  putreg32(regval, STM32L4_RCC_CR);
-
-  /* Wait until the HSI is ready (or until a timeout elapsed) */
-
-  for (timeout = HSIRDY_TIMEOUT; timeout > 0; timeout--)
-    {
-      /* Check if the HSIRDY flag is the set in the CR */
-
-      if ((getreg32(STM32L4_RCC_CR) & RCC_CR_HSIRDY) != 0)
-        {
-          /* If so, then break-out with timeout > 0 */
-
-          break;
-        }
-    }
-
-#elif defined(STM32L4_BOARD_USEMSI)
-  /* Enable Internal Multi-Speed Clock (MSI) */
-
-  /* Wait until the MSI is either off or ready (or until a timeout elapsed) */
-
-  for (timeout = MSIRDY_TIMEOUT; timeout > 0; timeout--)
-    {
-      if ((regval = getreg32(STM32L4_RCC_CR)), (regval & RCC_CR_MSIRDY) || ~(regval & RCC_CR_MSION))
-        {
-          /* If so, then break-out with timeout > 0 */
-
-          break;
-        }
-    }
-
-  /* setting MSIRANGE */
-
-  regval  = getreg32(STM32L4_RCC_CR);
-  regval |= (STM32L4_BOARD_MSIRANGE | RCC_CR_MSION);    /* Enable MSI and frequency */
-  putreg32(regval, STM32L4_RCC_CR);
-
-  /* Wait until the MSI is ready (or until a timeout elapsed) */
-
-  for (timeout = MSIRDY_TIMEOUT; timeout > 0; timeout--)
-    {
-      /* Check if the MSIRDY flag is the set in the CR */
-
-      if ((getreg32(STM32L4_RCC_CR) & RCC_CR_MSIRDY) != 0)
-        {
-          /* If so, then break-out with timeout > 0 */
-
-          break;
-        }
-    }
-
-#elif defined(STM32L4_BOARD_USEHSE)
-  /* Enable External High-Speed Clock (HSE) */
-
-  regval  = getreg32(STM32L4_RCC_CR);
-  regval |= RCC_CR_HSEON;           /* Enable HSE */
-  putreg32(regval, STM32L4_RCC_CR);
-
-  /* Wait until the HSE is ready (or until a timeout elapsed) */
-
-  for (timeout = HSERDY_TIMEOUT; timeout > 0; timeout--)
-    {
-      /* Check if the HSERDY flag is the set in the CR */
-
-      if ((getreg32(STM32L4_RCC_CR) & RCC_CR_HSERDY) != 0)
-        {
-          /* If so, then break-out with timeout > 0 */
-
-          break;
-        }
-    }
-#else
-
-#  error stm32l4_stdclockconfig(), must have one of STM32L4_BOARD_USEHSI, STM32L4_BOARD_USEMSI, STM32L4_BOARD_USEHSE defined
-
-#endif
-
-  /* Check for a timeout.  If this timeout occurs, then we are hosed.  We
-   * have no real back-up plan, although the following logic makes it look
-   * as though we do.
-   */
-
-  if (timeout > 0)
-    {
-#warning todo: regulator voltage according to clock freq
-#if 0
-      /* Ensure Power control is enabled before modifying it. */
-
-      regval  = getreg32(STM32L4_RCC_APB1ENR);
-      regval |= RCC_APB1ENR_PWREN;
-      putreg32(regval, STM32L4_RCC_APB1ENR);
-
-      /* Select regulator voltage output Scale 1 mode to support system
-       * frequencies up to 168 MHz.
-       */
-
-      regval  = getreg32(STM32L4_PWR_CR);
-      regval &= ~PWR_CR_VOS_MASK;
-      regval |= PWR_CR_VOS_SCALE_1;
-      putreg32(regval, STM32L4_PWR_CR);
-#endif
-
-      /* Set the HCLK source/divider */
-
-      regval  = getreg32(STM32L4_RCC_CFGR);
-      regval &= ~RCC_CFGR_HPRE_MASK;
-      regval |= STM32L4_RCC_CFGR_HPRE;
-      putreg32(regval, STM32L4_RCC_CFGR);
-
-      /* Set the PCLK2 divider */
-
-      regval  = getreg32(STM32L4_RCC_CFGR);
-      regval &= ~RCC_CFGR_PPRE2_MASK;
-      regval |= STM32L4_RCC_CFGR_PPRE2;
-      putreg32(regval, STM32L4_RCC_CFGR);
-
-      /* Set the PCLK1 divider */
-
-      regval  = getreg32(STM32L4_RCC_CFGR);
-      regval &= ~RCC_CFGR_PPRE1_MASK;
-      regval |= STM32L4_RCC_CFGR_PPRE1;
-      putreg32(regval, STM32L4_RCC_CFGR);
-
-#ifdef CONFIG_RTC_HSECLOCK
-      /* Set the RTC clock divisor */
-
-      regval  = getreg32(STM32L4_RCC_CFGR);
-      regval &= ~RCC_CFGR_RTCPRE_MASK;
-      regval |= RCC_CFGR_RTCPRE(HSE_DIVISOR);
-      putreg32(regval, STM32L4_RCC_CFGR);
-#endif
-
-      /* Set the PLL source and main divider */
-
-      regval  = getreg32(STM32L4_RCC_PLLCFG);
-
-      /* Configure Main PLL */
-
-      /* Set the PLL dividers and multipliers to configure the main PLL */
-
-      regval = (STM32L4_PLLCFG_PLLM | STM32L4_PLLCFG_PLLN | STM32L4_PLLCFG_PLLP
-                | STM32L4_PLLCFG_PLLQ | STM32L4_PLLCFG_PLLR);
-
-#ifdef STM32L4_PLLCFG_PLLP_ENABLED
-      regval |= RCC_PLLCFG_PLLPEN;
-#endif
-#ifdef STM32L4_PLLCFG_PLLQ_ENABLED
-      regval |= RCC_PLLCFG_PLLQEN;
-#endif
-#ifdef STM32L4_PLLCFG_PLLR_ENABLED
-      regval |= RCC_PLLCFG_PLLREN;
-#endif
-
-      /* XXX The choice of clock source to PLL (all three) is independent
-       * of the sys clock source choice, review the STM32L4_BOARD_USEHSI
-       * name; probably split it into two, one for PLL source and one
-       * for sys clock source.
-       */
-
-#ifdef STM32L4_BOARD_USEHSI
-      regval |= RCC_PLLCFG_PLLSRC_HSI;
-#elif defined(STM32L4_BOARD_USEMSI)
-      regval |= RCC_PLLCFG_PLLSRC_MSI;
-#else /* if STM32L4_BOARD_USEHSE */
-      regval |= RCC_PLLCFG_PLLSRC_HSE;
-#endif
-
-      putreg32(regval, STM32L4_RCC_PLLCFG);
-
-      /* Enable the main PLL */
-
-      regval  = getreg32(STM32L4_RCC_CR);
-      regval |= RCC_CR_PLLON;
-      putreg32(regval, STM32L4_RCC_CR);
-
-      /* Wait until the PLL is ready */
-
-      while ((getreg32(STM32L4_RCC_CR) & RCC_CR_PLLRDY) == 0)
-        {
-        }
-
-#ifdef CONFIG_STM32L4_SAI1PLL
-      /* Configure SAI1 PLL */
-
-      regval  = getreg32(STM32L4_RCC_PLLSAI1CFG);
-
-      /* Set the PLL dividers and multipliers to configure the SAI1 PLL */
-
-      regval = (STM32L4_PLLSAI1CFG_PLLN | STM32L4_PLLSAI1CFG_PLLP
-                | STM32L4_PLLSAI1CFG_PLLQ | STM32L4_PLLSAI1CFG_PLLR);
-
-#ifdef STM32L4_PLLSAI1CFG_PLLP_ENABLED
-      regval |= RCC_PLLSAI1CFG_PLLPEN;
-#endif
-#ifdef STM32L4_PLLSAI1CFG_PLLQ_ENABLED
-      regval |= RCC_PLLSAI1CFG_PLLQEN;
-#endif
-#ifdef STM32L4_PLLSAI1CFG_PLLR_ENABLED
-      regval |= RCC_PLLSAI1CFG_PLLREN;
-#endif
-
-      putreg32(regval, STM32L4_RCC_PLLSAI1CFG);
-
-      /* Enable the SAI1 PLL */
-
-      regval  = getreg32(STM32L4_RCC_CR);
-      regval |= RCC_CR_PLLSAI1ON;
-      putreg32(regval, STM32L4_RCC_CR);
-
-      /* Wait until the PLL is ready */
-
-      while ((getreg32(STM32L4_RCC_CR) & RCC_CR_PLLSAI1RDY) == 0)
-        {
-        }
-#endif
-
-#ifdef CONFIG_STM32L4_SAI2PLL
-      /* Configure SAI2 PLL */
-
-      regval  = getreg32(STM32L4_RCC_PLLSAI2CFG);
-
-      /* Enable the SAI2 PLL */
-      /* Set the PLL dividers and multipliers to configure the SAI2 PLL */
-
-      regval = (STM32L4_PLLSAI2CFG_PLLN | STM32L4_PLLSAI2CFG_PLLP |
-                STM32L4_PLLSAI2CFG_PLLR);
-
-#ifdef STM32L4_PLLSAI2CFG_PLLP_ENABLED
-      regval |= RCC_PLLSAI2CFG_PLLPEN;
-#endif
-#ifdef STM32L4_PLLSAI2CFG_PLLR_ENABLED
-      regval |= RCC_PLLSAI2CFG_PLLREN;
-#endif
-
-      putreg32(regval, STM32L4_RCC_PLLSAI2CFG);
-
-      /* Enable the SAI1 PLL */
-
-      regval  = getreg32(STM32L4_RCC_CR);
-      regval |= RCC_CR_PLLSAI2ON;
-      putreg32(regval, STM32L4_RCC_CR);
-
-      /* Wait until the PLL is ready */
-
-      while ((getreg32(STM32L4_RCC_CR) & RCC_CR_PLLSAI2RDY) == 0)
-        {
-        }
-#endif
-
-      /* Enable FLASH prefetch, instruction cache, data cache, and 5 wait states */
-
-#ifdef CONFIG_STM32L4_FLASH_PREFETCH
-      regval = (FLASH_ACR_LATENCY_4 | FLASH_ACR_ICEN | FLASH_ACR_DCEN | FLASH_ACR_PRFTEN);
-#else
-      regval = (FLASH_ACR_LATENCY_4 | FLASH_ACR_ICEN | FLASH_ACR_DCEN);
-#endif
-      putreg32(regval, STM32L4_FLASH_ACR);
-
-      /* Select the main PLL as system clock source */
-
-      regval  = getreg32(STM32L4_RCC_CFGR);
-      regval &= ~RCC_CFGR_SW_MASK;
-      regval |= RCC_CFGR_SW_PLL;
-      putreg32(regval, STM32L4_RCC_CFGR);
-
-      /* Wait until the PLL source is used as the system clock source */
-
-      while ((getreg32(STM32L4_RCC_CFGR) & RCC_CFGR_SWS_MASK) != RCC_CFGR_SWS_PLL)
-        {
-        }
-
-#if defined(CONFIG_STM32L4_IWDG) || defined(CONFIG_RTC_LSICLOCK)
-      /* Low speed internal clock source LSI */
-
-      stm32l4_rcc_enablelsi();
-#endif
-
-#if defined(STM32L4_USE_LSE)
-      /* Low speed external clock source LSE
-       *
-       * TODO: There is another case where the LSE needs to
-       * be enabled: if the MCO1 pin selects LSE as source.
-       * XXX and other cases, like automatic trimming of MSI for USB use
-       */
-
-      /* ensure Power control is enabled since it is indirectly required
-       * to alter the LSE parameters.
-       */
-      stm32l4_pwr_enableclk(true);
-
-      /* XXX other LSE settings must be made before turning on the oscillator
-       * and we need to ensure it is first off before doing so.
-       */
-
-      /* Turn on the LSE oscillator
-       * XXX this will almost surely get moved since we also want to use
-       * this for automatically trimming MSI, etc.
-       */
-
-      stm32l4_rcc_enablelse();
-
-#  if defined(STM32L4_BOARD_USEMSI)
-      /* Now that LSE is up, auto trim the MSI */
-
-      regval  = getreg32(STM32L4_RCC_CR);
-      regval |= RCC_CR_MSIPLLEN;
-      putreg32(regval, STM32L4_RCC_CR);
-#  endif
-#endif
-
-#if defined(STM32L4_USE_CLK48)
-      /* XXX sanity if sdmmc1 or usb or rng, then we need to set the clk48 source
-       * and then we can also do away with STM32L4_USE_CLK48, and give better
-       * warning messages
-       *
-       * XXX sanity if our STM32L4_CLK48_SEL is YYY then we need to have already
-       * enabled ZZZ
-       */
-
-      regval  = getreg32(STM32L4_RCC_CCIPR);
-      regval &= RCC_CCIPR_CLK48SEL_MASK;
-      regval |= STM32L4_CLK48_SEL;
-      putreg32(regval, STM32L4_RCC_CCIPR);
-#endif
-    }
-}
-#endif
-
-/****************************************************************************
- * Name: rcc_enableperiphals
- ****************************************************************************/
-
-static inline void rcc_enableperipherals(void)
-{
-  rcc_enableahb1();
-  rcc_enableahb2();
-  rcc_enableahb3();
-  rcc_enableapb1();
-  rcc_enableapb2();
-}
-
-/****************************************************************************
- * Public Functions
- ****************************************************************************/
diff --git a/arch/arm/src/nrf52/nrf52_rcc.h b/arch/arm/src/nrf52/nrf52_rcc.h
deleted file mode 100644
index c00d261557..0000000000
--- a/arch/arm/src/nrf52/nrf52_rcc.h
+++ /dev/null
@@ -1,230 +0,0 @@
-/************************************************************************************
- * arch/arm/src/stm32l4/stm32l4_rcc.h
- *
- *   Copyright (C) 2009, 2011-2014 Gregory Nutt. All rights reserved.
- *   Author: Gregory Nutt <gnutt@nuttx.orgr>
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ************************************************************************************/
-
-#ifndef __ARCH_ARM_SRC_STM32L4_STM32L4_RRC_H
-#define __ARCH_ARM_SRC_STM32L4_STM32L4_RRC_H
-
-/************************************************************************************
- * Included Files
- ************************************************************************************/
-
-#include <nuttx/config.h>
-
-#include "up_arch.h"
-#include "chip.h"
-
-#if defined(CONFIG_STM32L4_STM32L476XX) || defined(CONFIG_STM32L4_STM32L486XX)
-#  include "chip/stm32l4x6xx_rcc.h"
-#else
-#  error "Unsupported STM32L4 chip"
-#endif
-
-/************************************************************************************
- * Pre-processor Definitions
- ************************************************************************************/
-
-#ifndef __ASSEMBLY__
-
-#undef EXTERN
-#if defined(__cplusplus)
-#define EXTERN extern "C"
-extern "C"
-{
-#else
-#define EXTERN extern
-#endif
-
-/************************************************************************************
- * Public Data
- ************************************************************************************/
-
-/* This symbol references the Cortex-M4 vector table (as positioned by the linker
- * script, ld.script or ld.script.dfu.  The standard location for the vector table is
- * at the beginning of FLASH at address 0x0800:0000.  If we are using the STMicro DFU
- * bootloader, then the vector table will be offset to a different location in FLASH
- * and we will need to set the NVIC vector location to this alternative location.
- */
-
-extern uint32_t _vectors[];  /* See stm32l4_vectors.S */
-
-/************************************************************************************
- * Inline Functions
- ************************************************************************************/
-
-/************************************************************************************
- * Name: stm32l4_mcoconfig
- *
- * Description:
- *   Selects the clock source to output on MC pin (PA8) for stm32f10xxx.
- *   PA8 should be configured in alternate function mode.
- *
- * Input Parameters:
- *   source - One of the definitions for the RCC_CFGR_MCO definitions from
- *     chip/stm32f10xxx_rcc.h {RCC_CFGR_SYSCLK, RCC_CFGR_INTCLK, RCC_CFGR_EXTCLK,
- *     RCC_CFGR_PLLCLKd2, RCC_CFGR_PLL2CLK, RCC_CFGR_PLL3CLKd2, RCC_CFGR_XT1,
- *     RCC_CFGR_PLL3CLK}
- *
- * Returned Value:
- *   None
- *
- ************************************************************************************/
-
-static inline void stm32l4_mcoconfig(uint32_t source)
-{
-  uint32_t regval;
-
-  /* Set MCO source */
-
-  regval = getreg32(STM32L4_RCC_CFGR);
-  regval &= ~(RCC_CFGR_MCO_MASK);
-  regval |= (source & RCC_CFGR_MCO_MASK);
-  putreg32(regval, STM32L4_RCC_CFGR);
-}
-
-/************************************************************************************
- * Public Function Prototypes
- ************************************************************************************/
-
-/************************************************************************************
- * Name: stm32l4_clockconfig
- *
- * Description:
- *   Called to establish the clock settings based on the values in board.h.  This
- *   function (by default) will reset most everything, enable the PLL, and enable
- *   peripheral clocking for all periperipherals enabled in the NuttX configuration
- *   file.
- *
- *   If CONFIG_ARCH_BOARD_STM32L4_CUSTOM_CLOCKCONFIG is defined, then clocking will
- *   be enabled by an externally provided, board-specific function called
- *   stm32l4_board_clockconfig().
- *
- * Input Parameters:
- *   None
- *
- * Returned Value:
- *   None
- *
- ************************************************************************************/
-
-void stm32l4_clockconfig(void);
-
-/************************************************************************************
- * Name: stm32l4_board_clockconfig
- *
- * Description:
- *   Any STM32L4 board may replace the "standard" board clock configuration logic with
- *   its own, custom clock cofiguration logic.
- *
- ************************************************************************************/
-
-#ifdef CONFIG_ARCH_BOARD_STM32L4_CUSTOM_CLOCKCONFIG
-void stm32l4_board_clockconfig(void);
-#endif
-
-/************************************************************************************
- * Name: stm32l4_clockenable
- *
- * Description:
- *   Re-enable the clock and restore the clock settings based on settings in board.h.
- *   This function is only available to support low-power modes of operation:  When
- *   re-awakening from deep-sleep modes, it is necessary to re-enable/re-start the
- *   PLL
- *
- *   This functional performs a subset of the operations performed by
- *   stm32l4_clockconfig():  It does not reset any devices, and it does not reset the
- *   currenlty enabled peripheral clocks.
- *
- *   If CONFIG_ARCH_BOARD_STM32L4_CUSTOM_CLOCKCONFIG is defined, then clocking will
- *   be enabled by an externally provided, board-specific function called
- *   stm32l4_board_clockconfig().
- *
- * Input Parameters:
- *   None
- *
- * Returned Value:
- *   None
- *
- ************************************************************************************/
-
-#ifdef CONFIG_PM
-void stm32l4_clockenable(void);
-#endif
-
-/************************************************************************************
- * Name: stm32l4_rcc_enablelse
- *
- * Description:
- *   Enable the External Low-Speed (LSE) Oscillator and, if the RTC is
- *   configured, setup the LSE as the RTC clock source, and enable the RTC.
- *
- *   For the STM32L15X family, this will also select the LSE as the clock source of
- *   the LCD.
- *
- * Input Parameters:
- *   None
- *
- * Returned Value:
- *   None
- *
- ************************************************************************************/
-
-void stm32l4_rcc_enablelse(void);
-
-/****************************************************************************
- * Name: stm32l4_rcc_enablelsi
- *
- * Description:
- *   Enable the Internal Low-Speed (LSI) RC Oscillator.
- *
- ****************************************************************************/
-
-void stm32l4_rcc_enablelsi(void);
-
-/****************************************************************************
- * Name: stm32l4_rcc_disablelsi
- *
- * Description:
- *   Disable the Internal Low-Speed (LSI) RC Oscillator.
- *
- ****************************************************************************/
-
-void stm32l4_rcc_disablelsi(void);
-
-#undef EXTERN
-#if defined(__cplusplus)
-}
-#endif
-#endif /* __ASSEMBLY__ */
-#endif /* __ARCH_ARM_SRC_STM32L4_STM32L4_RCC_H */
diff --git a/arch/arm/src/nrf52/nrf52_sai.c b/arch/arm/src/nrf52/nrf52_sai.c
deleted file mode 100644
index 02552c0e49..0000000000
--- a/arch/arm/src/nrf52/nrf52_sai.c
+++ /dev/null
@@ -1,1452 +0,0 @@
-/****************************************************************************
- * arch/arm/src/stm32l4/stm32l4_sai.c
- *
- *   Copyright (C) 2013-2014, 2017 Gregory Nutt. All rights reserved.
- *   Authors: Gregory Nutt <gnutt@nuttx.org>
- *   Copyright (c) 2016 Motorola Mobility, LLC. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ****************************************************************************/
-
-/****************************************************************************
- * Included Files
- ****************************************************************************/
-
-#include <nuttx/config.h>
-
-#include <sys/types.h>
-#include <stdint.h>
-#include <stdbool.h>
-#include <semaphore.h>
-#include <errno.h>
-#include <assert.h>
-#include <queue.h>
-#include <debug.h>
-
-#include <arch/board/board.h>
-
-#include <nuttx/wdog.h>
-#include <nuttx/irq.h>
-#include <nuttx/wqueue.h>
-#include <nuttx/audio/audio.h>
-#include <nuttx/audio/i2s.h>
-
-#include "stm32l4_dma.h"
-#include "stm32l4_gpio.h"
-#include "stm32l4_sai.h"
-
-#ifdef CONFIG_STM32L4_SAI
-
-/****************************************************************************
- * Pre-processor Definitions
- ****************************************************************************/
-
-#ifndef CONFIG_SCHED_WORKQUEUE
-#  error Work queue support is required (CONFIG_SCHED_WORKQUEUE)
-#endif
-
-#ifndef CONFIG_AUDIO
-#  error CONFIG_AUDIO required by this driver
-#endif
-
-#ifndef CONFIG_I2S
-#  error CONFIG_I2S required by this driver
-#endif
-
-#ifdef CONFIG_STM32L4_SAI_POLLING
-#  error "Polling SAI not yet supported"
-#endif
-
-#ifdef CONFIG_STM32L4_SAI_INTERRUPTS
-#  error "Interrupt driven SAI not yet supported"
-#endif
-
-#ifndef CONFIG_STM32L4_SAI_DEFAULT_SAMPLERATE
-#  define CONFIG_STM32L4_SAI_DEFAULT_SAMPLERATE  (48000)
-#endif
-
-#ifndef CONFIG_STM32L4_SAI_DEFAULT_DATALEN
-#  define CONFIG_STM32L4_SAI_DEFAULT_DATALEN     (16)
-#endif
-
-#ifndef CONFIG_STM32L4_SAI_MAXINFLIGHT
-#  define CONFIG_STM32L4_SAI_MAXINFLIGHT         (16)
-#endif
-
-#ifdef CONFIG_STM32L4_SAI_DMA
-/* SAI DMA priority */
-
-#  if defined(CONFIG_STM32L4_SAI_DMAPRIO)
-#    define SAI_DMA_PRIO       CONFIG_STM32L4_SAI_DMAPRIO
-#  else
-#    define SAI_DMA_PRIO       DMA_CCR_PRIMED
-#  endif
-
-#  if (SAI_DMA_PRIO & ~DMA_CCR_PL_MASK) != 0
-#    error "Illegal value for CONFIG_STM32L4_SAI_DMAPRIO"
-#  endif
-
-/* DMA channel configuration */
-
-#  define SAI_RXDMA8_CONFIG    (SAI_DMA_PRIO|DMA_CCR_MSIZE_8BITS |DMA_CCR_PSIZE_8BITS |DMA_CCR_MINC            )
-#  define SAI_RXDMA16_CONFIG   (SAI_DMA_PRIO|DMA_CCR_MSIZE_16BITS|DMA_CCR_PSIZE_16BITS|DMA_CCR_MINC            )
-#  define SAI_RXDMA32_CONFIG   (SAI_DMA_PRIO|DMA_CCR_MSIZE_32BITS|DMA_CCR_PSIZE_32BITS|DMA_CCR_MINC            )
-#  define SAI_TXDMA8_CONFIG    (SAI_DMA_PRIO|DMA_CCR_MSIZE_8BITS |DMA_CCR_PSIZE_8BITS |DMA_CCR_MINC|DMA_CCR_DIR)
-#  define SAI_TXDMA16_CONFIG   (SAI_DMA_PRIO|DMA_CCR_MSIZE_16BITS|DMA_CCR_PSIZE_16BITS|DMA_CCR_MINC|DMA_CCR_DIR)
-#  define SAI_TXDMA32_CONFIG   (SAI_DMA_PRIO|DMA_CCR_MSIZE_32BITS|DMA_CCR_PSIZE_32BITS|DMA_CCR_MINC|DMA_CCR_DIR)
-#endif
-
-/****************************************************************************
- * Private Types
- ****************************************************************************/
-
-/* I2S buffer container */
-
-struct sai_buffer_s
-{
-  struct sai_buffer_s *flink;  /* Supports a singly linked list */
-  i2s_callback_t callback;     /* Function to call when the transfer completes */
-  uint32_t timeout;            /* The timeout value to use with transfers */
-  void *arg;                   /* The argument to be returned with the callback */
-  struct ap_buffer_s *apb;     /* The audio buffer */
-  int result;                  /* The result of the transfer */
-};
-
-/* The state of the one SAI peripheral */
-
-struct stm32l4_sai_s
-{
-  struct i2s_dev_s dev;        /* Externally visible I2S interface */
-  uintptr_t base;              /* SAI block register base address */
-  sem_t exclsem;               /* Assures mutually exclusive acess to SAI */
-  uint32_t frequency;          /* SAI clock frequency */
-  uint32_t syncen;             /* Synchronization setting */
-#ifdef CONFIG_STM32L4_SAI_DMA
-  uint16_t dma_ch;             /* DMA channel number */
-  DMA_HANDLE dma;              /* DMA channel handle */
-  uint32_t dma_ccr;            /* DMA control register */
-#endif
-  uint8_t datalen;             /* Data width */
-  uint32_t samplerate;         /* Data sample rate */
-  uint8_t rxenab: 1;           /* True: RX transfers enabled */
-  uint8_t txenab: 1;           /* True: TX transfers enabled */
-  WDOG_ID dog;                 /* Watchdog that handles timeouts */
-  sq_queue_t pend;             /* A queue of pending transfers */
-  sq_queue_t act;              /* A queue of active transfers */
-  sq_queue_t done;             /* A queue of completed transfers */
-  struct work_s work;          /* Supports worker thread operations */
-
-  /* Pre-allocated pool of buffer containers */
-
-  sem_t bufsem;                   /* Buffer wait semaphore */
-  struct sai_buffer_s *freelist;  /* A list a free buffer containers */
-  struct sai_buffer_s containers[CONFIG_STM32L4_SAI_MAXINFLIGHT];
-};
-
-/****************************************************************************
- * Private Function Prototypes
- ****************************************************************************/
-
-#ifdef CONFIG_DEBUG_I2S_INFO
-static void     sai_dump_regs(struct stm32l4_sai_s *priv, const char *msg);
-#else
-#  define       sai_dump_regs(s,m)
-#endif
-
-/* Semaphore helpers */
-
-static void     sai_exclsem_take(struct stm32l4_sai_s *priv);
-#define         sai_exclsem_give(priv) sem_post(&priv->exclsem)
-
-static void     sai_bufsem_take(struct stm32l4_sai_s *priv);
-#define         sai_bufsem_give(priv) sem_post(&priv->bufsem)
-
-/* Buffer container helpers */
-
-static struct sai_buffer_s *
-sai_buf_allocate(struct stm32l4_sai_s *priv);
-static void     sai_buf_free(struct stm32l4_sai_s *priv,
-                             struct sai_buffer_s *bfcontainer);
-static void     sai_buf_initialize(struct stm32l4_sai_s *priv);
-
-/* DMA support */
-
-#ifdef CONFIG_STM32L4_SAI_DMA
-static void     sai_schedule(struct stm32l4_sai_s *priv, int result);
-static void     sai_dma_callback(DMA_HANDLE handle, uint8_t isr, void *arg);
-#endif
-
-/* I2S methods */
-
-static uint32_t sai_samplerate(struct i2s_dev_s *dev, uint32_t rate);
-static uint32_t sai_datawidth(struct i2s_dev_s *dev, int bits);
-static int      sai_receive(struct i2s_dev_s *dev, struct ap_buffer_s *apb,
-                            i2s_callback_t callback, void *arg, uint32_t timeout);
-static int      sai_send(struct i2s_dev_s *dev, struct ap_buffer_s *apb,
-                         i2s_callback_t callback, void *arg,
-                         uint32_t timeout);
-
-/****************************************************************************
- * Private Data
- ****************************************************************************/
-
-/* I2S device operations */
-
-static const struct i2s_ops_s g_i2sops =
-{
-  /* Receiver methods */
-
-  .i2s_rxsamplerate = sai_samplerate,
-  .i2s_rxdatawidth  = sai_datawidth,
-  .i2s_receive      = sai_receive,
-
-  /* Transmitter methods */
-
-  .i2s_txsamplerate = sai_samplerate,
-  .i2s_txdatawidth  = sai_datawidth,
-  .i2s_send         = sai_send,
-};
-
-/* SAI1 state */
-
-#ifdef CONFIG_STM32L4_SAI1_A
-static struct stm32l4_sai_s g_sai1a_priv =
-{
-  .dev.ops     = &g_i2sops,
-  .base        = STM32L4_SAI1_A_BASE,
-  .frequency   = STM32L4_SAI1_FREQUENCY,
-#ifdef CONFIG_STM32L4_SAI1_A_SYNC_WITH_B
-  .syncen      = SAI_CR1_SYNCEN_SYNC_INT,
-#else
-  .syncen      = SAI_CR1_SYNCEN_ASYNC,
-#endif
-#ifdef CONFIG_STM32L4_SAI_DMA
-  .dma_ch      = DMACHAN_SAI1_A,
-#endif
-  .datalen     = CONFIG_STM32L4_SAI_DEFAULT_DATALEN,
-  .samplerate  = CONFIG_STM32L4_SAI_DEFAULT_SAMPLERATE,
-};
-#endif
-
-#ifdef CONFIG_STM32L4_SAI1_B
-static struct stm32l4_sai_s g_sai1b_priv =
-{
-  .dev.ops     = &g_i2sops,
-  .base        = STM32L4_SAI1_B_BASE,
-  .frequency   = STM32L4_SAI1_FREQUENCY,
-#ifdef CONFIG_STM32L4_SAI1_B_SYNC_WITH_A
-  .syncen      = SAI_CR1_SYNCEN_SYNC_INT,
-#else
-  .syncen      = SAI_CR1_SYNCEN_ASYNC,
-#endif
-#ifdef CONFIG_STM32L4_SAI_DMA
-  .dma_ch      = DMACHAN_SAI1_B,
-#endif
-  .datalen     = CONFIG_STM32L4_SAI_DEFAULT_DATALEN,
-  .samplerate  = CONFIG_STM32L4_SAI_DEFAULT_SAMPLERATE,
-};
-#endif
-
-/* SAI2 state */
-
-#ifdef CONFIG_STM32L4_SAI2_A
-static struct stm32l4_sai_s g_sai2a_priv =
-{
-  .dev.ops     = &g_i2sops,
-  .base        = STM32L4_SAI2_A_BASE,
-  .frequency   = STM32L4_SAI2_FREQUENCY,
-#ifdef CONFIG_STM32L4_SAI2_A_SYNC_WITH_B
-  .syncen      = SAI_CR1_SYNCEN_SYNC_INT,
-#else
-  .syncen      = SAI_CR1_SYNCEN_ASYNC,
-#endif
-#ifdef CONFIG_STM32L4_SAI_DMA
-  .dma_ch      = DMACHAN_SAI2_A,
-#endif
-  .datalen     = CONFIG_STM32L4_SAI_DEFAULT_DATALEN,
-  .samplerate  = CONFIG_STM32L4_SAI_DEFAULT_SAMPLERATE,
-};
-#endif
-
-#ifdef CONFIG_STM32L4_SAI2_B
-static struct stm32l4_sai_s g_sai2b_priv =
-{
-  .dev.ops     = &g_i2sops,
-  .base        = STM32L4_SAI2_B_BASE,
-  .frequency   = STM32L4_SAI2_FREQUENCY,
-#ifdef CONFIG_STM32L4_SAI2_B_SYNC_WITH_A
-  .syncen      = SAI_CR1_SYNCEN_SYNC_INT,
-#else
-  .syncen      = SAI_CR1_SYNCEN_ASYNC,
-#endif
-#ifdef CONFIG_STM32L4_SAI_DMA
-  .dma_ch      = DMACHAN_SAI2_B,
-#endif
-  .datalen     = CONFIG_STM32L4_SAI_DEFAULT_DATALEN,
-  .samplerate  = CONFIG_STM32L4_SAI_DEFAULT_SAMPLERATE,
-};
-#endif
-
-/****************************************************************************
- * Private Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: sai_getbitrate
- *
- * Description:
- *   Get the currently configured bitrate
- *
- * Input Parameters:
- *   priv   - private SAI device structure
- *
- * Returned Value:
- *   The current bitrate
- *
- ****************************************************************************/
-
-static inline uint32_t sai_getbitrate(struct stm32l4_sai_s *priv)
-{
-  /* Calculate the bitrate in Hz */
-
-  return priv->samplerate * priv->datalen;
-}
-
-/****************************************************************************
- * Name: sai_getreg
- *
- * Description:
- *   Get the contents of the SAI register at offset
- *
- * Input Parameters:
- *   priv   - private SAI device structure
- *   offset - offset to the register of interest
- *
- * Returned Value:
- *   The contents of the 32-bit register
- *
- ****************************************************************************/
-
-static inline uint32_t sai_getreg(struct stm32l4_sai_s *priv, uint8_t offset)
-{
-  return getreg32(priv->base + offset);
-}
-
-/****************************************************************************
- * Name: sai_putreg
- *
- * Description:
- *   Write a 16-bit value to the SAI register at offset
- *
- * Input Parameters:
- *   priv   - private SAI device structure
- *   offset - offset to the register of interest
- *   value  - the 32-bit value to be written
- *
- * Returned Value:
- *   None
- *
- ****************************************************************************/
-
-static inline void sai_putreg(struct stm32l4_sai_s *priv, uint8_t offset,
-                              uint32_t value)
-{
-  putreg32(value, priv->base + offset);
-}
-
-/************************************************************************************
- * Name: sai_modifyreg
- *
- * Description:
- *   Clear and set bits in the SAI register at offset
- *
- * Input Parameters:
- *   priv    - private SAI device structure
- *   offset  - offset to the register of interest
- *   clrbits - The bits to clear
- *   setbits - The bits to set
- *
- * Returned Value:
- *   None
- *
- ************************************************************************************/
-
-static void sai_modifyreg(struct stm32l4_sai_s *priv, uint8_t offset,
-                          uint32_t clrbits, uint32_t setbits)
-{
-  uint32_t regval;
-
-  regval  = sai_getreg(priv, offset);
-  regval &= ~clrbits;
-  regval |= setbits;
-  sai_putreg(priv, offset, regval);
-}
-
-/****************************************************************************
- * Name: sai_dump_regs
- *
- * Description:
- *   Dump the contents of all SAI block registers
- *
- * Input Parameters:
- *   priv - The SAI block controller to dump
- *   msg - Message to print before the register data
- *
- * Returned Value:
- *   None
- *
- ****************************************************************************/
-
-#ifdef CONFIG_DEBUG_I2S_INFO
-static void sai_dump_regs(struct stm32l4_sai_s *priv, const char *msg)
-{
-  if (msg)
-    {
-      i2sinfo("%s\n", msg);
-    }
-
-  i2sinfo("CR1:%08x CR2:%08x  FRCR:%08x SLOTR:%08x\n",
-          sai_getreg(priv, STM32L4_SAI_CR1_OFFSET),
-          sai_getreg(priv, STM32L4_SAI_CR2_OFFSET),
-          sai_getreg(priv, STM32L4_SAI_FRCR_OFFSET),
-          sai_getreg(priv, STM32L4_SAI_SLOTR_OFFSET));
-  i2sinfo(" IM:%08x  SR:%08x CLRFR:%08x\n",
-          sai_getreg(priv, STM32L4_SAI_IM_OFFSET),
-          sai_getreg(priv, STM32L4_SAI_SR_OFFSET),
-          sai_getreg(priv, STM32L4_SAI_CLRFR_OFFSET));
-}
-#endif
-
-/****************************************************************************
- * Name: sai_exclsem_take
- *
- * Description:
- *   Take the exclusive access semaphore handling any exceptional conditions
- *
- * Input Parameters:
- *   priv - A reference to the SAI peripheral state
- *
- * Returned Value:
- *  None
- *
- ****************************************************************************/
-
-static void sai_exclsem_take(struct stm32l4_sai_s *priv)
-{
-  int ret;
-
-  /* Wait until we successfully get the semaphore.  EINTR is the only
-   * expected 'failure' (meaning that the wait for the semaphore was
-   * interrupted by a signal).
-   */
-
-  do
-    {
-      ret = sem_wait(&priv->exclsem);
-      DEBUGASSERT(ret == 0 || errno == EINTR);
-    }
-  while (ret < 0);
-}
-
-/****************************************************************************
- * Name: sai_mckdivider
- *
- * Description:
- *   Setup the master clock divider based on the currently selected data width
- *   and the sample rate
- *
- * Input Parameter:
- *   priv - SAI device structure (only the sample rate and frequency are
- *          needed at this point).
- *
- * Returned Value:
- *   None
- *
- ****************************************************************************/
-
-static void sai_mckdivider(struct stm32l4_sai_s *priv)
-{
-  uint8_t mckdiv;
-
-  DEBUGASSERT(priv && priv->samplerate > 0 && priv->frequency > 0);
-
-  /* Configure Master Clock using the following formula:
-   * MCLK_x = SAI_CK_x / (MCKDIV[3:0] * 2) with MCLK_x = 256 * FS
-   * FS = SAI_CK_x / (MCKDIV[3:0] * 2) * 256
-   * MCKDIV[3:0] = SAI_CK_x / FS * 512
-   */
-
-  mckdiv = priv->frequency / (priv->samplerate * 2 * 256);
-
-  sai_modifyreg(priv, STM32L4_SAI_CR1_OFFSET, SAI_CR1_MCKDIV_MASK,
-                mckdiv << SAI_CR1_MCKDIV_SHIFT);
-}
-
-/****************************************************************************
- * Name: sai_timeout
- *
- * Description:
- *   The watchdog timeout without completion of the transfer.
- *
- * Input Parameters:
- *   argc   - The number of arguments (should be 1)
- *   arg    - The argument (state structure reference cast to uint32_t)
- *
- * Returned Value:
- *   None
- *
- * Assumptions:
- *   Always called from the interrupt level with interrupts disabled.
- *
- ****************************************************************************/
-
-static void sai_timeout(int argc, uint32_t arg)
-{
-  struct stm32l4_sai_s *priv = (struct stm32l4_sai_s *)arg;
-  DEBUGASSERT(priv != NULL);
-
-#ifdef CONFIG_STM32L4_SAI_DMA
-  /* Cancel the DMA */
-
-  stm32l4_dmastop(priv->dma);
-#endif
-
-  /* Then schedule completion of the transfer to occur on the worker thread. */
-
-  sai_schedule(priv, -ETIMEDOUT);
-}
-
-/****************************************************************************
- * Name: sai_dma_setup
- *
- * Description:
- *   Setup and initiate the next DMA transfer
- *
- * Input Parameters:
- *   priv - SAI state instance
- *
- * Returned Value:
- *   OK on success; a negated errno value on failure
- *
- * Assumptions:
- *   Interrupts are disabled
- *
- ****************************************************************************/
-
-#ifdef CONFIG_STM32L4_SAI_DMA
-static int sai_dma_setup(struct stm32l4_sai_s *priv)
-{
-  struct sai_buffer_s *bfcontainer;
-  struct ap_buffer_s *apb;
-  uintptr_t samp;
-  apb_samp_t nbytes;
-  size_t ntransfers = 0;
-  int ret;
-
-  /* If there is already an active transmission in progress, then bail
-   * returning success.
-   */
-
-  if (!sq_empty(&priv->act))
-    {
-      return OK;
-    }
-
-  /* If there are no pending transfer, then bail returning success */
-
-  if (sq_empty(&priv->pend))
-    {
-      priv->txenab = priv->rxenab = false;
-      return OK;
-    }
-
-  /* Remove the pending transfer at the head of the pending queue. */
-
-  bfcontainer = (struct sai_buffer_s *)sq_remfirst(&priv->pend);
-  DEBUGASSERT(bfcontainer && bfcontainer->apb);
-
-  apb = bfcontainer->apb;
-
-  /* Get the transfer information, accounting for any data offset */
-
-  samp = (uintptr_t)&apb->samp[apb->curbyte];
-
-  /* Configure the DMA */
-
-  if (priv->txenab)
-    {
-      nbytes = apb->nbytes - apb->curbyte;
-
-      switch (priv->datalen)
-        {
-          case 8:
-            priv->dma_ccr = SAI_TXDMA8_CONFIG;
-            ntransfers = nbytes;
-            break;
-
-          case 16:
-            priv->dma_ccr = SAI_TXDMA16_CONFIG;
-            DEBUGASSERT((nbytes & 0x1) == 0);
-            ntransfers = nbytes >> 1;
-            break;
-
-          case 32:
-            priv->dma_ccr = SAI_TXDMA32_CONFIG;
-            DEBUGASSERT((nbytes & 0x3) == 0);
-            ntransfers = nbytes >> 2;
-            break;
-        }
-    }
-  else if (priv->rxenab)
-    {
-      nbytes = apb->nmaxbytes - apb->curbyte;
-
-      switch (priv->datalen)
-        {
-          case 8:
-            priv->dma_ccr = SAI_RXDMA8_CONFIG;
-            ntransfers = nbytes;
-            break;
-
-          case 16:
-            priv->dma_ccr = SAI_RXDMA16_CONFIG;
-            DEBUGASSERT((nbytes & 0x1) == 0);
-            ntransfers = nbytes >> 1;
-            break;
-
-          case 32:
-            priv->dma_ccr = SAI_RXDMA32_CONFIG;
-            DEBUGASSERT((nbytes & 0x3) == 0);
-            ntransfers = nbytes >> 2;
-            break;
-        }
-    }
-
-  DEBUGASSERT(ntransfers > 0);
-
-  stm32l4_dmasetup(priv->dma, priv->base + STM32L4_SAI_DR_OFFSET,
-                   samp, ntransfers, priv->dma_ccr);
-
-  /* Add the container to the list of active DMAs */
-
-  sq_addlast((sq_entry_t *)bfcontainer, &priv->act);
-
-  /* Start the DMA, saving the container as the current active transfer */
-
-  stm32l4_dmastart(priv->dma, sai_dma_callback, priv, false);
-
-  /* Enable the transmitter */
-
-  sai_modifyreg(priv, STM32L4_SAI_CR1_OFFSET, 0, SAI_CR1_SAIEN);
-
-  /* Start a watchdog to catch DMA timeouts */
-
-  if (bfcontainer->timeout > 0)
-    {
-      ret = wd_start(priv->dog, bfcontainer->timeout, (wdentry_t)sai_timeout,
-                     1, (uint32_t)priv);
-
-      /* Check if we have successfully started the watchdog timer.  Note
-       * that we do nothing in the case of failure to start the timer.  We
-       * are already committed to the DMA anyway.  Let's just hope that the
-       * DMA does not hang.
-       */
-
-      if (ret < 0)
-        {
-          i2serr("ERROR: wd_start failed: %d\n", ret);
-        }
-    }
-
-  return OK;
-}
-#endif
-
-/****************************************************************************
- * Name: sai_worker
- *
- * Description:
- *   Transfer done worker
- *
- * Input Parameters:
- *   arg - the SAI device instance cast to void*
- *
- * Returned Value:
- *   None
- *
- ****************************************************************************/
-
-static void sai_worker(void *arg)
-{
-  struct stm32l4_sai_s *priv = (struct stm32l4_sai_s *)arg;
-  struct sai_buffer_s *bfcontainer;
-  irqstate_t flags;
-
-  DEBUGASSERT(priv);
-
-  /* When the transfer was started, the active buffer containers were removed
-   * from the pend queue and saved in the act queue.  We get here when the
-   * transfer is finished... either successfully, with an error, or with a
-   * timeout.
-   *
-   * In any case, the buffer containers in act will be moved to the end
-   * of the done queue and act will be emptied before this worker is
-   * started.
-   */
-
-  i2sinfo("act.head=%p done.head=%p\n", priv->act.head, priv->done.head);
-
-  /* Check if IDLE */
-
-  if (sq_empty(&priv->act))
-    {
-      /* Then start the next transfer.  This must be done with interrupts
-       * disabled.
-       */
-
-      flags = enter_critical_section();
-#ifdef CONFIG_STM32L4_SAI_DMA
-      (void)sai_dma_setup(priv);
-#endif
-      leave_critical_section(flags);
-    }
-
-  /* Process each buffer in the done queue */
-
-  while (sq_peek(&priv->done) != NULL)
-    {
-      /* Remove the buffer container from the done queue.  NOTE that
-       * interupts must be enabled to do this because the done queue is
-       * also modified from the interrupt level.
-       */
-
-      flags = enter_critical_section();
-      bfcontainer = (struct sai_buffer_s *)sq_remfirst(&priv->done);
-      leave_critical_section(flags);
-
-      /* Perform the transfer done callback */
-
-      DEBUGASSERT(bfcontainer && bfcontainer->callback);
-      bfcontainer->callback(&priv->dev, bfcontainer->apb,
-                            bfcontainer->arg, bfcontainer->result);
-
-      /* Release our reference on the audio buffer.  This may very likely
-       * cause the audio buffer to be freed.
-       */
-
-      apb_free(bfcontainer->apb);
-
-      /* And release the buffer container */
-
-      sai_buf_free(priv, bfcontainer);
-    }
-}
-
-/****************************************************************************
- * Name: sai_schedule
- *
- * Description:
- *   An transfer completion or timeout has occurred.  Schedule processing on
- *   the working thread.
- *
- * Input Parameters:
- *   priv   - SAI state instance
- *   result - The result of the transfer
- *
- * Returned Value:
- *   None
- *
- * Assumptions:
- *   - Interrupts are disabled
- *   - The timeout has been canceled.
- *
- ****************************************************************************/
-
-static void sai_schedule(struct stm32l4_sai_s *priv, int result)
-{
-  struct sai_buffer_s *bfcontainer;
-  int ret;
-
-  /* Move all entries from the act queue to the done queue */
-
-  while (!sq_empty(&priv->act))
-    {
-      /* Remove the next buffer container from the act list */
-
-      bfcontainer = (struct sai_buffer_s *)sq_remfirst(&priv->act);
-
-      /* Report the result of the transfer */
-
-      bfcontainer->result = result;
-
-      /* Add the completed buffer container to the tail of the done queue */
-
-      sq_addlast((sq_entry_t *)bfcontainer, &priv->done);
-    }
-
-  /* If the worker has completed running, then reschedule the working thread.
-   * REVISIT:  There may be a race condition here.  So we do nothing is the
-   * worker is not available.
-   */
-
-  if (work_available(&priv->work))
-    {
-      /* Schedule the done processing to occur on the worker thread. */
-
-      ret = work_queue(HPWORK, &priv->work, sai_worker, priv, 0);
-      if (ret != 0)
-        {
-          i2serr("ERROR: Failed to queue work: %d\n", ret);
-        }
-    }
-}
-
-/****************************************************************************
- * Name: sai_dma_callback
- *
- * Description:
- *   This callback function is invoked at the completion of the SAI DMA.
- *
- * Input Parameters:
- *   handle - The DMA handler
- *   isr    - The interrupt status of the DMA transfer
- *   arg    - A pointer to the SAI state instance
- *
- * Returned Value:
- *   None
- *
- ****************************************************************************/
-
-#ifdef CONFIG_STM32L4_SAI_DMA
-static void sai_dma_callback(DMA_HANDLE handle, uint8_t isr, void *arg)
-{
-  struct stm32l4_sai_s *priv = (struct stm32l4_sai_s *)arg;
-  DEBUGASSERT(priv);
-
-  /* Cancel the watchdog timeout */
-
-  (void)wd_cancel(priv->dog);
-
-  /* Then schedule completion of the transfer to occur on the worker thread */
-
-  sai_schedule(priv, (isr & DMA_CHAN_TEIF_BIT) ? -EIO : OK);
-}
-#endif
-
-/****************************************************************************
- * Name: sai_samplerate
- *
- * Description:
- *   Set the I2S RX/TX sample rate.
- *
- * Input Parameters:
- *   dev  - Device-specific state data
- *   rate - The I2S sample rate in samples (not bits) per second
- *
- * Returned Value:
- *   Returns the resulting bitrate
- *
- ****************************************************************************/
-
-static uint32_t sai_samplerate(struct i2s_dev_s *dev, uint32_t rate)
-{
-  struct stm32l4_sai_s *priv = (struct stm32l4_sai_s *)dev;
-
-  DEBUGASSERT(priv && rate > 0);
-
-  /* Save the new sample rate and update the divider */
-
-  priv->samplerate = rate;
-  sai_mckdivider(priv);
-
-  return sai_getbitrate(priv);
-}
-
-/****************************************************************************
- * Name: sai_datawidth
- *
- * Description:
- *   Set the I2S data width.  The bitrate is determined by
- *   sample_rate * data_width.
- *
- * Input Parameters:
- *   dev   - Device-specific state data
- *   width - The I2S data with in bits.
- *
- * Returned Value:
- *   Returns the resulting bitrate
- *
- ****************************************************************************/
-
-static uint32_t sai_datawidth(struct i2s_dev_s *dev, int bits)
-{
-  struct stm32l4_sai_s *priv = (struct stm32l4_sai_s *)dev;
-  uint32_t setbits;
-
-  DEBUGASSERT(priv && bits >= 8);
-
-  switch (bits)
-    {
-      case 8:
-        setbits = SAI_CR1_DS_8BITS;
-        break;
-
-      case 16:
-        setbits = SAI_CR1_DS_16BITS;
-        break;
-
-      case 32:
-        setbits = SAI_CR1_DS_32BITS;
-        break;
-
-      default:
-        i2serr("ERROR: Unsupported or invalid data width: %d\n", bits);
-        return 0;
-    }
-
-  sai_modifyreg(priv, STM32L4_SAI_CR1_OFFSET, SAI_CR1_DS_MASK, setbits);
-
-  sai_modifyreg(priv, STM32L4_SAI_FRCR_OFFSET,
-                SAI_FRCR_FSALL_MASK | SAI_FRCR_FRL_MASK,
-                SAI_FRCR_FSALL(bits) | SAI_FRCR_FRL(bits * 2));
-
-  /* Save the new data width */
-
-  priv->datalen = bits;
-
-  return sai_getbitrate(priv);
-}
-
-/****************************************************************************
- * Name: sai_receive
- *
- * Description:
- *   Receive a block of data from I2S.
- *
- * Input Parameters:
- *   dev      - Device-specific state data
- *   apb      - A pointer to the audio buffer in which to recieve data
- *   callback - A user provided callback function that will be called at
- *              the completion of the transfer.  The callback will be
- *              performed in the context of the worker thread.
- *   arg      - An opaque argument that will be provided to the callback
- *              when the transfer complete
- *   timeout  - The timeout value to use.  The transfer will be canceled
- *              and an ETIMEDOUT error will be reported if this timeout
- *              elapsed without completion of the DMA transfer.  Units
- *              are system clock ticks.  Zero means no timeout.
- *
- * Returned Value:
- *   OK on success; a negated errno value on failure.  NOTE:  This function
- *   only enqueues the transfer and returns immediately.  Success here only
- *   means that the transfer was enqueued correctly.
- *
- *   When the transfer is complete, a 'result' value will be provided as
- *   an argument to the callback function that will indicate if the transfer
- *   failed.
- *
- ****************************************************************************/
-
-static int sai_receive(struct i2s_dev_s *dev, struct ap_buffer_s *apb,
-                       i2s_callback_t callback, void *arg, uint32_t timeout)
-{
-  struct stm32l4_sai_s *priv = (struct stm32l4_sai_s *)dev;
-  struct sai_buffer_s *bfcontainer;
-  uint32_t mode;
-  irqstate_t flags;
-  int ret;
-
-  DEBUGASSERT(priv && apb);
-  i2sinfo("apb=%p nbytes=%d arg=%p timeout=%d\n",
-          apb, apb->nbytes - apb->curbyte, arg, timeout);
-
-  /* Allocate a buffer container in advance */
-
-  bfcontainer = sai_buf_allocate(priv);
-  DEBUGASSERT(bfcontainer);
-
-  /* Get exclusive access to the SAI driver data */
-
-  sai_exclsem_take(priv);
-
-  /* Verify not already TX'ing */
-
-  if (priv->txenab)
-    {
-      i2serr("ERROR: SAI has no receiver\n");
-      ret = -EAGAIN;
-      goto errout_with_exclsem;
-    }
-
-  mode = priv->syncen ? SAI_CR1_MODE_SLAVE_RX : SAI_CR1_MODE_MASTER_RX;
-  sai_modifyreg(priv, STM32L4_SAI_CR1_OFFSET, SAI_CR1_MODE_MASK, mode);
-  priv->rxenab = true;
-
-  /* Add a reference to the audio buffer */
-
-  apb_reference(apb);
-
-  /* Initialize the buffer container structure */
-
-  bfcontainer->callback = (void *)callback;
-  bfcontainer->timeout  = timeout;
-  bfcontainer->arg      = arg;
-  bfcontainer->apb      = apb;
-  bfcontainer->result   = -EBUSY;
-
-  /* Add the buffer container to the end of the pending queue */
-
-  flags = enter_critical_section();
-  sq_addlast((sq_entry_t *)bfcontainer, &priv->pend);
-
-  /* Then start the next transfer.  If there is already a transfer in progess,
-   * then this will do nothing.
-   */
-
-#ifdef CONFIG_STM32L4_SAI_DMA
-  ret = sai_dma_setup(priv);
-#endif
-  DEBUGASSERT(ret == OK);
-  leave_critical_section(flags);
-  sai_exclsem_give(priv);
-  return OK;
-
-errout_with_exclsem:
-  sai_exclsem_give(priv);
-  sai_buf_free(priv, bfcontainer);
-  return ret;
-}
-
-/****************************************************************************
- * Name: sai_send
- *
- * Description:
- *   Send a block of data on I2S.
- *
- * Input Parameters:
- *   dev      - Device-specific state data
- *   apb      - A pointer to the audio buffer from which to send data
- *   callback - A user provided callback function that will be called at
- *              the completion of the transfer.  The callback will be
- *              performed in the context of the worker thread.
- *   arg      - An opaque argument that will be provided to the callback
- *              when the transfer complete
- *   timeout  - The timeout value to use.  The transfer will be canceled
- *              and an ETIMEDOUT error will be reported if this timeout
- *              elapsed without completion of the DMA transfer.  Units
- *              are system clock ticks.  Zero means no timeout.
- *
- * Returned Value:
- *   OK on success; a negated errno value on failure.  NOTE:  This function
- *   only enqueues the transfer and returns immediately.  Success here only
- *   means that the transfer was enqueued correctly.
- *
- *   When the transfer is complete, a 'result' value will be provided as
- *   an argument to the callback function that will indicate if the transfer
- *   failed.
- *
- ****************************************************************************/
-
-static int sai_send(struct i2s_dev_s *dev, struct ap_buffer_s *apb,
-                    i2s_callback_t callback, void *arg, uint32_t timeout)
-{
-  struct stm32l4_sai_s *priv = (struct stm32l4_sai_s *)dev;
-  struct sai_buffer_s *bfcontainer;
-  uint32_t mode;
-  irqstate_t flags;
-  int ret;
-
-  DEBUGASSERT(priv && apb);
-  i2sinfo("apb=%p nbytes=%d arg=%p timeout=%d\n",
-          apb, apb->nbytes - apb->curbyte, arg, timeout);
-
-  /* Allocate a buffer container in advance */
-
-  bfcontainer = sai_buf_allocate(priv);
-  DEBUGASSERT(bfcontainer);
-
-  /* Get exclusive access to the SAI driver data */
-
-  sai_exclsem_take(priv);
-
-  /* Verify not already RX'ing */
-
-  if (priv->rxenab)
-    {
-      i2serr("ERROR: SAI has no transmitter\n");
-      ret = -EAGAIN;
-      goto errout_with_exclsem;
-    }
-
-  mode = priv->syncen ? SAI_CR1_MODE_SLAVE_TX : SAI_CR1_MODE_MASTER_TX;
-  sai_modifyreg(priv, STM32L4_SAI_CR1_OFFSET, SAI_CR1_MODE_MASK, mode);
-  priv->txenab = true;
-
-  /* Add a reference to the audio buffer */
-
-  apb_reference(apb);
-
-  /* Initialize the buffer container structure */
-
-  bfcontainer->callback = (void *)callback;
-  bfcontainer->timeout  = timeout;
-  bfcontainer->arg      = arg;
-  bfcontainer->apb      = apb;
-  bfcontainer->result   = -EBUSY;
-
-  /* Add the buffer container to the end of the pending queue */
-
-  flags = enter_critical_section();
-  sq_addlast((sq_entry_t *)bfcontainer, &priv->pend);
-
-  /* Then start the next transfer.  If there is already a transfer in progess,
-   * then this will do nothing.
-   */
-
-#ifdef CONFIG_STM32L4_SAI_DMA
-  ret = sai_dma_setup(priv);
-#endif
-  DEBUGASSERT(ret == OK);
-  leave_critical_section(flags);
-  sai_exclsem_give(priv);
-  return OK;
-
-errout_with_exclsem:
-  sai_exclsem_give(priv);
-  sai_buf_free(priv, bfcontainer);
-  return ret;
-}
-
-/****************************************************************************
- * Name: sai_bufsem_take
- *
- * Description:
- *   Take the buffer semaphore handling any exceptional conditions
- *
- * Input Parameters:
- *   priv - A reference to the SAI peripheral state
- *
- * Returned Value:
- *  None
- *
- ****************************************************************************/
-
-static void sai_bufsem_take(struct stm32l4_sai_s *priv)
-{
-  int ret;
-
-  /* Wait until we successfully get the semaphore.  EINTR is the only
-   * expected 'failure' (meaning that the wait for the semaphore was
-   * interrupted by a signal).
-   */
-
-  do
-    {
-      ret = sem_wait(&priv->bufsem);
-      DEBUGASSERT(ret == 0 || errno == EINTR);
-    }
-  while (ret < 0);
-}
-
-/****************************************************************************
- * Name: sai_buf_allocate
- *
- * Description:
- *   Allocate a buffer container by removing the one at the head of the
- *   free list
- *
- * Input Parameters:
- *   priv - SAI state instance
- *
- * Returned Value:
- *   A non-NULL pointer to the allocate buffer container on success; NULL if
- *   there are no available buffer containers.
- *
- * Assumptions:
- *   The caller does NOT have exclusive access to the SAI state structure.
- *   That would result in a deadlock!
- *
- ****************************************************************************/
-
-static struct sai_buffer_s *sai_buf_allocate(struct stm32l4_sai_s *priv)
-{
-  struct sai_buffer_s *bfcontainer;
-  irqstate_t flags;
-
-  /* Set aside a buffer container.  By doing this, we guarantee that we will
-   * have at least one free buffer container.
-   */
-
-  sai_bufsem_take(priv);
-
-  /* Get the buffer from the head of the free list */
-
-  flags = enter_critical_section();
-  bfcontainer = priv->freelist;
-  ASSERT(bfcontainer);
-
-  /* Unlink the buffer from the freelist */
-
-  priv->freelist = bfcontainer->flink;
-  leave_critical_section(flags);
-  return bfcontainer;
-}
-
-/****************************************************************************
- * Name: sai_buf_free
- *
- * Description:
- *   Free buffer container by adding it to the head of the free list
- *
- * Input Parameters:
- *   priv - SAI state instance
- *   bfcontainer - The buffer container to be freed
- *
- * Returned Value:
- *   None
- *
- * Assumptions:
- *   The caller has exclusive access to the SAI state structure
- *
- ****************************************************************************/
-
-static void sai_buf_free(struct stm32l4_sai_s *priv, struct sai_buffer_s *bfcontainer)
-{
-  irqstate_t flags;
-
-  /* Put the buffer container back on the free list */
-
-  flags = enter_critical_section();
-  bfcontainer->flink  = priv->freelist;
-  priv->freelist = bfcontainer;
-  leave_critical_section(flags);
-
-  /* Wake up any threads waiting for a buffer container */
-
-  sai_bufsem_give(priv);
-}
-
-/****************************************************************************
- * Name: sai_buf_initialize
- *
- * Description:
- *   Initialize the buffer container allocator by adding all of the
- *   pre-allocated buffer containers to the free list
- *
- * Input Parameters:
- *   priv - SAI state instance
- *
- * Returned Value:
- *   None
- *
- * Assumptions:
- *   Called early in SAI initialization so that there are no issues with
- *   concurrency.
- *
- ****************************************************************************/
-
-static void sai_buf_initialize(struct stm32l4_sai_s *priv)
-{
-  int i;
-
-  priv->freelist = NULL;
-  sem_init(&priv->bufsem, 0, CONFIG_STM32L4_SAI_MAXINFLIGHT);
-
-  for (i = 0; i < CONFIG_STM32L4_SAI_MAXINFLIGHT; i++)
-    {
-      sai_buf_free(priv, &priv->containers[i]);
-    }
-}
-
-/****************************************************************************
- * Name: sai_portinitialize
- *
- * Description:
- *   Initialize the selected SAI port in its default state
- *
- * Input Parameter:
- *   priv   - private SAI device structure
- *
- * Returned Value:
- *   None
- *
- ****************************************************************************/
-
-static void sai_portinitialize(struct stm32l4_sai_s *priv)
-{
-  sai_dump_regs(priv, "Before initialization");
-
-  sem_init(&priv->exclsem, 0, 1);
-
-  /* Create a watchdog timer to catch transfer timeouts */
-
-  priv->dog = wd_create();
-  ASSERT(priv->dog);
-
-  /* Initialize buffering */
-
-  sai_buf_initialize(priv);
-
-  /* Configure the master clock divider */
-
-  sai_mckdivider(priv);
-
-  /* Configure the data width */
-
-  sai_datawidth((struct i2s_dev_s *)priv, CONFIG_STM32L4_SAI_DEFAULT_DATALEN);
-
-#ifdef CONFIG_STM32L4_SAI_DMA
-  /* Get DMA channel */
-
-  priv->dma = stm32l4_dmachannel(priv->dma_ch);
-  DEBUGASSERT(priv->dma);
-
-  sai_modifyreg(priv, STM32L4_SAI_CR1_OFFSET, 0, SAI_CR1_DMAEN);
-#endif
-
-  sai_modifyreg(priv, STM32L4_SAI_CR1_OFFSET, SAI_CR1_SYNCEN_MASK, priv->syncen);
-
-  sai_modifyreg(priv, STM32L4_SAI_CR2_OFFSET, SAI_CR2_FTH_MASK, SAI_CR2_FTH_1QF);
-
-  sai_modifyreg(priv, STM32L4_SAI_FRCR_OFFSET,
-                SAI_FRCR_FSDEF | SAI_FRCR_FSPOL | SAI_FRCR_FSOFF,
-                SAI_FRCR_FSDEF_CHID | SAI_FRCR_FSPOL_LOW | SAI_FRCR_FSOFF_BFB);
-
-  sai_modifyreg(priv, STM32L4_SAI_SLOTR_OFFSET,
-                SAI_SLOTR_NBSLOT_MASK | SAI_SLOTR_SLOTEN_MASK,
-                SAI_SLOTR_NBSLOT(2) | SAI_SLOTR_SLOTEN_0 | SAI_SLOTR_SLOTEN_1);
-
-  sai_dump_regs(priv, "After initialization");
-}
-
-/****************************************************************************
- * Public Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_sai_initialize
- *
- * Description:
- *   Initialize the selected SAI block
- *
- * Input Parameter:
- *   intf - I2S interface number (identifying the "logical" SAI interface)
- *
- * Returned Value:
- *   Valid I2S device structure reference on success; a NULL on failure
- *
- ****************************************************************************/
-
-struct i2s_dev_s *stm32l4_sai_initialize(int intf)
-{
-  struct stm32l4_sai_s *priv;
-  irqstate_t flags;
-
-  flags = enter_critical_section();
-
-  switch (intf)
-    {
-#ifdef CONFIG_STM32L4_SAI1_A
-      case SAI1_BLOCK_A:
-        {
-          i2sinfo("SAI1 Block A Selected\n");
-          priv = &g_sai1a_priv;
-
-          stm32l4_configgpio(GPIO_SAI1_SD_A);
-#  ifndef CONFIG_STM32L4_SAI1_A_SYNC_WITH_B
-          stm32l4_configgpio(GPIO_SAI1_FS_A);
-          stm32l4_configgpio(GPIO_SAI1_SCK_A);
-          stm32l4_configgpio(GPIO_SAI1_MCLK_A);
-#  endif
-          break;
-        }
-#endif
-#ifdef CONFIG_STM32L4_SAI1_B
-      case SAI1_BLOCK_B:
-        {
-          i2sinfo("SAI1 Block B Selected\n");
-          priv = &g_sai1b_priv;
-
-          stm32l4_configgpio(GPIO_SAI1_SD_B);
-#  ifndef CONFIG_STM32L4_SAI1_B_SYNC_WITH_A
-          stm32l4_configgpio(GPIO_SAI1_FS_B);
-          stm32l4_configgpio(GPIO_SAI1_SCK_B);
-          stm32l4_configgpio(GPIO_SAI1_MCLK_B);
-#  endif
-          break;
-        }
-#endif
-#ifdef CONFIG_STM32L4_SAI2_A
-      case SAI2_BLOCK_A:
-        {
-          i2sinfo("SAI2 Block A Selected\n");
-          priv = &g_sai2a_priv;
-
-          stm32l4_configgpio(GPIO_SAI2_SD_A);
-#  ifndef CONFIG_STM32L4_SAI2_A_SYNC_WITH_B
-          stm32l4_configgpio(GPIO_SAI2_FS_A);
-          stm32l4_configgpio(GPIO_SAI2_SCK_A);
-          stm32l4_configgpio(GPIO_SAI2_MCLK_A);
-#  endif
-          break;
-        }
-#endif
-#ifdef CONFIG_STM32L4_SAI2_B
-      case SAI2_BLOCK_B:
-        {
-          i2sinfo("SAI2 Block B Selected\n");
-          priv = &g_sai2b_priv;
-
-          stm32l4_configgpio(GPIO_SAI2_SD_B);
-#  ifndef CONFIG_STM32L4_SAI2_B_SYNC_WITH_A
-          stm32l4_configgpio(GPIO_SAI2_FS_B);
-          stm32l4_configgpio(GPIO_SAI2_SCK_B);
-          stm32l4_configgpio(GPIO_SAI2_MCLK_B);
-#  endif
-          break;
-        }
-#endif
-      default:
-        {
-          i2sinfo("No SAI interface defined\n");
-          goto err;
-        }
-    }
-
-  sai_portinitialize(priv);
-  leave_critical_section(flags);
-
-  return &priv->dev;
-
-err:
-  leave_critical_section(flags);
-  return NULL;
-}
-
-#endif
diff --git a/arch/arm/src/nrf52/nrf52_sai.h b/arch/arm/src/nrf52/nrf52_sai.h
deleted file mode 100644
index b1b4955185..0000000000
--- a/arch/arm/src/nrf52/nrf52_sai.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/******************************************************************************
- * arch/arm/src/stm32l4/stm32l4_sai.h
- *
- *   Copyright (C) 2017 Gregory Nutt. All rights reserved.
- *   Copyright (c) 2016 Motorola Mobility, LLC. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ******************************************************************************/
-
-#ifndef __ARCH_ARM_SRC_STM32L4_STM32L4_SAI_H
-#define __ARCH_ARM_SRC_STM32L4_STM32L4_SAI_H
-
-/******************************************************************************
- * Included Files
- ******************************************************************************/
-
-#include <nuttx/config.h>
-
-#include "chip.h"
-#include "chip/stm32l4_sai.h"
-
-#include <nuttx/audio/i2s.h>
-
-/******************************************************************************
- * Pre-processor definitions
- ******************************************************************************/
-
-#define SAI1_BLOCK_A     0
-#define SAI1_BLOCK_B     1
-#define SAI2_BLOCK_A     2
-#define SAI2_BLOCK_B     3
-
-/******************************************************************************
- * Public Function Prototypes
- ******************************************************************************/
-
-#ifndef __ASSEMBLY__
-#ifdef __cplusplus
-#define EXTERN extern "C"
-extern "C"
-{
-#else
-#define EXTERN extern
-#endif
-
-/****************************************************************************
- * Name: stm32l4_sai_initialize
- *
- * Description:
- *   Initialize the selected SAI block
- *
- * Input Parameters:
- *   intf - I2S interface number (identifying the "logical" SAI interface)
- *
- * Returned Value:
- *   Valid I2S device structure reference on success; a NULL on failure
- *
- ****************************************************************************/
-
-struct i2s_dev_s *stm32l4_sai_initialize(int intf);
-
-#undef EXTERN
-#ifdef __cplusplus
-}
-#endif
-#endif /* __ASSEMBLY__ */
-
-#endif /* __ARCH_ARM_SRC_STM32L4_STM32L4_SAI_H */
diff --git a/arch/arm/src/nrf52/nrf52_tickless.c b/arch/arm/src/nrf52/nrf52_tickless.c
deleted file mode 100644
index 8b8a257045..0000000000
--- a/arch/arm/src/nrf52/nrf52_tickless.c
+++ /dev/null
@@ -1,351 +0,0 @@
-/****************************************************************************
- * arch/arm/src/stm32l4/stm32l4_tickless.c
- *
- *   Copyright (C) 2016 Gregory Nutt. All rights reserved.
- *   Author: Gregory Nutt <gnutt@nuttx.org>
- *           dev@ziggurat29.com
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ****************************************************************************/
-/****************************************************************************
- * Tickless OS Support.
- *
- * When CONFIG_SCHED_TICKLESS is enabled, all support for timer interrupts
- * is suppressed and the platform specific code is expected to provide the
- * following custom functions.
- *
- *   void arm_timer_initialize(void): Initializes the timer facilities.
- *     Called early in the initialization sequence (by up_intialize()).
- *   int up_timer_gettime(FAR struct timespec *ts):  Returns the current
- *     time from the platform specific time source.
- *   int up_timer_cancel(void):  Cancels the interval timer.
- *   int up_timer_start(FAR const struct timespec *ts): Start (or re-starts)
- *     the interval timer.
- *
- * The RTOS will provide the following interfaces for use by the platform-
- * specific interval timer implementation:
- *
- *   void sched_timer_expiration(void):  Called by the platform-specific
- *     logic when the interval timer expires.
- *
- ****************************************************************************/
-/****************************************************************************
- * STM32L4 Timer Usage
- *
- * This current implementation uses two timers:  A one-shot timer to provide
- * the timed events and a free running timer to provide the current time.
- * Since timers are a limited resource, that could be an issue on some
- * systems.
- *
- * We could do the job with a single timer if we were to keep the single
- * timer in a free-running at all times.  The STM32 timer/counters have
- * 16-bit/32-bit counters with the capability to generate a compare interrupt
- * when the timer matches a compare value but also to continue counting
- * without stopping (giving another, different interrupt when the timer
- * rolls over from 0xffffffff to zero).  So we could potentially just set
- * the compare at the number of ticks you want PLUS the current value of
- * timer.  Then you could have both with a single timer:  An interval timer
- * and a free-running counter with the same timer!
- *
- * Patches are welcome!
- *
- ****************************************************************************/
-
-/****************************************************************************
- * Included Files
- ****************************************************************************/
-
-#include <nuttx/config.h>
-
-#include <stdint.h>
-#include <stdbool.h>
-
-#include <nuttx/arch.h>
-#include <debug.h>
-
-#include "stm32l4_oneshot.h"
-#include "stm32l4_freerun.h"
-
-#ifdef CONFIG_SCHED_TICKLESS
-
-/****************************************************************************
- * Pre-processor Definitions
- ****************************************************************************/
-
-#ifndef CONFIG_STM32L4_ONESHOT
-#  error CONFIG_STM32L4_ONESHOT must be selected for the Tickless OS option
-#endif
-
-#ifndef CONFIG_STM32L4_FREERUN
-#  error CONFIG_STM32L4_FREERUN must be selected for the Tickless OS option
-#endif
-
-#ifndef CONFIG_STM32L4_TICKLESS_FREERUN
-#  error CONFIG_STM32L4_TICKLESS_FREERUN must be selected for the Tickless OS option
-#endif
-
-#ifndef CONFIG_STM32L4_TICKLESS_ONESHOT
-#  error CONFIG_STM32L4_TICKLESS_ONESHOT must be selected for the Tickless OS option
-#endif
-
-/****************************************************************************
- * Private Types
- ****************************************************************************/
-
-struct stm32l4_tickless_s
-{
-  struct stm32l4_oneshot_s oneshot;
-  struct stm32l4_freerun_s freerun;
-};
-
-/****************************************************************************
- * Private Data
- ****************************************************************************/
-
-static struct stm32l4_tickless_s g_tickless;
-
-/****************************************************************************
- * Private Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: stm32l4_oneshot_handler
- *
- * Description:
- *   Called when the one shot timer expires
- *
- * Input Parameters:
- *   None
- *
- * Returned Value:
- *   None
- *
- * Assumptions:
- *   Called early in the initialization sequence before any special
- *   concurrency protections are required.
- *
- ****************************************************************************/
-
-static void stm32l4_oneshot_handler(FAR void *arg)
-{
-  tmrinfo("Expired...\n");
-  sched_timer_expiration();
-}
-
-/****************************************************************************
- * Public Functions
- ****************************************************************************/
-
-/****************************************************************************
- * Name: arm_timer_initialize
- *
- * Description:
- *   Initializes all platform-specific timer facilities.  This function is
- *   called early in the initialization sequence by up_intialize().
- *   On return, the current up-time should be available from
- *   up_timer_gettime() and the interval timer is ready for use (but not
- *   actively timing.
- *
- *   Provided by platform-specific code and called from the architecture-
- *   specific logic.
- *
- * Input Parameters:
- *   None
- *
- * Returned Value:
- *   None
- *
- * Assumptions:
- *   Called early in the initialization sequence before any special
- *   concurrency protections are required.
- *
- ****************************************************************************/
-
-void arm_timer_initialize(void)
-{
-#ifdef CONFIG_SCHED_TICKLESS_LIMIT_MAX_SLEEP
-  uint64_t max_delay;
-#endif
-  int ret;
-
-  /* Initialize the one-shot timer */
-
-  ret = stm32l4_oneshot_initialize(&g_tickless.oneshot,
-                                   CONFIG_STM32L4_TICKLESS_ONESHOT,
-                                   CONFIG_USEC_PER_TICK);
-  if (ret < 0)
-    {
-      tmrerr("ERROR: stm32l4_oneshot_initialize failed\n");
-      PANIC();
-    }
-
-#ifdef CONFIG_SCHED_TICKLESS_LIMIT_MAX_SLEEP
-  /* Get the maximum delay of the one-shot timer in microseconds */
-
-  ret = stm32l4_oneshot_max_delay(&g_tickless.oneshot, &max_delay);
-  if (ret < 0)
-    {
-      tmrerr("ERROR: stm32l4_oneshot_max_delay failed\n");
-      PANIC();
-    }
-
-  /* Convert this to configured clock ticks for use by the OS timer logic */
-
-  max_delay /= CONFIG_USEC_PER_TICK;
-  if (max_delay > UINT32_MAX)
-    {
-      g_oneshot_maxticks = UINT32_MAX;
-    }
-  else
-    {
-      g_oneshot_maxticks = max_delay;
-    }
-#endif
-
-  /* Initialize the free-running timer */
-
-  ret = stm32l4_freerun_initialize(&g_tickless.freerun,
-                                   CONFIG_STM32L4_TICKLESS_FREERUN,
-                                   CONFIG_USEC_PER_TICK);
-  if (ret < 0)
-    {
-      tmrerr("ERROR: stm32l4_freerun_initialize failed\n");
-      PANIC();
-    }
-}
-
-/****************************************************************************
- * Name: up_timer_gettime
- *
- * Description:
- *   Return the elapsed time since power-up (or, more correctly, since
- *   arm_timer_initialize() was called).  This function is functionally
- *   equivalent to:
- *
- *      int clock_gettime(clockid_t clockid, FAR struct timespec *ts);
- *
- *   when clockid is CLOCK_MONOTONIC.
- *
- *   This function provides the basis for reporting the current time and
- *   also is used to eliminate error build-up from small errors in interval
- *   time calculations.
- *
- *   Provided by platform-specific code and called from the RTOS base code.
- *
- * Input Parameters:
- *   ts - Provides the location in which to return the up-time.
- *
- * Returned Value:
- *   Zero (OK) is returned on success; a negated errno value is returned on
- *   any failure.
- *
- * Assumptions:
- *   Called from the the normal tasking context.  The implementation must
- *   provide whatever mutual exclusion is necessary for correct operation.
- *   This can include disabling interrupts in order to assure atomic register
- *   operations.
- *
- ****************************************************************************/
-
-int up_timer_gettime(FAR struct timespec *ts)
-{
-  return stm32l4_freerun_counter(&g_tickless.freerun, ts);
-}
-
-/****************************************************************************
- * Name: up_timer_cancel
- *
- * Description:
- *   Cancel the interval timer and return the time remaining on the timer.
- *   These two steps need to be as nearly atomic as possible.
- *   sched_timer_expiration() will not be called unless the timer is
- *   restarted with up_timer_start().
- *
- *   If, as a race condition, the timer has already expired when this
- *   function is called, then that pending interrupt must be cleared so
- *   that up_timer_start() and the remaining time of zero should be
- *   returned.
- *
- *   NOTE: This function may execute at a high rate with no timer running (as
- *   when pre-emption is enabled and disabled).
- *
- *   Provided by platform-specific code and called from the RTOS base code.
- *
- * Input Parameters:
- *   ts - Location to return the remaining time.  Zero should be returned
- *        if the timer is not active.  ts may be zero in which case the
- *        time remaining is not returned.
- *
- * Returned Value:
- *   Zero (OK) is returned on success.  A call to up_timer_cancel() when
- *   the timer is not active should also return success; a negated errno
- *   value is returned on any failure.
- *
- * Assumptions:
- *   May be called from interrupt level handling or from the normal tasking
- *   level.  Interrupts may need to be disabled internally to assure
- *   non-reentrancy.
- *
- ****************************************************************************/
-
-int up_timer_cancel(FAR struct timespec *ts)
-{
-  return stm32l4_oneshot_cancel(&g_tickless.oneshot, ts);
-}
-
-/****************************************************************************
- * Name: up_timer_start
- *
- * Description:
- *   Start the interval timer.  sched_timer_expiration() will be
- *   called at the completion of the timeout (unless up_timer_cancel
- *   is called to stop the timing.
- *
- *   Provided by platform-specific code and called from the RTOS base code.
- *
- * Input Parameters:
- *   ts - Provides the time interval until sched_timer_expiration() is
- *        called.
- *
- * Returned Value:
- *   Zero (OK) is returned on success; a negated errno value is returned on
- *   any failure.
- *
- * Assumptions:
- *   May be called from interrupt level handling or from the normal tasking
- *   level.  Interrupts may need to be disabled internally to assure
- *   non-reentrancy.
- *
- ****************************************************************************/
-
-int up_timer_start(FAR const struct timespec *ts)
-{
-  return stm32l4_oneshot_start(&g_tickless.oneshot, stm32l4_oneshot_handler, NULL, ts);
-}
-#endif /* CONFIG_SCHED_TICKLESS */
diff --git a/arch/arm/src/nrf52/nrf52_waste.c b/arch/arm/src/nrf52/nrf52_waste.c
deleted file mode 100644
index 0097ff82d1..0000000000
--- a/arch/arm/src/nrf52/nrf52_waste.c
+++ /dev/null
@@ -1,57 +0,0 @@
-/****************************************************************************
- *  arch/arm/src/stm32l4/stm32l4_waste.c
- *
- *   Copyright (C) 2011 Uros Platise. All rights reserved.
- *   Author: Uros Platise <uros.platise@isotel.eu>
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ****************************************************************************/
-
-/****************************************************************************
- * Included Files
- ****************************************************************************/
-
-#include <nuttx/config.h>
-#include <stdint.h>
-#include "nrf52_waste.h"
-
-/****************************************************************************
- * Private Data
- ****************************************************************************/
-
-uint32_t idle_wastecounter = 0;
-
-/****************************************************************************
- * Public Functions
- ****************************************************************************/
-
-void up_waste(void)
-{
-  idle_wastecounter++;
-}
diff --git a/arch/arm/src/nrf52/nrf52_waste.h b/arch/arm/src/nrf52/nrf52_waste.h
deleted file mode 100644
index 5a7d2b64e8..0000000000
--- a/arch/arm/src/nrf52/nrf52_waste.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/****************************************************************************
- *  arch/arm/src/nrr52/nrf52_waste.h
- *
- *   Copyright (C) 2011, 2017 Uros Platise. All rights reserved.
- *   Author: Uros Platise <uros.platise@isotel.eu>
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- ****************************************************************************/
-
-#ifndef __ARCH_ARM_SRC_NRF52_NRF52_WASTE_H
-#define __ARCH_ARM_SRC_NRF52_NRF52_WASTE_H
-
-/* Waste CPU Time */
-
-/****************************************************************************
- * Pre-processor Definitions
- ****************************************************************************/
-
-#ifndef __ASSEMBLY__
-
-#undef EXTERN
-#if defined(__cplusplus)
-#define EXTERN extern "C"
-extern "C"
-{
-#else
-#define EXTERN extern
-#endif
-
-/****************************************************************************
- * Public Functions
- ****************************************************************************/
-
-/** Waste CPU Time
- *
- *   up_waste() is the logic that will be executed when portions of kernel
- *   or user-app is polling some register or similar, waiting for desired
- *   status. This time is wasted away. This function offers a measure of
- *   badly written piece of software or some undesired behavior.
- *
- *   At the same time this function adds to some IDLE time which portion
- *   cannot be used for other purposes (yet).
- **/
-
-void up_waste(void);
-
-#undef EXTERN
-#if defined(__cplusplus)
-}
-#endif
-
-#endif /* __ASSEMBLY__ */
-#endif /* __ARCH_ARM_SRC_NRF52_NRF52_WASTE_H */
diff --git a/arch/arm/src/nrf52/nrf52_wdg.c b/arch/arm/src/nrf52/nrf52_wdg.c
index c36acfe98a..048379ed8b 100644
--- a/arch/arm/src/nrf52/nrf52_wdg.c
+++ b/arch/arm/src/nrf52/nrf52_wdg.c
@@ -57,8 +57,6 @@
 #include "nrf_drv_common.h"
 #include "nrf_wdt.h"
 
-//#include "nrf52_rcc.h"
-//#include "chip/nrf52_dbgmcu.h"
 #include "nrf52_wdg.h"
 
 #if defined(CONFIG_WATCHDOG) && defined(CONFIG_NRF52_WDG)
diff --git a/arch/arm/src/nrf52/nrf_uarte.h b/arch/arm/src/nrf52/nrf_uarte.h
deleted file mode 100644
index 3d9c39b93f..0000000000
--- a/arch/arm/src/nrf52/nrf_uarte.h
+++ /dev/null
@@ -1,547 +0,0 @@
-/* Copyright (c) 2015 Nordic Semiconductor. All Rights Reserved.
- *
- * The information contained herein is property of Nordic Semiconductor ASA.
- * Terms and conditions of usage are described in detail in NORDIC
- * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
- *
- * Licensees are granted free, non-transferable use of the information. NO
- * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
- * the file.
- *
- */
-#ifndef NRF_UARTE_H__
-#define NRF_UARTE_H__
-
-// #include "nrf.h"
-#include <stdint.h>
-#include <stddef.h>
-#include <stdbool.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define NRF_UARTE_PSEL_DISCONNECTED 0xFFFFFFFF
-
-/**
- * @defgroup nrf_uarte_hal UARTE HAL
- * @{
- * @ingroup nrf_uart
- *
- * @brief Hardware access layer for accessing the UARTE peripheral.
- */
-
-/**
- * @enum  nrf_uarte_task_t
- * @brief UARTE tasks.
- */
-typedef enum
-{
-  /*lint -save -e30*/
-  NRF_UARTE_TASK_STARTRX   = offsetof(NRF_UARTE_Type, TASKS_STARTRX),///< Start UART receiver.
-  NRF_UARTE_TASK_STOPRX    = offsetof(NRF_UARTE_Type, TASKS_STOPRX), ///< Stop UART receiver.
-  NRF_UARTE_TASK_STARTTX   = offsetof(NRF_UARTE_Type, TASKS_STARTTX),///< Start UART transmitter.
-  NRF_UARTE_TASK_STOPTX    = offsetof(NRF_UARTE_Type, TASKS_STOPTX), ///< Stop UART transmitter.
-  NRF_UARTE_TASK_FLUSHRX   = offsetof(NRF_UARTE_Type, TASKS_FLUSHRX) ///< Flush RX FIFO in RX buffer.
-                             /*lint -restore*/
-} nrf_uarte_task_t;
-
-/**
- * @enum  nrf_uarte_event_t
- * @brief UARTE events.
- */
-typedef enum
-{
-  /*lint -save -e30*/
-  NRF_UARTE_EVENT_CTS       = offsetof(NRF_UARTE_Type, EVENTS_CTS),      ///< CTS is activated.
-  NRF_UARTE_EVENT_NCTS      = offsetof(NRF_UARTE_Type, EVENTS_NCTS),     ///< CTS is deactivated.
-  NRF_UARTE_EVENT_ENDRX     = offsetof(NRF_UARTE_Type, EVENTS_ENDRX),    ///< Receive buffer is filled up.
-  NRF_UARTE_EVENT_ENDTX     = offsetof(NRF_UARTE_Type, EVENTS_ENDTX),    ///< Last TX byte transmitted.
-  NRF_UARTE_EVENT_ERROR     = offsetof(NRF_UARTE_Type, EVENTS_ERROR),    ///< Error detected.
-  NRF_UARTE_EVENT_RXTO      = offsetof(NRF_UARTE_Type, EVENTS_RXTO),     ///< Receiver timeout.
-  NRF_UARTE_EVENT_RXSTARTED = offsetof(NRF_UARTE_Type, EVENTS_RXSTARTED),///< Receiver has started.
-  NRF_UARTE_EVENT_TXSTARTED = offsetof(NRF_UARTE_Type, EVENTS_TXSTARTED),///< Transmitter has started.
-  NRF_UARTE_EVENT_TXSTOPPED = offsetof(NRF_UARTE_Type, EVENTS_TXSTOPPED) ///< Transmitted stopped.
-                              /*lint -restore*/
-} nrf_uarte_event_t;
-
-/**
- * @brief Types of UARTE shortcuts.
- */
-typedef enum
-{
-  NRF_UARTE_SHORT_ENDRX_STARTRX = UARTE_SHORTS_ENDRX_STARTRX_Msk,///< Shortcut between ENDRX event and STARTRX task.
-  NRF_UARTE_SHORT_ENDRX_STOPRX  = UARTE_SHORTS_ENDRX_STOPRX_Msk, ///< Shortcut between ENDRX event and STOPRX task.
-} nrf_uarte_short_t;
-
-
-/**
- * @enum  nrf_uarte_int_mask_t
- * @brief UARTE interrupts.
- */
-typedef enum
-{
-  NRF_UARTE_INT_CTS_MASK       = UARTE_INTENSET_CTS_Msk,      ///< Interrupt on CTS event.
-  NRF_UARTE_INT_NCTSRX_MASK    = UARTE_INTENSET_NCTS_Msk,     ///< Interrupt on NCTS event.
-  NRF_UARTE_INT_ENDRX_MASK     = UARTE_INTENSET_ENDRX_Msk,    ///< Interrupt on ENDRX event.
-  NRF_UARTE_INT_ENDTX_MASK     = UARTE_INTENSET_ENDTX_Msk,    ///< Interrupt on ENDTX event.
-  NRF_UARTE_INT_ERROR_MASK     = UARTE_INTENSET_ERROR_Msk,    ///< Interrupt on ERROR event.
-  NRF_UARTE_INT_RXTO_MASK      = UARTE_INTENSET_RXTO_Msk,     ///< Interrupt on RXTO event.
-  NRF_UARTE_INT_RXSTARTED_MASK = UARTE_INTENSET_RXSTARTED_Msk,///< Interrupt on RXSTARTED event.
-  NRF_UARTE_INT_TXSTARTED_MASK = UARTE_INTENSET_TXSTARTED_Msk,///< Interrupt on TXSTARTED event.
-  NRF_UARTE_INT_TXSTOPPED_MASK = UARTE_INTENSET_TXSTOPPED_Msk ///< Interrupt on TXSTOPPED event.
-} nrf_uarte_int_mask_t;
-
-/**
- * @enum nrf_uarte_baudrate_t
- * @brief Baudrates supported by UARTE.
- */
-typedef enum
-{
-  NRF_UARTE_BAUDRATE_1200   =  UARTE_BAUDRATE_BAUDRATE_Baud1200,   ///< 1200 baud.
-  NRF_UARTE_BAUDRATE_2400   =  UARTE_BAUDRATE_BAUDRATE_Baud2400,   ///< 2400 baud.
-  NRF_UARTE_BAUDRATE_4800   =  UARTE_BAUDRATE_BAUDRATE_Baud4800,   ///< 4800 baud.
-  NRF_UARTE_BAUDRATE_9600   =  UARTE_BAUDRATE_BAUDRATE_Baud9600,   ///< 9600 baud.
-  NRF_UARTE_BAUDRATE_14400  =  UARTE_BAUDRATE_BAUDRATE_Baud14400,  ///< 14400 baud.
-  NRF_UARTE_BAUDRATE_19200  =  UARTE_BAUDRATE_BAUDRATE_Baud19200,  ///< 19200 baud.
-  NRF_UARTE_BAUDRATE_28800  =  UARTE_BAUDRATE_BAUDRATE_Baud28800,  ///< 28800 baud.
-  NRF_UARTE_BAUDRATE_38400  =  UARTE_BAUDRATE_BAUDRATE_Baud38400,  ///< 38400 baud.
-  NRF_UARTE_BAUDRATE_57600  =  UARTE_BAUDRATE_BAUDRATE_Baud57600,  ///< 57600 baud.
-  NRF_UARTE_BAUDRATE_76800  =  UARTE_BAUDRATE_BAUDRATE_Baud76800,  ///< 76800 baud.
-  NRF_UARTE_BAUDRATE_115200 =  UARTE_BAUDRATE_BAUDRATE_Baud115200, ///< 115200 baud.
-  NRF_UARTE_BAUDRATE_230400 =  UARTE_BAUDRATE_BAUDRATE_Baud230400, ///< 230400 baud.
-  NRF_UARTE_BAUDRATE_250000 =  UARTE_BAUDRATE_BAUDRATE_Baud250000, ///< 250000 baud.
-  NRF_UARTE_BAUDRATE_460800 =  UARTE_BAUDRATE_BAUDRATE_Baud460800, ///< 460800 baud.
-  NRF_UARTE_BAUDRATE_921600 =  UARTE_BAUDRATE_BAUDRATE_Baud921600, ///< 921600 baud.
-  NRF_UARTE_BAUDRATE_1000000 =  UARTE_BAUDRATE_BAUDRATE_Baud1M,    ///< 1000000 baud.
-} nrf_uarte_baudrate_t;
-
-/**
- * @enum nrf_uarte_error_mask_t
- * @brief Types of UARTE error masks.
- */
-typedef enum
-{
-  NRF_UARTE_ERROR_OVERRUN_MASK = UARTE_ERRORSRC_OVERRUN_Msk,   ///< Overrun error.
-  NRF_UARTE_ERROR_PARITY_MASK  = UARTE_ERRORSRC_PARITY_Msk,    ///< Parity error.
-  NRF_UARTE_ERROR_FRAMING_MASK = UARTE_ERRORSRC_FRAMING_Msk,   ///< Framing error.
-  NRF_UARTE_ERROR_BREAK_MASK   = UARTE_ERRORSRC_BREAK_Msk,     ///< Break error.
-} nrf_uarte_error_mask_t;
-
-/**
- * @enum nrf_uarte_parity_t
- * @brief Types of UARTE parity modes.
- */
-typedef enum
-{
-  NRF_UARTE_PARITY_EXCLUDED = UARTE_CONFIG_PARITY_Excluded << UARTE_CONFIG_PARITY_Pos, ///< Parity excluded.
-  NRF_UARTE_PARITY_INCLUDED = UARTE_CONFIG_PARITY_Included << UARTE_CONFIG_PARITY_Pos, ///< Parity included.
-} nrf_uarte_parity_t;
-
-/**
- * @enum nrf_uarte_hwfc_t
- * @brief Types of UARTE flow control modes.
- */
-typedef enum
-{
-  NRF_UARTE_HWFC_DISABLED = UARTE_CONFIG_HWFC_Disabled << UARTE_CONFIG_HWFC_Pos, ///< HW flow control disabled.
-  NRF_UARTE_HWFC_ENABLED  = UARTE_CONFIG_HWFC_Enabled  << UARTE_CONFIG_HWFC_Pos, ///< HW flow control enabled.
-} nrf_uarte_hwfc_t;
-
-
-/**
- * @brief Function for clearing a specific UARTE event.
- *
- * @param[in] p_reg  Pointer to the peripheral registers structure.
- * @param[in] event  Event to clear.
- */
-__STATIC_INLINE void nrf_uarte_event_clear(NRF_UARTE_Type *p_reg, nrf_uarte_event_t event);
-
-/**
- * @brief Function for checking the state of a specific UARTE event.
- *
- * @param[in] p_reg  Pointer to the peripheral registers structure.
- * @param[in] event  Event to check.
- *
- * @retval True if event is set, False otherwise.
- */
-__STATIC_INLINE bool nrf_uarte_event_check(NRF_UARTE_Type *p_reg, nrf_uarte_event_t event);
-
-/**
- * @brief Function for returning the address of a specific UARTE event register.
- *
- * @param[in] p_reg  Pointer to the peripheral registers structure.
- * @param[in] event  Desired event.
- *
- * @retval Address of specified event register.
- */
-__STATIC_INLINE uint32_t nrf_uarte_event_address_get(NRF_UARTE_Type   *p_reg,
-                                                     nrf_uarte_event_t  event);
-
-/**
- * @brief Function for enabling UARTE shortcuts.
- *
- * @param p_reg       Pointer to the peripheral registers structure.
- * @param shorts_mask Shortcuts to enable.
- */
-__STATIC_INLINE void nrf_uarte_shorts_enable(NRF_UARTE_Type *p_reg, uint32_t shorts_mask);
-
-/**
- * @brief Function for disabling UARTE shortcuts.
- *
- * @param p_reg       Pointer to the peripheral registers structure.
- * @param shorts_mask Shortcuts to disable.
- */
-__STATIC_INLINE void nrf_uarte_shorts_disable(NRF_UARTE_Type *p_reg, uint32_t shorts_mask);
-
-/**
- * @brief Function for enabling UARTE interrupts.
- *
- * @param p_reg     Pointer to the peripheral registers structure.
- * @param int_mask  Interrupts to enable.
- */
-__STATIC_INLINE void nrf_uarte_int_enable(NRF_UARTE_Type *p_reg, uint32_t int_mask);
-
-/**
- * @brief Function for retrieving the state of a given interrupt.
- *
- * @param p_reg     Pointer to the peripheral registers structure.
- * @param int_mask  Mask of interrupt to check.
- *
- * @retval true  If the interrupt is enabled.
- * @retval false If the interrupt is not enabled.
- */
-__STATIC_INLINE bool nrf_uarte_int_enable_check(NRF_UARTE_Type *p_reg, nrf_uarte_int_mask_t int_mask);
-
-/**
- * @brief Function for disabling specific interrupts.
- *
- * @param p_reg    Instance.
- * @param int_mask Interrupts to disable.
- */
-__STATIC_INLINE void nrf_uarte_int_disable(NRF_UARTE_Type *p_reg, uint32_t int_mask);
-
-/**
- * @brief Function for getting error source mask. Function is clearing error source flags after reading.
- *
- * @param p_reg    Pointer to the peripheral registers structure.
- * @return         Mask with error source flags.
- */
-__STATIC_INLINE uint32_t nrf_uarte_errorsrc_get_and_clear(NRF_UARTE_Type *p_reg);
-
-/**
- * @brief Function for enabling UARTE.
- *
- * @param p_reg    Pointer to the peripheral registers structure.
- */
-__STATIC_INLINE void nrf_uarte_enable(NRF_UARTE_Type *p_reg);
-
-/**
- * @brief Function for disabling UARTE.
- *
- * @param p_reg    Pointer to the peripheral registers structure.
- */
-__STATIC_INLINE void nrf_uarte_disable(NRF_UARTE_Type *p_reg);
-
-/**
- * @brief Function for configuring TX/RX pins.
- *
- * @param p_reg    Pointer to the peripheral registers structure.
- * @param pseltxd  TXD pin number.
- * @param pselrxd  RXD pin number.
- */
-__STATIC_INLINE void nrf_uarte_txrx_pins_set(NRF_UARTE_Type *p_reg, uint32_t pseltxd, uint32_t pselrxd);
-
-/**
- * @brief Function for disconnecting TX/RX pins.
- *
- * @param p_reg    Pointer to the peripheral registers structure.
- */
-__STATIC_INLINE void nrf_uarte_txrx_pins_disconnect(NRF_UARTE_Type *p_reg);
-
-/**
- * @brief Function for getting TX pin.
- *
- * @param p_reg    Pointer to the peripheral registers structure.
- */
-__STATIC_INLINE uint32_t nrf_uarte_tx_pin_get(NRF_UARTE_Type *p_reg);
-
-/**
- * @brief Function for getting RX pin.
- *
- * @param p_reg    Pointer to the peripheral registers structure.
- */
-__STATIC_INLINE uint32_t nrf_uarte_rx_pin_get(NRF_UARTE_Type *p_reg);
-
-/**
- * @brief Function for getting RTS pin.
- *
- * @param p_reg    Pointer to the peripheral registers structure.
- */
-__STATIC_INLINE uint32_t nrf_uarte_rts_pin_get(NRF_UARTE_Type *p_reg);
-
-/**
- * @brief Function for getting CTS pin.
- *
- * @param p_reg    Pointer to the peripheral registers structure.
- */
-__STATIC_INLINE uint32_t nrf_uarte_cts_pin_get(NRF_UARTE_Type *p_reg);
-
-
-/**
- * @brief Function for configuring flow control pins.
- *
- * @param p_reg    Pointer to the peripheral registers structure.
- * @param pselrts  RTS pin number.
- * @param pselcts  CTS pin number.
- */
-__STATIC_INLINE void nrf_uarte_hwfc_pins_set(NRF_UARTE_Type *p_reg,
-                                             uint32_t        pselrts,
-                                             uint32_t        pselcts);
-
-/**
- * @brief Function for disconnecting flow control pins.
- *
- * @param p_reg    Pointer to the peripheral registers structure.
- */
-__STATIC_INLINE void nrf_uarte_hwfc_pins_disconnect(NRF_UARTE_Type *p_reg);
-
-/**
- * @brief Function for starting an UARTE task.
- *
- * @param p_reg    Pointer to the peripheral registers structure.
- * @param task     Task.
- */
-__STATIC_INLINE void nrf_uarte_task_trigger(NRF_UARTE_Type *p_reg, nrf_uarte_task_t task);
-
-/**
- * @brief Function for returning the address of a specific task register.
- *
- * @param p_reg Pointer to the peripheral registers structure.
- * @param task  Task.
- *
- * @return      Task address.
- */
-__STATIC_INLINE uint32_t nrf_uarte_task_address_get(NRF_UARTE_Type *p_reg, nrf_uarte_task_t task);
-
-/**
- * @brief Function for configuring UARTE.
- *
- * @param p_reg  Pointer to the peripheral registers structure.
- * @param hwfc   Hardware flow control. Enabled if true.
- * @param parity Parity. Included if true.
- */
-__STATIC_INLINE void nrf_uarte_configure(NRF_UARTE_Type    *p_reg,
-                                         nrf_uarte_parity_t parity,
-                                         nrf_uarte_hwfc_t   hwfc);
-
-
-/**
- * @brief Function for setting UARTE baudrate.
- *
- * @param p_reg    Instance.
- * @param baudrate Baudrate.
- */
-__STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type    *p_reg, nrf_uarte_baudrate_t baudrate);
-
-/**
- * @brief Function for setting the transmit buffer.
- *
- * @param[in] p_reg     Instance.
- * @param[in] p_buffer  Pointer to the buffer with data to send.
- * @param[in] length    Maximum number of data bytes to transmit.
- */
-__STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type *p_reg,
-                                             uint8_t  const *p_buffer,
-                                             uint8_t          length);
-
-/**
- * @brief Function for getting number of bytes transmitted in the last transaction.
- *
- * @param[in] p_reg     Instance.
- *
- * @retval Amount of bytes transmitted.
- */
-__STATIC_INLINE uint32_t nrf_uarte_tx_amount_get(NRF_UARTE_Type *p_reg);
-
-/**
- * @brief Function for setting the receive buffer.
- *
- * @param[in] p_reg     Pointer to the peripheral registers structure.
- * @param[in] p_buffer  Pointer to the buffer for received data.
- * @param[in] length    Maximum number of data bytes to receive.
- */
-__STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type *p_reg,
-                                             uint8_t *p_buffer,
-                                             uint8_t   length);
-
-/**
- * @brief Function for getting number of bytes received in the last transaction.
- *
- * @param[in] p_reg     Pointer to the peripheral registers structure.
- *
- * @retval Amount of bytes received.
- */
-__STATIC_INLINE uint32_t nrf_uarte_rx_amount_get(NRF_UARTE_Type *p_reg);
-
-#ifndef SUPPRESS_INLINE_IMPLEMENTATION
-__STATIC_INLINE void nrf_uarte_event_clear(NRF_UARTE_Type *p_reg, nrf_uarte_event_t event)
-{
-  *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
-#if __CORTEX_M == 0x04
-  volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
-  (void)dummy;
-#endif
-
-}
-
-__STATIC_INLINE bool nrf_uarte_event_check(NRF_UARTE_Type *p_reg, nrf_uarte_event_t event)
-{
-  return (bool) * (volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
-}
-
-__STATIC_INLINE uint32_t nrf_uarte_event_address_get(NRF_UARTE_Type   *p_reg,
-                                                     nrf_uarte_event_t  event)
-{
-  return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
-}
-
-__STATIC_INLINE void nrf_uarte_shorts_enable(NRF_UARTE_Type *p_reg, uint32_t shorts_mask)
-{
-  p_reg->SHORTS |= shorts_mask;
-}
-
-__STATIC_INLINE void nrf_uarte_shorts_disable(NRF_UARTE_Type *p_reg, uint32_t shorts_mask)
-{
-  p_reg->SHORTS &= ~(shorts_mask);
-}
-
-__STATIC_INLINE void nrf_uarte_int_enable(NRF_UARTE_Type *p_reg, uint32_t int_mask)
-{
-  p_reg->INTENSET = int_mask;
-}
-
-__STATIC_INLINE bool nrf_uarte_int_enable_check(NRF_UARTE_Type *p_reg, nrf_uarte_int_mask_t int_mask)
-{
-  return (bool)(p_reg->INTENSET & int_mask);
-}
-
-__STATIC_INLINE void nrf_uarte_int_disable(NRF_UARTE_Type *p_reg, uint32_t int_mask)
-{
-  p_reg->INTENCLR = int_mask;
-}
-
-__STATIC_INLINE uint32_t nrf_uarte_errorsrc_get_and_clear(NRF_UARTE_Type *p_reg)
-{
-  uint32_t errsrc_mask = p_reg->ERRORSRC;
-  p_reg->ERRORSRC = errsrc_mask;
-  return errsrc_mask;
-}
-
-__STATIC_INLINE void nrf_uarte_enable(NRF_UARTE_Type *p_reg)
-{
-  p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
-}
-
-__STATIC_INLINE void nrf_uarte_disable(NRF_UARTE_Type *p_reg)
-{
-  p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
-}
-
-__STATIC_INLINE void nrf_uarte_txrx_pins_set(NRF_UARTE_Type *p_reg, uint32_t pseltxd, uint32_t pselrxd)
-{
-  p_reg->PSEL.TXD = pseltxd;
-  p_reg->PSEL.RXD = pselrxd;
-}
-
-__STATIC_INLINE void nrf_uarte_txrx_pins_disconnect(NRF_UARTE_Type *p_reg)
-{
-  nrf_uarte_txrx_pins_set(p_reg, NRF_UARTE_PSEL_DISCONNECTED, NRF_UARTE_PSEL_DISCONNECTED);
-}
-
-__STATIC_INLINE uint32_t nrf_uarte_tx_pin_get(NRF_UARTE_Type *p_reg)
-{
-  return p_reg->PSEL.TXD;
-}
-
-__STATIC_INLINE uint32_t nrf_uarte_rx_pin_get(NRF_UARTE_Type *p_reg)
-{
-  return p_reg->PSEL.RXD;
-}
-
-__STATIC_INLINE uint32_t nrf_uarte_rts_pin_get(NRF_UARTE_Type *p_reg)
-{
-  return p_reg->PSEL.RTS;
-}
-
-__STATIC_INLINE uint32_t nrf_uarte_cts_pin_get(NRF_UARTE_Type *p_reg)
-{
-  return p_reg->PSEL.CTS;
-}
-
-__STATIC_INLINE void nrf_uarte_hwfc_pins_set(NRF_UARTE_Type *p_reg, uint32_t pselrts, uint32_t pselcts)
-{
-  p_reg->PSEL.RTS = pselrts;
-  p_reg->PSEL.CTS = pselcts;
-}
-
-__STATIC_INLINE void nrf_uarte_hwfc_pins_disconnect(NRF_UARTE_Type *p_reg)
-{
-  nrf_uarte_hwfc_pins_set(p_reg, NRF_UARTE_PSEL_DISCONNECTED, NRF_UARTE_PSEL_DISCONNECTED);
-}
-
-__STATIC_INLINE void nrf_uarte_task_trigger(NRF_UARTE_Type *p_reg, nrf_uarte_task_t task)
-{
-  *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
-}
-
-__STATIC_INLINE uint32_t nrf_uarte_task_address_get(NRF_UARTE_Type *p_reg, nrf_uarte_task_t task)
-{
-  return (uint32_t)p_reg + (uint32_t)task;
-}
-
-__STATIC_INLINE void nrf_uarte_configure(NRF_UARTE_Type    *p_reg,
-                                         nrf_uarte_parity_t parity,
-                                         nrf_uarte_hwfc_t   hwfc)
-{
-  p_reg->CONFIG = (uint32_t)parity | (uint32_t)hwfc;
-}
-
-__STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type    *p_reg, nrf_uarte_baudrate_t baudrate)
-{
-  p_reg->BAUDRATE = baudrate;
-}
-
-__STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type *p_reg,
-                                             uint8_t  const *p_buffer,
-                                             uint8_t          length)
-{
-  p_reg->TXD.PTR    = (uint32_t)p_buffer;
-  p_reg->TXD.MAXCNT = length;
-}
-
-__STATIC_INLINE uint32_t nrf_uarte_tx_amount_get(NRF_UARTE_Type *p_reg)
-{
-  return p_reg->TXD.AMOUNT;
-}
-
-__STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type *p_reg,
-                                             uint8_t *p_buffer,
-                                             uint8_t   length)
-{
-  p_reg->RXD.PTR    = (uint32_t)p_buffer;
-  p_reg->RXD.MAXCNT = length;
-}
-
-__STATIC_INLINE uint32_t nrf_uarte_rx_amount_get(NRF_UARTE_Type *p_reg)
-{
-  return p_reg->RXD.AMOUNT;
-}
-#endif //SUPPRESS_INLINE_IMPLEMENTATION
-/** @} */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif //NRF_UARTE_H__
diff --git a/configs/nrf52832_dk/defaults.mk b/configs/nrf52832_dk/defaults.mk
index 721cd073eb..1bf75024b0 100644
--- a/configs/nrf52832_dk/defaults.mk
+++ b/configs/nrf52832_dk/defaults.mk
@@ -78,7 +78,8 @@ else
   ARCHINCLUDES  = -I$(CHIP_DIR) -I$(TOPDIR)/arch/arm/src/board -I. \
 	          -isystem $(TOPDIR)/include -I$(TOOL_INCDIR) -I$(TOOLCHAIN) \
 		  -I$(BLE_XMPL_PERIPH) -I$(LIB_UTIL) -I$(DEV_DIR) -I$(LIB_UART)\
-		  -I$(SD_HEADERS) -I$(HAL_HEADERS) -I$(CLOCK) -I$(LIB_LOG) -I$(LIB_SRC)
+		  -I$(SD_HEADERS) -I$(HAL_HEADERS) -I$(CLOCK) -I$(LIB_LOG) \
+		   -I$(LIB_SRC) -I$(CHIP_DIR)/chip
 
 ifeq ($(CONFIG_NRF52_BLUETOOTH),y)
   ARCHINCLUDES += -I$(DEV_DIR) \
-- 
2.11.0

